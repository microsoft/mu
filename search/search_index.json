{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Project Mu \u00b6 Project Mu is a modular adaptation of TianoCore's edk2 tuned for building modern devices using a scalable, maintainable, and reusable pattern. Mu is built around the idea that shipping and maintaining a UEFI product is an ongoing collaboration between numerous partners. For too long, the industry has built products using a \"forking\" model combined with copy/paste/rename and with each new product, the maintenance burden grows to such a level that updates are near impossible due to cost and risk. Project Mu also tries to address the complex business relationships and legal challenges facing partners today. To build most products, it often requires both closed-source, proprietary assets as well as open-source and industry-standard code. The distributed build system and multi-repository design allow product teams to keep code separate and connected to their original source while respecting legal and business boundaries. Project Mu originated from building modern Windows PCs but its patterns and design allow it to be scaled down or up for whatever the final product's intent. IoT, Server, PC, or any other form factor should be able to leverage the content. Primary Goals \u00b6 Initially, this project will focus on two central goals. Share \u00b6 We will share our active code tree to both solicit feedback and entice partners to collaborate. Project Mu is an active project. This is not a side project, mirror, clone, or example. This is the same code used today on many of Microsoft's 1 st party devices and it will be kept current because it must be to continue to enable shipping products. Support an industry shift to a more collaborative environment to lower costs and raise quality \u00b6 We will use this project to promote, evangelize, and support an industry shift to a more collaborative environment so that the entire ecosystem can develop and maintain products with lower costs and higher quality. Today's open source projects, although extremely valuable, are very resource-intensive to interact with. This friction leads to major industry players avoiding public interaction, thus diminishing the overall community\u2019s value. The modern era of open source projects has incorporated new tools and procedures to lower this friction and it is our goal to leverage those tools. GitHub provides issue tracking, Pull Requests, Gated builds, tracked/required web-based code reviews, and CI/CD (Continuous integration and delivery). It is our belief that by leveraging and extending this automation and workflow, we can lower the friction and foster a safe place for all contributors to work. Guiding Principles \u00b6 Less is More * Be open to change / flexible - Keep learning. If it was easy this would have been solved before Design for code reuse Leverage tools / invest in automation Navigation \u00b6 Have a look around this site to see what is Project Mu. Start by reviewing the details of the community and our process. See how to interact and get involved, why it's different, how to work within or extend it, as well as where everything is located. Finally, explore the Developer Docs if you want to review more in-depth details. Having trouble \u00b6 Skim the FAQ Roadmap \u00b6 After the first few months of Mu, our initial roadmap is largely complete. Any remaining items have been moved to the GitHub Issues and will continue to be tracked there. We hope to use GitHub Issues to track new roadmap items going forwards. Project Mu GitHub Issues Join Us \u00b6 Contact info and additional methods to collaborate coming soon. Code of conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Reporting Issues \u00b6 Short answer: Open a github issue. More details: Contributing Contributing \u00b6 Short answer: Open a pull request. More details: Contributing License \u00b6 Refer to License Documentation Build Information Version: 0.9.1 Build Time: 2022-11-30 20:09","title":"Home"},{"location":"#welcome-to-project-mu","text":"Project Mu is a modular adaptation of TianoCore's edk2 tuned for building modern devices using a scalable, maintainable, and reusable pattern. Mu is built around the idea that shipping and maintaining a UEFI product is an ongoing collaboration between numerous partners. For too long, the industry has built products using a \"forking\" model combined with copy/paste/rename and with each new product, the maintenance burden grows to such a level that updates are near impossible due to cost and risk. Project Mu also tries to address the complex business relationships and legal challenges facing partners today. To build most products, it often requires both closed-source, proprietary assets as well as open-source and industry-standard code. The distributed build system and multi-repository design allow product teams to keep code separate and connected to their original source while respecting legal and business boundaries. Project Mu originated from building modern Windows PCs but its patterns and design allow it to be scaled down or up for whatever the final product's intent. IoT, Server, PC, or any other form factor should be able to leverage the content.","title":"Welcome to Project Mu"},{"location":"#primary-goals","text":"Initially, this project will focus on two central goals.","title":"Primary Goals"},{"location":"#share","text":"We will share our active code tree to both solicit feedback and entice partners to collaborate. Project Mu is an active project. This is not a side project, mirror, clone, or example. This is the same code used today on many of Microsoft's 1 st party devices and it will be kept current because it must be to continue to enable shipping products.","title":"Share"},{"location":"#support-an-industry-shift-to-a-more-collaborative-environment-to-lower-costs-and-raise-quality","text":"We will use this project to promote, evangelize, and support an industry shift to a more collaborative environment so that the entire ecosystem can develop and maintain products with lower costs and higher quality. Today's open source projects, although extremely valuable, are very resource-intensive to interact with. This friction leads to major industry players avoiding public interaction, thus diminishing the overall community\u2019s value. The modern era of open source projects has incorporated new tools and procedures to lower this friction and it is our goal to leverage those tools. GitHub provides issue tracking, Pull Requests, Gated builds, tracked/required web-based code reviews, and CI/CD (Continuous integration and delivery). It is our belief that by leveraging and extending this automation and workflow, we can lower the friction and foster a safe place for all contributors to work.","title":"Support an industry shift to a more collaborative environment to lower costs and raise quality"},{"location":"#guiding-principles","text":"Less is More * Be open to change / flexible - Keep learning. If it was easy this would have been solved before Design for code reuse Leverage tools / invest in automation","title":"Guiding Principles"},{"location":"#navigation","text":"Have a look around this site to see what is Project Mu. Start by reviewing the details of the community and our process. See how to interact and get involved, why it's different, how to work within or extend it, as well as where everything is located. Finally, explore the Developer Docs if you want to review more in-depth details.","title":"Navigation"},{"location":"#having-trouble","text":"Skim the FAQ","title":"Having trouble"},{"location":"#roadmap","text":"After the first few months of Mu, our initial roadmap is largely complete. Any remaining items have been moved to the GitHub Issues and will continue to be tracked there. We hope to use GitHub Issues to track new roadmap items going forwards. Project Mu GitHub Issues","title":"Roadmap"},{"location":"#join-us","text":"Contact info and additional methods to collaborate coming soon.","title":"Join Us"},{"location":"#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Code of conduct"},{"location":"#reporting-issues","text":"Short answer: Open a github issue. More details: Contributing","title":"Reporting Issues"},{"location":"#contributing","text":"Short answer: Open a pull request. More details: Contributing","title":"Contributing"},{"location":"#license","text":"Refer to License Documentation Build Information Version: 0.9.1 Build Time: 2022-11-30 20:09","title":"License"},{"location":"faq/","text":"FAQ \u00b6 Purpose/Goals \u00b6 How is this related to TianoCore \u00b6 As you can probably tell, Project Mu is based on TianoCore . It represents a variant of TianoCore that was customized within Microsoft for scaling and maintainability. It's not exactly a staging branch for TianoCore, as there are some changes that may not have application within or meet the explicit goals of that project, but it is a place where features and changes can be publicly featured and discussed. So, is this a fork \u00b6 Not entirely. It is our goal to continue to treat TianoCore as a true upstream. Our release branches will always be based on the latest stable TianoCore release, and we will always try to PR viable fixes and features into the TianoCore project. What is it? Where is it going \u00b6 Project Mu is a product of the Microsoft Core UEFI team and is the basis for the system firmware within a number of Microsoft products. It will continue to be maintained to reflect the FW practices and features leveraged for the best experience with Windows and other Microsoft products. A secondary purpose is to engage with the community, both in TianoCore and the industry at large. We hope that Project Mu serves as a concrete example for discussing different approaches to managing the challenges faced by the UEFI ecosystem. Content/Structure \u00b6 Is this really following \"Less is More\" \u00b6 Yes. The idea is lowering the entanglement of code, lowering the coupling, and allowing the product to pick and choose the code it needs. This means when building any given product, you don't need all the Project Mu code. Why are there so many repos \u00b6 Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. For details, see \"Repo Philosophy\" in What and Why .","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#purposegoals","text":"","title":"Purpose/Goals"},{"location":"faq/#how-is-this-related-to-tianocore","text":"As you can probably tell, Project Mu is based on TianoCore . It represents a variant of TianoCore that was customized within Microsoft for scaling and maintainability. It's not exactly a staging branch for TianoCore, as there are some changes that may not have application within or meet the explicit goals of that project, but it is a place where features and changes can be publicly featured and discussed.","title":"How is this related to TianoCore"},{"location":"faq/#so-is-this-a-fork","text":"Not entirely. It is our goal to continue to treat TianoCore as a true upstream. Our release branches will always be based on the latest stable TianoCore release, and we will always try to PR viable fixes and features into the TianoCore project.","title":"So, is this a fork"},{"location":"faq/#what-is-it-where-is-it-going","text":"Project Mu is a product of the Microsoft Core UEFI team and is the basis for the system firmware within a number of Microsoft products. It will continue to be maintained to reflect the FW practices and features leveraged for the best experience with Windows and other Microsoft products. A secondary purpose is to engage with the community, both in TianoCore and the industry at large. We hope that Project Mu serves as a concrete example for discussing different approaches to managing the challenges faced by the UEFI ecosystem.","title":"What is it? Where is it going"},{"location":"faq/#contentstructure","text":"","title":"Content/Structure"},{"location":"faq/#is-this-really-following-less-is-more","text":"Yes. The idea is lowering the entanglement of code, lowering the coupling, and allowing the product to pick and choose the code it needs. This means when building any given product, you don't need all the Project Mu code.","title":"Is this really following \"Less is More\""},{"location":"faq/#why-are-there-so-many-repos","text":"Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. For details, see \"Repo Philosophy\" in What and Why .","title":"Why are there so many repos"},{"location":"license/","text":"Licensing for Project Mu \u00b6 Project Mu has numerous repositories. Each of these can have different licenses depending on the content and partner but in general we want OSS friendly licenses. For this documentation we use the following license. License \u00b6 BSD 2-Clause License Copyright \u00a9 Microsoft All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"license/#licensing-for-project-mu","text":"Project Mu has numerous repositories. Each of these can have different licenses depending on the content and partner but in general we want OSS friendly licenses. For this documentation we use the following license.","title":"Licensing for Project Mu"},{"location":"license/#license","text":"BSD 2-Clause License Copyright \u00a9 Microsoft All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"CodeDevelopment/compile/","text":"How to Build/Compile \u00b6 Info MAJOR UPDATE -- The Project Mu Python packages for UEFI support and build tools have migrated to Tianocore and as a result things have changed. These docs are now updated to leverage building with \"edk2-pytools\". The repository/product/project should describe the unique steps required to build and test. The build tools are now a set of unique single purpose built tools called \"stuart\". These tools together support building, updating binary dependencies, updating git dependencies, and other functions. Project Mu has two main patterns for building. Those will be described here to encourage pattern/code reuse and limit the required repository specific documentation. More details for pytools can be found here: https://github.com/tianocore/edk2-pytool-extensions/tree/master/docs https://github.com/tianocore/edk2-pytool-library/tree/master/docs CI multi-package Building and Testing aka stuart_ci_build \u00b6 stuart_ci_build is a framework for running a battery of tests against a single Mu repository (and its dependencies). A plugin model is used for adding additional tests. Today one such plugin is a basic compile test. Another plugin compiles host based unit tests and runs them. A third plugin checks for misspellings. Check out the repository for details on the tests. Additional test plugins are usually found in .pytool/Plugin It is often desirable to compile test code and at times there might not be a product to test with. This is also how the Pull Requests gates are implemented and enforced. CI Build Process \u00b6 Open cmd prompt at workspace root Activate your python virtual environment Install or update Python dependencies using pip pip install --upgrade -r pip_requirements.txt Run stuart_setup to download required submodules. stuart_setup -c <PyTool Config File> Run stuart_ci_setup to download CI only dependencies stuart_ci_setup -c <PyTool Config File> Run stuart_update to download or update binary dependencies stuart_update -c <PyTool Config File> Run stuart_ci_build to build and test the packages stuart_ci_build -c <PyTool Config File> Open TestResults.xml in the build output for results (usually in workspace/Build) Open log files to debug any errors Info In Project Mu repos the config file is generally at .pytool/CISettings.py Project Mu runs on Windows 10 using the following tags: VS2019 and VS2022 Project Mu runs on Ubuntu 18.04 using the tags: GCC5 Each of the stuart commands can take in additional parameters. To see customized help run <stuart cmd> -c .pytool/CISettings.py -h Some common optional parameters that might allow the stuart operation to optimize for expected usage. For example if only building for X64 ARCH then the ARM compilers might not be downloaded. Or if using the Visual Studio toolchain then GCC specific assets aren't needed. If you only want to run CI against the MdePkg and MdeModulePkg then you can do that with -p . -a <arch csv> - list of architectures to run for -p <packages csv> - list of packages to run against -t <targets csv> - list of targets to run for TOOL_CHAIN_TAG=<tag> - set toolchain for operation Project Build aka PlatformBuild aka stuart_build \u00b6 When you actually want to compile for a platform that will create a firmware binary which can be flashed and execute on a platform the process is generally as follows. Again the platform repository should have details but this is generally the process. Platform Build Process \u00b6 Open cmd prompt at workspace root Activate your python virtual environment Install or update Python dependencies using pip pip install --upgrade -r <pip_requirements.txt file> Run stuart_setup to download required submodules. stuart_setup -c <platform Config File> Run stuart_update to download or update binary dependencies stuart_update -c <platform Config File> Run stuart_build to build and test the packages stuart_build -c <platform Config File> Open the build output for log files to debug any errors (usually in workspace/Build) Info In Project Mu repos the platform config file is generally in the platform package. Toolchains and host OS support is defined by the platform documentation. Each of the stuart commands can take in additional parameters. To see customized help run <stuart cmd> -c <platform config file> -h Other features \u00b6 stuart_build leverages a common UefiBuild python component. This component provides a common set of features. The UefiBuild component documentation is published from the edk2-pytool-extensions repository but here are a few of the common features developers find useful. Control the target of the build. Pass Target=RELEASE Build a single module: BuildModule=MdePkg/ModuleToBuild.inf Build with reporting: Single report type BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD\" Change report file BUILDREPORT_FILE=filename.txt default is BUILD_REPORT.TXT All report types. BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\" Clean build: --clean Clean only (no compile): --cleanonly Skip some of the build steps: Skip the Edk2 build step: --skipbuild Skip pre or post build steps: --skipprebuild or --skippostbuild Change a Build variable that is used in Edk2 build process: BLD_*_DEBUG_OUTPUT_LEVEL=0x80000004 will be passed to DSC/FDF as DEBUG_OUTPUT_LEVEL . These variable names and behavior are platform defined. BLD_*_<var name> is used for builds of any target type unless there is a more specific version for the given target type. BLD_DEBUG_<var name> is used for debug builds only BLD_RELEASE_<var name> is used for release builds only Using a config file. To simplify calling of PlatformBuild.py if there is a BuildConfig.conf in the root of your UEFI workspace those parameters will be used as well. The command line overrides anything from the conf file. Example BuildConfig.conf \u00b6 # Turn on full build reports BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\"","title":"Compiling"},{"location":"CodeDevelopment/compile/#how-to-buildcompile","text":"Info MAJOR UPDATE -- The Project Mu Python packages for UEFI support and build tools have migrated to Tianocore and as a result things have changed. These docs are now updated to leverage building with \"edk2-pytools\". The repository/product/project should describe the unique steps required to build and test. The build tools are now a set of unique single purpose built tools called \"stuart\". These tools together support building, updating binary dependencies, updating git dependencies, and other functions. Project Mu has two main patterns for building. Those will be described here to encourage pattern/code reuse and limit the required repository specific documentation. More details for pytools can be found here: https://github.com/tianocore/edk2-pytool-extensions/tree/master/docs https://github.com/tianocore/edk2-pytool-library/tree/master/docs","title":"How to Build/Compile"},{"location":"CodeDevelopment/compile/#ci-multi-package-building-and-testing-aka-stuart_ci_build","text":"stuart_ci_build is a framework for running a battery of tests against a single Mu repository (and its dependencies). A plugin model is used for adding additional tests. Today one such plugin is a basic compile test. Another plugin compiles host based unit tests and runs them. A third plugin checks for misspellings. Check out the repository for details on the tests. Additional test plugins are usually found in .pytool/Plugin It is often desirable to compile test code and at times there might not be a product to test with. This is also how the Pull Requests gates are implemented and enforced.","title":"CI multi-package Building and Testing aka stuart_ci_build"},{"location":"CodeDevelopment/compile/#ci-build-process","text":"Open cmd prompt at workspace root Activate your python virtual environment Install or update Python dependencies using pip pip install --upgrade -r pip_requirements.txt Run stuart_setup to download required submodules. stuart_setup -c <PyTool Config File> Run stuart_ci_setup to download CI only dependencies stuart_ci_setup -c <PyTool Config File> Run stuart_update to download or update binary dependencies stuart_update -c <PyTool Config File> Run stuart_ci_build to build and test the packages stuart_ci_build -c <PyTool Config File> Open TestResults.xml in the build output for results (usually in workspace/Build) Open log files to debug any errors Info In Project Mu repos the config file is generally at .pytool/CISettings.py Project Mu runs on Windows 10 using the following tags: VS2019 and VS2022 Project Mu runs on Ubuntu 18.04 using the tags: GCC5 Each of the stuart commands can take in additional parameters. To see customized help run <stuart cmd> -c .pytool/CISettings.py -h Some common optional parameters that might allow the stuart operation to optimize for expected usage. For example if only building for X64 ARCH then the ARM compilers might not be downloaded. Or if using the Visual Studio toolchain then GCC specific assets aren't needed. If you only want to run CI against the MdePkg and MdeModulePkg then you can do that with -p . -a <arch csv> - list of architectures to run for -p <packages csv> - list of packages to run against -t <targets csv> - list of targets to run for TOOL_CHAIN_TAG=<tag> - set toolchain for operation","title":"CI Build Process"},{"location":"CodeDevelopment/compile/#project-build-aka-platformbuild-aka-stuart_build","text":"When you actually want to compile for a platform that will create a firmware binary which can be flashed and execute on a platform the process is generally as follows. Again the platform repository should have details but this is generally the process.","title":"Project Build aka PlatformBuild aka stuart_build"},{"location":"CodeDevelopment/compile/#platform-build-process","text":"Open cmd prompt at workspace root Activate your python virtual environment Install or update Python dependencies using pip pip install --upgrade -r <pip_requirements.txt file> Run stuart_setup to download required submodules. stuart_setup -c <platform Config File> Run stuart_update to download or update binary dependencies stuart_update -c <platform Config File> Run stuart_build to build and test the packages stuart_build -c <platform Config File> Open the build output for log files to debug any errors (usually in workspace/Build) Info In Project Mu repos the platform config file is generally in the platform package. Toolchains and host OS support is defined by the platform documentation. Each of the stuart commands can take in additional parameters. To see customized help run <stuart cmd> -c <platform config file> -h","title":"Platform Build Process"},{"location":"CodeDevelopment/compile/#other-features","text":"stuart_build leverages a common UefiBuild python component. This component provides a common set of features. The UefiBuild component documentation is published from the edk2-pytool-extensions repository but here are a few of the common features developers find useful. Control the target of the build. Pass Target=RELEASE Build a single module: BuildModule=MdePkg/ModuleToBuild.inf Build with reporting: Single report type BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD\" Change report file BUILDREPORT_FILE=filename.txt default is BUILD_REPORT.TXT All report types. BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\" Clean build: --clean Clean only (no compile): --cleanonly Skip some of the build steps: Skip the Edk2 build step: --skipbuild Skip pre or post build steps: --skipprebuild or --skippostbuild Change a Build variable that is used in Edk2 build process: BLD_*_DEBUG_OUTPUT_LEVEL=0x80000004 will be passed to DSC/FDF as DEBUG_OUTPUT_LEVEL . These variable names and behavior are platform defined. BLD_*_<var name> is used for builds of any target type unless there is a more specific version for the given target type. BLD_DEBUG_<var name> is used for debug builds only BLD_RELEASE_<var name> is used for release builds only Using a config file. To simplify calling of PlatformBuild.py if there is a BuildConfig.conf in the root of your UEFI workspace those parameters will be used as well. The command line overrides anything from the conf file.","title":"Other features"},{"location":"CodeDevelopment/compile/#example-buildconfigconf","text":"# Turn on full build reports BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\"","title":"Example BuildConfig.conf"},{"location":"CodeDevelopment/overview/","text":"Code Development Overview \u00b6 Tools \u00b6 First you will need to setup your UEFI development environment. Project Mu leverages most of the tools from TianoCore EDK2 . We have streamlined the process for the tool chains and systems we use but our project's goals are to support various tool chains and development environments. For the best experience or for those new to UEFI and Project Mu we have provided guidance in our prerequisites page. Code \u00b6 Next you will need to clone a repository or set of repositories to work on. For core work (Project Mu Repos) you can clone the desired repo, make your changes, run CI builds, run your tests, and submit a PR. For platform work (outside of Project Mu) you will need to clone the platform repository and then follow the platform setup process. See details on the compile page for more information about CI builds and how to compile a package or platform. Code should follow best practices. We are working to add some best practices on the requirements page. We also attempt to enforce these best practices thru our CI build process. Tests \u00b6 One area of focus for Project Mu is on testing. Firmware testing has traditionally been hard and very manual. With Project Mu and our recent contributions to Tianocore, we now have a unit test framework available to developers. Host based tests written in this framework will be automatically run during CI passes and are required for new contributions. Check out the testing page for more details.","title":"Overview"},{"location":"CodeDevelopment/overview/#code-development-overview","text":"","title":"Code Development Overview"},{"location":"CodeDevelopment/overview/#tools","text":"First you will need to setup your UEFI development environment. Project Mu leverages most of the tools from TianoCore EDK2 . We have streamlined the process for the tool chains and systems we use but our project's goals are to support various tool chains and development environments. For the best experience or for those new to UEFI and Project Mu we have provided guidance in our prerequisites page.","title":"Tools"},{"location":"CodeDevelopment/overview/#code","text":"Next you will need to clone a repository or set of repositories to work on. For core work (Project Mu Repos) you can clone the desired repo, make your changes, run CI builds, run your tests, and submit a PR. For platform work (outside of Project Mu) you will need to clone the platform repository and then follow the platform setup process. See details on the compile page for more information about CI builds and how to compile a package or platform. Code should follow best practices. We are working to add some best practices on the requirements page. We also attempt to enforce these best practices thru our CI build process.","title":"Code"},{"location":"CodeDevelopment/overview/#tests","text":"One area of focus for Project Mu is on testing. Firmware testing has traditionally been hard and very manual. With Project Mu and our recent contributions to Tianocore, we now have a unit test framework available to developers. Host based tests written in this framework will be automatically run during CI passes and are required for new contributions. Check out the testing page for more details.","title":"Tests"},{"location":"CodeDevelopment/prerequisites/","text":"Prerequisites for building Code \u00b6 Generally there are a set of tools required on the platform. Project Mu tries to minimize the number of global tools but there are a few. There could be more depending on the repository/product/platform you are building but this should get you started. If the repo requires other tools those should be documented within the repo. The tools also vary by Operating System and Compiler choice. Project Mu will document what is currently supported but the expectation is that between Project Mu and TianoCore Edk2 you could use any of those tool sets. Windows 10 x64 \u00b6 Python \u00b6 Download latest Python from https://www.python.org/downloads https://www.python.org/ftp/python/3.10.7/python-3.10.7-amd64.exe It is recommended you use the following options when installing python: include pip support include test support include venv virtual environment support Git \u00b6 Download latest Git For Windows from https://git-scm.com/download/win https://github.com/git-for-windows/git/releases/download/v2.37.3.windows.1/Git-2.37.3-64-bit.exe It is recommended you use the following options: Checkout as is, commit as is. Native Channel support (this will help in corp environments) Check the box to \"Enable Git Credential Manager\" Visual Studio 2022 preferred \u00b6 Download latest version of VS build Tools to c:\\TEMP https://aka.ms/vs/17/release/vs_buildtools.exe Install from cmd line with required features (this set will change over time). C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^ --add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^ --add Microsoft.VisualStudio.Component.Windows11SDK.22000 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^ --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2022 Visual Studio 2019 \u00b6 Download latest version of VS build Tools to c:\\TEMP https://aka.ms/vs/16/release/vs_buildtools.exe Install from cmd line with required features (this set will change over time). C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^ --add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^ --add Microsoft.VisualStudio.Component.Windows10SDK.19041 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^ --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2019 Optional - Windows Driver Kit \u00b6 Provides Inf2Cat.exe, needed to prepare Windows firmware update packages for signing . Download the WDK installer https://go.microsoft.com/fwlink/?linkid=2085767 Install from cmd line with required features (this set will change over time). wdksetup.exe /features OptionId.WindowsDriverKitComplete /q Optional - Create an Omnicache \u00b6 An Omnicache is a Project Mu tool that leverages git features to speed up git update operations. This helps speed up git operations if you have multiple workspaces by using the git \"--reference\" feature. Windows Subsystem For Linux (WSL) and Linux \u00b6 Basic directions here. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_linux.md All Operating Systems - Python Virtual Environment and PyTools \u00b6 In all Operating Systems environments the PyTools python modules are needed. Python virtual environments are strongly suggested especially when doing development in multiple workspaces. Each workspace should have its own virtual environment as to not modify the global system state. Since Project Mu uses Pip modules this allows each workspace to keep the versions in sync with the workspace requirements. More info on Python Virtual Environments: https://docs.python.org/3/library/venv.html Workspace Virtual Environment Setup Process \u00b6 A sample directory layout of workspaces and Python Virtual Environments \u00b6 /Workspace1Root (basic platform) |-- src_of_project1 |-- venv <-- Virtual environment for Project in workspace root 1 | /Workspace2Root (basic + local pytool dev support) | -- src_of_project2 | -- venv <-- Virtual environment for Project in workspace root 2 pip requirements | -- venv_dev <-- Virtual environment configured to use local python modules | -- edk2-pytool-library <-- local clone of python modules in library | -- edk2-pytool-extensions <-- local clone of python modules in extensions Virtual environments only need to be created once per workspace. They must be activated in each new cmd shell. Open Cmd Prompt in the directory where you want to store your virtual environment. A directory adjacent to workspace directories is convenient. run python cmd python -m venv <your virtual env name> Activate it for your session. Activate Virtual Environment \u00b6 Do this each time you open a new command window to build your workspace. Open Cmd Prompt run activate script - for windows cmd prompt (cmd.exe) do this <your virtual env name>\\Scripts\\activate cd into your workspace directory Update/Install your python pip requirements. This is generally at the workspace root. pip install --upgrade -r pip-requirements.txt Do dev work and run your builds!","title":"Tools and Prerequisite"},{"location":"CodeDevelopment/prerequisites/#prerequisites-for-building-code","text":"Generally there are a set of tools required on the platform. Project Mu tries to minimize the number of global tools but there are a few. There could be more depending on the repository/product/platform you are building but this should get you started. If the repo requires other tools those should be documented within the repo. The tools also vary by Operating System and Compiler choice. Project Mu will document what is currently supported but the expectation is that between Project Mu and TianoCore Edk2 you could use any of those tool sets.","title":"Prerequisites for building Code"},{"location":"CodeDevelopment/prerequisites/#windows-10-x64","text":"","title":"Windows 10 x64"},{"location":"CodeDevelopment/prerequisites/#python","text":"Download latest Python from https://www.python.org/downloads https://www.python.org/ftp/python/3.10.7/python-3.10.7-amd64.exe It is recommended you use the following options when installing python: include pip support include test support include venv virtual environment support","title":"Python"},{"location":"CodeDevelopment/prerequisites/#git","text":"Download latest Git For Windows from https://git-scm.com/download/win https://github.com/git-for-windows/git/releases/download/v2.37.3.windows.1/Git-2.37.3-64-bit.exe It is recommended you use the following options: Checkout as is, commit as is. Native Channel support (this will help in corp environments) Check the box to \"Enable Git Credential Manager\"","title":"Git"},{"location":"CodeDevelopment/prerequisites/#visual-studio-2022-preferred","text":"Download latest version of VS build Tools to c:\\TEMP https://aka.ms/vs/17/release/vs_buildtools.exe Install from cmd line with required features (this set will change over time). C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^ --add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^ --add Microsoft.VisualStudio.Component.Windows11SDK.22000 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^ --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2022","title":"Visual Studio 2022 preferred"},{"location":"CodeDevelopment/prerequisites/#visual-studio-2019","text":"Download latest version of VS build Tools to c:\\TEMP https://aka.ms/vs/16/release/vs_buildtools.exe Install from cmd line with required features (this set will change over time). C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^ --add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^ --add Microsoft.VisualStudio.Component.Windows10SDK.19041 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^ --add Microsoft.VisualStudio.Component.VC.Tools.ARM64 See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2019","title":"Visual Studio 2019"},{"location":"CodeDevelopment/prerequisites/#optional-windows-driver-kit","text":"Provides Inf2Cat.exe, needed to prepare Windows firmware update packages for signing . Download the WDK installer https://go.microsoft.com/fwlink/?linkid=2085767 Install from cmd line with required features (this set will change over time). wdksetup.exe /features OptionId.WindowsDriverKitComplete /q","title":"Optional - Windows Driver Kit"},{"location":"CodeDevelopment/prerequisites/#optional-create-an-omnicache","text":"An Omnicache is a Project Mu tool that leverages git features to speed up git update operations. This helps speed up git operations if you have multiple workspaces by using the git \"--reference\" feature.","title":"Optional - Create an Omnicache"},{"location":"CodeDevelopment/prerequisites/#windows-subsystem-for-linux-wsl-and-linux","text":"Basic directions here. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_linux.md","title":"Windows Subsystem For Linux (WSL) and Linux"},{"location":"CodeDevelopment/prerequisites/#all-operating-systems-python-virtual-environment-and-pytools","text":"In all Operating Systems environments the PyTools python modules are needed. Python virtual environments are strongly suggested especially when doing development in multiple workspaces. Each workspace should have its own virtual environment as to not modify the global system state. Since Project Mu uses Pip modules this allows each workspace to keep the versions in sync with the workspace requirements. More info on Python Virtual Environments: https://docs.python.org/3/library/venv.html","title":"All Operating Systems - Python Virtual Environment and PyTools"},{"location":"CodeDevelopment/prerequisites/#workspace-virtual-environment-setup-process","text":"","title":"Workspace Virtual Environment Setup Process"},{"location":"CodeDevelopment/prerequisites/#a-sample-directory-layout-of-workspaces-and-python-virtual-environments","text":"/Workspace1Root (basic platform) |-- src_of_project1 |-- venv <-- Virtual environment for Project in workspace root 1 | /Workspace2Root (basic + local pytool dev support) | -- src_of_project2 | -- venv <-- Virtual environment for Project in workspace root 2 pip requirements | -- venv_dev <-- Virtual environment configured to use local python modules | -- edk2-pytool-library <-- local clone of python modules in library | -- edk2-pytool-extensions <-- local clone of python modules in extensions Virtual environments only need to be created once per workspace. They must be activated in each new cmd shell. Open Cmd Prompt in the directory where you want to store your virtual environment. A directory adjacent to workspace directories is convenient. run python cmd python -m venv <your virtual env name> Activate it for your session.","title":"A sample directory layout of workspaces and Python Virtual Environments"},{"location":"CodeDevelopment/prerequisites/#activate-virtual-environment","text":"Do this each time you open a new command window to build your workspace. Open Cmd Prompt run activate script - for windows cmd prompt (cmd.exe) do this <your virtual env name>\\Scripts\\activate cd into your workspace directory Update/Install your python pip requirements. This is generally at the workspace root. pip install --upgrade -r pip-requirements.txt Do dev work and run your builds!","title":"Activate Virtual Environment"},{"location":"CodeDevelopment/requirements/","text":"Requirements for contributing Source Code \u00b6 Basics \u00b6 Make sure it follows the package, repo, and codebase rules Make sure it builds Write a unit test for it. Test positive cases as well as negative cases. Make sure it has docs. Even a minimal readme.md will get collected and added to the docs. Make sure it has only valid characters encoded (often copy paste from Microsoft Word docs or the internet will lead to invalid characters) Any changes made to code that originates from outside Project Mu (e.g. upstream project TianoCore, OpenSSL, etc.) should be surrounded with comments/tags indicating that it is a \"MU_CHANGE\". Most of the contents of mu_basecore , mu_tiano_plus , mu_silicon_arm_tiano , and mu_silicon_intel_tiano fall under this requirement. Example: EFI_STATUS EFIAPI SomeFunction ( VOID ) { EFI_STATUS Status ; // MU_CHANGE [BEGIN] - Add new counters for Feature X UINTN CounterA ; UINTN CounterB ; // MU_CHANGE [END] Status = EFI_ABORTED ; ... } Uefi Package \u00b6 UEFI Components \u00b6 All new modules must be listed in their containing package DSC in the components section All modules must follow the dependency rules of their containing package All modules within common layers should avoid silicon or architecture dependencies. Use existing libraries and functionality when possible Build out minimal required abstraction to allow other silicon or architectures to leverage common capabilities Public Header files \u00b6 Don't include other header files Don't mix public and private information in the same header file Implementation details should be contained to the instance Use \"doxygen\" style function header comments to clearly specify parameters and return results. Use a guidgen tool to define any guids For libraries: Library class should be listed in Package DEC file A NULL instance must be created that allows compiling and linking with minimal dependencies. Library Instance \u00b6 The supported module types in the INFs must be accurate. LIBRARY_CLASS: <Library Class Name>|<Module types supported by this instance> Use STATIC on each non-public function and non-public global to avoid conflicts with other modules. Use EFIAPI on all public library class functions. More info \u00b6 For general Edk2 and UEFI development additional information can be found at the TianoCore.org website.","title":"Code Requirements"},{"location":"CodeDevelopment/requirements/#requirements-for-contributing-source-code","text":"","title":"Requirements for contributing Source Code"},{"location":"CodeDevelopment/requirements/#basics","text":"Make sure it follows the package, repo, and codebase rules Make sure it builds Write a unit test for it. Test positive cases as well as negative cases. Make sure it has docs. Even a minimal readme.md will get collected and added to the docs. Make sure it has only valid characters encoded (often copy paste from Microsoft Word docs or the internet will lead to invalid characters) Any changes made to code that originates from outside Project Mu (e.g. upstream project TianoCore, OpenSSL, etc.) should be surrounded with comments/tags indicating that it is a \"MU_CHANGE\". Most of the contents of mu_basecore , mu_tiano_plus , mu_silicon_arm_tiano , and mu_silicon_intel_tiano fall under this requirement. Example: EFI_STATUS EFIAPI SomeFunction ( VOID ) { EFI_STATUS Status ; // MU_CHANGE [BEGIN] - Add new counters for Feature X UINTN CounterA ; UINTN CounterB ; // MU_CHANGE [END] Status = EFI_ABORTED ; ... }","title":"Basics"},{"location":"CodeDevelopment/requirements/#uefi-package","text":"","title":"Uefi Package"},{"location":"CodeDevelopment/requirements/#uefi-components","text":"All new modules must be listed in their containing package DSC in the components section All modules must follow the dependency rules of their containing package All modules within common layers should avoid silicon or architecture dependencies. Use existing libraries and functionality when possible Build out minimal required abstraction to allow other silicon or architectures to leverage common capabilities","title":"UEFI Components"},{"location":"CodeDevelopment/requirements/#public-header-files","text":"Don't include other header files Don't mix public and private information in the same header file Implementation details should be contained to the instance Use \"doxygen\" style function header comments to clearly specify parameters and return results. Use a guidgen tool to define any guids For libraries: Library class should be listed in Package DEC file A NULL instance must be created that allows compiling and linking with minimal dependencies.","title":"Public Header files"},{"location":"CodeDevelopment/requirements/#library-instance","text":"The supported module types in the INFs must be accurate. LIBRARY_CLASS: <Library Class Name>|<Module types supported by this instance> Use STATIC on each non-public function and non-public global to avoid conflicts with other modules. Use EFIAPI on all public library class functions.","title":"Library Instance"},{"location":"CodeDevelopment/requirements/#more-info","text":"For general Edk2 and UEFI development additional information can be found at the TianoCore.org website.","title":"More info"},{"location":"CodeDevelopment/test/","text":"Tests \u00b6 Testing firmware is critical and should be done so much more than it is today. So please, start writing tests. A lot of work has been done to make it easier. Static Code Tests (analysis) \u00b6 stuart_ci_build provides a framework for running static tests on the code base. More details of the ever changing tests can be found here. https://github.com/microsoft/mu_basecore/tree/release/202002/.pytool/Plugin UEFI Unit Tests - C code \u00b6 It now exists!! There is a framework available in Tianocore and Project Mu basecore. Simple API here. https://github.com/microsoft/mu_basecore/blob/release/202002/MdePkg/Include/Library/UnitTestLib.h Implementation details here. https://github.com/microsoft/mu_basecore/tree/release/202002/UnitTestFrameworkPkg Host Based - console app \u00b6 Host based allow you to run your tests on the same machine in which you are compiling your code. These tests will run as applications within the operating system host environment. This is the preferred route when possible as these tests will automatically roll into the CI process and are much faster and easier to run. Obviously this means you will need to write your code and tests with limited UEFI dependencies. Any dependency your code has will need to be mocked or faked for the unit test scenario. The host test does leverage cmocka so lightweight mocking is possible. Target Based (UEFI Firmware on a device) \u00b6 Some testing just doesn't make sense to run as a host test. Tests that rely on system hardware and system state might only work as target tests. The unit test framework supports this and the implementation works for both. This can also include features that require reboots and saving state before the reboot so that tests can resume upon continued execution. UEFI Shell Based Functional Tests \u00b6 These can also leverage the UEFI target based tests. UEFI Shell Based Audit Tests \u00b6 These tests are often one off UEFI shell applications that collect system data and then compare that data against known good values for a system. This is because these types of tests have no right or wrong answer. Often we have a python script/component to the test to compare expected result to actual result. If the actual result doesn't match then this type of test should fail. Testing Automation for physical hardware \u00b6 The Project Mu team has done a lot of work with the open source project \"robot framework\". This framework provides a great logging and execution environment but at this time it is out of scope for Project Mu docs. If you want to know more, contact us as we are definitely willing to partner/share/engage. Testing Python \u00b6 Create pytest and/or python unit-test compatible tests. Make sure the python code passes the flake8 \"linter\"","title":"Testing"},{"location":"CodeDevelopment/test/#tests","text":"Testing firmware is critical and should be done so much more than it is today. So please, start writing tests. A lot of work has been done to make it easier.","title":"Tests"},{"location":"CodeDevelopment/test/#static-code-tests-analysis","text":"stuart_ci_build provides a framework for running static tests on the code base. More details of the ever changing tests can be found here. https://github.com/microsoft/mu_basecore/tree/release/202002/.pytool/Plugin","title":"Static Code Tests (analysis)"},{"location":"CodeDevelopment/test/#uefi-unit-tests-c-code","text":"It now exists!! There is a framework available in Tianocore and Project Mu basecore. Simple API here. https://github.com/microsoft/mu_basecore/blob/release/202002/MdePkg/Include/Library/UnitTestLib.h Implementation details here. https://github.com/microsoft/mu_basecore/tree/release/202002/UnitTestFrameworkPkg","title":"UEFI Unit Tests - C code"},{"location":"CodeDevelopment/test/#host-based-console-app","text":"Host based allow you to run your tests on the same machine in which you are compiling your code. These tests will run as applications within the operating system host environment. This is the preferred route when possible as these tests will automatically roll into the CI process and are much faster and easier to run. Obviously this means you will need to write your code and tests with limited UEFI dependencies. Any dependency your code has will need to be mocked or faked for the unit test scenario. The host test does leverage cmocka so lightweight mocking is possible.","title":"Host Based - console app"},{"location":"CodeDevelopment/test/#target-based-uefi-firmware-on-a-device","text":"Some testing just doesn't make sense to run as a host test. Tests that rely on system hardware and system state might only work as target tests. The unit test framework supports this and the implementation works for both. This can also include features that require reboots and saving state before the reboot so that tests can resume upon continued execution.","title":"Target Based (UEFI Firmware on a device)"},{"location":"CodeDevelopment/test/#uefi-shell-based-functional-tests","text":"These can also leverage the UEFI target based tests.","title":"UEFI Shell Based Functional Tests"},{"location":"CodeDevelopment/test/#uefi-shell-based-audit-tests","text":"These tests are often one off UEFI shell applications that collect system data and then compare that data against known good values for a system. This is because these types of tests have no right or wrong answer. Often we have a python script/component to the test to compare expected result to actual result. If the actual result doesn't match then this type of test should fail.","title":"UEFI Shell Based Audit Tests"},{"location":"CodeDevelopment/test/#testing-automation-for-physical-hardware","text":"The Project Mu team has done a lot of work with the open source project \"robot framework\". This framework provides a great logging and execution environment but at this time it is out of scope for Project Mu docs. If you want to know more, contact us as we are definitely willing to partner/share/engage.","title":"Testing Automation for physical hardware"},{"location":"CodeDevelopment/test/#testing-python","text":"Create pytest and/or python unit-test compatible tests. Make sure the python code passes the flake8 \"linter\"","title":"Testing Python"},{"location":"DeveloperDocs/attribution/","text":"Documentation framework attribution \u00b6 A special thank you to the people and projects that helped make Project Mu Documentation possible. Projects \u00b6 Mkdocs \u00b6 https://www.mkdocs.org/ MkDocs License (BSD) Copyright \u00a9 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. mkdocs macros plugin \u00b6 https://github.com/fralau/mkdocs_macros_plugin MIT License Copyright (C) 2018 Laurent Franceschetti Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Material for MkDocs \u00b6 https://squidfunk.github.io/mkdocs-material/ License MIT License Copyright \u00a9 2016 - 2017 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. PyMdown Extensions \u00b6 https://facelessuser.github.io/pymdown-extensions/ PyMdown Extensions The MIT License (MIT) (Except where stated below) Copyright \u00a9 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Doc Framework Attribution"},{"location":"DeveloperDocs/attribution/#documentation-framework-attribution","text":"A special thank you to the people and projects that helped make Project Mu Documentation possible.","title":"Documentation framework attribution"},{"location":"DeveloperDocs/attribution/#projects","text":"","title":"Projects"},{"location":"DeveloperDocs/attribution/#mkdocs","text":"https://www.mkdocs.org/ MkDocs License (BSD) Copyright \u00a9 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Mkdocs"},{"location":"DeveloperDocs/attribution/#mkdocs-macros-plugin","text":"https://github.com/fralau/mkdocs_macros_plugin MIT License Copyright (C) 2018 Laurent Franceschetti Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"mkdocs macros plugin"},{"location":"DeveloperDocs/attribution/#material-for-mkdocs","text":"https://squidfunk.github.io/mkdocs-material/ License MIT License Copyright \u00a9 2016 - 2017 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Material for MkDocs"},{"location":"DeveloperDocs/attribution/#pymdown-extensions","text":"https://facelessuser.github.io/pymdown-extensions/ PyMdown Extensions The MIT License (MIT) (Except where stated below) Copyright \u00a9 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"PyMdown Extensions"},{"location":"DeveloperDocs/build_community_docs/","text":"Building Community Docs \u00b6 Info Today this process has been validated for use on Windows 10. This setup process is expected to roughly the same on other operating systems and none of the actual documentation source or tools should have any OS dependency. Get the docs repository \u00b6 First, you need to clone the project mu docs repository. git clone https://github.com/Microsoft/mu.git Install required tools \u00b6 Install python (Current suggested version is 3.7.x). Current min requirement is python 3.4+. Checkout python.org for directions. Install pip. Generally, this is done when installing python but can also be done as its own process. Details here https://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip Update pip. python -m pip install --upgrade pip Install dependencies. pip install --upgrade -r requirements.txt Install nodejs for more tooling Install nodejs from https://nodejs.org/en/ Include npm for package management Install markdownlint cli tool for linting the markdown npm install -g markdownlint-cli Install cspell cli tool for spell checking the markdown npm install -g cspell Install Git on your path (Required for generating dynamic repo based content during pre-process) General Suggested documentation workflow \u00b6 open two command windows at the root of docs repository Window 1: Use to serve files locally Use mkdocs serve Any changes from the DocBuild process will be picked up and served Window 2: Use to pre-process the source repo files Run the DocBuild.py command from this window Make changes to the docs in source repos or this repo and then re-run the DocBuild.py build command Pre-process with dynamic content from source repo(s) \u00b6 Create \"repos\" folder (somewhere outside of workspace) Clone all repositories for dynamic content here Set each repo to the branch/commit that you want to document run the DocBuild.py command supplying the parameters DocBuild.py --clean --build --OutputDir docs --yml mkdocs_base.yml --RootDir ..\\repos Pre-process with no source repo(s) content \u00b6 run the DocBuild.py command supplying minimal parameters DocBuild.py --clean --build --yml mkdocs_base.yml Clean / Remove all pre-processed content \u00b6 use DocBuild.py command DocBuild.py --clean --yml <path to yml base file> --OutputDir <docs folder> Check for character encoding issues \u00b6 navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run Utf8Test python script cmd prompt Utf8Test.py --RootDir docs should complete with no errors Note Note you can also run it on any dynamic content by using a different RootDir parameter. Use -h for usage to get more detailed information of any failures Use mkdocs to build the docs \u00b6 navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run mkdocs build from cmd prompt at root mkdocs build -s -v should complete with no errors Spell check the docs \u00b6 navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run command to spell check cspell \"docs/**/*.md\" should complete with no errors False Spelling Errors If the spelling error is a false positive there are two solutions: 1. If it is a valid word or commonly understood term then add the word to the cspell.json config file words section 2. Update the cspell.json file ignorePaths element to ignore the entire file. Lint the Markdown \u00b6 navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run command to lint the markdown markdownlint \"**/*.md\" Should complete with no errors. Rules can be found here https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md Configuration info here https://github.com/DavidAnson/markdownlint#configuration Project specific configuration is is in .markdownlint.yaml file at the root Locally serve the docs \u00b6 One great feature of mkdocs is how easy it is to locally serve the docs to validate your changes. Use mkdocs to serve your local copy mkdocs serve navigate to 127.0.0.1:8000 in web browser Important If you get an error like Config file 'mkdocs.yml' does not exist you must run the pre-process step. Advanced doc features \u00b6 We do turn on a few advanced/extension features. Please use these carefully as they may break compatibility if the publishing engine is changed. Checkout the sample syntax / test page for syntax and information.","title":"How To Build"},{"location":"DeveloperDocs/build_community_docs/#building-community-docs","text":"Info Today this process has been validated for use on Windows 10. This setup process is expected to roughly the same on other operating systems and none of the actual documentation source or tools should have any OS dependency.","title":"Building Community Docs"},{"location":"DeveloperDocs/build_community_docs/#get-the-docs-repository","text":"First, you need to clone the project mu docs repository. git clone https://github.com/Microsoft/mu.git","title":"Get the docs repository"},{"location":"DeveloperDocs/build_community_docs/#install-required-tools","text":"Install python (Current suggested version is 3.7.x). Current min requirement is python 3.4+. Checkout python.org for directions. Install pip. Generally, this is done when installing python but can also be done as its own process. Details here https://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip Update pip. python -m pip install --upgrade pip Install dependencies. pip install --upgrade -r requirements.txt Install nodejs for more tooling Install nodejs from https://nodejs.org/en/ Include npm for package management Install markdownlint cli tool for linting the markdown npm install -g markdownlint-cli Install cspell cli tool for spell checking the markdown npm install -g cspell Install Git on your path (Required for generating dynamic repo based content during pre-process)","title":"Install required tools"},{"location":"DeveloperDocs/build_community_docs/#general-suggested-documentation-workflow","text":"open two command windows at the root of docs repository Window 1: Use to serve files locally Use mkdocs serve Any changes from the DocBuild process will be picked up and served Window 2: Use to pre-process the source repo files Run the DocBuild.py command from this window Make changes to the docs in source repos or this repo and then re-run the DocBuild.py build command","title":"General Suggested documentation workflow"},{"location":"DeveloperDocs/build_community_docs/#pre-process-with-dynamic-content-from-source-repos","text":"Create \"repos\" folder (somewhere outside of workspace) Clone all repositories for dynamic content here Set each repo to the branch/commit that you want to document run the DocBuild.py command supplying the parameters DocBuild.py --clean --build --OutputDir docs --yml mkdocs_base.yml --RootDir ..\\repos","title":"Pre-process with dynamic content from source repo(s)"},{"location":"DeveloperDocs/build_community_docs/#pre-process-with-no-source-repos-content","text":"run the DocBuild.py command supplying minimal parameters DocBuild.py --clean --build --yml mkdocs_base.yml","title":"Pre-process with no source repo(s) content"},{"location":"DeveloperDocs/build_community_docs/#clean-remove-all-pre-processed-content","text":"use DocBuild.py command DocBuild.py --clean --yml <path to yml base file> --OutputDir <docs folder>","title":"Clean / Remove all pre-processed content"},{"location":"DeveloperDocs/build_community_docs/#check-for-character-encoding-issues","text":"navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run Utf8Test python script cmd prompt Utf8Test.py --RootDir docs should complete with no errors Note Note you can also run it on any dynamic content by using a different RootDir parameter. Use -h for usage to get more detailed information of any failures","title":"Check for character encoding issues"},{"location":"DeveloperDocs/build_community_docs/#use-mkdocs-to-build-the-docs","text":"navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run mkdocs build from cmd prompt at root mkdocs build -s -v should complete with no errors","title":"Use mkdocs to build the docs"},{"location":"DeveloperDocs/build_community_docs/#spell-check-the-docs","text":"navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run command to spell check cspell \"docs/**/*.md\" should complete with no errors False Spelling Errors If the spelling error is a false positive there are two solutions: 1. If it is a valid word or commonly understood term then add the word to the cspell.json config file words section 2. Update the cspell.json file ignorePaths element to ignore the entire file.","title":"Spell check the docs"},{"location":"DeveloperDocs/build_community_docs/#lint-the-markdown","text":"navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things) open command window run command to lint the markdown markdownlint \"**/*.md\" Should complete with no errors. Rules can be found here https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md Configuration info here https://github.com/DavidAnson/markdownlint#configuration Project specific configuration is is in .markdownlint.yaml file at the root","title":"Lint the Markdown"},{"location":"DeveloperDocs/build_community_docs/#locally-serve-the-docs","text":"One great feature of mkdocs is how easy it is to locally serve the docs to validate your changes. Use mkdocs to serve your local copy mkdocs serve navigate to 127.0.0.1:8000 in web browser Important If you get an error like Config file 'mkdocs.yml' does not exist you must run the pre-process step.","title":"Locally serve the docs"},{"location":"DeveloperDocs/build_community_docs/#advanced-doc-features","text":"We do turn on a few advanced/extension features. Please use these carefully as they may break compatibility if the publishing engine is changed. Checkout the sample syntax / test page for syntax and information.","title":"Advanced doc features"},{"location":"DeveloperDocs/developer_docs/","text":"Developer Docs \u00b6 Philosophy \u00b6 Documentation is critical. There is a steep learning curve in UEFI and no amount of documentation will change that, but at a minimum quick, clear, and easy documentation can help everyone adopt features faster and with higher confidence. Our documentation system will focus on making this an easy, low friction, and collaborative process. The pull request process will eventually compel developers to submit documentation whenever they submit new components and refactoring. Documentation will be done in markdown as this has the benefit of being easily readable in both plain text as well as transformed into a richer experience. It also is quick to learn and to write. Currently, we leverage mkdocs as our publishing engine but since all content is in markdown it could be transitioned to another engine without significant reinvestment. Community documentation \u00b6 This content is documented in static markdown files within the Project Mu repository. We leverage mkdocs to generate web-hosted content on every change and host these using github.io. These static files focus on how the project and community interact. We strongly encourage contribution and follow the standard PR model for all changes, big and small. Developer documentation \u00b6 This content is documented in a couple of ways. There are static markdown files in the Project Mu repository. This contains details about high level concepts, how-to articles, and features of the project and all repos within Project Mu. Examples: Code layout, git usage, tools, building, packaging, etc. There is repo and package level documentation for features. These are also static markdown files but these are contained within the repo that contains the feature. A \u201cdocs\u201d folder for each repo and each package will host this content. Changes will also follow the standard PR model for the containing repo. Next, there is feature and instance documentation. This should inform a developer interested in the implementation specifics of what this module is and what additional requirements it has including code dependencies and limitations. This should be documented in markdown files located with the component. These should be updated whenever the component is updated and should be part of a code PR. Finally, for API and traditional functional documentation, our current stance is this is required in code (public APIs) but the published documentation (doxygen html, pdf, etc) is not necessary. Code tools like vscode already provide a lower friction method to index, find def, and search that uses this content directly embedded in the code.","title":"Overview"},{"location":"DeveloperDocs/developer_docs/#developer-docs","text":"","title":"Developer Docs"},{"location":"DeveloperDocs/developer_docs/#philosophy","text":"Documentation is critical. There is a steep learning curve in UEFI and no amount of documentation will change that, but at a minimum quick, clear, and easy documentation can help everyone adopt features faster and with higher confidence. Our documentation system will focus on making this an easy, low friction, and collaborative process. The pull request process will eventually compel developers to submit documentation whenever they submit new components and refactoring. Documentation will be done in markdown as this has the benefit of being easily readable in both plain text as well as transformed into a richer experience. It also is quick to learn and to write. Currently, we leverage mkdocs as our publishing engine but since all content is in markdown it could be transitioned to another engine without significant reinvestment.","title":"Philosophy"},{"location":"DeveloperDocs/developer_docs/#community-documentation","text":"This content is documented in static markdown files within the Project Mu repository. We leverage mkdocs to generate web-hosted content on every change and host these using github.io. These static files focus on how the project and community interact. We strongly encourage contribution and follow the standard PR model for all changes, big and small.","title":"Community documentation"},{"location":"DeveloperDocs/developer_docs/#developer-documentation","text":"This content is documented in a couple of ways. There are static markdown files in the Project Mu repository. This contains details about high level concepts, how-to articles, and features of the project and all repos within Project Mu. Examples: Code layout, git usage, tools, building, packaging, etc. There is repo and package level documentation for features. These are also static markdown files but these are contained within the repo that contains the feature. A \u201cdocs\u201d folder for each repo and each package will host this content. Changes will also follow the standard PR model for the containing repo. Next, there is feature and instance documentation. This should inform a developer interested in the implementation specifics of what this module is and what additional requirements it has including code dependencies and limitations. This should be documented in markdown files located with the component. These should be updated whenever the component is updated and should be part of a code PR. Finally, for API and traditional functional documentation, our current stance is this is required in code (public APIs) but the published documentation (doxygen html, pdf, etc) is not necessary. Code tools like vscode already provide a lower friction method to index, find def, and search that uses this content directly embedded in the code.","title":"Developer documentation"},{"location":"DeveloperDocs/doc_sample_test/","text":"Documentation Sample / Test file / Advanced doc features \u00b6 mkdocs macros plugin \u00b6 This plugin allows providing some variables in mkdocs.yml file and then reference those variables using jinja2 syntax in md files. Most of these variables are populated and created during the DocBuild step and inserted into the yml file. Docs: https://mkdocs-macros-plugin.readthedocs.io/en/latest/ Src Project: https://github.com/fralau/mkdocs_macros_plugin Material theme \u00b6 This theme provides the skin for the site. This also provides capabilities thru plugins. https://squidfunk.github.io/mkdocs-material/ Markdown Extensions \u00b6 The Material theme supports markdown extensions. Check the yml file for what extensions are currently on. Below is more specific info. https://squidfunk.github.io/mkdocs-material/extensions/permalinks/ https://squidfunk.github.io/mkdocs-material/extensions/pymdown/ Admonition plugin \u00b6 This plugin in combo with the material theme provides great looking ways for doc developers to highlight parts of their message. Please check out: https://squidfunk.github.io/mkdocs-material/extensions/admonition/ for the capabilities and syntax. One example: Note Sample note here. emoji support \u00b6 Who doesn't love using emojis. Icon usage has shown to help communicate directions and cross language barriers. https://facelessuser.github.io/pymdown-extensions/extensions/emoji/ Twitter, github, and emojione tags available. Tab support \u00b6 You can now use tabs to organize your content. Basic Example Tab1 Some content in tab1 Example Tab2 More content in tab2 Link to More details https://facelessuser.github.io/pymdown-extensions/extensions/tabbed/ Mermaid Charts \u00b6 A picture is worth 1000 words so lets make a few. Mermaid supports a rich, easily integrated set. https://mermaid-js.github.io/mermaid/ This is done with custom superfences configuration. See here: https://github.com/squidfunk/mkdocs-material/issues/693#issuecomment-591933381 To support this the Mermaid format is supported. Chart Result graph TD; A-->B; A-->C; B-->D; C-->D; Markdown Syntax ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ``` Others \u00b6 Check out the mkdocs.yml file for other extensions and details can be found in the links above.","title":"Sample Syntax"},{"location":"DeveloperDocs/doc_sample_test/#documentation-sample-test-file-advanced-doc-features","text":"","title":"Documentation Sample / Test file / Advanced doc features"},{"location":"DeveloperDocs/doc_sample_test/#mkdocs-macros-plugin","text":"This plugin allows providing some variables in mkdocs.yml file and then reference those variables using jinja2 syntax in md files. Most of these variables are populated and created during the DocBuild step and inserted into the yml file. Docs: https://mkdocs-macros-plugin.readthedocs.io/en/latest/ Src Project: https://github.com/fralau/mkdocs_macros_plugin","title":"mkdocs macros plugin"},{"location":"DeveloperDocs/doc_sample_test/#material-theme","text":"This theme provides the skin for the site. This also provides capabilities thru plugins. https://squidfunk.github.io/mkdocs-material/","title":"Material theme"},{"location":"DeveloperDocs/doc_sample_test/#markdown-extensions","text":"The Material theme supports markdown extensions. Check the yml file for what extensions are currently on. Below is more specific info. https://squidfunk.github.io/mkdocs-material/extensions/permalinks/ https://squidfunk.github.io/mkdocs-material/extensions/pymdown/","title":"Markdown Extensions"},{"location":"DeveloperDocs/doc_sample_test/#admonition-plugin","text":"This plugin in combo with the material theme provides great looking ways for doc developers to highlight parts of their message. Please check out: https://squidfunk.github.io/mkdocs-material/extensions/admonition/ for the capabilities and syntax. One example: Note Sample note here.","title":"Admonition plugin"},{"location":"DeveloperDocs/doc_sample_test/#emoji-support","text":"Who doesn't love using emojis. Icon usage has shown to help communicate directions and cross language barriers. https://facelessuser.github.io/pymdown-extensions/extensions/emoji/ Twitter, github, and emojione tags available.","title":"emoji support"},{"location":"DeveloperDocs/doc_sample_test/#tab-support","text":"You can now use tabs to organize your content. Basic Example Tab1 Some content in tab1 Example Tab2 More content in tab2 Link to More details https://facelessuser.github.io/pymdown-extensions/extensions/tabbed/","title":"Tab support"},{"location":"DeveloperDocs/doc_sample_test/#mermaid-charts","text":"A picture is worth 1000 words so lets make a few. Mermaid supports a rich, easily integrated set. https://mermaid-js.github.io/mermaid/ This is done with custom superfences configuration. See here: https://github.com/squidfunk/mkdocs-material/issues/693#issuecomment-591933381 To support this the Mermaid format is supported. Chart Result graph TD; A-->B; A-->C; B-->D; C-->D; Markdown Syntax ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ```","title":"Mermaid Charts"},{"location":"DeveloperDocs/doc_sample_test/#others","text":"Check out the mkdocs.yml file for other extensions and details can be found in the links above.","title":"Others"},{"location":"DeveloperDocs/requirements/","text":"Requirements for contributing documentation \u00b6 Conventions and lessons learned \u00b6 Please update this list as you learn more. filenames should all be lowercase. filenames should use \"_\" to separate words and should not have spaces. all links to pages are case sensitive (when published to GitHub the server is case sensitive) use a code editor like vscode for markdown. It has linting support and will identify issues prior to build. For rare cases you need to break a linter rule you can do so using the syntax defined here: https://github.com/DavidAnson/markdownlint#configuration If you markdown has images: Awesome. Images help make docs more informative and easier to understand Path in markdown to image must be relative Suggested to put in same directory as md file image filename must end with _mu. extension . Example my_image_name_mu.png Supported image extensions are gif, jpg, png","title":"Documentation Requirements"},{"location":"DeveloperDocs/requirements/#requirements-for-contributing-documentation","text":"","title":"Requirements for contributing documentation"},{"location":"DeveloperDocs/requirements/#conventions-and-lessons-learned","text":"Please update this list as you learn more. filenames should all be lowercase. filenames should use \"_\" to separate words and should not have spaces. all links to pages are case sensitive (when published to GitHub the server is case sensitive) use a code editor like vscode for markdown. It has linting support and will identify issues prior to build. For rare cases you need to break a linter rule you can do so using the syntax defined here: https://github.com/DavidAnson/markdownlint#configuration If you markdown has images: Awesome. Images help make docs more informative and easier to understand Path in markdown to image must be relative Suggested to put in same directory as md file image filename must end with _mu. extension . Example my_image_name_mu.png Supported image extensions are gif, jpg, png","title":"Conventions and lessons learned"},{"location":"How/contributing/","text":"How to contribute \u00b6 There are three common ways to contribute. Participate in discussions using GitHub issues. Contribute documentation by opening a GitHub Pull Request. Contribute code by opening a GitHub Pull Request Filing Issues \u00b6 File a GitHub issue in the corresponding Project Mu repository. General feedback and discussions \u00b6 If the feedback is actionable, such as a feature request, file a feature request issue. Otherwise, start a new thread in the GitHub Discussions section of the corresponding Project Mu GitHub repository. Bugs and feature requests \u00b6 For non-security related bugs, please submit a new issue in the Project Mu GitHub repository that contains the code related to the issue. The best way to get your bug fixed is to be as detailed as you can be about the problem. Providing a code snippet or sample driver that exposes the issue with steps to reproduce the problem is ideal. Reporting security issues and bugs \u00b6 Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) secure@microsoft.com . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter . Contributions of Documentation and/or Code \u00b6 Pull Requests \u00b6 If you don't know what a pull request is read this article: https://help.github.com/articles/about-pull-requests . Make sure the repository can build and all tests pass. Familiarize yourself with the project workflow and our coding conventions. General workflow \u00b6 Fork Repository in GitHub Make desired changes. Build it, test it, document it Submit a Pull Request back to the development branch you would like to target. You will be asked to digitally sign a CLA The server will run some builds and tests and report status Community and reviewers will provide feedback in the Pull Request Make changes / adjust based on feedback and discussion Keep your PR branch in-sync with the branch you are targeting and resolve any merge conflicts Once the the PR status is all passing it can be squashed and merged (just press the button in the PR). If the PR is ready the maintainers may complete it for you. That is it. Thanks for contributing. More details on : Code Development Tests Development Documentation Development Contributor License Agreement (CLA) \u00b6 This project welcomes contributions and suggestions. Most (code and documentation) contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.","title":"Contributing"},{"location":"How/contributing/#how-to-contribute","text":"There are three common ways to contribute. Participate in discussions using GitHub issues. Contribute documentation by opening a GitHub Pull Request. Contribute code by opening a GitHub Pull Request","title":"How to contribute"},{"location":"How/contributing/#filing-issues","text":"File a GitHub issue in the corresponding Project Mu repository.","title":"Filing Issues"},{"location":"How/contributing/#general-feedback-and-discussions","text":"If the feedback is actionable, such as a feature request, file a feature request issue. Otherwise, start a new thread in the GitHub Discussions section of the corresponding Project Mu GitHub repository.","title":"General feedback and discussions"},{"location":"How/contributing/#bugs-and-feature-requests","text":"For non-security related bugs, please submit a new issue in the Project Mu GitHub repository that contains the code related to the issue. The best way to get your bug fixed is to be as detailed as you can be about the problem. Providing a code snippet or sample driver that exposes the issue with steps to reproduce the problem is ideal.","title":"Bugs and feature requests"},{"location":"How/contributing/#reporting-security-issues-and-bugs","text":"Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) secure@microsoft.com . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter .","title":"Reporting security issues and bugs"},{"location":"How/contributing/#contributions-of-documentation-andor-code","text":"","title":"Contributions of Documentation and/or Code"},{"location":"How/contributing/#pull-requests","text":"If you don't know what a pull request is read this article: https://help.github.com/articles/about-pull-requests . Make sure the repository can build and all tests pass. Familiarize yourself with the project workflow and our coding conventions.","title":"Pull Requests"},{"location":"How/contributing/#general-workflow","text":"Fork Repository in GitHub Make desired changes. Build it, test it, document it Submit a Pull Request back to the development branch you would like to target. You will be asked to digitally sign a CLA The server will run some builds and tests and report status Community and reviewers will provide feedback in the Pull Request Make changes / adjust based on feedback and discussion Keep your PR branch in-sync with the branch you are targeting and resolve any merge conflicts Once the the PR status is all passing it can be squashed and merged (just press the button in the PR). If the PR is ready the maintainers may complete it for you. That is it. Thanks for contributing. More details on : Code Development Tests Development Documentation Development","title":"General workflow"},{"location":"How/contributing/#contributor-license-agreement-cla","text":"This project welcomes contributions and suggestions. Most (code and documentation) contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.","title":"Contributor License Agreement (CLA)"},{"location":"How/integration_checklist/","text":"Steps for a New Integration \u00b6 Overview \u00b6 In Project Mu, any time we snap to a new commit from our upstream project, Tianocore , we call that an Integration. This usually happens when Tianocore releases a new stable tag, but it can happen at other times, as needed. Below, you will find a checklist of the steps that should be followed by any project maintainers when performing a new upstream integration. This is for reference by the maintainers and by any of the community interested in the process. We will do our best to keep this up to date, so it's an excellent reference for what to expect if you're waiting on an integration. 1) Announce \u00b6 Advertise the upcoming update, where it will start from, how long it will take, and what will happen with the existing release branch afterwards. This should be done in the Release Announcements channel in the Project Mu Team. 2) Rebase and Test \u00b6 Much of this process is designed to be run on every Mu repo. When deciding which repos to update first, refer to the CI dependencies documented in each repo. See here for an example. a) Prep for the Naive Rebase \u00b6 Create rebase/*_naive branch by starting at the very tip of the current (latest) release branch There may be reasons to choose a commit other than the very tip, but this is the default Update the readme with new branch info and update all CI badges to look for the new branch Make sure to update source and destination commits When selecting the destination [upstream] commit... For mu_basecore , this will tend to be the latest stable tag (e.g. edk2-stable202111 ), but that's not always true. Make a selection based on the state of edk2 and the requirements of Mu For other repos, generally you want to pick the exact same commit as mu_basecore . If not, you should probably make a note about why in the Readme Check all tools and other dependencies (probably only in mu_basecore ) to see whether they make sense to move forwards, including... pip modules in pip-requirements.txt markdownlint-cli cspell nasm ACPI tools etc. Sync the Azure pipelines, pip, gitignore files, configs, and other docs with mu_basecore . Try to keep things consistent where possible Easiest way to do this is just a Beyond Compare with Basecore and look at the .azurepipelines and .pytool directories, as well as the pip_requirements.txt , .gitignore , RepoDetails.txt , and Readme.rst files There may be other files that need to be checked as well b) Perform the Naive Rebase \u00b6 NOTE: This process will not be followed the same way on \"pure Mu\" repos such as mu_plus . For each repo, refer to the Readme for any special maintenance instructions . Work through the Naive Rebase Make sure to pay attention to any \"TCMORPH\" commits and whether any new packages/files/submodules need to be dropped Make sure to drop any new .pytool/Plugins that may have been added to other repos that are only needed in mu_basecore . Some plugins may have been added by the upstream project, but most plugins should only live in mu_basecore Keep notes of any major conflicts/sightings, how they were resolved, and any follow up steps that may be needed c) Clean the Rebase \u00b6 This is an optional -- though desireable -- step where we have the opportunity to squash small bugfixes, drop temporary/testing commits, update features with new testing requirements, and any other behavior that helps keep the history clean and readable. Create rebase/*_1 branch and perform initial cleaning Repeat with as many new cleaning branches as necessary Always diff with the rebase/*_naive branch to ensure changes are understood Create the rebase/*_staging branch when complete d) Prepare for Testing \u00b6 Tag the branch as *_Rebase and push tag to remotes NOTE: From here on out, you can only perform a rebase above the *_Rebase tag e) Take care of binary deliverables ( mu_basecore ) \u00b6 Disable the ext deps for BaseTools and Crypto Run the BaseTools release pipeline Trigger the actual release once the build passes Tag the commit that these were released from Update the Basetools version and re-enable the extdep See here for more details f) Run Testing \u00b6 Repeatedly run the PR gate or CI pipelines ( must use the pipelines on the servers) and resolve build issues as they emerge Each issue should be solved in it's own commit and include an update to the Readme with details and potential follow-up actions g) Clean Up \u00b6 Confirm all CI Build notes were updated in the Readme Tag as *_CIBuild and push to all remotes NOTE: Again, from here on out we can only rebase above this tag Create release/* branch in all repos and push branch to remotes From now on, fixes will have to come through PRs 3) Boot a Reference Platform \u00b6 Once rebase has been completed on all repos... On a reference platform, create a new branch for integration testing Pivot all Mu submodules to the new release/* branches Build platform and fix issues as discovered Update individual Readme files with notes on changes required Try to keep these notes associated with the correct repo. Example: if the platform requires a new PCD to build and this PCD is defined in UefiCpuPkg , update the mu_basecore Readme with a note about the platform decision (and ideally include recommendations) Once built, boot platform and fix issues as discovered Update individual Readme files with notes on changes required 4) Change Default Branches \u00b6 Once a reference platform successfully boots to Windows... Tag all repos as *_RefBoot and push tag to remotes Follow the steps in the tutorial videos to move the public and internal defaults 5) Update Security Repos \u00b6 Follow the steps in the tutorial video to update all current Security Patch repos 6) Announce Completion \u00b6 Use the Release Announcements channel in the Project Mu Team to announce completion","title":"Integration Checklist"},{"location":"How/integration_checklist/#steps-for-a-new-integration","text":"","title":"Steps for a New Integration"},{"location":"How/integration_checklist/#overview","text":"In Project Mu, any time we snap to a new commit from our upstream project, Tianocore , we call that an Integration. This usually happens when Tianocore releases a new stable tag, but it can happen at other times, as needed. Below, you will find a checklist of the steps that should be followed by any project maintainers when performing a new upstream integration. This is for reference by the maintainers and by any of the community interested in the process. We will do our best to keep this up to date, so it's an excellent reference for what to expect if you're waiting on an integration.","title":"Overview"},{"location":"How/integration_checklist/#1-announce","text":"Advertise the upcoming update, where it will start from, how long it will take, and what will happen with the existing release branch afterwards. This should be done in the Release Announcements channel in the Project Mu Team.","title":"1) Announce"},{"location":"How/integration_checklist/#2-rebase-and-test","text":"Much of this process is designed to be run on every Mu repo. When deciding which repos to update first, refer to the CI dependencies documented in each repo. See here for an example.","title":"2) Rebase and Test"},{"location":"How/integration_checklist/#a-prep-for-the-naive-rebase","text":"Create rebase/*_naive branch by starting at the very tip of the current (latest) release branch There may be reasons to choose a commit other than the very tip, but this is the default Update the readme with new branch info and update all CI badges to look for the new branch Make sure to update source and destination commits When selecting the destination [upstream] commit... For mu_basecore , this will tend to be the latest stable tag (e.g. edk2-stable202111 ), but that's not always true. Make a selection based on the state of edk2 and the requirements of Mu For other repos, generally you want to pick the exact same commit as mu_basecore . If not, you should probably make a note about why in the Readme Check all tools and other dependencies (probably only in mu_basecore ) to see whether they make sense to move forwards, including... pip modules in pip-requirements.txt markdownlint-cli cspell nasm ACPI tools etc. Sync the Azure pipelines, pip, gitignore files, configs, and other docs with mu_basecore . Try to keep things consistent where possible Easiest way to do this is just a Beyond Compare with Basecore and look at the .azurepipelines and .pytool directories, as well as the pip_requirements.txt , .gitignore , RepoDetails.txt , and Readme.rst files There may be other files that need to be checked as well","title":"a) Prep for the Naive Rebase"},{"location":"How/integration_checklist/#b-perform-the-naive-rebase","text":"NOTE: This process will not be followed the same way on \"pure Mu\" repos such as mu_plus . For each repo, refer to the Readme for any special maintenance instructions . Work through the Naive Rebase Make sure to pay attention to any \"TCMORPH\" commits and whether any new packages/files/submodules need to be dropped Make sure to drop any new .pytool/Plugins that may have been added to other repos that are only needed in mu_basecore . Some plugins may have been added by the upstream project, but most plugins should only live in mu_basecore Keep notes of any major conflicts/sightings, how they were resolved, and any follow up steps that may be needed","title":"b) Perform the Naive Rebase"},{"location":"How/integration_checklist/#c-clean-the-rebase","text":"This is an optional -- though desireable -- step where we have the opportunity to squash small bugfixes, drop temporary/testing commits, update features with new testing requirements, and any other behavior that helps keep the history clean and readable. Create rebase/*_1 branch and perform initial cleaning Repeat with as many new cleaning branches as necessary Always diff with the rebase/*_naive branch to ensure changes are understood Create the rebase/*_staging branch when complete","title":"c) Clean the Rebase"},{"location":"How/integration_checklist/#d-prepare-for-testing","text":"Tag the branch as *_Rebase and push tag to remotes NOTE: From here on out, you can only perform a rebase above the *_Rebase tag","title":"d) Prepare for Testing"},{"location":"How/integration_checklist/#e-take-care-of-binary-deliverables-mu_basecore","text":"Disable the ext deps for BaseTools and Crypto Run the BaseTools release pipeline Trigger the actual release once the build passes Tag the commit that these were released from Update the Basetools version and re-enable the extdep See here for more details","title":"e) Take care of binary deliverables (mu_basecore)"},{"location":"How/integration_checklist/#f-run-testing","text":"Repeatedly run the PR gate or CI pipelines ( must use the pipelines on the servers) and resolve build issues as they emerge Each issue should be solved in it's own commit and include an update to the Readme with details and potential follow-up actions","title":"f) Run Testing"},{"location":"How/integration_checklist/#g-clean-up","text":"Confirm all CI Build notes were updated in the Readme Tag as *_CIBuild and push to all remotes NOTE: Again, from here on out we can only rebase above this tag Create release/* branch in all repos and push branch to remotes From now on, fixes will have to come through PRs","title":"g) Clean Up"},{"location":"How/integration_checklist/#3-boot-a-reference-platform","text":"Once rebase has been completed on all repos... On a reference platform, create a new branch for integration testing Pivot all Mu submodules to the new release/* branches Build platform and fix issues as discovered Update individual Readme files with notes on changes required Try to keep these notes associated with the correct repo. Example: if the platform requires a new PCD to build and this PCD is defined in UefiCpuPkg , update the mu_basecore Readme with a note about the platform decision (and ideally include recommendations) Once built, boot platform and fix issues as discovered Update individual Readme files with notes on changes required","title":"3) Boot a Reference Platform"},{"location":"How/integration_checklist/#4-change-default-branches","text":"Once a reference platform successfully boots to Windows... Tag all repos as *_RefBoot and push tag to remotes Follow the steps in the tutorial videos to move the public and internal defaults","title":"4) Change Default Branches"},{"location":"How/integration_checklist/#5-update-security-repos","text":"Follow the steps in the tutorial video to update all current Security Patch repos","title":"5) Update Security Repos"},{"location":"How/integration_checklist/#6-announce-completion","text":"Use the Release Announcements channel in the Project Mu Team to announce completion","title":"6) Announce Completion"},{"location":"How/release_process/","text":"Release Process \u00b6 Overview \u00b6 Contents and Process Under Active Development While we've been using this process for a couple of years now and think we've worked out all the kinks, it is still subject to change at any time and evolve with our relationship to the upstream project as well as requests and requirements from our downstream consumers and the community. In the interest of maintaining a close, well-defined relationship with the upstream project, TianoCore, the active release branch of Project Mu is periodically deprecated and all Mu-related changes are rebased onto a selected commit of TianoCore. This keeps Project Mu up to date with TianoCore while highlighting all Project Mu differences in the most recent commits and encouraging the reverse integration of all changes/fixes back into TianoCore. In general, the life-cycle of active code follows the following path: All active work in Project Mu is performed on a release/* branch, named sequentially according to the date of TianoCore commit that it's based on (e.g. release/201808 is based on the edk2-stable201808 branch in TianoCore). Work proceeds on that branch until a new TianoCore integration is targeted, at which point a new branch is created and all existing changes are rebased onto the new branch and the new branch is used for all active development going forward. At this point, the previous branch enters a stabilization period where further tests are performed and only bug/security fixes are allowed to be committed. Once in stabilization, the branch will receive a Release Candidate tag (like 2002_RC1 ) to provide synchronization across all Mu repos and represents releases of the code that has been tested and is known to work together. release/* branches will be maintained in LTS (Long-Term Support) for at least the next two releases (though it may be longer based on community needs). Once LTS has ended, the branch will be archived following the process described below . The below diagram illustrates the life-cycle of a single branch and indicates the critical points in its lifetime. These critical points will be applied as tags for reference and documentation. The tags are given a name relative to the target branch and consist of: Upstream base, Rebase complete, Rebase builds and passes CI, Rebase boots on a designated reference platform, and stabilized Release Candidates. These tags are discussed in more detail below . Important Due to the impacts of the rebase process on the history of Mu release branches, any downstream consumers will have to follow a similar integration process when upgrading to a new release. Any custom changes made within the Project Mu repos will have to be rebased from one release to the next. This is why we strongly discourage forking Project Mu for direct modification (ie. consumption, not contribution). Instead, leverage the distributed repo management system and override management system to integrate proprietary code/modules. Current Branch Status \u00b6 The status of each branch will be recorded in the ReadMe.rst file at the root of the branch. In general, the ReadMe found in Basecore will contain information that is common to all of the Mu submodules, but each submodule will also have its own ReadMe for each release branch that contains notes specific to the development that occurs in that submodule during a release cycle. The ReadMe will also contain a summary of the branch status at a given time. For example, here is a sample status for Basecore release/202008 as of the time of this writing: :Status: In Development :Entered Development: 2020/09/23 :Anticipated Stabilization: November 2020 In addition, the ReadMe.rst file contains information related to the target upstream commit (\"Destination commit\") for the current integration as well as the final commit (\"Source commit\") from the previous release/* branch when the integration commenced. Upstream Integration Phase \u00b6 At this time, we are targeting upstream integrations for roughly once a quarter, attempting to align 1:1 with the TianoCore stable release cadence. Prior to an integration, the Project Mu Teams channel will be updated with the target date of completion and the target TianoCore commit and/or release. For example, a plan was made to transition off of release/20180529 when TianoCore announced the edk2-stable201808 release. Once a commit is selected, a set of rebase commits will be chosen from the active (previous) release/* branch. Ideally, these commits would include everything from the previous rebase through the most recent *_RC tag. For example, when moving from the release/201808 branch, the commits will be selected from 1808_Upstream (not inclusive) tag to 1808_RC1 . After selection, this list of commits will be evaluated to determine whether any changes are no longer needed in the Mu history. The most likely causes of this action are: A change was submitted to TianoCore and has been accepted since the last rebase. Therefore, the change is no longer needed in Mu history. A change was reverted or modified more recently in Mu history, and the history of this change was squashed to maintain simplicity when comparing with upstream (TianoCore). Once all evaluation is completed, the rebase will be performed in the new release/* branch. This branch will then be submitted for the same CI/PR gates that any commit would be required to pass to ensure that there have been no regressions and to guarantee that dev work can transition to the new branch. Finally, the new release branches will be integrated into a designated reference platform and porting notes will be written in the ReadMe.rst file describing any known breaking changes. Once all these milestones have been passed, the new release/* branch will be made the default branch for all repos and the old branch will enter a brief stabilization period before receiving an *_RC tag. Integration Milestone Tags \u00b6 During integration, multiple tags are applied to the branch to serve as milestones. They also serve as reference point for changelog documentation that is produced during the integration process. Not all repos will have all tags, because not all repos have an upstream. These tags are described below: *_Upstream This tag is placed on the exact TianoCore commit that a given release branch started from. This is used as a reference point between branches and relative to the rebase operation. The documentation produced for this tag contains the differences in TianoCore between this branch and the previous branch. For branches that originated from TianoCore releases, this changelog should be identical to the TianoCore changelog. (Does not exist on all repos.) *_Rebase This tag is placed on the commit at the branch HEAD once the rebase is completed. The only changes to the commits from the last branch should be merge conflict resolutions and any history simplification as described above. The documentation produced for this tag contains a record of these resolutions and simplifications. (Does not exist on all repos.) *_CIBuild This tag is placed on the commit where all code in the given repo passes all CI/PR checks that would normally be required of any commit to the branch. These checks include comprehensive compilation checks as well as things like: spelling, library declarations, code format, etc. The documentation produced for this tag contains any changes required to pass these checks. *_RefBoot This tag is placed on the commit where a reference platform consuming a large portion of the Mu code can successfully boot. The documentation produced for this tag contains any changes required to get the reference platform building and booting. It includes a list of changes outside the Mu project that are recommended for any consuming platform. In each of these cases, the * will be replaced with a corresponding branch name. For example, the tags associated with release/201808 will be prefixed with 1808 (e.g. 1808_Rebase , 1808_RC1 , etc.). Active Development Phase \u00b6 During the active development phase, the release branch is open for comment and contribution both internally and publicly. All work contributed by the Project Mu team will be publicly available after an internal PR review. These commits will automatically be mirrored to the public repos. Similarly, all completed public PRs are mirrored in internal review repos (with preference being given to the public PR in event of a conflict). While this means that there will be times where Project Mu team will make contributions without going through a full public PR review, all code is open to comment and contribution, up to and including a full revert of the internal Mu team contribution. Public Contribution/Commentary \u00b6 For information on the contribution policies and steps, see the How to Contribute document. Upstream Cherry-Picks \u00b6 In the event that a critical change is made in the TianoCore upstream during the Active Development phase, the Project Mu team (with any suggestions or comment from downstream contributors) will evaluate the change for a mid-release cherry pick. If warranted, the commit(s) will be cherry-picked directly from TianoCore using the -x parameter so that it is obvious which upstream commit corresponds to the cherry-pick. This is for provenance as well as ensuring that these commits are cleaned up on the next integration. Stabilization Phase \u00b6 Once active development has moved off of a given release/* branch, the branch will undergo a period of stabilization where no major changes will be made while additional hours are gained and -- potentially -- additional tests are run. Once sufficient confidence is built, the branch will be tagged with an *_RC1 tag. Only major bug fixes and features that have reached community consensus will be accepted from then on. It is Project Mu's goal that this cadence be aligned with the TianoCore release cadence, with the previous branch stabilizing at the same time a new TianoCore release is available. In this way, development can seamlessly move to the next release/* branch without lapse in availability. Note It is possible that multiple *_RCn tags may be useful to distinguish between milestones of a particularly protracted Stabilization phase, or if major issues were found after the initial *_RC tag. If this occurs, the ReadMe.rst file will be updated with the motivation behind the extra release. It should also be noted that this will cause a new release across all the Project Mu repos to confirm that the code has been tested together. As a result, there may exist a single commit with multiple *_RC tags. Transition Branches \u00b6 In the event that it becomes necessary to stabilize a release/* branch prior to the availability of a suitable TianoCore commit for rebasing, all active development will move to a dev/* branch that will branch from the previous *_RC1 tag. If bugs are discovered in the Stabilization phase for the release/* branch, they will also be fixed in the dev/* branch and all changes made in the dev/* branch will be rebased as part of the next release/* branch when it is ready. Long-Term Support (LTS) \u00b6 It is Project Mu's goal that all release/* branches continue to be maintained with active bug fixes -- as necessary -- for at least two full releases after the branch becomes stable. The Project Mu team will serve as the primary deciding body for whether a bug fix to the current release/* branch merits porting back to the prior two branches, but community input or suggestions are always welcome. All release branches that make it to the Stabilization phase will be hosted and kept in the repository in perpetuity. If any change was required to this policy (perhaps for server considerations), the branches will remain archived for posterity and should be available by request. Post-LTS and Archiving \u00b6 LTS branch maintenance requires significant resources, both to human (to manually curate and port critical fixes, as well as documentation) and computational (to run regular CI on all active branches across all repos). As such, while we try to keep these branches stable and active for as long as possible, we cannot do it forever. To uphold our commitment to persist any branch that makes it to the LTS phase, these branches will instead be \"archived\". Prior to archival, a notice will be posted to the Project Mu Teams channel announcing the planned dates. The actual process for archiving on the server is: Create a new branch under the archived/* namespace at the exact commit of the existing branch. release/202008 \u2192 archived/release/202008 Push this new branch to the server. Delete the old branch on the server. This process is repeated across all Mu repos. Since the commit history always has a Git branch referencing it, all of the commits will be preserved and any projects that are currently consuming the commit will continue to function as expected. However, after this point the branch will receive no further updates and all consumers are encouraged to move to one of the active LTS branches.","title":"Release Process"},{"location":"How/release_process/#release-process","text":"","title":"Release Process"},{"location":"How/release_process/#overview","text":"Contents and Process Under Active Development While we've been using this process for a couple of years now and think we've worked out all the kinks, it is still subject to change at any time and evolve with our relationship to the upstream project as well as requests and requirements from our downstream consumers and the community. In the interest of maintaining a close, well-defined relationship with the upstream project, TianoCore, the active release branch of Project Mu is periodically deprecated and all Mu-related changes are rebased onto a selected commit of TianoCore. This keeps Project Mu up to date with TianoCore while highlighting all Project Mu differences in the most recent commits and encouraging the reverse integration of all changes/fixes back into TianoCore. In general, the life-cycle of active code follows the following path: All active work in Project Mu is performed on a release/* branch, named sequentially according to the date of TianoCore commit that it's based on (e.g. release/201808 is based on the edk2-stable201808 branch in TianoCore). Work proceeds on that branch until a new TianoCore integration is targeted, at which point a new branch is created and all existing changes are rebased onto the new branch and the new branch is used for all active development going forward. At this point, the previous branch enters a stabilization period where further tests are performed and only bug/security fixes are allowed to be committed. Once in stabilization, the branch will receive a Release Candidate tag (like 2002_RC1 ) to provide synchronization across all Mu repos and represents releases of the code that has been tested and is known to work together. release/* branches will be maintained in LTS (Long-Term Support) for at least the next two releases (though it may be longer based on community needs). Once LTS has ended, the branch will be archived following the process described below . The below diagram illustrates the life-cycle of a single branch and indicates the critical points in its lifetime. These critical points will be applied as tags for reference and documentation. The tags are given a name relative to the target branch and consist of: Upstream base, Rebase complete, Rebase builds and passes CI, Rebase boots on a designated reference platform, and stabilized Release Candidates. These tags are discussed in more detail below . Important Due to the impacts of the rebase process on the history of Mu release branches, any downstream consumers will have to follow a similar integration process when upgrading to a new release. Any custom changes made within the Project Mu repos will have to be rebased from one release to the next. This is why we strongly discourage forking Project Mu for direct modification (ie. consumption, not contribution). Instead, leverage the distributed repo management system and override management system to integrate proprietary code/modules.","title":"Overview"},{"location":"How/release_process/#current-branch-status","text":"The status of each branch will be recorded in the ReadMe.rst file at the root of the branch. In general, the ReadMe found in Basecore will contain information that is common to all of the Mu submodules, but each submodule will also have its own ReadMe for each release branch that contains notes specific to the development that occurs in that submodule during a release cycle. The ReadMe will also contain a summary of the branch status at a given time. For example, here is a sample status for Basecore release/202008 as of the time of this writing: :Status: In Development :Entered Development: 2020/09/23 :Anticipated Stabilization: November 2020 In addition, the ReadMe.rst file contains information related to the target upstream commit (\"Destination commit\") for the current integration as well as the final commit (\"Source commit\") from the previous release/* branch when the integration commenced.","title":"Current Branch Status"},{"location":"How/release_process/#upstream-integration-phase","text":"At this time, we are targeting upstream integrations for roughly once a quarter, attempting to align 1:1 with the TianoCore stable release cadence. Prior to an integration, the Project Mu Teams channel will be updated with the target date of completion and the target TianoCore commit and/or release. For example, a plan was made to transition off of release/20180529 when TianoCore announced the edk2-stable201808 release. Once a commit is selected, a set of rebase commits will be chosen from the active (previous) release/* branch. Ideally, these commits would include everything from the previous rebase through the most recent *_RC tag. For example, when moving from the release/201808 branch, the commits will be selected from 1808_Upstream (not inclusive) tag to 1808_RC1 . After selection, this list of commits will be evaluated to determine whether any changes are no longer needed in the Mu history. The most likely causes of this action are: A change was submitted to TianoCore and has been accepted since the last rebase. Therefore, the change is no longer needed in Mu history. A change was reverted or modified more recently in Mu history, and the history of this change was squashed to maintain simplicity when comparing with upstream (TianoCore). Once all evaluation is completed, the rebase will be performed in the new release/* branch. This branch will then be submitted for the same CI/PR gates that any commit would be required to pass to ensure that there have been no regressions and to guarantee that dev work can transition to the new branch. Finally, the new release branches will be integrated into a designated reference platform and porting notes will be written in the ReadMe.rst file describing any known breaking changes. Once all these milestones have been passed, the new release/* branch will be made the default branch for all repos and the old branch will enter a brief stabilization period before receiving an *_RC tag.","title":"Upstream Integration Phase"},{"location":"How/release_process/#integration-milestone-tags","text":"During integration, multiple tags are applied to the branch to serve as milestones. They also serve as reference point for changelog documentation that is produced during the integration process. Not all repos will have all tags, because not all repos have an upstream. These tags are described below: *_Upstream This tag is placed on the exact TianoCore commit that a given release branch started from. This is used as a reference point between branches and relative to the rebase operation. The documentation produced for this tag contains the differences in TianoCore between this branch and the previous branch. For branches that originated from TianoCore releases, this changelog should be identical to the TianoCore changelog. (Does not exist on all repos.) *_Rebase This tag is placed on the commit at the branch HEAD once the rebase is completed. The only changes to the commits from the last branch should be merge conflict resolutions and any history simplification as described above. The documentation produced for this tag contains a record of these resolutions and simplifications. (Does not exist on all repos.) *_CIBuild This tag is placed on the commit where all code in the given repo passes all CI/PR checks that would normally be required of any commit to the branch. These checks include comprehensive compilation checks as well as things like: spelling, library declarations, code format, etc. The documentation produced for this tag contains any changes required to pass these checks. *_RefBoot This tag is placed on the commit where a reference platform consuming a large portion of the Mu code can successfully boot. The documentation produced for this tag contains any changes required to get the reference platform building and booting. It includes a list of changes outside the Mu project that are recommended for any consuming platform. In each of these cases, the * will be replaced with a corresponding branch name. For example, the tags associated with release/201808 will be prefixed with 1808 (e.g. 1808_Rebase , 1808_RC1 , etc.).","title":"Integration Milestone Tags"},{"location":"How/release_process/#active-development-phase","text":"During the active development phase, the release branch is open for comment and contribution both internally and publicly. All work contributed by the Project Mu team will be publicly available after an internal PR review. These commits will automatically be mirrored to the public repos. Similarly, all completed public PRs are mirrored in internal review repos (with preference being given to the public PR in event of a conflict). While this means that there will be times where Project Mu team will make contributions without going through a full public PR review, all code is open to comment and contribution, up to and including a full revert of the internal Mu team contribution.","title":"Active Development Phase"},{"location":"How/release_process/#public-contributioncommentary","text":"For information on the contribution policies and steps, see the How to Contribute document.","title":"Public Contribution/Commentary"},{"location":"How/release_process/#upstream-cherry-picks","text":"In the event that a critical change is made in the TianoCore upstream during the Active Development phase, the Project Mu team (with any suggestions or comment from downstream contributors) will evaluate the change for a mid-release cherry pick. If warranted, the commit(s) will be cherry-picked directly from TianoCore using the -x parameter so that it is obvious which upstream commit corresponds to the cherry-pick. This is for provenance as well as ensuring that these commits are cleaned up on the next integration.","title":"Upstream Cherry-Picks"},{"location":"How/release_process/#stabilization-phase","text":"Once active development has moved off of a given release/* branch, the branch will undergo a period of stabilization where no major changes will be made while additional hours are gained and -- potentially -- additional tests are run. Once sufficient confidence is built, the branch will be tagged with an *_RC1 tag. Only major bug fixes and features that have reached community consensus will be accepted from then on. It is Project Mu's goal that this cadence be aligned with the TianoCore release cadence, with the previous branch stabilizing at the same time a new TianoCore release is available. In this way, development can seamlessly move to the next release/* branch without lapse in availability. Note It is possible that multiple *_RCn tags may be useful to distinguish between milestones of a particularly protracted Stabilization phase, or if major issues were found after the initial *_RC tag. If this occurs, the ReadMe.rst file will be updated with the motivation behind the extra release. It should also be noted that this will cause a new release across all the Project Mu repos to confirm that the code has been tested together. As a result, there may exist a single commit with multiple *_RC tags.","title":"Stabilization Phase"},{"location":"How/release_process/#transition-branches","text":"In the event that it becomes necessary to stabilize a release/* branch prior to the availability of a suitable TianoCore commit for rebasing, all active development will move to a dev/* branch that will branch from the previous *_RC1 tag. If bugs are discovered in the Stabilization phase for the release/* branch, they will also be fixed in the dev/* branch and all changes made in the dev/* branch will be rebased as part of the next release/* branch when it is ready.","title":"Transition Branches"},{"location":"How/release_process/#long-term-support-lts","text":"It is Project Mu's goal that all release/* branches continue to be maintained with active bug fixes -- as necessary -- for at least two full releases after the branch becomes stable. The Project Mu team will serve as the primary deciding body for whether a bug fix to the current release/* branch merits porting back to the prior two branches, but community input or suggestions are always welcome. All release branches that make it to the Stabilization phase will be hosted and kept in the repository in perpetuity. If any change was required to this policy (perhaps for server considerations), the branches will remain archived for posterity and should be available by request.","title":"Long-Term Support (LTS)"},{"location":"How/release_process/#post-lts-and-archiving","text":"LTS branch maintenance requires significant resources, both to human (to manually curate and port critical fixes, as well as documentation) and computational (to run regular CI on all active branches across all repos). As such, while we try to keep these branches stable and active for as long as possible, we cannot do it forever. To uphold our commitment to persist any branch that makes it to the LTS phase, these branches will instead be \"archived\". Prior to archival, a notice will be posted to the Project Mu Teams channel announcing the planned dates. The actual process for archiving on the server is: Create a new branch under the archived/* namespace at the exact commit of the existing branch. release/202008 \u2192 archived/release/202008 Push this new branch to the server. Delete the old branch on the server. This process is repeated across all Mu repos. Since the commit history always has a Git branch referencing it, all of the commits will be preserved and any projects that are currently consuming the commit will continue to function as expected. However, after this point the branch will receive no further updates and all consumers are encouraged to move to one of the active LTS branches.","title":"Post-LTS and Archiving"},{"location":"How/using_project_mu/","text":"How to setup a new Repo for a Platform that will use Project MU \u00b6 This document will describe the base guidelines for setting up a Project MU repo. You will need to install the prerequisites tools Determine how to layout your project and the content Look at layout to understand our recommended repository layout. You can also look at ms-iot iMX8 for a real platform implementation. Check out our docs in our Project Mu Teams channel as we have presentations on OVMF and Intel OpenKBL platforms. Nomenclature \u00b6 I will use the term workspace root to reference the base folder for your code tree. Ordinarily, we use the Platform Repository as the outer-most layer. This means that the outermost git repository is where we store Platform specific files and libraries. In this case, our Platform Repo is also our workspace root . If you choose to have a different repository layout, it will be important to note what your workspace root is, as it should still be the base folder of your code tree. Submodules are full git repos on their own. What we do with these repos is add them as sub-repos to the workspace root . Git will create a .gitmodules file that contains links to the repo and default branches. There are git submodule commands that you can use to work with your submodules, such as: git submodule add <url> <path> # url to submodule, path to submodule installation git submodule update --init --recursive # Recursively initializes and updates all submodules. git submodule foreach git status # git submodule foreach can be used to run a command in each submodule. # git status is just an example. For more information available here . Create Git Repo \u00b6 Make new directory. mkdir NewPlatformRepo cd NewPlatformRepo git init This will serve as our Platform Repository as well as our Workspace Root. For more information on creating a Git repo, here are command line instructions and here are web instructions . Add pertinent submodules \u00b6 Project MU is separated into submodules. For each submodule that you need for your project, run the \"git submodule add\" command to add it to your base Repository. The path after the URL is the path we typically use to group the submodules. You can change it if you'd like, just remember your environment will diverge from the one in these instructions. MU_BASECORE \u00b6 This is the core section of TianoCore. Contains the guts of UEFI, forked from TianoCore, as well as the BaseTools needed to build. You will need this to continue. git submodule add https://github.com/Microsoft/mu_basecore.git MU_BASECORE MU_PLUS \u00b6 Additional, optional libraries and tools we've added to make MU great! git submodule add https://github.com/Microsoft/mu_plus.git Common/MU MU_TIANO_PLUS \u00b6 Additional, optional libraries and tools forked from TianoCore. git submodule add https://github.com/Microsoft/mu_tiano_plus.git Common/TIANO MU_OEM_SAMPLE \u00b6 This module is a sample implementation of a FrontPage and several BDS support libraries. This module is intended to be forked and customized. git submodule add https://github.com/Microsoft/mu_oem_sample.git Common/MU_OEM_SAMPLE MU_SILICON_ARM_TIANO \u00b6 Silicon code from TianoCore has been broken out into individual submodules. This is the ARM specific submodule. git submodule add https://github.com/Microsoft/mu_silicon_arm_tiano.git Silicon/ARM/TIANO MU_SILICON_INTEL_TIANO \u00b6 Silicon code from TianoCore has been broken out into individual submodules. This is the Intel specific submodule. git submodule add https://github.com/Microsoft/mu_silicon_intel_tiano.git Silicon/INTEL/TIANO You can run git submodule --update --init to make sure all the submodules are set up. Adding your platform contents \u00b6 New_Platform_Repo/ \u251c\u2500\u2500 Common/ \u2502 \u2514\u2500\u2500 ... # MU_PLUS, MU_OEM_SAMPLE, MU_TIANO_PLUS are generally created by the \"git submodule ...\" \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 PlatformGroup/ \u2502 \u2514\u2500\u2500 PlatformName/ \u2502 \u2514\u2500\u2500 PlatformBuild.py # Python script to provide information to the build process. \u2502 \u2514\u2500\u2500 Platform.dsc # List of UEFI libraries and drivers to compile, as well as platform settings. \u2502 \u2514\u2500\u2500 Platform.fdf # List of UEFI Drivers to put into Firmware Volumes. \u251c\u2500\u2500 Silicon/ \u2502 \u2514\u2500\u2500 SiProvider/ # You should create a separate git repo for Silicon code for development with partners. \u2502 \u2514\u2500\u2500 REF_CODE/ # Enablement code for your architecture \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules You will need to create PlatformBuild.py, Platform.dsc, and Platform.fdf. These files will go inside the platform folder, which will be New_Platform_Repo/PlatformGroup/PlatformName . The ms-iot iMX8 repo can help you get started as a layout reference and can demonstrate the PlatformBuild file. More information about PlatformBuild can be found here .","title":"Using"},{"location":"How/using_project_mu/#how-to-setup-a-new-repo-for-a-platform-that-will-use-project-mu","text":"This document will describe the base guidelines for setting up a Project MU repo. You will need to install the prerequisites tools Determine how to layout your project and the content Look at layout to understand our recommended repository layout. You can also look at ms-iot iMX8 for a real platform implementation. Check out our docs in our Project Mu Teams channel as we have presentations on OVMF and Intel OpenKBL platforms.","title":"How to setup a new Repo for a Platform that will use Project MU"},{"location":"How/using_project_mu/#nomenclature","text":"I will use the term workspace root to reference the base folder for your code tree. Ordinarily, we use the Platform Repository as the outer-most layer. This means that the outermost git repository is where we store Platform specific files and libraries. In this case, our Platform Repo is also our workspace root . If you choose to have a different repository layout, it will be important to note what your workspace root is, as it should still be the base folder of your code tree. Submodules are full git repos on their own. What we do with these repos is add them as sub-repos to the workspace root . Git will create a .gitmodules file that contains links to the repo and default branches. There are git submodule commands that you can use to work with your submodules, such as: git submodule add <url> <path> # url to submodule, path to submodule installation git submodule update --init --recursive # Recursively initializes and updates all submodules. git submodule foreach git status # git submodule foreach can be used to run a command in each submodule. # git status is just an example. For more information available here .","title":"Nomenclature"},{"location":"How/using_project_mu/#create-git-repo","text":"Make new directory. mkdir NewPlatformRepo cd NewPlatformRepo git init This will serve as our Platform Repository as well as our Workspace Root. For more information on creating a Git repo, here are command line instructions and here are web instructions .","title":"Create Git Repo"},{"location":"How/using_project_mu/#add-pertinent-submodules","text":"Project MU is separated into submodules. For each submodule that you need for your project, run the \"git submodule add\" command to add it to your base Repository. The path after the URL is the path we typically use to group the submodules. You can change it if you'd like, just remember your environment will diverge from the one in these instructions.","title":"Add pertinent submodules"},{"location":"How/using_project_mu/#mu_basecore","text":"This is the core section of TianoCore. Contains the guts of UEFI, forked from TianoCore, as well as the BaseTools needed to build. You will need this to continue. git submodule add https://github.com/Microsoft/mu_basecore.git MU_BASECORE","title":"MU_BASECORE"},{"location":"How/using_project_mu/#mu_plus","text":"Additional, optional libraries and tools we've added to make MU great! git submodule add https://github.com/Microsoft/mu_plus.git Common/MU","title":"MU_PLUS"},{"location":"How/using_project_mu/#mu_tiano_plus","text":"Additional, optional libraries and tools forked from TianoCore. git submodule add https://github.com/Microsoft/mu_tiano_plus.git Common/TIANO","title":"MU_TIANO_PLUS"},{"location":"How/using_project_mu/#mu_oem_sample","text":"This module is a sample implementation of a FrontPage and several BDS support libraries. This module is intended to be forked and customized. git submodule add https://github.com/Microsoft/mu_oem_sample.git Common/MU_OEM_SAMPLE","title":"MU_OEM_SAMPLE"},{"location":"How/using_project_mu/#mu_silicon_arm_tiano","text":"Silicon code from TianoCore has been broken out into individual submodules. This is the ARM specific submodule. git submodule add https://github.com/Microsoft/mu_silicon_arm_tiano.git Silicon/ARM/TIANO","title":"MU_SILICON_ARM_TIANO"},{"location":"How/using_project_mu/#mu_silicon_intel_tiano","text":"Silicon code from TianoCore has been broken out into individual submodules. This is the Intel specific submodule. git submodule add https://github.com/Microsoft/mu_silicon_intel_tiano.git Silicon/INTEL/TIANO You can run git submodule --update --init to make sure all the submodules are set up.","title":"MU_SILICON_INTEL_TIANO"},{"location":"How/using_project_mu/#adding-your-platform-contents","text":"New_Platform_Repo/ \u251c\u2500\u2500 Common/ \u2502 \u2514\u2500\u2500 ... # MU_PLUS, MU_OEM_SAMPLE, MU_TIANO_PLUS are generally created by the \"git submodule ...\" \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 PlatformGroup/ \u2502 \u2514\u2500\u2500 PlatformName/ \u2502 \u2514\u2500\u2500 PlatformBuild.py # Python script to provide information to the build process. \u2502 \u2514\u2500\u2500 Platform.dsc # List of UEFI libraries and drivers to compile, as well as platform settings. \u2502 \u2514\u2500\u2500 Platform.fdf # List of UEFI Drivers to put into Firmware Volumes. \u251c\u2500\u2500 Silicon/ \u2502 \u2514\u2500\u2500 SiProvider/ # You should create a separate git repo for Silicon code for development with partners. \u2502 \u2514\u2500\u2500 REF_CODE/ # Enablement code for your architecture \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules You will need to create PlatformBuild.py, Platform.dsc, and Platform.fdf. These files will go inside the platform folder, which will be New_Platform_Repo/PlatformGroup/PlatformName . The ms-iot iMX8 repo can help you get started as a layout reference and can demonstrate the PlatformBuild file. More information about PlatformBuild can be found here .","title":"Adding your platform contents"},{"location":"WhatAndWhy/features/","text":"Features \u00b6 Summary \u00b6 Project Mu features will generally be found in a \"MU\" sub-module, for example, \"Common/MU\" or \"Silicon/Intel/MU\". What major features does Project Mu bring to the table above/beyond EDK2? Feature List \u00b6 Pluggable, cross-device, performance-optimized BDS Device Firmware Configuration Interface (DFCI) - enables practical MDM management PBKDF2-based BIOS password example Support for EKU-based trust anchors during signature validation Microsoft unit test framework Audit, function, & performance tests for platform features Scalable Python build environment Build plug in: override tracking tool Build plug in: flash descriptor analysis Binary package management via NuGet Capsule signing via signtool.exe Up-to-date Visual Studio compiler support Base64 encode for binary objects XML Support Package Features Coming Soon \u00b6 Modern BIOS menu example (Surface inspired) On screen keyboard (OSK) with mouse, touch support Graphical end-to-end boot performance analysis library and tool Infineon TPM firmware update via Capsule On screen notifications: color bars to inform users that a device is not in a production configuration Features integrated into Tiano \u00b6 Safe Integer library Heap Guard ESRT DXE driver Scalable device FMP framework Progress bar for Capsule Updates TCG FV pre hashing optimization NVME shutdown","title":"Features"},{"location":"WhatAndWhy/features/#features","text":"","title":"Features"},{"location":"WhatAndWhy/features/#summary","text":"Project Mu features will generally be found in a \"MU\" sub-module, for example, \"Common/MU\" or \"Silicon/Intel/MU\". What major features does Project Mu bring to the table above/beyond EDK2?","title":"Summary"},{"location":"WhatAndWhy/features/#feature-list","text":"Pluggable, cross-device, performance-optimized BDS Device Firmware Configuration Interface (DFCI) - enables practical MDM management PBKDF2-based BIOS password example Support for EKU-based trust anchors during signature validation Microsoft unit test framework Audit, function, & performance tests for platform features Scalable Python build environment Build plug in: override tracking tool Build plug in: flash descriptor analysis Binary package management via NuGet Capsule signing via signtool.exe Up-to-date Visual Studio compiler support Base64 encode for binary objects XML Support Package","title":"Feature List"},{"location":"WhatAndWhy/features/#features-coming-soon","text":"Modern BIOS menu example (Surface inspired) On screen keyboard (OSK) with mouse, touch support Graphical end-to-end boot performance analysis library and tool Infineon TPM firmware update via Capsule On screen notifications: color bars to inform users that a device is not in a production configuration","title":"Features Coming Soon"},{"location":"WhatAndWhy/features/#features-integrated-into-tiano","text":"Safe Integer library Heap Guard ESRT DXE driver Scalable device FMP framework Progress bar for Capsule Updates TCG FV pre hashing optimization NVME shutdown","title":"Features integrated into Tiano"},{"location":"WhatAndWhy/layout/","text":"Dependencies and Layout \u00b6 Conceptual Layers \u00b6 A modern, full-featured, product-ready UEFI firmware codebase combines code from a multitude of sources: TianoCore EDK2 UEFI standard-based code Value-add code from TianoCore Silicon vendor hardware initialization code Silicon vendor value-add code Independent BIOS Vendor code ODM/OEM customization code OS firmware support code Legacy BIOS compatibility code Board-specific code etc. Some of the above components come from closed-source projects (silicon vendors, IBVs, OEMs), others are open source. Each component is supported at its own schedule with new features and bug fixes, creating a problem of stale code if not synced up regularly. Compound the version and source problem with the sheer size: a common UEFI codebase is typically well above 1 million LOC and only goes up from there. What is a dependency \u00b6 To understand the layering you must first understand the terminology. There are two types of code assets. A definition of something. Generally, this is defined in an accessible header file. This is the API provided by some asset. This API can be \"depended\" upon to provide some capability. An implementation of something. flowchart BT id1[\"Implementation/Module <br> (Inf/C)\"] id2[\"Definition/Declaration <br>(Public Header file)\"] id1 -.-> id2 Example of a build time/link dependency: DxeCore in the Basecore layer depends on the TimerLib interface. TimerLib interface is defined in the same Basecore layer as DxeCore, so in this case a Basecore module is depending on a Basecore interface. This is allowed. flowchart BT id1[\"DxeCore Module\"] id2[\"TimerLib Interface\"] id1 -.-> id2 To extend this example even more into construction details. Often the logic of a library will be implemented in the silicon layer. This means the code may vary based on which silicon is used in the product but because the interface is defined in the basecore layer this is allowed and working as designed. The core module can be optimized and targeted for a specific silicon implementation. flowchart BT subgraph bc [Basecore] id1[\"DxeCore\"] id2[\"TimerLib\"] id1 -.-> id2 end subgraph sl [Silicon layer] id3[\"Silicon TimerLib\"] end id3 -->id2 An example of an unacceptable/unsustainable dependency is if the core module starts to use the silicon layer directly. For example if a feature was introduced that used a silicon special widget in the DxeCore then this would fail our dependency checks. flowchart BT subgraph bc [Basecore] id1[\"DxeCore\"] end subgraph sl [Silicon layer] id3[\"Silicon Special Widget Lib<br>Implementations\"] id4[\"Silicon SpecialWidgetLib\"] id3 -->id4 end id1 -. NOT ALLOWED .-> id4 Architecture \u00b6 Project Mu is an attempt to create a rigid layering scheme that defines the hierarchy of dependencies. Architectural goal kept in mind when designing this layering scheme is a controlled, limited scope, and allowed dependencies for each module within a given layer. It is important to know, when implementing a module, what the module is allowed to depend on. When creating an interface, it is important to identify the correct layer for it such that all the consuming modules are located in the layers below. Motivation and goals of the layering scheme: Easy component integration Code reuse Only carry relevant code Dependency Block Diagram \u00b6 File Layout \u00b6 To best preserve and delineate these concepts of componentization and unidirectional dependency, we have chosen to lay out our repository files in a structure that reinforces the same mentality. The underlying logic of this layout is to clearly distinguish each layer from the rest. As such, the Basecore -- which is considered foundational -- is broken out on its own, followed by the Common repos, followed by the Silicon, followed by the Platform. As mentioned elsewhere, Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the firmware ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. One of the goals of Project Mu is to make this seemingly complicated layout easier to work with. Min Platform Example \u00b6 A simple tree might look like this... project_mu/ \u251c\u2500\u2500 Build/ \u251c\u2500\u2500 Common/ \u2502 \u2514\u2500\u2500 ... # Common code optional, but probably not required \u251c\u2500\u2500 Conf/ \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 Platform/ \u2502 \u2514\u2500\u2500 Sample/ \u2502 \u2514\u2500\u2500 MyMinPlatform # Platform-specific build files and code \u251c\u2500\u2500 Silicon/ \u2502 \u2514\u2500\u2500 SiProvider/ \u2502 \u2514\u2500\u2500 REF_CODE/ # Enablement code for your architecture \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules Note that this file structure is likely located in a Git repository, and every \"ALL CAPS\" directory in this example is a Git submodule/nested repository. Surface Laptop Example \u00b6 For a real-world example, this is a tree that could build the Surface Laptop product, including both open- and closed-source repositories: project_mu/ \u251c\u2500\u2500 Build/ \u251c\u2500\u2500 Common/ \u2502 \u251c\u2500\u2500 MSCORE_INTERNAL/ # Proprietary code and code not yet approved for public distribution \u2502 \u251c\u2500\u2500 MU/ \u2502 \u251c\u2500\u2500 MU_TIANO/ \u2502 \u2514\u2500\u2500 SURFACE/ # Shared code to enable common features like FrontPage \u251c\u2500\u2500 Conf/ \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 Platform/ \u2502 \u251c\u2500\u2500 Surface/ \u2502 \u2502 \u251c\u2500\u2500 SurfKbl/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 Laptop/ # Surface Laptop-Specific Platform Code \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 Others/ \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 Silicon/ \u2502 \u251c\u2500\u2500 Intel/ \u2502 \u2502 \u251c\u2500\u2500 KBL/ # Intel KBL Reference Code \u2502 \u2502 \u251c\u2500\u2500 MU/ # Project Mu Intel Common Code \u2502 \u2502 \u251c\u2500\u2500 MU_TIANO/ # Project Mu Intel Code from TianoCore \u2502 \u2502 \u2514\u2500\u2500 SURF_KBL/ # Surface Customizations/Overrides for KBL Ref Code \u2502 \u2514\u2500\u2500 SURFACE/ # Shared code to enable common HW like ECs \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules Once again, the \"ALL CAPS\" directories are submodules.","title":"Dependencies and Layout"},{"location":"WhatAndWhy/layout/#dependencies-and-layout","text":"","title":"Dependencies and Layout"},{"location":"WhatAndWhy/layout/#conceptual-layers","text":"A modern, full-featured, product-ready UEFI firmware codebase combines code from a multitude of sources: TianoCore EDK2 UEFI standard-based code Value-add code from TianoCore Silicon vendor hardware initialization code Silicon vendor value-add code Independent BIOS Vendor code ODM/OEM customization code OS firmware support code Legacy BIOS compatibility code Board-specific code etc. Some of the above components come from closed-source projects (silicon vendors, IBVs, OEMs), others are open source. Each component is supported at its own schedule with new features and bug fixes, creating a problem of stale code if not synced up regularly. Compound the version and source problem with the sheer size: a common UEFI codebase is typically well above 1 million LOC and only goes up from there.","title":"Conceptual Layers"},{"location":"WhatAndWhy/layout/#what-is-a-dependency","text":"To understand the layering you must first understand the terminology. There are two types of code assets. A definition of something. Generally, this is defined in an accessible header file. This is the API provided by some asset. This API can be \"depended\" upon to provide some capability. An implementation of something. flowchart BT id1[\"Implementation/Module <br> (Inf/C)\"] id2[\"Definition/Declaration <br>(Public Header file)\"] id1 -.-> id2 Example of a build time/link dependency: DxeCore in the Basecore layer depends on the TimerLib interface. TimerLib interface is defined in the same Basecore layer as DxeCore, so in this case a Basecore module is depending on a Basecore interface. This is allowed. flowchart BT id1[\"DxeCore Module\"] id2[\"TimerLib Interface\"] id1 -.-> id2 To extend this example even more into construction details. Often the logic of a library will be implemented in the silicon layer. This means the code may vary based on which silicon is used in the product but because the interface is defined in the basecore layer this is allowed and working as designed. The core module can be optimized and targeted for a specific silicon implementation. flowchart BT subgraph bc [Basecore] id1[\"DxeCore\"] id2[\"TimerLib\"] id1 -.-> id2 end subgraph sl [Silicon layer] id3[\"Silicon TimerLib\"] end id3 -->id2 An example of an unacceptable/unsustainable dependency is if the core module starts to use the silicon layer directly. For example if a feature was introduced that used a silicon special widget in the DxeCore then this would fail our dependency checks. flowchart BT subgraph bc [Basecore] id1[\"DxeCore\"] end subgraph sl [Silicon layer] id3[\"Silicon Special Widget Lib<br>Implementations\"] id4[\"Silicon SpecialWidgetLib\"] id3 -->id4 end id1 -. NOT ALLOWED .-> id4","title":"What is a dependency"},{"location":"WhatAndWhy/layout/#architecture","text":"Project Mu is an attempt to create a rigid layering scheme that defines the hierarchy of dependencies. Architectural goal kept in mind when designing this layering scheme is a controlled, limited scope, and allowed dependencies for each module within a given layer. It is important to know, when implementing a module, what the module is allowed to depend on. When creating an interface, it is important to identify the correct layer for it such that all the consuming modules are located in the layers below. Motivation and goals of the layering scheme: Easy component integration Code reuse Only carry relevant code","title":"Architecture"},{"location":"WhatAndWhy/layout/#dependency-block-diagram","text":"","title":"Dependency Block Diagram"},{"location":"WhatAndWhy/layout/#file-layout","text":"To best preserve and delineate these concepts of componentization and unidirectional dependency, we have chosen to lay out our repository files in a structure that reinforces the same mentality. The underlying logic of this layout is to clearly distinguish each layer from the rest. As such, the Basecore -- which is considered foundational -- is broken out on its own, followed by the Common repos, followed by the Silicon, followed by the Platform. As mentioned elsewhere, Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the firmware ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. One of the goals of Project Mu is to make this seemingly complicated layout easier to work with.","title":"File Layout"},{"location":"WhatAndWhy/layout/#min-platform-example","text":"A simple tree might look like this... project_mu/ \u251c\u2500\u2500 Build/ \u251c\u2500\u2500 Common/ \u2502 \u2514\u2500\u2500 ... # Common code optional, but probably not required \u251c\u2500\u2500 Conf/ \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 Platform/ \u2502 \u2514\u2500\u2500 Sample/ \u2502 \u2514\u2500\u2500 MyMinPlatform # Platform-specific build files and code \u251c\u2500\u2500 Silicon/ \u2502 \u2514\u2500\u2500 SiProvider/ \u2502 \u2514\u2500\u2500 REF_CODE/ # Enablement code for your architecture \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules Note that this file structure is likely located in a Git repository, and every \"ALL CAPS\" directory in this example is a Git submodule/nested repository.","title":"Min Platform Example"},{"location":"WhatAndWhy/layout/#surface-laptop-example","text":"For a real-world example, this is a tree that could build the Surface Laptop product, including both open- and closed-source repositories: project_mu/ \u251c\u2500\u2500 Build/ \u251c\u2500\u2500 Common/ \u2502 \u251c\u2500\u2500 MSCORE_INTERNAL/ # Proprietary code and code not yet approved for public distribution \u2502 \u251c\u2500\u2500 MU/ \u2502 \u251c\u2500\u2500 MU_TIANO/ \u2502 \u2514\u2500\u2500 SURFACE/ # Shared code to enable common features like FrontPage \u251c\u2500\u2500 Conf/ \u251c\u2500\u2500 MU_BASECORE/ \u251c\u2500\u2500 Platform/ \u2502 \u251c\u2500\u2500 Surface/ \u2502 \u2502 \u251c\u2500\u2500 SurfKbl/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 Laptop/ # Surface Laptop-Specific Platform Code \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 Others/ \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 Silicon/ \u2502 \u251c\u2500\u2500 Intel/ \u2502 \u2502 \u251c\u2500\u2500 KBL/ # Intel KBL Reference Code \u2502 \u2502 \u251c\u2500\u2500 MU/ # Project Mu Intel Common Code \u2502 \u2502 \u251c\u2500\u2500 MU_TIANO/ # Project Mu Intel Code from TianoCore \u2502 \u2502 \u2514\u2500\u2500 SURF_KBL/ # Surface Customizations/Overrides for KBL Ref Code \u2502 \u2514\u2500\u2500 SURFACE/ # Shared code to enable common HW like ECs \u251c\u2500\u2500 .gitattributes \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 .gitmodules Once again, the \"ALL CAPS\" directories are submodules.","title":"Surface Laptop Example"},{"location":"WhatAndWhy/overview/","text":"Overview \u00b6 Project Organization \u00b6 This documentation is hosted in the main repository for Project Mu, which is used as a central collection point for community interaction and documentation. The build system and firmware code for the project is hosted in a number of other repositories, grouped/divided by function, partner, license, and dependencies. Several of these repositories are brought together by the build system to create a FW project, but we'll get into those details later. For now, an overview of the repositories and what code you'll find there... Mu Basecore \u00b6 This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this code should be one or more of the following: Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including Industry Standards UEFI Specifications ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic This can also include central technologies like variable services Mu Common Plus \u00b6 The packages found in this repository are contributed entirely by Project Mu. They should be common to all silicon architectures and only depend on Mu Basecore. These packages provide features and functionality that are entirely optional, but may be recommended for PC platform FW. Mu Tiano Plus \u00b6 This repository contains only modules that were originally sourced from TianoCore. They are not essential for any particular platform, but are likely useful to many platforms. The versions contained in this repo are modified and/or improved to work with the rest of Project Mu. Repo Philosophy \u00b6 Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. Examples of this are: A downstream contributor wants to add a generic feature with a silicon-specific implementation. This feature would be leveraged by Common code. If all code were in one repository, no barriers would be in place to prevent the contributor from directly calling from Common code into the Silicon implementation. By forcing the API/interface to be published in a separate repository, we can ensure that the unidirectional dependency relationship is maintained. Module A and Module B both provide optional functionality. However, Module A is far more likely to be consume by a wide audience than Module B. To achieve \"Less is More\", Module A may be placed in a different repos to enable downstream consumers to carry as little \"unused\" code as possible, since it's likely they would not need Module B in their code tree. A downstream consumer is producing a product in conjunction with a vendor/partner. While most of the enabling code for the vendor component is open-source, a portion of it is only released under NDA. By having multiple repositories comprise a single workspace, the downstream consumer is able to maximize their open-source consumption (which minimizes forking) while maintaining the legal requirements of closed-source/proprietary partitioning.","title":"Overview"},{"location":"WhatAndWhy/overview/#overview","text":"","title":"Overview"},{"location":"WhatAndWhy/overview/#project-organization","text":"This documentation is hosted in the main repository for Project Mu, which is used as a central collection point for community interaction and documentation. The build system and firmware code for the project is hosted in a number of other repositories, grouped/divided by function, partner, license, and dependencies. Several of these repositories are brought together by the build system to create a FW project, but we'll get into those details later. For now, an overview of the repositories and what code you'll find there...","title":"Project Organization"},{"location":"WhatAndWhy/overview/#mu-basecore","text":"This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this code should be one or more of the following: Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including Industry Standards UEFI Specifications ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic This can also include central technologies like variable services","title":"Mu Basecore"},{"location":"WhatAndWhy/overview/#mu-common-plus","text":"The packages found in this repository are contributed entirely by Project Mu. They should be common to all silicon architectures and only depend on Mu Basecore. These packages provide features and functionality that are entirely optional, but may be recommended for PC platform FW.","title":"Mu Common Plus"},{"location":"WhatAndWhy/overview/#mu-tiano-plus","text":"This repository contains only modules that were originally sourced from TianoCore. They are not essential for any particular platform, but are likely useful to many platforms. The versions contained in this repo are modified and/or improved to work with the rest of Project Mu.","title":"Mu Tiano Plus"},{"location":"WhatAndWhy/overview/#repo-philosophy","text":"Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. Examples of this are: A downstream contributor wants to add a generic feature with a silicon-specific implementation. This feature would be leveraged by Common code. If all code were in one repository, no barriers would be in place to prevent the contributor from directly calling from Common code into the Silicon implementation. By forcing the API/interface to be published in a separate repository, we can ensure that the unidirectional dependency relationship is maintained. Module A and Module B both provide optional functionality. However, Module A is far more likely to be consume by a wide audience than Module B. To achieve \"Less is More\", Module A may be placed in a different repos to enable downstream consumers to carry as little \"unused\" code as possible, since it's likely they would not need Module B in their code tree. A downstream consumer is producing a product in conjunction with a vendor/partner. While most of the enabling code for the vendor component is open-source, a portion of it is only released under NDA. By having multiple repositories comprise a single workspace, the downstream consumer is able to maximize their open-source consumption (which minimizes forking) while maintaining the legal requirements of closed-source/proprietary partitioning.","title":"Repo Philosophy"},{"location":"WhatAndWhy/security/","text":"Active Security Patching \u00b6 Summary \u00b6 In order to simplify adoption and to ensure that security fixes make it into the core repository as quickly as possible, Project Mu maintains \"Security Patch\" versions of all applicable repos that are constantly synced with the public versions. These Security Patch repos are identical to the top of tree in the public repos, but already have all known (and relevant) security patches applied, to the best of our judgement (any choices that were required when authoring the patch are described in the patch notes). Each of the security-specific patches are noted with SECURITY PATCH in the commit title and a MU_SEC_*** tag in the commit title that indicates the related bug database tracking the issue (e.g. TianoCore Bugzilla, CVE, etc.). Requesting Access \u00b6 Due to a number of factors including disclosure embargoes, these repos are available to the public by request only. If you are interested in getting access, please contact us through the Project Mu Team. Access will be granted to any members who can establish that they have already been given prior clearance to the relevant bug tracking databases. Usage \u00b6 The Security Patch repos maintain branches that are 1:1 matches with public branches. All that is necessary to ingest the security patches is to re-target your Git submodule at the Security Patch repo and pull the branch with the same name. They are also kept in sync with any *_RC tags that are applied to the public repo, so it should be simple to identify which public commit corresponds to which SP repo commit.","title":"Security"},{"location":"WhatAndWhy/security/#active-security-patching","text":"","title":"Active Security Patching"},{"location":"WhatAndWhy/security/#summary","text":"In order to simplify adoption and to ensure that security fixes make it into the core repository as quickly as possible, Project Mu maintains \"Security Patch\" versions of all applicable repos that are constantly synced with the public versions. These Security Patch repos are identical to the top of tree in the public repos, but already have all known (and relevant) security patches applied, to the best of our judgement (any choices that were required when authoring the patch are described in the patch notes). Each of the security-specific patches are noted with SECURITY PATCH in the commit title and a MU_SEC_*** tag in the commit title that indicates the related bug database tracking the issue (e.g. TianoCore Bugzilla, CVE, etc.).","title":"Summary"},{"location":"WhatAndWhy/security/#requesting-access","text":"Due to a number of factors including disclosure embargoes, these repos are available to the public by request only. If you are interested in getting access, please contact us through the Project Mu Team. Access will be granted to any members who can establish that they have already been given prior clearance to the relevant bug tracking databases.","title":"Requesting Access"},{"location":"WhatAndWhy/security/#usage","text":"The Security Patch repos maintain branches that are 1:1 matches with public branches. All that is necessary to ingest the security patches is to re-target your Git submodule at the Security Patch repo and pull the branch with the same name. They are also kept in sync with any *_RC tags that are applied to the public repo, so it should be simple to identify which public commit corresponds to which SP repo commit.","title":"Usage"},{"location":"Where/external_resources/","text":"External Resources \u00b6 UEFI Industry Organization \u00b6 UEFI is the industry standards body that develops and distributes the UEFI, PI, and ACPI specifications. These specifications govern the firmware interfaces between OS, OEM/Device Manufacturer, and Silicon partner. This is a great site to download the industry specifications and if you are a member you can join working groups for future specifications. TianoCore Project \u00b6 Tianocore is an existing open source project. Their EDK2 repository is the basis for many/most UEFI implementations used on products today. It provides UEFI spec compliant code modules, supports industry standard hardware, and a multi-platform build environment. This is a great site to download specifications for the different file types and build process. It also has links to repositories that Project Mu tracks as \"upstreams\". MkDocs \u00b6 Great tool for creating documentation websites based on markdown. In fact it was used to generate this documentation. Markdown Help \u00b6 Quick link for common markdown support.","title":"External Resources"},{"location":"Where/external_resources/#external-resources","text":"","title":"External Resources"},{"location":"Where/external_resources/#uefi-industry-organization","text":"UEFI is the industry standards body that develops and distributes the UEFI, PI, and ACPI specifications. These specifications govern the firmware interfaces between OS, OEM/Device Manufacturer, and Silicon partner. This is a great site to download the industry specifications and if you are a member you can join working groups for future specifications.","title":"UEFI Industry Organization"},{"location":"Where/external_resources/#tianocore-project","text":"Tianocore is an existing open source project. Their EDK2 repository is the basis for many/most UEFI implementations used on products today. It provides UEFI spec compliant code modules, supports industry standard hardware, and a multi-platform build environment. This is a great site to download specifications for the different file types and build process. It also has links to repositories that Project Mu tracks as \"upstreams\".","title":"TianoCore Project"},{"location":"Where/external_resources/#mkdocs","text":"Great tool for creating documentation websites based on markdown. In fact it was used to generate this documentation.","title":"MkDocs"},{"location":"Where/external_resources/#markdown-help","text":"Quick link for common markdown support.","title":"Markdown Help"},{"location":"Where/project_resources/","text":"Project Resources \u00b6 Public Source Code Repositories \u00b6 Listed here: GitHub Project Mu Repo List Issue/Bug/Feature Tracking \u00b6 https://github.com/Microsoft/mu/issues Builds \u00b6 https://dev.azure.com/projectmu/mu/_build Docs \u00b6 https://microsoft.github.io/mu/ Collaborate \u00b6 Send an email request to join the discussion on our Teams channels. Help \u00b6 For one-off questions, feel free to start a new thread in the Discussions section of this repository. For deeper discussion & faster communication, join our Microsoft Teams channels. To join send an email request .","title":"Project Resources"},{"location":"Where/project_resources/#project-resources","text":"","title":"Project Resources"},{"location":"Where/project_resources/#public-source-code-repositories","text":"Listed here: GitHub Project Mu Repo List","title":"Public Source Code Repositories"},{"location":"Where/project_resources/#issuebugfeature-tracking","text":"https://github.com/Microsoft/mu/issues","title":"Issue/Bug/Feature Tracking"},{"location":"Where/project_resources/#builds","text":"https://dev.azure.com/projectmu/mu/_build","title":"Builds"},{"location":"Where/project_resources/#docs","text":"https://microsoft.github.io/mu/","title":"Docs"},{"location":"Where/project_resources/#collaborate","text":"Send an email request to join the discussion on our Teams channels.","title":"Collaborate"},{"location":"Where/project_resources/#help","text":"For one-off questions, feel free to start a new thread in the Discussions section of this repository. For deeper discussion & faster communication, join our Microsoft Teams channels. To join send an email request .","title":"Help"},{"location":"dyn/mu_basecore/CONTRIBUTING/","text":"Contributing to EDK2 \u00b6 Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"CONTRIBUTING"},{"location":"dyn/mu_basecore/CONTRIBUTING/#contributing-to-edk2","text":"Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"Contributing to EDK2"},{"location":"dyn/mu_basecore/RepoDetails/","text":"Project Mu Basecore Repository \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_basecore.git Branch: release/202202 Commit: f02bebd221b5cf49197fd3599a18ae57724db7de Commit Date: 2022-11-18 19:13:29 -0500 This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this any code within this repository should be one or more of the following Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including Industry Standards UEFI Specifications ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic This can also include central technologies like variable services More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Repo Details"},{"location":"dyn/mu_basecore/RepoDetails/#project-mu-basecore-repository","text":"Git Details Repository Url: https://github.com/Microsoft/mu_basecore.git Branch: release/202202 Commit: f02bebd221b5cf49197fd3599a18ae57724db7de Commit Date: 2022-11-18 19:13:29 -0500 This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this any code within this repository should be one or more of the following Part of the build system Common to any silicon architecture Part of the \"API layer\" that contains protocol and library definitions including Industry Standards UEFI Specifications ACPI Specifications Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic This can also include central technologies like variable services","title":"Project Mu Basecore Repository"},{"location":"dyn/mu_basecore/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_basecore/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_basecore/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_basecore/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_basecore/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_basecore/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_basecore/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"pull request template"},{"location":"dyn/mu_basecore/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken?","title":"Description"},{"location":"dyn/mu_basecore/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_basecore/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/","text":".ver file specification \u00b6 1 Introduction \u00b6 This document describes file format for .ver files. The end goal is to add a VERSIONINFO resource to a UEFI driver or application. The .ver file provides a convenient method to declare the version information. The build system first converts the .VER file to a resource-definition file (.ARC), which is then compiled into a binary resource file and finally linked to the module. The .ver file is referred to as the version info file. VERSIONINFO refers to the format that is specified by the resource compiler. 1.1 Related Information \u00b6 The following publications and sources of information may be useful to you or are referred to by this specification: Unified Extensible Firmware Interface Specifications EDK2 Documents EDK II Build Specification, Intel, 2016. EDK II DEC File Specification , Intel, 2016. EDK II INF File Specification , Intel, 2016. EDK II DSC File Specification , Intel, 2016. EDK II FDF File Specification , Intel, 2016. EDK II Expression Syntax Specification , Intel, 2015. EDK II C Coding Standards Specification , Intel, 2015. Copyright \u00a9 Microsoft 1.2 Terms \u00b6 The following terms are used throughout this document: EFI \u00b6 Generic term that refers to one of the versions of the EFI specification: EFI 1.02, EFI 1.10, or UEFI 2.0. Module \u00b6 A module is either an executable image or a library instance. For a list of module types supported by this package, see module type. UEFI Application \u00b6 An application that follows the UEFI specification. The only difference between a UEFI application and a UEFI driver is that an application is unloaded from memory when it exits regardless of return status, while a driver that returns a successful return status is not unloaded when its entry point exits. UEFI Driver \u00b6 A driver that follows the UEFI specification. 2 Version Info File Format \u00b6 The format is JSON files with the extension .ver that encodes the VERSIONINFO metadata according to the PE spec here . 2.1 Version Info file examples \u00b6 When specifying a version info file (.ver), there are two modes: minimal and full. An example of the minimal file would be: { \"FileVersion\" : \"1.0.0.0\" , \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , } or equivalently: { \"Minimal\" : true , \"FileVersion\" : \"1.0.0.0\" , \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , } The Minimal attribute if not defined is considered to be true. Other values are inferred using the defaults specified in this document. However, if Minimal is set to false, you must define more attributes. However, many more additional attributes can be included. Details are listed on the VERSIONINFO spec here . A full example follows: { \"Minimal\" : false , \"FileVersion\" : \"1.0.0.0\" , \"ProductVersion\" : \"1.0.0.0\" , \"FileFlagsMask\" : \"VS_FFI_FILEFLAGSMASK\" , \"FileFlags\" : \"0\" , \"FileOS\" : \"VOS_NT\" , \"FileType\" : \"VFT_DRV\" , \"FileSubtype\" : \"VFT2_DRV_SYSTEM\" , \"StringFileInfo\" : { \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , \"FileVersion\" : \"1.0.0.0\" , }, \"VarFileInfo\" : { \"Translation\" : \"0x0409 0x04b0\" } } These three examples produce the same results as the values used in the above example are the default values used by versioninfo_tool. StringFileInfo and VarFileInfo can both have many more entries. More information is available here . 2.2 VERSIONINFO data format \u00b6 The attributes of VERSIONINFO are listed below: Attribute Description FileVersion Binary version number for the file. The version consists of four 16-bit integers ProductVersion Binary version number for the product with which the file is distributed. The version parameter is four 16-bit integers FileFlagsMask Indicates which bits in the FILEFLAGS statement are valid. For 16-bit Windows, this value is 0x3f. FileFlags Attributes of the file. See the spec FileOS Operating system for which this file was designed. The fileos parameter can be one of the operating system values given in the spec FileType General type of file. The filetype parameter can be one of the file type values listed in the spec. FileSubtype Function of the file. The subtype parameter is zero unless the filetype parameter in the FILETYPE statement is VFT_DRV, VFT_FONT, or VFT_VXD. For a list of file subtype values, see the spec. StringFileInfo Contains details around the file information such as CompanyName or OriginalFilename VarFileInfo Contains data around the language and character set in the file The spec referred to above is the VERSIONINFO spec . For VarFileInfo in the .ver file, it has a single member Translation , which is two hexadecimal numbers separated by a space. The two number represent, the langId and charsetId respectively. Currently the recommend value for Translation is \"0x0409 0x04b0\" , which corresponds to English and Unicode. More information can be found here . 3 Build System Support \u00b6 The EDK2 build system supports adding version info files (.ver) to UEFI applications, modules, and drivers. By adding a .ver file to the sources of the inf, the build system will process it. An example follows: ## # Sample UEFI Application Reference EDKII Module. # SPDX-License-Identifier: BSD-2-Clause-Patent ## [Defines] INF_VERSION = 0x00010005 BASE_NAME = HelloWorld MODULE_UNI_FILE = HelloWorld.uni FILE_GUID = 6987936E-ED34-44db-AE97-1FA5E4ED2116 MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] HelloWorld.c HelloWorldStr.uni HelloWorld.ver 3.1 A Detailed Flow \u00b6 First, versioninfo_tool is invoked on the .ver file. More information is available here: or at the edk2-pytool-extensions repo. The versioninfo_tool creates a temporary file ending in .arc, which is the metadata encoded in the proper resource compiler format. The .arc file is processed by the Microsoft Resource Compiler (x86_64-w64-mingw32-windres on Linux and rc.exe on windows) to produce an object file. This file is then linked in to the resulting binary, the .rsrc section being present in the final PE formatted image. 3.2 Current Constraints \u00b6 Currently, Linux is not supported. You can track the progress of this work with this GitHub issue .","title":"Package Overview"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#ver-file-specification","text":"","title":".ver file specification"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#1-introduction","text":"This document describes file format for .ver files. The end goal is to add a VERSIONINFO resource to a UEFI driver or application. The .ver file provides a convenient method to declare the version information. The build system first converts the .VER file to a resource-definition file (.ARC), which is then compiled into a binary resource file and finally linked to the module. The .ver file is referred to as the version info file. VERSIONINFO refers to the format that is specified by the resource compiler.","title":"1 Introduction"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#11-related-information","text":"The following publications and sources of information may be useful to you or are referred to by this specification: Unified Extensible Firmware Interface Specifications EDK2 Documents EDK II Build Specification, Intel, 2016. EDK II DEC File Specification , Intel, 2016. EDK II INF File Specification , Intel, 2016. EDK II DSC File Specification , Intel, 2016. EDK II FDF File Specification , Intel, 2016. EDK II Expression Syntax Specification , Intel, 2015. EDK II C Coding Standards Specification , Intel, 2015. Copyright \u00a9 Microsoft","title":"1.1 Related Information"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#12-terms","text":"The following terms are used throughout this document:","title":"1.2 Terms"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#efi","text":"Generic term that refers to one of the versions of the EFI specification: EFI 1.02, EFI 1.10, or UEFI 2.0.","title":"EFI"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#module","text":"A module is either an executable image or a library instance. For a list of module types supported by this package, see module type.","title":"Module"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#uefi-application","text":"An application that follows the UEFI specification. The only difference between a UEFI application and a UEFI driver is that an application is unloaded from memory when it exits regardless of return status, while a driver that returns a successful return status is not unloaded when its entry point exits.","title":"UEFI Application"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#uefi-driver","text":"A driver that follows the UEFI specification.","title":"UEFI Driver"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#2-version-info-file-format","text":"The format is JSON files with the extension .ver that encodes the VERSIONINFO metadata according to the PE spec here .","title":"2 Version Info File Format"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#21-version-info-file-examples","text":"When specifying a version info file (.ver), there are two modes: minimal and full. An example of the minimal file would be: { \"FileVersion\" : \"1.0.0.0\" , \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , } or equivalently: { \"Minimal\" : true , \"FileVersion\" : \"1.0.0.0\" , \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , } The Minimal attribute if not defined is considered to be true. Other values are inferred using the defaults specified in this document. However, if Minimal is set to false, you must define more attributes. However, many more additional attributes can be included. Details are listed on the VERSIONINFO spec here . A full example follows: { \"Minimal\" : false , \"FileVersion\" : \"1.0.0.0\" , \"ProductVersion\" : \"1.0.0.0\" , \"FileFlagsMask\" : \"VS_FFI_FILEFLAGSMASK\" , \"FileFlags\" : \"0\" , \"FileOS\" : \"VOS_NT\" , \"FileType\" : \"VFT_DRV\" , \"FileSubtype\" : \"VFT2_DRV_SYSTEM\" , \"StringFileInfo\" : { \"CompanyName\" : \"Example Company\" , \"OriginalFilename\" : \"ExampleApp.efi\" , \"FileVersion\" : \"1.0.0.0\" , }, \"VarFileInfo\" : { \"Translation\" : \"0x0409 0x04b0\" } } These three examples produce the same results as the values used in the above example are the default values used by versioninfo_tool. StringFileInfo and VarFileInfo can both have many more entries. More information is available here .","title":"2.1 Version Info file examples"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#22-versioninfo-data-format","text":"The attributes of VERSIONINFO are listed below: Attribute Description FileVersion Binary version number for the file. The version consists of four 16-bit integers ProductVersion Binary version number for the product with which the file is distributed. The version parameter is four 16-bit integers FileFlagsMask Indicates which bits in the FILEFLAGS statement are valid. For 16-bit Windows, this value is 0x3f. FileFlags Attributes of the file. See the spec FileOS Operating system for which this file was designed. The fileos parameter can be one of the operating system values given in the spec FileType General type of file. The filetype parameter can be one of the file type values listed in the spec. FileSubtype Function of the file. The subtype parameter is zero unless the filetype parameter in the FILETYPE statement is VFT_DRV, VFT_FONT, or VFT_VXD. For a list of file subtype values, see the spec. StringFileInfo Contains details around the file information such as CompanyName or OriginalFilename VarFileInfo Contains data around the language and character set in the file The spec referred to above is the VERSIONINFO spec . For VarFileInfo in the .ver file, it has a single member Translation , which is two hexadecimal numbers separated by a space. The two number represent, the langId and charsetId respectively. Currently the recommend value for Translation is \"0x0409 0x04b0\" , which corresponds to English and Unicode. More information can be found here .","title":"2.2 VERSIONINFO data format"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#3-build-system-support","text":"The EDK2 build system supports adding version info files (.ver) to UEFI applications, modules, and drivers. By adding a .ver file to the sources of the inf, the build system will process it. An example follows: ## # Sample UEFI Application Reference EDKII Module. # SPDX-License-Identifier: BSD-2-Clause-Patent ## [Defines] INF_VERSION = 0x00010005 BASE_NAME = HelloWorld MODULE_UNI_FILE = HelloWorld.uni FILE_GUID = 6987936E-ED34-44db-AE97-1FA5E4ED2116 MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = UefiMain [Sources] HelloWorld.c HelloWorldStr.uni HelloWorld.ver","title":"3 Build System Support"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#31-a-detailed-flow","text":"First, versioninfo_tool is invoked on the .ver file. More information is available here: or at the edk2-pytool-extensions repo. The versioninfo_tool creates a temporary file ending in .arc, which is the metadata encoded in the proper resource compiler format. The .arc file is processed by the Microsoft Resource Compiler (x86_64-w64-mingw32-windres on Linux and rc.exe on windows) to produce an object file. This file is then linked in to the resulting binary, the .rsrc section being present in the final PE formatted image.","title":"3.1 A Detailed Flow"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#32-current-constraints","text":"Currently, Linux is not supported. You can track the progress of this work with this GitHub issue .","title":"3.2 Current Constraints"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/","text":"Mu BaseTools Notes \u00b6 This is a set of compiled tools for Edk2 development on x86 for Windows and Linux. This set has both the standard Edk2 tools as well as additional tools created for Project Mu. Where \u00b6 Information about the TianoCore Edk2 Basetools can be found here: https://tianocore.org https://github.com/tianocore/edk2 https://github.com/tianocore/edk2-BaseTools-win32 Information about Project Mu can be found here: https://microsoft.github.io/mu/ https://github.com/Microsoft/mu https://github.com/microsoft/mu_basecore What \u00b6 TianoCore/Project Mu Edk2 Build tools Version \u00b6 BaseTools binaries are versioned based on the Release branch they are associated with (e.g. release/201808, release/201811, etc.). The version format is YYYY.MM.XX where: YYYY is the 4-digit year MM is the 2-digit month XX is a point-release in case fixes are required Nuget version is AA.BB.CC If the version is a single number then make it the AA field and use zeros for BB.CC Example: version command is 20160912 then NuGet version is 20160912.0.0 If a version has two numbers partitioned by a \"-\" then make those the AA.BB fields and use zero for the CC Example: version command is 1234-56 then NuGet version is 1234.56.0 Process to publish new version of tool \u00b6 Download desired version from Unzip Make a new folder (for my example I will call it \"new\") Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md) Copy the assets to publish into this new folder Run the < TOOL > -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Basetools.config.json --Version <nuget version here> --InputFolderPath <path to newly created folder here> --ApiKey <your key here>","title":"Mu-Basetools"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#mu-basetools-notes","text":"This is a set of compiled tools for Edk2 development on x86 for Windows and Linux. This set has both the standard Edk2 tools as well as additional tools created for Project Mu.","title":"Mu BaseTools Notes"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#where","text":"Information about the TianoCore Edk2 Basetools can be found here: https://tianocore.org https://github.com/tianocore/edk2 https://github.com/tianocore/edk2-BaseTools-win32 Information about Project Mu can be found here: https://microsoft.github.io/mu/ https://github.com/Microsoft/mu https://github.com/microsoft/mu_basecore","title":"Where"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#what","text":"TianoCore/Project Mu Edk2 Build tools","title":"What"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#version","text":"BaseTools binaries are versioned based on the Release branch they are associated with (e.g. release/201808, release/201811, etc.). The version format is YYYY.MM.XX where: YYYY is the 4-digit year MM is the 2-digit month XX is a point-release in case fixes are required Nuget version is AA.BB.CC If the version is a single number then make it the AA field and use zeros for BB.CC Example: version command is 20160912 then NuGet version is 20160912.0.0 If a version has two numbers partitioned by a \"-\" then make those the AA.BB fields and use zero for the CC Example: version command is 1234-56 then NuGet version is 1234.56.0","title":"Version"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#process-to-publish-new-version-of-tool","text":"Download desired version from Unzip Make a new folder (for my example I will call it \"new\") Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md) Copy the assets to publish into this new folder Run the < TOOL > -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Basetools.config.json --Version <nuget version here> --InputFolderPath <path to newly created folder here> --ApiKey <your key here>","title":"Process to publish new version of tool"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/","text":"Mu-Nasm Notes \u00b6 This tool is the open source NASM assembler. More information can be found at https://nasm.us/ Where \u00b6 Go to https://nasm.us and find the desired download. What \u00b6 nasm.exe is the assembler. Version \u00b6 nasm.exe -v Nuget version is AA.BB.CC The version command generally outputs a version in AA.BB.CC format. Process to publish new version of tool \u00b6 Download desired version from nasm.us (Windows .exe and Linux .rpm) Unzip (unzipping RPM requires fork of 7z that supports Zstandard compression) Make a new folder (for my example I will call it \"new\") Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md) Copy the assets to publish into this new folder (in this case just nasm and ndisasm) Run the nasm.exe -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Nasm.config.json --Version <nuget version here> --InputFolderPath <path to newly created folder here> --ApiKey <your key here>","title":"Mu-Nasm"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#mu-nasm-notes","text":"This tool is the open source NASM assembler. More information can be found at https://nasm.us/","title":"Mu-Nasm Notes"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#where","text":"Go to https://nasm.us and find the desired download.","title":"Where"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#what","text":"nasm.exe is the assembler.","title":"What"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#version","text":"nasm.exe -v Nuget version is AA.BB.CC The version command generally outputs a version in AA.BB.CC format.","title":"Version"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#process-to-publish-new-version-of-tool","text":"Download desired version from nasm.us (Windows .exe and Linux .rpm) Unzip (unzipping RPM requires fork of 7z that supports Zstandard compression) Make a new folder (for my example I will call it \"new\") Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md) Copy the assets to publish into this new folder (in this case just nasm and ndisasm) Run the nasm.exe -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Nasm.config.json --Version <nuget version here> --InputFolderPath <path to newly created folder here> --ApiKey <your key here>","title":"Process to publish new version of tool"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/","text":"NugetPublishing \u00b6 Tool to help create and publish nuget packages for Project Mu resources Usage \u00b6 See NugetPublishing.py -h OPTIONAL: host_specific folders \u00b6 The possible different setups for the host are: OS: Linux, Windows, Java Architecture: x86 or ARM Highest Order Bit: 32 or 64 Before the path to the NuGet package contents is published, the Python environment can look inside at several subfolders and decide which one to use based on the Host OS, highest order bit available, and the architecture of the processor. To do so, add \"separated\" to your flags like so: \"flags\": [\"host_specific\"], If this flag is present, the environment will make a list possible subfolders that would be acceptable for the host machine. For this example, a 64 bit Windows machine with an x86 processor was used: Windows-x86-64 Windows-x86 Windows-64 x86-64 Windows x86 64 The environment will look for these folders, following this order, and select the first one it finds. If none are found, the flag will be ignored. Authentication \u00b6 For publishing most service providers require authentication. The --ApiKey parameter allows the caller to supply a unique key for authorization. There are numerous ways to authenticate. For example Azure Dev Ops: VSTS credential manager. In an interactive session a dialog will popup for the user to login Tokens can also be used as the API key. Go to your account page to generate a token that can push packages NuGet.org Must use an API key. Go to your account page and generate a key. Example: Creating new config file for first use \u00b6 This will create the config files and place them in the current directory: NugetPublishing.py --Operation New --Name iasl --Author ProjectMu --ConfigFileFolderPath . --Description \"Description of item.\" --FeedUrl https://api.nuget.org/v3/index.json --ProjectUrl http://aka.ms/projectmu --LicenseType BSD2 For help run: NugetPublishing.py --Operation New --help Example: Publishing new version of tool \u00b6 Using an existing config file publish a new iasl.exe. See the example file iasl.config.json Download version from acpica.org Unzip Make a new folder (for my example I will call it \"new\") Copy the assets to publish into this new folder (in this case just iasl.exe) Run the iasl.exe -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push (here is my example command. ) NugetPublishing.py --Operation PackAndPush --ConfigFilePath iasl.config.json --Version 20180209.0.0 --InputFolderPath \"C:\\temp\\iasl-win-20180209\\new\" --ApiKey <your key here>","title":"Read Me"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#nugetpublishing","text":"Tool to help create and publish nuget packages for Project Mu resources","title":"NugetPublishing"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#usage","text":"See NugetPublishing.py -h","title":"Usage"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#optional-host_specific-folders","text":"The possible different setups for the host are: OS: Linux, Windows, Java Architecture: x86 or ARM Highest Order Bit: 32 or 64 Before the path to the NuGet package contents is published, the Python environment can look inside at several subfolders and decide which one to use based on the Host OS, highest order bit available, and the architecture of the processor. To do so, add \"separated\" to your flags like so: \"flags\": [\"host_specific\"], If this flag is present, the environment will make a list possible subfolders that would be acceptable for the host machine. For this example, a 64 bit Windows machine with an x86 processor was used: Windows-x86-64 Windows-x86 Windows-64 x86-64 Windows x86 64 The environment will look for these folders, following this order, and select the first one it finds. If none are found, the flag will be ignored.","title":"OPTIONAL: host_specific folders"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#authentication","text":"For publishing most service providers require authentication. The --ApiKey parameter allows the caller to supply a unique key for authorization. There are numerous ways to authenticate. For example Azure Dev Ops: VSTS credential manager. In an interactive session a dialog will popup for the user to login Tokens can also be used as the API key. Go to your account page to generate a token that can push packages NuGet.org Must use an API key. Go to your account page and generate a key.","title":"Authentication"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#example-creating-new-config-file-for-first-use","text":"This will create the config files and place them in the current directory: NugetPublishing.py --Operation New --Name iasl --Author ProjectMu --ConfigFileFolderPath . --Description \"Description of item.\" --FeedUrl https://api.nuget.org/v3/index.json --ProjectUrl http://aka.ms/projectmu --LicenseType BSD2 For help run: NugetPublishing.py --Operation New --help","title":"Example: Creating new config file for first use"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#example-publishing-new-version-of-tool","text":"Using an existing config file publish a new iasl.exe. See the example file iasl.config.json Download version from acpica.org Unzip Make a new folder (for my example I will call it \"new\") Copy the assets to publish into this new folder (in this case just iasl.exe) Run the iasl.exe -v command to see the version. Open cmd prompt in the NugetPublishing dir Pack and push (here is my example command. ) NugetPublishing.py --Operation PackAndPush --ConfigFilePath iasl.config.json --Version 20180209.0.0 --InputFolderPath \"C:\\temp\\iasl-win-20180209\\new\" --ApiKey <your key here>","title":"Example: Publishing new version of tool"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/","text":"Flash Descriptor Size Report Generator Plugin and Command Line Tool \u00b6 Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent About \u00b6 FdSizeReportGenerator is a UEFI Build Plugin and Command Line Tool used to parse EDK2 build reports and FDF files and then produce an HTML report of the module sizes and fd sizes. The HTML report then allows deeper analysis of the Flash Usage, the Module Sizes, and overall breakdown of usage. UEFI Build Plugin \u00b6 When used in the plugin capacity this plugin will do its work in the do_post_build function. This plugin uses the following variables from the build environment: BUILDREPORTING - [REQUIRED] - must be True otherwise plugin will not run BUILDREPORT_TYPES - [REQUIRED] - for FdSizeReport, should at least contain the FLASH parameter. FLASH_DEFINITION - [REQUIRED] - must point to the platform FDF file BUILDREPORT_FILE - [REQUIRED] - must point to the build report file FDSIZEREPORT_FILE - [OPTIONAL] - should be path for output HTML report. If not set default path will be set based on BUILD_OUTPUT_BASE variable PRODUCT_NAME - [OPTIONAL] - should give friendly product name BUILDID_STRING - [OPTIONAL] - should give friendly version string of firmware version Integrating into a self describing build environment \u00b6 In a self describing build environment, the self.env.SetValue can be used to set the environment variables The below example is relevant to supporting QemuQ35 platform self.env.SetValue(\"BUILDREPORTING\", \"TRUE\", \"Platform Hardcoded\") self.env.SetValue(\"BUILDREPORT_TYPES\", \"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\", \"Platform Hardcoded\") self.env.SetValue(\"FLASH_DEFINITION\", \"QemuQ35Pkg.fdf\", \"Platform Hardcoded\") self.env.SetValue(\"BUILDREPORT_FILE\", \"BuildReport.txt\", \"Platform Hardcoded\") self.env.SetValue(\"PRODUCT_NAME\", \"QemuQ35\", \"Platform Hardcoded\") Command Line Tool \u00b6 When used as a command line tool check the required parameters by using the -h option.","title":"Fd Size Report"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#flash-descriptor-size-report-generator-plugin-and-command-line-tool","text":"","title":"Flash Descriptor Size Report Generator Plugin and Command Line Tool"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#about","text":"FdSizeReportGenerator is a UEFI Build Plugin and Command Line Tool used to parse EDK2 build reports and FDF files and then produce an HTML report of the module sizes and fd sizes. The HTML report then allows deeper analysis of the Flash Usage, the Module Sizes, and overall breakdown of usage.","title":"About"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#uefi-build-plugin","text":"When used in the plugin capacity this plugin will do its work in the do_post_build function. This plugin uses the following variables from the build environment: BUILDREPORTING - [REQUIRED] - must be True otherwise plugin will not run BUILDREPORT_TYPES - [REQUIRED] - for FdSizeReport, should at least contain the FLASH parameter. FLASH_DEFINITION - [REQUIRED] - must point to the platform FDF file BUILDREPORT_FILE - [REQUIRED] - must point to the build report file FDSIZEREPORT_FILE - [OPTIONAL] - should be path for output HTML report. If not set default path will be set based on BUILD_OUTPUT_BASE variable PRODUCT_NAME - [OPTIONAL] - should give friendly product name BUILDID_STRING - [OPTIONAL] - should give friendly version string of firmware version","title":"UEFI Build Plugin"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#integrating-into-a-self-describing-build-environment","text":"In a self describing build environment, the self.env.SetValue can be used to set the environment variables The below example is relevant to supporting QemuQ35 platform self.env.SetValue(\"BUILDREPORTING\", \"TRUE\", \"Platform Hardcoded\") self.env.SetValue(\"BUILDREPORT_TYPES\", \"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\", \"Platform Hardcoded\") self.env.SetValue(\"FLASH_DEFINITION\", \"QemuQ35Pkg.fdf\", \"Platform Hardcoded\") self.env.SetValue(\"BUILDREPORT_FILE\", \"BuildReport.txt\", \"Platform Hardcoded\") self.env.SetValue(\"PRODUCT_NAME\", \"QemuQ35\", \"Platform Hardcoded\")","title":"Integrating into a self describing build environment"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#command-line-tool","text":"When used as a command line tool check the required parameters by using the -h option.","title":"Command Line Tool"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/","text":"Override Validation Plugin \u00b6 Module Level Override Validation Plugin and Linkage Creation Command Line Tool About \u00b6 OverrideValidation is a UEFI Build Plugin and Command Line Tool used to create linkage between overriding and overridden modules and parse INF files referenced in platform DSC files during build process and then produce a TXT report of the module overriding status. The TXT report then allows deeper analysis of the Overriding Hierarchy, the Override Linkage Validity, the Override Linkage Ages, and overall breakdown of usage. UEFI Build Plugin \u00b6 When used in the plugin capacity this plugin will do its override linkage validation work in the do_pre_build function. This plugin uses the following variables from the build environment: ACTIVE_PLATFORM - [REQUIRED] - must be workspace relative or package path relative pointing to the target platform dsc file, otherwise this validation will not run BUILD_OUTPUT_BASE - [REQUIRED] - must be an absolute path specified to store override log at $(BUILD_OUTPUT_BASE)/OVERRIDELOG.TXT, otherwise no report will be generated BUILDSHA - [OPTIONAL] - should have valid commit sha value for report purpose, if not provided, 'None' will be used for the corresponding field PRODUCT_NAME - [OPTIONAL] - should give friendly product name, if not provided, 'None' will be used for the corresponding field BUILDID_STRING - [OPTIONAL] - should give friendly version string of firmware version, if not provided, 'None' will be used for the corresponding field This tool provides two types of validation, determined by the type of tags included in the overriding module: Override : Override validation, as indicated by override tags, intends to enforce the validity of a linkage. Thus if the target that is overridden is either not found or has an change since the last linkage update, the build will break. Track : Track validation, indicated by track tags from tracking modules, intends to soft-track updates of certain module with various flavors across upstream changes. This validation will ignore this tag if the corresponding target is not found. If a single target is found in multiple track tags, there must be one and only one linkage that matches the current status of target, otherwise build will break. Note : If one module contains one or more track tags, at least one tracked target needs to be found, otherwise build will break. Command Line Tool \u00b6 When used as a command line tool, this tool takes the absolute path of workspace (the root directory of Devices repo) as well as the absolute path of overridden module's inf file and then generate a screen-print line for users to include in overriding modules in order to create override linkage. Check the required parameters by using the -h option for command line argument details. The override can also be used on the Active Platform DSC or the Flash Definition FDF defined by the DSC. Example \u00b6 Command to generate an override record: OverrideValidation.py -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf Override record to be included in overriding module's inf: #Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 Command to generate a track record: OverrideValidation.py --track -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf Track record to be included in tracking module's inf: #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f Track records to be included in tracking multiple flavors of the same module's inf (you should do not need this in a perfect world): # Production build #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f # Debug build #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | dbfc0ece0cb8fa499ac2141c80107926 | 2022-02-09T00-31-30 | fd114d321703a32c4684d8411ba0fe7dd7012c14 Command to generate an override record for a target file or directory: OverrideValidation.py -w C:\\Repo -t C:\\Repo\\MU_BASECORE\\MdeModulePkg\\Library\\BaseSerialPortLib16550 Override record to be included in overriding module's inf: #Override : 00000002 | MdeModulePkg/Library/BaseSerialPortLib16550 | 140759cf30a73b02f48cc1f226b015d8 | 2021-12-07T05-30-10 | fa99a33fdb7e8bf6063513fddb807105ec2fad81 Override log generated during pre-build process: Platform: PlatformName Version: 123.456.7890 Date: 2018-05-11T17-56-27 Commit: _SHA_2c9def7a4ce84ef26ed6597afcc60cee4e5c92c0 State: 3/4 Overrides ---------------------------------------------------------------- OVERRIDER: MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf ORIGINALS: + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days OVERRIDER: PlatformNamePkg/Library/NvmConfigLib/NvmConfigLib.inf ORIGINALS: + MdeModulePkg/Bus/Pci/NvmExpressDxe/NvmExpressDxe.inf | MISMATCH | 35 days | Current State: 62929532257365b261080b7e7b1c4e7a | Last Fingerprint: dc9f5e3af1efbac6cf5485b672291903 + MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf | SUCCESS | 0 days + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days + MdeModulePkg/Library/BaseSerialPortLib16550 | SUCCESS | 7 days Command to regenerate the override records in a given .inf file: OverrideValidation.py -w c:\\src -r c:\\src\\FooPkg\\OverridingModule.inf an example of the diff produced when using -r: diff --git a/FooPkg/OverridingModule.inf b/FooPkg/OverridingModule.inf index 2d4ca47299..90da207a39 100644 --- a/FooPkg/OverridingModule.inf +++ b/FooPkg/OverridingModule.inf @@ -8,7 +8,7 @@ # # -#Override : 00000002 | BarPkg/OverridenModule.inf | 4f7eed98e3c084eecdff5fa2e1e57db1 | 2021-11-23T21-41-21 | 44b40c0358489da6c444e7cfb2be26e56b7c16a1 +#Override : 00000002 | BarPkg/OverridenModule.inf | 143b08782a2abc620d1eb57461c6e290 | 2022-03-10T23-09-45 | 6f8c53a3fcd79b202c708e7aa58256cafbf24bc4 # Versions \u00b6 There are two versions of the override format. Version 1 \u00b6 #Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 Version 2 \u00b6 #Override : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 | 575096df6a Version 2 includes a second hash at the end, which is the git commit that the upstream was last updated. This allows to tools to do a git diff between what you currently have and what is in the tree. It currently only diffs the overridden file (the INF or DSC) and the overriding file. Copyright & License \u00b6 Copyright \u00a9 Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Override Validation"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#override-validation-plugin","text":"Module Level Override Validation Plugin and Linkage Creation Command Line Tool","title":"Override Validation Plugin"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#about","text":"OverrideValidation is a UEFI Build Plugin and Command Line Tool used to create linkage between overriding and overridden modules and parse INF files referenced in platform DSC files during build process and then produce a TXT report of the module overriding status. The TXT report then allows deeper analysis of the Overriding Hierarchy, the Override Linkage Validity, the Override Linkage Ages, and overall breakdown of usage.","title":"About"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#uefi-build-plugin","text":"When used in the plugin capacity this plugin will do its override linkage validation work in the do_pre_build function. This plugin uses the following variables from the build environment: ACTIVE_PLATFORM - [REQUIRED] - must be workspace relative or package path relative pointing to the target platform dsc file, otherwise this validation will not run BUILD_OUTPUT_BASE - [REQUIRED] - must be an absolute path specified to store override log at $(BUILD_OUTPUT_BASE)/OVERRIDELOG.TXT, otherwise no report will be generated BUILDSHA - [OPTIONAL] - should have valid commit sha value for report purpose, if not provided, 'None' will be used for the corresponding field PRODUCT_NAME - [OPTIONAL] - should give friendly product name, if not provided, 'None' will be used for the corresponding field BUILDID_STRING - [OPTIONAL] - should give friendly version string of firmware version, if not provided, 'None' will be used for the corresponding field This tool provides two types of validation, determined by the type of tags included in the overriding module: Override : Override validation, as indicated by override tags, intends to enforce the validity of a linkage. Thus if the target that is overridden is either not found or has an change since the last linkage update, the build will break. Track : Track validation, indicated by track tags from tracking modules, intends to soft-track updates of certain module with various flavors across upstream changes. This validation will ignore this tag if the corresponding target is not found. If a single target is found in multiple track tags, there must be one and only one linkage that matches the current status of target, otherwise build will break. Note : If one module contains one or more track tags, at least one tracked target needs to be found, otherwise build will break.","title":"UEFI Build Plugin"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#command-line-tool","text":"When used as a command line tool, this tool takes the absolute path of workspace (the root directory of Devices repo) as well as the absolute path of overridden module's inf file and then generate a screen-print line for users to include in overriding modules in order to create override linkage. Check the required parameters by using the -h option for command line argument details. The override can also be used on the Active Platform DSC or the Flash Definition FDF defined by the DSC.","title":"Command Line Tool"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#example","text":"Command to generate an override record: OverrideValidation.py -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf Override record to be included in overriding module's inf: #Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 Command to generate a track record: OverrideValidation.py --track -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf Track record to be included in tracking module's inf: #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f Track records to be included in tracking multiple flavors of the same module's inf (you should do not need this in a perfect world): # Production build #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f # Debug build #Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | dbfc0ece0cb8fa499ac2141c80107926 | 2022-02-09T00-31-30 | fd114d321703a32c4684d8411ba0fe7dd7012c14 Command to generate an override record for a target file or directory: OverrideValidation.py -w C:\\Repo -t C:\\Repo\\MU_BASECORE\\MdeModulePkg\\Library\\BaseSerialPortLib16550 Override record to be included in overriding module's inf: #Override : 00000002 | MdeModulePkg/Library/BaseSerialPortLib16550 | 140759cf30a73b02f48cc1f226b015d8 | 2021-12-07T05-30-10 | fa99a33fdb7e8bf6063513fddb807105ec2fad81 Override log generated during pre-build process: Platform: PlatformName Version: 123.456.7890 Date: 2018-05-11T17-56-27 Commit: _SHA_2c9def7a4ce84ef26ed6597afcc60cee4e5c92c0 State: 3/4 Overrides ---------------------------------------------------------------- OVERRIDER: MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf ORIGINALS: + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days OVERRIDER: PlatformNamePkg/Library/NvmConfigLib/NvmConfigLib.inf ORIGINALS: + MdeModulePkg/Bus/Pci/NvmExpressDxe/NvmExpressDxe.inf | MISMATCH | 35 days | Current State: 62929532257365b261080b7e7b1c4e7a | Last Fingerprint: dc9f5e3af1efbac6cf5485b672291903 + MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf | SUCCESS | 0 days + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days + MdeModulePkg/Library/BaseSerialPortLib16550 | SUCCESS | 7 days Command to regenerate the override records in a given .inf file: OverrideValidation.py -w c:\\src -r c:\\src\\FooPkg\\OverridingModule.inf an example of the diff produced when using -r: diff --git a/FooPkg/OverridingModule.inf b/FooPkg/OverridingModule.inf index 2d4ca47299..90da207a39 100644 --- a/FooPkg/OverridingModule.inf +++ b/FooPkg/OverridingModule.inf @@ -8,7 +8,7 @@ # # -#Override : 00000002 | BarPkg/OverridenModule.inf | 4f7eed98e3c084eecdff5fa2e1e57db1 | 2021-11-23T21-41-21 | 44b40c0358489da6c444e7cfb2be26e56b7c16a1 +#Override : 00000002 | BarPkg/OverridenModule.inf | 143b08782a2abc620d1eb57461c6e290 | 2022-03-10T23-09-45 | 6f8c53a3fcd79b202c708e7aa58256cafbf24bc4 #","title":"Example"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#versions","text":"There are two versions of the override format.","title":"Versions"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#version-1","text":"#Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17","title":"Version 1"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#version-2","text":"#Override : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 | 575096df6a Version 2 includes a second hash at the end, which is the git commit that the upstream was last updated. This allows to tools to do a git diff between what you currently have and what is in the tree. It currently only diffs the overridden file (the INF or DSC) and the overriding file.","title":"Version 2"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#copyright-license","text":"Copyright \u00a9 Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_basecore/BaseTools/Scripts/PackageDocumentTools/Readme/","text":"Package Document Tool \u00b6 Prerequisite Tools: Install Python 2.7.3 from https://www.python.org/download/releases/2.7.3/ Install wxPython 2.8.12.1 from https://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/ generally the libraries will be installed at python's subfolder, for example in windows: c:\\python27\\Lib\\site-packages\\ Install DoxyGen 1.8.6 from https://sourceforge.net/projects/doxygen/files/rel-1.8.6/ (Windows only) Install Htmlhelp tool from https://msdn.microsoft.com/en-us/library/windows/desktop/ms669985(v=vs.85).aspx Limitation: Current tool doesn't work on latest wxPython and DoxyGen tool. Please use the sepecific version in above. Run the Tool: Run with GUI: Enter src folder, double click \"packagedocapp.pyw\" or run command \"python packagedocapp.pyw\" to open the GUI. Make sure all the information in blank are correct. Click \"Generate Package Document!\" Run with command line: Open command line window Enter src folder, for example: \"cd C:\\PackageDocumentTools\\src\" Run \"python packagedoc_cli.py --help\" for detail command.","title":"Package Document Tools"},{"location":"dyn/mu_basecore/BaseTools/Scripts/PackageDocumentTools/Readme/#package-document-tool","text":"Prerequisite Tools: Install Python 2.7.3 from https://www.python.org/download/releases/2.7.3/ Install wxPython 2.8.12.1 from https://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/ generally the libraries will be installed at python's subfolder, for example in windows: c:\\python27\\Lib\\site-packages\\ Install DoxyGen 1.8.6 from https://sourceforge.net/projects/doxygen/files/rel-1.8.6/ (Windows only) Install Htmlhelp tool from https://msdn.microsoft.com/en-us/library/windows/desktop/ms669985(v=vs.85).aspx Limitation: Current tool doesn't work on latest wxPython and DoxyGen tool. Please use the sepecific version in above. Run the Tool: Run with GUI: Enter src folder, double click \"packagedocapp.pyw\" or run command \"python packagedocapp.pyw\" to open the GUI. Make sure all the information in blank are correct. Click \"Generate Package Document!\" Run with command line: Open command line window Enter src folder, for example: \"cd C:\\PackageDocumentTools\\src\" Run \"python packagedoc_cli.py --help\" for detail command.","title":"Package Document Tool"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/","text":"Edk2 Basetools \u00b6 This folder has traditionally held the source of Python based tools used by EDK2. The official repo this source has moved to https://github.com/tianocore/edk2-basetools . This folder will remain in the tree until the next stable release (expected 202102). There is a new folder under Basetools BinPipWrappers that uses the pip module rather than this tree for Basetools. By adding the scope pipbuild-win or pipbuild-unix (depending on your host system), the SDE will use the BinPipWrappers instead of the regular BinWrappers . Why Move It \u00b6 The discussion is on the mailing list. The RFC is here: https://edk2.groups.io/g/rfc/topic/74009714#270 The benefits allow for the Basetools project to be used separately from EDK2 itself as well as offering it in a globally accessible manner. This makes it much easier to build a module using Basetools. Separating the Basetools into their own repo allows for easier CI and contribution process. Additional pros, cons, and process can be found on the mailing list. How Do I Install It \u00b6 By default, EDK2 is tied to and tested with a specific version of the Basetools through pip-requirements.txt . You can simply run: pip install -r pip-requirements.txt This will install the required module, thought we strongly suggest setting up a virtual environment. Additionally, you can also install a local clone of the Basetools as well as a specific git commit.","title":"README"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/#edk2-basetools","text":"This folder has traditionally held the source of Python based tools used by EDK2. The official repo this source has moved to https://github.com/tianocore/edk2-basetools . This folder will remain in the tree until the next stable release (expected 202102). There is a new folder under Basetools BinPipWrappers that uses the pip module rather than this tree for Basetools. By adding the scope pipbuild-win or pipbuild-unix (depending on your host system), the SDE will use the BinPipWrappers instead of the regular BinWrappers .","title":"Edk2 Basetools"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/#why-move-it","text":"The discussion is on the mailing list. The RFC is here: https://edk2.groups.io/g/rfc/topic/74009714#270 The benefits allow for the Basetools project to be used separately from EDK2 itself as well as offering it in a globally accessible manner. This makes it much easier to build a module using Basetools. Separating the Basetools into their own repo allows for easier CI and contribution process. Additional pros, cons, and process can be found on the mailing list.","title":"Why Move It"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/#how-do-i-install-it","text":"By default, EDK2 is tied to and tested with a specific version of the Basetools through pip-requirements.txt . You can simply run: pip install -r pip-requirements.txt This will install the required module, thought we strongly suggest setting up a virtual environment. Additionally, you can also install a local clone of the Basetools as well as a specific git commit.","title":"How Do I Install It"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/","text":"Step by step to generate sample self-signed X.509 certificate chain and sign data with PKCS7 structure \u00b6 This readme demonstrates how to generate 3-layer X.509 certificate chain (RootCA -> IntermediateCA -> SigningCert) with OpenSSL commands, and user MUST set a UNIQUE Subject Name (\"Common Name\") on these three different certificates. How to generate a self-signed X.509 certificate chain via OPENSSL \u00b6 Set OPENSSL environment \u00b6 NOTE: Below steps are required for Windows. Linux may already have the OPENSSL environment correctly. set OPENSSL_HOME=c:\\home\\openssl\\openssl-[version] set OPENSSL_CONF=%OPENSSL_HOME%\\apps\\openssl.cnf When a user uses OpenSSL (req or ca command) to generate the certificates, OpenSSL will use the openssl.cnf file as the configuration data (can use \"-config path/to/openssl.cnf\" to describe the specific config file). The user need check the openssl.cnf file, to find your CA path setting, e.g. check if the path exists in [ CA_default ] section. [ CA_default ] dir = ./demoCA # Where everything is kept You may need the following steps for initialization: rd ./demoCA /S/Q mkdir ./demoCA echo.>./demoCA/index.txt echo 01 > ./demoCA/serial mkdir ./demoCA/newcerts OpenSSL will apply the options from the specified sections in openssl.cnf when creating certificates or certificate signing requests. Make sure your configuration in openssl.cnf is correct and rational for certificate constraints. The following sample sections were used when generating test certificates in this readme. [ req ] default_bits = 2048 default_keyfile = privkey.pem distinguished_name = req_distinguished_name attributes = req_attributes x509_extensions = v3_ca # The extensions to add to the self signed cert ... [ v3_ca ] # Extensions for a typical Root CA. subjectKeyIdentifier=hash authorityKeyIdentifier=keyid:always,issuer basicConstraints = critical,CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign ... [ v3_intermediate_ca ] # Extensions for a typical intermediate CA. subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign ... [ usr_cert ] # Extensions for user end certificates. basicConstraints = CA:FALSE nsCertType = client, email subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth, emailProtection ... Generate the certificate chain \u00b6 NOTE: User MUST set a UNIQUE \"Common Name\" on the different certificate 1) Generate the Root Pair: * Generate a root key: ```cmd openssl genrsa -aes256 -out TestRoot.key 2048 ``` * Generate a self-signed root certificate: ```cmd openssl req -extensions v3_ca -new -x509 -days 3650 -key TestRoot.key -out TestRoot.crt openssl x509 -in TestRoot.crt -out TestRoot.cer -outform DER openssl x509 -inform DER -in TestRoot.cer -outform PEM -out TestRoot.pub.pem ``` 2) Generate the Intermediate Pair: * Generate the intermediate key: ```cmd openssl genrsa -aes256 -out TestSub.key 2048 ``` * Generate the intermediate certificate: ```cmd openssl req -new -days 3650 -key TestSub.key -out TestSub.csr openssl ca -extensions v3_intermediate_ca -in TestSub.csr -days 3650 -out TestSub.crt -cert TestRoot.crt -keyfile TestRoot.key openssl x509 -in TestSub.crt -out TestSub.cer -outform DER openssl x509 -inform DER -in TestSub.cer -outform PEM -out TestSub.pub.pem ``` 3) Generate User Key Pair for Data Signing: * Generate User key : ``` cmd openssl genrsa - aes256 - out TestCert . key 2048 ``` * Generate User certificate : ``` cmd openssl req - new - days 3650 - key TestCert . key - out TestCert . csr openssl ca - extensions usr_cert - in TestCert . csr - days 3650 - out TestCert . crt - cert TestSub . crt - keyfile TestSub . key openssl x509 - in TestCert . crt - out TestCert . cer - outform DER openssl x509 - inform DER - in TestCert . cer - outform PEM - out TestCert . pub . pem ``` * Convert Key and Certificate for signing Password is removed with - nodes flag for convenience in this sample . ``` cmd openssl pkcs12 - export - out TestCert . pfx - inkey TestCert . key - in TestCert . crt openssl pkcs12 - in TestCert . pfx - nodes - out TestCert . pem ``` Verify Data Signing & Verification with new X.509 Certificate Chain \u00b6 1) Sign a Binary File to generate a detached PKCS7 signature: ```cmd openssl smime -sign -binary -signer TestCert.pem -outform DER -md sha256 -certfile TestSub.pub.pem -out test.bin.p7 -in test.bin ``` 2) Verify PKCS7 Signature of a Binary File: ```cmd openssl smime -verify -inform DER -in test.bin.p7 -content test.bin -CAfile TestRoot.pub.pem -out test.org.bin ``` Generate DSC PCD include files for Certificate \u00b6 The BinToPcd utility can be used to convert the binary Certificate file to a text file can be included from a DSC file to set a PCD to the contents of the Certificate file. The following 2 PCDs can be set to the PKCS7 Certificate value. The first one supports a single certificate. The second one supports multiple certificate values using the XDR format. gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr Generate DSC PCD include files \u00b6 BinToPcd.py -i TestRoot.cer -p gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer -o TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc BinToPcd.py -i TestRoot.cer -p gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr -x -o TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc These files can be used in !include statements in DSC file PCD sections. For example: Platform scoped fixed at build PCD section [PcdsFixedAtBuild] !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc Platform scoped patchable in module PCD section [PcdsPatchableInModule] !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc Module scoped fixed at build PCD section [Components] FmpDevicePkg/FmpDxe/FmpDxe.inf { <PcdsFixedAtBuild> !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc }","title":"Pkcs7Sign"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#step-by-step-to-generate-sample-self-signed-x509-certificate-chain-and-sign-data-with-pkcs7-structure","text":"This readme demonstrates how to generate 3-layer X.509 certificate chain (RootCA -> IntermediateCA -> SigningCert) with OpenSSL commands, and user MUST set a UNIQUE Subject Name (\"Common Name\") on these three different certificates.","title":"Step by step to generate sample self-signed X.509 certificate chain and sign data with PKCS7 structure"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#how-to-generate-a-self-signed-x509-certificate-chain-via-openssl","text":"","title":"How to generate a self-signed X.509 certificate chain via OPENSSL"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#set-openssl-environment","text":"NOTE: Below steps are required for Windows. Linux may already have the OPENSSL environment correctly. set OPENSSL_HOME=c:\\home\\openssl\\openssl-[version] set OPENSSL_CONF=%OPENSSL_HOME%\\apps\\openssl.cnf When a user uses OpenSSL (req or ca command) to generate the certificates, OpenSSL will use the openssl.cnf file as the configuration data (can use \"-config path/to/openssl.cnf\" to describe the specific config file). The user need check the openssl.cnf file, to find your CA path setting, e.g. check if the path exists in [ CA_default ] section. [ CA_default ] dir = ./demoCA # Where everything is kept You may need the following steps for initialization: rd ./demoCA /S/Q mkdir ./demoCA echo.>./demoCA/index.txt echo 01 > ./demoCA/serial mkdir ./demoCA/newcerts OpenSSL will apply the options from the specified sections in openssl.cnf when creating certificates or certificate signing requests. Make sure your configuration in openssl.cnf is correct and rational for certificate constraints. The following sample sections were used when generating test certificates in this readme. [ req ] default_bits = 2048 default_keyfile = privkey.pem distinguished_name = req_distinguished_name attributes = req_attributes x509_extensions = v3_ca # The extensions to add to the self signed cert ... [ v3_ca ] # Extensions for a typical Root CA. subjectKeyIdentifier=hash authorityKeyIdentifier=keyid:always,issuer basicConstraints = critical,CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign ... [ v3_intermediate_ca ] # Extensions for a typical intermediate CA. subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:true keyUsage = critical, digitalSignature, cRLSign, keyCertSign ... [ usr_cert ] # Extensions for user end certificates. basicConstraints = CA:FALSE nsCertType = client, email subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth, emailProtection ...","title":"Set OPENSSL environment"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-the-certificate-chain","text":"NOTE: User MUST set a UNIQUE \"Common Name\" on the different certificate 1) Generate the Root Pair: * Generate a root key: ```cmd openssl genrsa -aes256 -out TestRoot.key 2048 ``` * Generate a self-signed root certificate: ```cmd openssl req -extensions v3_ca -new -x509 -days 3650 -key TestRoot.key -out TestRoot.crt openssl x509 -in TestRoot.crt -out TestRoot.cer -outform DER openssl x509 -inform DER -in TestRoot.cer -outform PEM -out TestRoot.pub.pem ``` 2) Generate the Intermediate Pair: * Generate the intermediate key: ```cmd openssl genrsa -aes256 -out TestSub.key 2048 ``` * Generate the intermediate certificate: ```cmd openssl req -new -days 3650 -key TestSub.key -out TestSub.csr openssl ca -extensions v3_intermediate_ca -in TestSub.csr -days 3650 -out TestSub.crt -cert TestRoot.crt -keyfile TestRoot.key openssl x509 -in TestSub.crt -out TestSub.cer -outform DER openssl x509 -inform DER -in TestSub.cer -outform PEM -out TestSub.pub.pem ``` 3) Generate User Key Pair for Data Signing: * Generate User key : ``` cmd openssl genrsa - aes256 - out TestCert . key 2048 ``` * Generate User certificate : ``` cmd openssl req - new - days 3650 - key TestCert . key - out TestCert . csr openssl ca - extensions usr_cert - in TestCert . csr - days 3650 - out TestCert . crt - cert TestSub . crt - keyfile TestSub . key openssl x509 - in TestCert . crt - out TestCert . cer - outform DER openssl x509 - inform DER - in TestCert . cer - outform PEM - out TestCert . pub . pem ``` * Convert Key and Certificate for signing Password is removed with - nodes flag for convenience in this sample . ``` cmd openssl pkcs12 - export - out TestCert . pfx - inkey TestCert . key - in TestCert . crt openssl pkcs12 - in TestCert . pfx - nodes - out TestCert . pem ```","title":"Generate the certificate chain"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#verify-data-signing-verification-with-new-x509-certificate-chain","text":"1) Sign a Binary File to generate a detached PKCS7 signature: ```cmd openssl smime -sign -binary -signer TestCert.pem -outform DER -md sha256 -certfile TestSub.pub.pem -out test.bin.p7 -in test.bin ``` 2) Verify PKCS7 Signature of a Binary File: ```cmd openssl smime -verify -inform DER -in test.bin.p7 -content test.bin -CAfile TestRoot.pub.pem -out test.org.bin ```","title":"Verify Data Signing &amp; Verification with new X.509 Certificate Chain"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-dsc-pcd-include-files-for-certificate","text":"The BinToPcd utility can be used to convert the binary Certificate file to a text file can be included from a DSC file to set a PCD to the contents of the Certificate file. The following 2 PCDs can be set to the PKCS7 Certificate value. The first one supports a single certificate. The second one supports multiple certificate values using the XDR format. gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr","title":"Generate DSC PCD include files for Certificate"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-dsc-pcd-include-files","text":"BinToPcd.py -i TestRoot.cer -p gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer -o TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc BinToPcd.py -i TestRoot.cer -p gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr -x -o TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc These files can be used in !include statements in DSC file PCD sections. For example: Platform scoped fixed at build PCD section [PcdsFixedAtBuild] !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc Platform scoped patchable in module PCD section [PcdsPatchableInModule] !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc Module scoped fixed at build PCD section [Components] FmpDevicePkg/FmpDxe/FmpDxe.inf { <PcdsFixedAtBuild> !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc }","title":"Generate DSC PCD include files"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/","text":"Crypto Driver \u00b6 This is a potentially prepacked version of the BaseCryptLib and TlsLib, delivered via protocol. There are two routes: using the pre-compiled version and compiling it into your platform. Benefits \u00b6 But first, why would you care about this? It has a few benefits, namely: Smaller Binary sizes Easier to service/upgrade Transparency on what version of crypto you're using Reduced build times (if using pre-compiled version) There are different flavors of Crypto available, with different functions supported. Don't need to use HMAC in your PEI phase? Select a service level or flavor that doesn't include HMAC in your platform. How include on your platform \u00b6 Now there are a few options for you. We'll start with the pre-compiled route. The Pre-compiled (easy) way \u00b6 The easy way involves setting a few variables and a few includes. The hard way is just to do it yourself. First the easy way: Define the service level that you want for each phase of UEFI in the defines section of your DSC. [Defines] DEFINE PEI_CRYPTO_SERVICES = TINY_SHA DEFINE DXE_CRYPTO_SERVICES = STANDARD DEFINE SMM_CRYPTO_SERVICES = STANDARD DEFINE PEI_CRYPTO_ARCH = IA32 DEFINE DXE_CRYPTO_ARCH = X64 DEFINE SMM_CRYPTO_ARCH = X64 The above example is for a standard intel platform, and the service levels or flavors available. Add the DSC include !include CryptoPkg/Driver/Bin/CryptoDriver.inc.dsc This sets the definitions for BaseCryptLib as well as includes the correct flavor level of the component you wish to use. Add the FDF includes to your platform FDF Currently, it isn't possible in an FDF to redefine a FV section and have them be combined. There are two includes: BOOTBLOCK and DXE. The first includes the PEI phase and is meant to be stuck in your BOOTBLOCK FV. The second contains the DXE and SMM modules and is meant to be stuck in your FVDXE. [FV.FVBOOTBLOCK] ... !include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf ... [FV.FVDXE] ... !include CryptoPkg/Driver/Bin/CryptoDriver.DXE.inc.fdf Recommendations \u00b6 It is highly recommended to put this logic behind conditionals like so: [FV.FVBOOTBLOCK] !if $(ENABLE_SHARED_CRYPTO) == TRUE !include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf !endif This allows developers on the platform to use their own BaseCryptLib or TlsLib if they want. Just add a check if it's not defined in your DSC like so. !ifndef ENABLE_SHARED_CRYPTO # by default true ENABLE_SHARED_CRYPTO = TRUE !endif The DIY way \u00b6 If you want to take advantage of the BaseCryptOnProtocol but don't want to use a pre-compiled method, you can compile it within your platform itself. Shown here is for an Intel platform, adjust the architectures as needed. [LibraryClasses.IA32] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf [LibraryClasses.X64] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf [LibraryClasses.X64.DXE_SMM_DRIVER] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf [Components.IA32] CryptoPkg/Driver/CryptoPei.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/PeiCryptLib.inf TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } [Components.X64] CryptoPkg/Driver/CryptoDxe.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } CryptoPkg/Driver/CryptoSmm.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } The PCDs are long and default to all false. The flavors are stored as .inc.dsc files at CryptoPkg\\Driver\\Packaging . An example would be CryptoPkg\\Driver\\Packaging\\Crypto.pcd.TINY_SHA.inc.dsc which is a flavor that just has Sha1, Sha256, and Sha386. You'll need to include these components in your FDF as well. [FV.FVBOOTBLOCK] INF CryptoPkg/Driver/CryptoPei.inf [FV.FVDXE] INF CryptoPkg/Driver/CryptoSmm.inf INF CryptoPkg/Driver/CryptoDxe.inf","title":"Driver"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#crypto-driver","text":"This is a potentially prepacked version of the BaseCryptLib and TlsLib, delivered via protocol. There are two routes: using the pre-compiled version and compiling it into your platform.","title":"Crypto Driver"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#benefits","text":"But first, why would you care about this? It has a few benefits, namely: Smaller Binary sizes Easier to service/upgrade Transparency on what version of crypto you're using Reduced build times (if using pre-compiled version) There are different flavors of Crypto available, with different functions supported. Don't need to use HMAC in your PEI phase? Select a service level or flavor that doesn't include HMAC in your platform.","title":"Benefits"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#how-include-on-your-platform","text":"Now there are a few options for you. We'll start with the pre-compiled route.","title":"How include on your platform"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#the-pre-compiled-easy-way","text":"The easy way involves setting a few variables and a few includes. The hard way is just to do it yourself. First the easy way: Define the service level that you want for each phase of UEFI in the defines section of your DSC. [Defines] DEFINE PEI_CRYPTO_SERVICES = TINY_SHA DEFINE DXE_CRYPTO_SERVICES = STANDARD DEFINE SMM_CRYPTO_SERVICES = STANDARD DEFINE PEI_CRYPTO_ARCH = IA32 DEFINE DXE_CRYPTO_ARCH = X64 DEFINE SMM_CRYPTO_ARCH = X64 The above example is for a standard intel platform, and the service levels or flavors available. Add the DSC include !include CryptoPkg/Driver/Bin/CryptoDriver.inc.dsc This sets the definitions for BaseCryptLib as well as includes the correct flavor level of the component you wish to use. Add the FDF includes to your platform FDF Currently, it isn't possible in an FDF to redefine a FV section and have them be combined. There are two includes: BOOTBLOCK and DXE. The first includes the PEI phase and is meant to be stuck in your BOOTBLOCK FV. The second contains the DXE and SMM modules and is meant to be stuck in your FVDXE. [FV.FVBOOTBLOCK] ... !include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf ... [FV.FVDXE] ... !include CryptoPkg/Driver/Bin/CryptoDriver.DXE.inc.fdf","title":"The Pre-compiled (easy) way"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#recommendations","text":"It is highly recommended to put this logic behind conditionals like so: [FV.FVBOOTBLOCK] !if $(ENABLE_SHARED_CRYPTO) == TRUE !include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf !endif This allows developers on the platform to use their own BaseCryptLib or TlsLib if they want. Just add a check if it's not defined in your DSC like so. !ifndef ENABLE_SHARED_CRYPTO # by default true ENABLE_SHARED_CRYPTO = TRUE !endif","title":"Recommendations"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#the-diy-way","text":"If you want to take advantage of the BaseCryptOnProtocol but don't want to use a pre-compiled method, you can compile it within your platform itself. Shown here is for an Intel platform, adjust the architectures as needed. [LibraryClasses.IA32] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf [LibraryClasses.X64] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf [LibraryClasses.X64.DXE_SMM_DRIVER] BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf [Components.IA32] CryptoPkg/Driver/CryptoPei.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/PeiCryptLib.inf TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } [Components.X64] CryptoPkg/Driver/CryptoDxe.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } CryptoPkg/Driver/CryptoSmm.inf { <LibraryClasses> BaseCryptLib|CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf <PcdsFixedAtBuild> .. All the flavor PCDs here .. } The PCDs are long and default to all false. The flavors are stored as .inc.dsc files at CryptoPkg\\Driver\\Packaging . An example would be CryptoPkg\\Driver\\Packaging\\Crypto.pcd.TINY_SHA.inc.dsc which is a flavor that just has Sha1, Sha256, and Sha386. You'll need to include these components in your FDF as well. [FV.FVBOOTBLOCK] INF CryptoPkg/Driver/CryptoPei.inf [FV.FVDXE] INF CryptoPkg/Driver/CryptoSmm.inf INF CryptoPkg/Driver/CryptoDxe.inf","title":"The DIY way"},{"location":"dyn/mu_basecore/CryptoPkg/Library/BaseCryptLibOnProtocolPpi/readme/","text":"BaseCryptLibOnProtocolPpi \u00b6 This is an implementation of BaseCryptLib that uses a protocol. This makes binaries smaller, makes servicing easier, and allows crypto to be pre-compiled. See CryptoPkg/Driver/readme.md for more information.","title":"Base Crypt Lib On Protocol Ppi"},{"location":"dyn/mu_basecore/CryptoPkg/Library/BaseCryptLibOnProtocolPpi/readme/#basecryptlibonprotocolppi","text":"This is an implementation of BaseCryptLib that uses a protocol. This makes binaries smaller, makes servicing easier, and allows crypto to be pre-compiled. See CryptoPkg/Driver/readme.md for more information.","title":"BaseCryptLibOnProtocolPpi"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/","text":"OpenSSL Native Instructions \u00b6 The OpenSSL assembly files are traditionally generated at build time using a perl script. To avoid that burden on EDK2 users, these end-result assembly files are generated during the configuration steps through process_files.pl. Generating the assembly files \u00b6 This only needs to be done when updating to a new OpenSSL version. Due to the script wrapping required to process the OpenSSL configuration data, each native architecture must be processed individually (in addition to the standard version). Furthermore the standard version must be processed first before processing any other ARCH. Current supported ARCHs: [X64, X64Gcc, A32]. [From the OpenSSL library directory] ./process_files.pl ./process_files.pl X64 ./process_files.pl [Arch] etc. How include on your platform \u00b6 To include the precompiled OpenSSL native instructions you need to reference the specific architecture .inf file within you dsc file as well as include the appropriate align size within the build options. Note: In the build options the correct alignments are: 256 for 64-bit 64 for 32-bit Note: Specificity of where to put the buildoptions and library class references will vary. Example with X64: [LibraryClasses] OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibX64.inf [BuildOptions.X64] MSFT:*_*_*_DLINK_FLAGS = /ALIGN:256 Example with IA32: [LibraryClasses] OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibIA32.inf [BuildOptions.X64] MSFT:*_*_*_DLINK_FLAGS = /ALIGN:64","title":"Openssl Lib"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/#openssl-native-instructions","text":"The OpenSSL assembly files are traditionally generated at build time using a perl script. To avoid that burden on EDK2 users, these end-result assembly files are generated during the configuration steps through process_files.pl.","title":"OpenSSL Native Instructions"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/#generating-the-assembly-files","text":"This only needs to be done when updating to a new OpenSSL version. Due to the script wrapping required to process the OpenSSL configuration data, each native architecture must be processed individually (in addition to the standard version). Furthermore the standard version must be processed first before processing any other ARCH. Current supported ARCHs: [X64, X64Gcc, A32]. [From the OpenSSL library directory] ./process_files.pl ./process_files.pl X64 ./process_files.pl [Arch] etc.","title":"Generating the assembly files"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/#how-include-on-your-platform","text":"To include the precompiled OpenSSL native instructions you need to reference the specific architecture .inf file within you dsc file as well as include the appropriate align size within the build options. Note: In the build options the correct alignments are: 256 for 64-bit 64 for 32-bit Note: Specificity of where to put the buildoptions and library class references will vary. Example with X64: [LibraryClasses] OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibX64.inf [BuildOptions.X64] MSFT:*_*_*_DLINK_FLAGS = /ALIGN:256 Example with IA32: [LibraryClasses] OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibIA32.inf [BuildOptions.X64] MSFT:*_*_*_DLINK_FLAGS = /ALIGN:64","title":"How include on your platform"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/","text":"Memory Protections \u00b6 The Memory Protection Settings add safety functionality such as page and pool guards, stack guard and null pointer detection. The settings are split between MM and DXE environments for modularity. The target audience for this doc has intermediate knowledge of systems programming and working with EDK II. Useful Terms and Concepts (Linked in Text if Used) \u00b6 Option ROM \u00b6 A driver that interfaces between BIOS services and hardware. Boot Strap Processor (BSP) \u00b6 The bootstrap processor (BSP) handles initialization procedures for the system as a whole. These procedures include checking the integrity of memory, identifying properties of the system logic and starting the remaining processors. Application Processor (AP) \u00b6 A system processor used for processing signals in embedded systems. Boot Loader \u00b6 Places into working memory the required resources for runtime. Read Only (RO) \u00b6 A bit used to mark certain areas of memory as non-writeable. No eXecute/eXecute Never/eXecute Disable Attribute (NX/XN/XD) \u00b6 A bit used to mark certain areas of memory as non-executable. NX is a term usually used by AMD whereas XD is used by Intel and XN by Qualcomm. The only difference between NX, XD, and XN are their names. Physical/Page Address Extension \u00b6 A memory management feature in x86 architecture which defines a page table heirarchy with table entries of 64 bits allowing CPUs to directly address physical address spaces larger than 32 bits (4 GB). Model-specific Register (MSR) \u00b6 Any of the various control registers in the x86 instruction set used for debugging, execution tracing, performance monitoring and CPU feature toggling. EndOfDxe \u00b6 The point at which the driver execution (DXE) phase has ended and all drivers provided by the mfg (as part of the built-in ROM or loaded directly from another driver) should be loaded now, or else they have failed their dependency expressions. UEFI drivers and OpROMs have not yet been started. Page Fault Exception (#PF) \u00b6 An exception raised when EDK II code attempts to access memory which is not present or settings for the page make it invisible. Task State Segment (TSS) \u00b6 A structure on x86-based CPUs which holds information about a unit of execution. Cpu Context Dump \u00b6 A routine which prints to serial out the module in which the fault occurred, type of fault which occurred and contents of each CPU register. Memory Management Unit (MMU) \u00b6 Hardware on a CPU which is primarily responsible for translating Virtual Memory addresses to Physical ones. Translation Lookaside Buffer (TLB) \u00b6 A memory cache which is part of the CPUs MMU and stores translations of Virtual Memory to Physical Memory. The addresses stored in the TLB are dictated by some algorithm intended to decrease amount of memory accesses for which the address translation is outside the TLB. NXCOMPAT \u00b6 NXCOMPAT is a DLL flag which indicates that the loaded binary expects memory allocations to have the NX attribute applied which will be removed when the code is copied into the memory. NXCOMPAT images should also apply RO to the memory before execution to ensure that, at any point in time, all memory is executable or read-only but not both. Nonstop Mode \u00b6 In the case of Non-Stop mode being enabled for either HeapGuardPolicy or NullPointerDetectionPolicy , two exception handlers are registered. The first handler runs whenever the heap guard or null pointer page absences trigger a #PF . If Non-Stop mode is enabled for this type of #PF , the absent page(s) are temporarily set to be present and a Cpu Context Dump is run after which the second exception handler registered (the debug handler) is run. The debug handler sets the page to be present and clears the TLB to remove the current translation for the page which caused the #PF . Once these two handlers have run, code execution continues. Null Pointer Detection \u00b6 Summary \u00b6 Pages are allocated in 4KB chunks. This policy marks the 4KB page at the NULL address to be not present to detect NULL pointer references in Dxe and/or platform MM. Dxe Available Settings \u00b6 UefiNullDetection - Enable NULL pointer detection for DXE DisableEndOfDxe - Disable NULL pointer detection just after EndOfDxe DisableReadyToBoot - Disable NULL pointer detection just after ReadyToBoot MM Available Settings \u00b6 If NullPointerDetectionPolicy is TRUE, the present bit for the NULL page is cleared for SMM address space. Image Protection Policy \u00b6 Summary \u00b6 This policy enables an image to be protected by DxeCore if it is page-aligned, meaning the code sections become read-only, and the data sections become non-executable. This policy is only available in the DXE environment. There are 3 environment assumptions for enabling image protection: The PE code section and data sections are not merged. If those 2 sections are merged, a [#PF](#page-fault-exception-(aka-#pf) exception might be generated because the CPU may try to write read-only data in data section or execute an NX instruction in the code section. The PE image can be protected if it is page aligned. This feature should NOT be used if there is any self-modifying code in the code region. A platform may not disable NX in the DXE phase. If a platform disables NX in the DXE phase, the x86 page table will become invalid because the NX bit in the page table entry becomes a RESERVED bit and a #PF exception will be generated. If a platform wants to disable the NX bit, it must occur in the PEI phase. Overhead \u00b6 O(n) time and space overhead. Each image requires a 6K attributes header, so if there are n images the space overhead will be 6K*n and thus O(n) time to populate the headers. In most cases the number of images is in the order of hundreds making this feature relatively inexpensive. Because this feature requires aligned images, there will likely be an increased size footprint for each image. Available Settings \u00b6 FromUnknown - Protect images from unknown devices FromFv - Protect images from firmware volume RaiseErrorIfProtectionFails - If set, images which fail to be protected will be unloaded. This excludes failure because CPU Arch Protocol has not yet been installed BlockImagesWithoutNxFlag - NX may be set on EfiLoaderCode, EfiBootServicesCode, and EfiRuntimeServicesCode if the setting for each is active in the NX Memory Protection Policy . However, if the image does not indicate support for NX via the NXCOMPAT DLL flag in the header, the logic will cease to set the NX attribute on allocations of memory of type EfiLoaderCode, EfiBootServicesCode, and/or EfiRuntimeServicesCode. Using the BlockImagesWithoutNxFlag setting in this policy will prevent images which don't support NXCOMPAT from loading and thus cause NX to continue to be applied to allocations of a code memory type based on their respective setting in the NX Memory Protection Policy . NX Memory Protection Policy \u00b6 Summary \u00b6 This policy sets the NX attribute to memory of the associated memory type. This setting does not apply to MM. Every active memory type will be mapped as non-executable. Note that a portion of memory will only be marked as non-executable once the CPU Architectural Protocol is available. Also note that in order to enable Data Execution Protection, the operating system needs to set the IA32_EFER.NXE bit in the IA32_EFER MSR , and then set the XD bit in the CPU PAE page table. Overhead \u00b6 O(n) time where n is the number of memory mapped regions. The number of actual set bits beyond one is inconsequential because every memory region must be checked if at least one bit is set. There is no extra space complexity due to using the already present NX bit. Available Settings \u00b6 EfiReservedMemoryType EfiLoaderCode - If an image does not indicate support for NX via the NXCOMPAT DLL flag, the logic will cease to set the NX attribute on allocations of memory this type. Using the BlockImagesWithoutNxFlag in the Image Protection Policy will prevent images which don't support NXCOMPAT . EfiLoaderData EfiBootServicesCode - Same note as EfiLoaderCode. EfiBootServicesData EfiRuntimeServicesCode - Same note as EfiLoaderCode. EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved Page Guards \u00b6 Summary \u00b6 The HeapGuardPageType policy implements guard pages on the specified memory types to detect heap overflow. If a bit is set, a guard page will be added before and after the corresponding type of page allocated if there's enough free pages for all of them. Guard pages are set to NOT PRESENT so any attempt to access them will cause a #PF . The system will do its best to ensure that only one guard page separates two allocated pages to avoid wasted space. Overhead \u00b6 O(n) time where n is the number of page allocations/frees. Because there are 2 extra pages allocated for every call to AllocatePages(), O(n) space is also required. Available Settings for DXE and MM \u00b6 EfiReservedMemoryType EfiLoaderCode EfiLoaderData EfiBootServicesCode EfiBootServicesData EfiRuntimeServicesCode EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved Pool Guards \u00b6 Summary \u00b6 The HeapGuardPoolType policy is essentially the same as HeapGuardPageType policy. For each active memory type, a guard page will be added just before and after the portion of memory which the allocated pool occupies. The only added complexity comes when the allocated pool is not a multiple of the size of a page. In this case, the pool must align with either the head or tail guard page, meaning either overflow or underflow can be caught consistently but not both. The head/tail alignment is set in HeapGuardPolicy - look there for additional details. Overhead \u00b6 Same as above: O(n) time and space for same reasons as HeapGuardPageType . Note that this functionality requires creating guard pages, meaning that for n allocations, 4k * (n + 1) (assuming each of the n pools is adjacent to another pool) additional space is required. Available Settings for DXE and MM \u00b6 EfiReservedMemoryType EfiLoaderCode EfiLoaderData EfiBootServicesCode EfiBootServicesData EfiRuntimeServicesCode EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved HeapGuardPolicy \u00b6 Summary \u00b6 While the above two policies ( Pool Guards and Page Guards act as a switch for each protectable memory type, this policy is an enable/disable switch for those two policies (ex. if UefiPageGuard is unset, page guards in DXE are inactive regardless of the Page Guard settings). The only aspect of this policy which should be elaborated upon is Direction. Direction dictates whether an allocated pool which does not fit perfectly into a multiple of pages is aligned to the head or tail guard. The following Figure shows examples of the two: On free the pool head/tail is checked to ensure it was not overwritten while the not-present page will trigger a page fault immediately. Overhead \u00b6 Overhead is same as Page Guards and Pool Guards . DXE Available Settings \u00b6 UefiPageGuard - Enable UEFI page guard UefiPoolGuard - Enable UEFI pool guard UefiFreedMemoryGuard - Enable Use-After-Free memory detection Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0 MM Available Settings \u00b6 SmmPageGuard - Enable SMM page guard SmmPoolGuard - Enable SMM pool guard Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0 CPU Stack Guard \u00b6 The CpuStackGuard policy indicates if UEFI Stack Guard will be enabled. The stack guards add two additional pages to the bottom of the stack(s). The first page is simply the guard page which is set to not present. When a page fault occurs, the current stack address is invalid and so it is not possible to push the error code and architecture status onto the current stack. Because of this, there is a special \"Exception Stack\" or \"Known Good Stack\" which is the second page placed at the bottom of the stack. This page is reserved for use by the exception handler and ensures that a valid stack is always present when an exception occurs for error reporting. A note on SMM \u00b6 An equivalent SMM stack guard feature is contained in PiSmmCpuDxeSmm and is not dictated by this policy. Note that the UEFI stack protection starts in DxeIpl, because the region is fixed, and requires PcdDxeIplBuildPageTables to be TRUE. In Project Mu, we have hard-coded CpuStackGuard to be TRUE in PEI phase, so we always set up a switch stack, clear the PRESENT bit in the page table for the guard page of the Boot Strap Processor stack, and build the page tables. However, the stack switch handlers will still only be installed in DXE phase if CpuStackGuard is TRUE. Overhead \u00b6 O(1) time and space. Setting: If TRUE, UEFI Stack Guard will be enabled. How to Set the Memory Protection Policy \u00b6 For DXE settings, add the following to the platform DSC file: [ LibraryClasses . Common . DXE_DRIVER , LibraryClasses . Common . DXE_CORE , LibraryClasses . Common . UEFI_APPLICATION ] DxeMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / DxeMemoryProtectionHobLib . inf For MM settings, add the following to the platform DSC file if the platform utilizes SMM: [ LibraryClasses . common . SMM_CORE , LibraryClasses . common . DXE_SMM_DRIVER ] MmMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / SmmMemoryProtectionHobLib . inf or the following if the platform utilizes Standalone MM: [ LibraryClasses . common . MM_CORE_STANDALONE , LibraryClasses . common . MM_STANDALONE ] MmMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / StandaloneMmMemoryProtectionHobLib . inf Create the HOB entry in any PEI module by adding the include: #include <Guid/DxeMemoryProtectionSettings.h> #include <Guid/MmMemoryProtectionSettings.h> and somewhere within the code doing something like: DXE_MEMORY_PROTECTION_SETTINGS DxeSettings ; MM_MEMORY_PROTECTION_SETTINGS MmSettings ; DxeSettings = ( DXE_MEMORY_PROTECTION_SETTINGS ) DXE_MEMORY_PROTECTION_SETTINGS_DEBUG ; MmSettings = ( MM_MEMORY_PROTECTION_SETTINGS ) MM_MEMORY_PROTECTION_SETTINGS_DEBUG ; BuildGuidDataHob ( & gDxeMemoryProtectionSettingsGuid , & DxeSettings , sizeof ( DxeSettings ) ); BuildGuidDataHob ( & gMmMemoryProtectionSettingsGuid , & MmSettings , sizeof ( MmSettings ) ); This will also require you to add gMemoryProtectionSettingsGuid under the Guids section in the relevant INF. If you want to deviate from one of the settings profile definitions in DxeMemoryProtectionSettings.h and/or MmMemoryProtectionSettings, it is recommended that you start with the one which most closely aligns with your desired settings and update from there in a manner similar to below: MmSettings . HeapGuardPolicy . Fields . MmPageGuard = 0 ; MmSettings . HeapGuardPolicy . Fields . MmPoolGuard = 0 ; DxeSettings . ImageProtectionPolicy . Fields . ProtectImageFromUnknown = 1 ; before building the HOB.","title":"Package Overview"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#memory-protections","text":"The Memory Protection Settings add safety functionality such as page and pool guards, stack guard and null pointer detection. The settings are split between MM and DXE environments for modularity. The target audience for this doc has intermediate knowledge of systems programming and working with EDK II.","title":"Memory Protections"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#useful-terms-and-concepts-linked-in-text-if-used","text":"","title":"Useful Terms and Concepts (Linked in Text if Used)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#option-rom","text":"A driver that interfaces between BIOS services and hardware.","title":"Option ROM"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#boot-strap-processor-bsp","text":"The bootstrap processor (BSP) handles initialization procedures for the system as a whole. These procedures include checking the integrity of memory, identifying properties of the system logic and starting the remaining processors.","title":"Boot Strap Processor (BSP)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#application-processor-ap","text":"A system processor used for processing signals in embedded systems.","title":"Application Processor (AP)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#boot-loader","text":"Places into working memory the required resources for runtime.","title":"Boot Loader"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#read-only-ro","text":"A bit used to mark certain areas of memory as non-writeable.","title":"Read Only (RO)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#no-executeexecute-neverexecute-disable-attribute-nxxnxd","text":"A bit used to mark certain areas of memory as non-executable. NX is a term usually used by AMD whereas XD is used by Intel and XN by Qualcomm. The only difference between NX, XD, and XN are their names.","title":"No eXecute/eXecute Never/eXecute Disable Attribute (NX/XN/XD)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#physicalpage-address-extension","text":"A memory management feature in x86 architecture which defines a page table heirarchy with table entries of 64 bits allowing CPUs to directly address physical address spaces larger than 32 bits (4 GB).","title":"Physical/Page Address Extension"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#model-specific-register-msr","text":"Any of the various control registers in the x86 instruction set used for debugging, execution tracing, performance monitoring and CPU feature toggling.","title":"Model-specific Register (MSR)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#endofdxe","text":"The point at which the driver execution (DXE) phase has ended and all drivers provided by the mfg (as part of the built-in ROM or loaded directly from another driver) should be loaded now, or else they have failed their dependency expressions. UEFI drivers and OpROMs have not yet been started.","title":"EndOfDxe"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#page-fault-exception-pf","text":"An exception raised when EDK II code attempts to access memory which is not present or settings for the page make it invisible.","title":"Page Fault Exception (#PF)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#task-state-segment-tss","text":"A structure on x86-based CPUs which holds information about a unit of execution.","title":"Task State Segment (TSS)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#cpu-context-dump","text":"A routine which prints to serial out the module in which the fault occurred, type of fault which occurred and contents of each CPU register.","title":"Cpu Context Dump"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#memory-management-unit-mmu","text":"Hardware on a CPU which is primarily responsible for translating Virtual Memory addresses to Physical ones.","title":"Memory Management Unit (MMU)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#translation-lookaside-buffer-tlb","text":"A memory cache which is part of the CPUs MMU and stores translations of Virtual Memory to Physical Memory. The addresses stored in the TLB are dictated by some algorithm intended to decrease amount of memory accesses for which the address translation is outside the TLB.","title":"Translation Lookaside Buffer (TLB)"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nxcompat","text":"NXCOMPAT is a DLL flag which indicates that the loaded binary expects memory allocations to have the NX attribute applied which will be removed when the code is copied into the memory. NXCOMPAT images should also apply RO to the memory before execution to ensure that, at any point in time, all memory is executable or read-only but not both.","title":"NXCOMPAT"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nonstop-mode","text":"In the case of Non-Stop mode being enabled for either HeapGuardPolicy or NullPointerDetectionPolicy , two exception handlers are registered. The first handler runs whenever the heap guard or null pointer page absences trigger a #PF . If Non-Stop mode is enabled for this type of #PF , the absent page(s) are temporarily set to be present and a Cpu Context Dump is run after which the second exception handler registered (the debug handler) is run. The debug handler sets the page to be present and clears the TLB to remove the current translation for the page which caused the #PF . Once these two handlers have run, code execution continues.","title":"Nonstop Mode"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#null-pointer-detection","text":"","title":"Null Pointer Detection"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary","text":"Pages are allocated in 4KB chunks. This policy marks the 4KB page at the NULL address to be not present to detect NULL pointer references in Dxe and/or platform MM.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#dxe-available-settings","text":"UefiNullDetection - Enable NULL pointer detection for DXE DisableEndOfDxe - Disable NULL pointer detection just after EndOfDxe DisableReadyToBoot - Disable NULL pointer detection just after ReadyToBoot","title":"Dxe Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#mm-available-settings","text":"If NullPointerDetectionPolicy is TRUE, the present bit for the NULL page is cleared for SMM address space.","title":"MM Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#image-protection-policy","text":"","title":"Image Protection Policy"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_1","text":"This policy enables an image to be protected by DxeCore if it is page-aligned, meaning the code sections become read-only, and the data sections become non-executable. This policy is only available in the DXE environment. There are 3 environment assumptions for enabling image protection: The PE code section and data sections are not merged. If those 2 sections are merged, a [#PF](#page-fault-exception-(aka-#pf) exception might be generated because the CPU may try to write read-only data in data section or execute an NX instruction in the code section. The PE image can be protected if it is page aligned. This feature should NOT be used if there is any self-modifying code in the code region. A platform may not disable NX in the DXE phase. If a platform disables NX in the DXE phase, the x86 page table will become invalid because the NX bit in the page table entry becomes a RESERVED bit and a #PF exception will be generated. If a platform wants to disable the NX bit, it must occur in the PEI phase.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead","text":"O(n) time and space overhead. Each image requires a 6K attributes header, so if there are n images the space overhead will be 6K*n and thus O(n) time to populate the headers. In most cases the number of images is in the order of hundreds making this feature relatively inexpensive. Because this feature requires aligned images, there will likely be an increased size footprint for each image.","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings","text":"FromUnknown - Protect images from unknown devices FromFv - Protect images from firmware volume RaiseErrorIfProtectionFails - If set, images which fail to be protected will be unloaded. This excludes failure because CPU Arch Protocol has not yet been installed BlockImagesWithoutNxFlag - NX may be set on EfiLoaderCode, EfiBootServicesCode, and EfiRuntimeServicesCode if the setting for each is active in the NX Memory Protection Policy . However, if the image does not indicate support for NX via the NXCOMPAT DLL flag in the header, the logic will cease to set the NX attribute on allocations of memory of type EfiLoaderCode, EfiBootServicesCode, and/or EfiRuntimeServicesCode. Using the BlockImagesWithoutNxFlag setting in this policy will prevent images which don't support NXCOMPAT from loading and thus cause NX to continue to be applied to allocations of a code memory type based on their respective setting in the NX Memory Protection Policy .","title":"Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nx-memory-protection-policy","text":"","title":"NX Memory Protection Policy"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_2","text":"This policy sets the NX attribute to memory of the associated memory type. This setting does not apply to MM. Every active memory type will be mapped as non-executable. Note that a portion of memory will only be marked as non-executable once the CPU Architectural Protocol is available. Also note that in order to enable Data Execution Protection, the operating system needs to set the IA32_EFER.NXE bit in the IA32_EFER MSR , and then set the XD bit in the CPU PAE page table.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_1","text":"O(n) time where n is the number of memory mapped regions. The number of actual set bits beyond one is inconsequential because every memory region must be checked if at least one bit is set. There is no extra space complexity due to using the already present NX bit.","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings_1","text":"EfiReservedMemoryType EfiLoaderCode - If an image does not indicate support for NX via the NXCOMPAT DLL flag, the logic will cease to set the NX attribute on allocations of memory this type. Using the BlockImagesWithoutNxFlag in the Image Protection Policy will prevent images which don't support NXCOMPAT . EfiLoaderData EfiBootServicesCode - Same note as EfiLoaderCode. EfiBootServicesData EfiRuntimeServicesCode - Same note as EfiLoaderCode. EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved","title":"Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#page-guards","text":"","title":"Page Guards"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_3","text":"The HeapGuardPageType policy implements guard pages on the specified memory types to detect heap overflow. If a bit is set, a guard page will be added before and after the corresponding type of page allocated if there's enough free pages for all of them. Guard pages are set to NOT PRESENT so any attempt to access them will cause a #PF . The system will do its best to ensure that only one guard page separates two allocated pages to avoid wasted space.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_2","text":"O(n) time where n is the number of page allocations/frees. Because there are 2 extra pages allocated for every call to AllocatePages(), O(n) space is also required.","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings-for-dxe-and-mm","text":"EfiReservedMemoryType EfiLoaderCode EfiLoaderData EfiBootServicesCode EfiBootServicesData EfiRuntimeServicesCode EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved","title":"Available Settings for DXE and MM"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#pool-guards","text":"","title":"Pool Guards"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_4","text":"The HeapGuardPoolType policy is essentially the same as HeapGuardPageType policy. For each active memory type, a guard page will be added just before and after the portion of memory which the allocated pool occupies. The only added complexity comes when the allocated pool is not a multiple of the size of a page. In this case, the pool must align with either the head or tail guard page, meaning either overflow or underflow can be caught consistently but not both. The head/tail alignment is set in HeapGuardPolicy - look there for additional details.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_3","text":"Same as above: O(n) time and space for same reasons as HeapGuardPageType . Note that this functionality requires creating guard pages, meaning that for n allocations, 4k * (n + 1) (assuming each of the n pools is adjacent to another pool) additional space is required.","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings-for-dxe-and-mm_1","text":"EfiReservedMemoryType EfiLoaderCode EfiLoaderData EfiBootServicesCode EfiBootServicesData EfiRuntimeServicesCode EfiRuntimeServicesData EfiConventionalMemory EfiUnusableMemory EfiACPIReclaimMemory EfiACPIMemoryNVS EfiMemoryMappedIO EfiMemoryMappedIOPortSpace EfiPalCode EfiPersistentMemory OEMReserved OSReserved","title":"Available Settings for DXE and MM"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#heapguardpolicy","text":"","title":"HeapGuardPolicy"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_5","text":"While the above two policies ( Pool Guards and Page Guards act as a switch for each protectable memory type, this policy is an enable/disable switch for those two policies (ex. if UefiPageGuard is unset, page guards in DXE are inactive regardless of the Page Guard settings). The only aspect of this policy which should be elaborated upon is Direction. Direction dictates whether an allocated pool which does not fit perfectly into a multiple of pages is aligned to the head or tail guard. The following Figure shows examples of the two: On free the pool head/tail is checked to ensure it was not overwritten while the not-present page will trigger a page fault immediately.","title":"Summary"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_4","text":"Overhead is same as Page Guards and Pool Guards .","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#dxe-available-settings_1","text":"UefiPageGuard - Enable UEFI page guard UefiPoolGuard - Enable UEFI pool guard UefiFreedMemoryGuard - Enable Use-After-Free memory detection Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0","title":"DXE Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#mm-available-settings_1","text":"SmmPageGuard - Enable SMM page guard SmmPoolGuard - Enable SMM pool guard Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0","title":"MM Available Settings"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#cpu-stack-guard","text":"The CpuStackGuard policy indicates if UEFI Stack Guard will be enabled. The stack guards add two additional pages to the bottom of the stack(s). The first page is simply the guard page which is set to not present. When a page fault occurs, the current stack address is invalid and so it is not possible to push the error code and architecture status onto the current stack. Because of this, there is a special \"Exception Stack\" or \"Known Good Stack\" which is the second page placed at the bottom of the stack. This page is reserved for use by the exception handler and ensures that a valid stack is always present when an exception occurs for error reporting.","title":"CPU Stack Guard"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#a-note-on-smm","text":"An equivalent SMM stack guard feature is contained in PiSmmCpuDxeSmm and is not dictated by this policy. Note that the UEFI stack protection starts in DxeIpl, because the region is fixed, and requires PcdDxeIplBuildPageTables to be TRUE. In Project Mu, we have hard-coded CpuStackGuard to be TRUE in PEI phase, so we always set up a switch stack, clear the PRESENT bit in the page table for the guard page of the Boot Strap Processor stack, and build the page tables. However, the stack switch handlers will still only be installed in DXE phase if CpuStackGuard is TRUE.","title":"A note on SMM"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_5","text":"O(1) time and space. Setting: If TRUE, UEFI Stack Guard will be enabled.","title":"Overhead"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#how-to-set-the-memory-protection-policy","text":"For DXE settings, add the following to the platform DSC file: [ LibraryClasses . Common . DXE_DRIVER , LibraryClasses . Common . DXE_CORE , LibraryClasses . Common . UEFI_APPLICATION ] DxeMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / DxeMemoryProtectionHobLib . inf For MM settings, add the following to the platform DSC file if the platform utilizes SMM: [ LibraryClasses . common . SMM_CORE , LibraryClasses . common . DXE_SMM_DRIVER ] MmMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / SmmMemoryProtectionHobLib . inf or the following if the platform utilizes Standalone MM: [ LibraryClasses . common . MM_CORE_STANDALONE , LibraryClasses . common . MM_STANDALONE ] MmMemoryProtectionHobLib | MdeModulePkg / Library / MemoryProtectionHobLib / StandaloneMmMemoryProtectionHobLib . inf Create the HOB entry in any PEI module by adding the include: #include <Guid/DxeMemoryProtectionSettings.h> #include <Guid/MmMemoryProtectionSettings.h> and somewhere within the code doing something like: DXE_MEMORY_PROTECTION_SETTINGS DxeSettings ; MM_MEMORY_PROTECTION_SETTINGS MmSettings ; DxeSettings = ( DXE_MEMORY_PROTECTION_SETTINGS ) DXE_MEMORY_PROTECTION_SETTINGS_DEBUG ; MmSettings = ( MM_MEMORY_PROTECTION_SETTINGS ) MM_MEMORY_PROTECTION_SETTINGS_DEBUG ; BuildGuidDataHob ( & gDxeMemoryProtectionSettingsGuid , & DxeSettings , sizeof ( DxeSettings ) ); BuildGuidDataHob ( & gMmMemoryProtectionSettingsGuid , & MmSettings , sizeof ( MmSettings ) ); This will also require you to add gMemoryProtectionSettingsGuid under the Guids section in the relevant INF. If you want to deviate from one of the settings profile definitions in DxeMemoryProtectionSettings.h and/or MmMemoryProtectionSettings, it is recommended that you start with the one which most closely aligns with your desired settings and update from there in a manner similar to below: MmSettings . HeapGuardPolicy . Fields . MmPageGuard = 0 ; MmSettings . HeapGuardPolicy . Fields . MmPoolGuard = 0 ; DxeSettings . ImageProtectionPolicy . Fields . ProtectImageFromUnknown = 1 ; before building the HOB.","title":"How to Set the Memory Protection Policy"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/","text":"DeviceStateLib \u00b6 About \u00b6 The MsCorePkg provides the necessary functions to store platform specific device states. These device states can then be queried by any element within the boot environment to enable special code paths. In this library implementation a bitmask is stored in a PCD to signify what modes are active. The default bits in the bitmask are set in DeviceStateLib.h - but each platform is expected to implement its own header to define the platform specific device states or to define any of the unused bits: BIT 0: DEVICE_STATE_SECUREBOOT_OFF - UEFI Secure Boot disabled BIT 1: DEVICE_STATE_MANUFACTURING_MODE - Device is in an OEM defined manufacturing mode BIT 2: DEVICE_STATE_DEVELOPMENT_BUILD_ENABLED - Device is a development build. Non-production features might be enabled BIT 3: DEVICE_STATE_SOURCE_DEBUG_ENABLED - Source debug mode is enabled allowing a user to connect and control the device BIT 4: DEVICE_STATE_UNDEFINED - Set by the platform BIT 5: DEVICE_STATE_UNIT_TEST_MODE - Device has a unit test build. Some features are disabled to allow for unit tests in UEFI Shell BIT 24: DEVICE_STATE_PLATFORM_MODE_0 BIT 25: DEVICE_STATE_PLATFORM_MODE_1 BIT 26: DEVICE_STATE_PLATFORM_MODE_2 BIT 27: DEVICE_STATE_PLATFORM_MODE_3 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Device State Lib"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/#devicestatelib","text":"","title":"DeviceStateLib"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/#about","text":"The MsCorePkg provides the necessary functions to store platform specific device states. These device states can then be queried by any element within the boot environment to enable special code paths. In this library implementation a bitmask is stored in a PCD to signify what modes are active. The default bits in the bitmask are set in DeviceStateLib.h - but each platform is expected to implement its own header to define the platform specific device states or to define any of the unused bits: BIT 0: DEVICE_STATE_SECUREBOOT_OFF - UEFI Secure Boot disabled BIT 1: DEVICE_STATE_MANUFACTURING_MODE - Device is in an OEM defined manufacturing mode BIT 2: DEVICE_STATE_DEVELOPMENT_BUILD_ENABLED - Device is a development build. Non-production features might be enabled BIT 3: DEVICE_STATE_SOURCE_DEBUG_ENABLED - Source debug mode is enabled allowing a user to connect and control the device BIT 4: DEVICE_STATE_UNDEFINED - Set by the platform BIT 5: DEVICE_STATE_UNIT_TEST_MODE - Device has a unit test build. Some features are disabled to allow for unit tests in UEFI Shell BIT 24: DEVICE_STATE_PLATFORM_MODE_0 BIT 25: DEVICE_STATE_PLATFORM_MODE_1 BIT 26: DEVICE_STATE_PLATFORM_MODE_2 BIT 27: DEVICE_STATE_PLATFORM_MODE_3","title":"About"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/","text":"Summary \u00b6 UEFI Variable Policy spec aims to describe the DXE protocol interface which allows enforcing certain rules on certain UEFI variables. The protocol allows communication with the Variable Policy Engine which performs the policy enforcement. The Variable Policy is comprised of a set of policy entries which describe, per UEFI variable (identified by namespace GUID and variable name) the following rules: Required variable attributes Prohibited variable attributes Minimum variable size Maximum variable size Locking: Locking \"immediately\" Locking on creation Locking based on a state of another variable The spec assumes that the Variable Policy Engine runs in a trusted enclave, potentially off the main CPU that runs UEFI. For that reason, it is assumed that the Variable Policy Engine has no concept of UEFI events, and that the communication from the DXE driver to the trusted enclave is proprietary. At power-on, the Variable Policy Engine is: Enabled -- present policy entries are evaluated on variable access calls. Unlocked -- new policy entries can be registered. Policy is expected to be clear on power-on. Policy is volatile and not preserved across system reset. DXE Protocol \u00b6 typedef struct { UINT64 Revision; DISABLE_VARIABLE_POLICY DisableVariablePolicy; IS_VARIABLE_POLICY_ENABLED IsVariablePolicyEnabled; REGISTER_VARIABLE_POLICY RegisterVariablePolicy; DUMP_VARIABLE_POLICY DumpVariablePolicy; LOCK_VARIABLE_POLICY LockVariablePolicy; } _VARIABLE_POLICY_PROTOCOL; typedef _VARIABLE_POLICY_PROTOCOL VARIABLE_POLICY_PROTOCOL; extern EFI_GUID gVariablePolicyProtocolGuid; ## Include/Protocol/VariablePolicy.h gVariablePolicyProtocolGuid = { 0x81D1675C, 0x86F6, 0x48DF, { 0xBD, 0x95, 0x9A, 0x6E, 0x4F, 0x09, 0x25, 0xC3 } } DisableVariablePolicy \u00b6 Function prototype: EFI_STATUS EFIAPI DisableVariablePolicy ( VOID ); DisableVariablePolicy call disables the Variable Policy Engine, so that the present policy entries are no longer taken into account on variable access calls. This call effectively turns off the variable policy verification for this boot. This also disables UEFI Authenticated Variable protections including Secure Boot. DisableVariablePolicy can only be called once during boot. If called more than once, it will return EFI_ALREADY_STARTED . Note, this process is irreversible until the next system reset -- there is no \"EnablePolicy\" protocol function. IMPORTANT NOTE: It is strongly recommended that VariablePolicy NEVER be disabled in \"normal, production boot conditions\". It is expected to always be enforced. The most likely reasons to disable are for Manufacturing and Refurbishing scenarios. If in doubt, leave the gEfiMdeModulePkgTokenSpaceGuid.PcdAllowVariablePolicyEnforcementDisable PCD set to FALSE and VariablePolicy will always be enabled. IsVariablePolicyEnabled \u00b6 Function prototype: EFI_STATUS EFIAPI IsVariablePolicyEnabled ( OUT BOOLEAN * State ); IsVariablePolicyEnabled accepts a pointer to a Boolean in which it will store TRUE if Variable Policy Engine is enabled, or FALSE if Variable Policy Engine is disabled. The function returns EFI_SUCCESS . RegisterVariablePolicy \u00b6 Function prototype: EFI_STATUS EFIAPI RegisterVariablePolicy ( IN CONST VARIABLE_POLICY_ENTRY * PolicyEntry ); RegisterVariablePolicy call accepts a pointer to a policy entry structure and returns the status of policy registration. If the Variable Policy Engine is not locked and the policy structures are valid, the function will return EFI_SUCCESS . If the Variable Policy Engine is locked, RegisterVariablePolicy call will return EFI_WRITE_PROTECTED and will not register the policy entry. Bulk registration is not supported at this time due to the requirements around error handling on each policy registration. Upon successful registration of a policy entry, Variable Policy Engine will then evaluate this entry on subsequent variable access calls (as long as Variable Policy Engine hasn't been disabled). DumpVariablePolicy \u00b6 Function prototype: EFI_STATUS EFIAPI DumpVariablePolicy ( OUT UINT8 * Policy , IN OUT UINT32 * Size ); DumpVariablePolicy call accepts a pointer to a buffer and a pointer to the size of the buffer as parameters and returns the status of placing the policy into the buffer. On first call to DumpVariablePolicy one should pass NULL as the buffer and a pointer to 0 as the Size variable and DumpVariablePolicy will return EFI_BUFFER_TOO_SMALL and will populate the Size parameter with the size of the needed buffer to store the policy. This way, the caller can allocate the buffer of correct size and call DumpVariablePolicy again. The function will populate the buffer with policy and return EFI_SUCCESS . LockVariablePolicy \u00b6 Function prototype: EFI_STATUS EFIAPI LockVariablePolicy ( VOID ); LockVariablePolicy locks the Variable Policy Engine, i.e. prevents any new policy entries from getting registered in this boot ( RegisterVariablePolicy calls will fail with EFI_WRITE_PROTECTED status code returned). Policy Structure \u00b6 The structure below is meant for the DXE protocol calling interface, when communicating to the Variable Policy Engine, thus the pragma pack directive. How these policies are stored in memory is up to the implementation. #pragma pack(1) typedef struct { UINT32 Version ; UINT16 Size ; UINT16 OffsetToName ; EFI_GUID Namespace ; UINT32 MinSize ; UINT32 MaxSize ; UINT32 AttributesMustHave ; UINT32 AttributesCantHave ; UINT8 LockPolicyType ; UINT8 Reserved [ 3 ]; // UINT8 LockPolicy[]; // Variable Length Field // CHAR16 Name[]; // Variable Length Field } VARIABLE_POLICY_ENTRY ; The struct VARIABLE_POLICY_ENTRY above describes the layout for a policy entry. The first element, Size , is the size of the policy entry, then followed by OffsetToName -- the number of bytes from the beginning of the struct to the name of the UEFI variable targeted by the policy entry. The name can contain wildcards to match more than one variable, more on this in the Wildcards section. The rest of the struct elements are self-explanatory. #define VARIABLE_POLICY_TYPE_NO_LOCK 0 #define VARIABLE_POLICY_TYPE_LOCK_NOW 1 #define VARIABLE_POLICY_TYPE_LOCK_ON_CREATE 2 #define VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE 3 LockPolicyType can have the following values: VARIABLE_POLICY_TYPE_NO_LOCK -- means that no variable locking is performed. However, the attribute and size constraints are still enforced. LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_NOW -- means that the variable starts being locked immediately after policy entry registration. If the variable doesn't exist at this point, being LockedNow means it cannot be created on this boot. LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_ON_CREATE -- means that the variable starts being locked after it is created. This allows for variable creation and protection after LockVariablePolicy() function has been called. The LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE -- means that the Variable Policy Engine will examine the state/contents of another variable to determine if the variable referenced in the policy entry is locked. typedef struct { EFI_GUID Namespace ; UINT8 Value ; UINT8 Reserved ; // CHAR16 Name[]; // Variable Length Field } VARIABLE_LOCK_ON_VAR_STATE_POLICY ; If LockPolicyType is VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE , then the final element in the policy entry struct is of type VARIABLE_LOCK_ON_VAR_STATE_POLICY , which lists the namespace GUID, name (no wildcards here), and value of the variable which state determines the locking of the variable referenced in the policy entry. The \"locking\" variable must be 1 byte in terms of payload size. If the Referenced variable contents match the Value of the VARIABLE_LOCK_ON_VAR_STATE_POLICY structure, the lock will be considered active and the target variable will be locked. If the Reference variable does not exist (ie. returns EFI_NOT_FOUND ), this policy will be considered inactive. Variable Name Wildcards \u00b6 Two types of wildcards can be used in the UEFI variable name field in a policy entry: If the Name is a zero-length array (easily checked by comparing fields Size and OffsetToName -- if they're the same, then the Name is zero-length), then all variables in the namespace specified by the provided GUID are targeted by the policy entry. Character \"#\" in the Name corresponds to one numeric character (0-9, A-F, a-f). For example, string \"Boot####\" in the Name field of the policy entry will make it so that the policy entry will target variables named \"Boot0001\", \"Boot0002\", etc. Given the above two types of wildcards, one variable can be targeted by more than one policy entry, thus there is a need to establish the precedence rule: a more specific match is applied. When a variable access operation is performed, Variable Policy Engine should first check the variable being accessed against the policy entries without wildcards, then with 1 wildcard, then with 2 wildcards, etc., followed in the end by policy entries that match the whole namespace. One can still imagine a situation where two policy entries with the same number of wildcards match the same variable -- for example, policy entries with Names \"Boot00##\" and \"Boot##01\" will both match variable \"Boot0001\". Such situation can (and should) be avoided by designing mutually exclusive Name strings with wildcards, however, if it occurs, then the policy entry that was registered first will be used. After the most specific match is selected, all other policies are ignored. Available Testing \u00b6 This functionality is current supported by two kinds of tests: there is a host-based unit test for the core business logic (this test accompanies the VariablePolicyLib implementation that lives in MdeModulePkg/Library ) and there is a functional test for the protocol and its interfaces (this test lives in the MdeModulePkg/Test/ShellTest directory). Host-Based Unit Test \u00b6 MU_CHANGE This test: MdeModulePkg\\Library\\VariablePolicyLib\\VariablePolicyUnitTest\\VariablePolicyUnitTest.inf can be run as part of the Host-Based Unit Testing infrastructure provided by EDK2 PyTools (documented elsewhere). It will test all internal guarantees and is where you will find test cases for most of the policy matching and security of the Variable Policy Engine. Shell-Based Functional Test \u00b6 This test -- Variable Policy Functional Unit Test -- can be built as a UEFI Shell application and run to validate that the Variable Policy Engine is correctly installed and enforcing policies on the target system. NOTE: This test must be run prior to calling DisableVariablePolicy for all test cases to pass. For this reason, it is recommended to run this on a test-built FW for complete results, and then again on a production-built FW for release results. Use Cases \u00b6 The below examples are hypothetical scenarios based on real-world requirements that demonstrate how Variable Policies could be constructed to solve various problems. UEFI Setup Variables (Example 1) \u00b6 Variables containing values of the setup options exposed via UEFI menu (setup variables). These would be locked based on a state of another variable, \"ReadyToBoot\", which would be set to 1 at the ReadyToBoot event. Thus, the policy for the setup variables would be of type LockOnVarState , with the \"ReadyToBoot\" listed as the name of the variable, appropriate GUID listed as the namespace, and 1 as value. Entry into the trusted UEFI menu app doesn't signal ReadyToBoot, but booting to any device does, and the setup variables are write-protected. The \"ReadyToBoot\" variable would need to be locked-on-create. (THIS IS ESSENTIALLY LOCK ON EVENT, BUT SINCE THE POLICY ENGINE IS NOT IN THE UEFI ENVIRONMENT VARIABLES ARE USED) For example, \"AllowPXEBoot\" variable locked by \"ReadyToBoot\" variable. (NOTE: In the below example, the emphasized fields ('Namespace', 'Value', and 'Name') are members of the VARIABLE_LOCK_ON_VAR_STATE_POLICY structure.) Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE Namespace ... Value 1 Name \"ReadyToBoot\" //Name \"AllowPXEBoot\" Manufacturing VPD (Example 2) \u00b6 Manufacturing Variable Provisioning Data (VPD) is stored in variables and is created while in Manufacturing (MFG) Mode. In MFG Mode Variable Policy Engine is disabled, thus these VPD variables can be created. These variables are locked with lock policy type LockNow , so that these variables can't be tampered with in Customer Mode. To overwrite or clear VPD, the device would need to MFG mode, which is standard practice for refurbishing/remanufacturing scenarios. Example: \"DisplayPanelCalibration\" variable... Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_NOW // Name \"DisplayPanelCalibration\" 3 rd Party Calibration Data (Example 3) \u00b6 Bluetooth pre-pairing variables are locked-on-create because these get created by an OS application when Variable Policy is in effect. Example: \"KeyboardBTPairing\" variable Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_CREATE // Name \"KeyboardBTPairing\" Software-based Variable Policy (Example 4) \u00b6 Example: \"Boot####\" variables (a name string with wildcards that will match variables \"Boot0000\" to \"BootFFFF\") locked by \"LockBootOrder\" variable. Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE Namespace ... Value 1 Name \"LockBootOrder\" //Name \"Boot####\"","title":"Variable Policy Lib"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#summary","text":"UEFI Variable Policy spec aims to describe the DXE protocol interface which allows enforcing certain rules on certain UEFI variables. The protocol allows communication with the Variable Policy Engine which performs the policy enforcement. The Variable Policy is comprised of a set of policy entries which describe, per UEFI variable (identified by namespace GUID and variable name) the following rules: Required variable attributes Prohibited variable attributes Minimum variable size Maximum variable size Locking: Locking \"immediately\" Locking on creation Locking based on a state of another variable The spec assumes that the Variable Policy Engine runs in a trusted enclave, potentially off the main CPU that runs UEFI. For that reason, it is assumed that the Variable Policy Engine has no concept of UEFI events, and that the communication from the DXE driver to the trusted enclave is proprietary. At power-on, the Variable Policy Engine is: Enabled -- present policy entries are evaluated on variable access calls. Unlocked -- new policy entries can be registered. Policy is expected to be clear on power-on. Policy is volatile and not preserved across system reset.","title":"Summary"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#dxe-protocol","text":"typedef struct { UINT64 Revision; DISABLE_VARIABLE_POLICY DisableVariablePolicy; IS_VARIABLE_POLICY_ENABLED IsVariablePolicyEnabled; REGISTER_VARIABLE_POLICY RegisterVariablePolicy; DUMP_VARIABLE_POLICY DumpVariablePolicy; LOCK_VARIABLE_POLICY LockVariablePolicy; } _VARIABLE_POLICY_PROTOCOL; typedef _VARIABLE_POLICY_PROTOCOL VARIABLE_POLICY_PROTOCOL; extern EFI_GUID gVariablePolicyProtocolGuid; ## Include/Protocol/VariablePolicy.h gVariablePolicyProtocolGuid = { 0x81D1675C, 0x86F6, 0x48DF, { 0xBD, 0x95, 0x9A, 0x6E, 0x4F, 0x09, 0x25, 0xC3 } }","title":"DXE Protocol"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#disablevariablepolicy","text":"Function prototype: EFI_STATUS EFIAPI DisableVariablePolicy ( VOID ); DisableVariablePolicy call disables the Variable Policy Engine, so that the present policy entries are no longer taken into account on variable access calls. This call effectively turns off the variable policy verification for this boot. This also disables UEFI Authenticated Variable protections including Secure Boot. DisableVariablePolicy can only be called once during boot. If called more than once, it will return EFI_ALREADY_STARTED . Note, this process is irreversible until the next system reset -- there is no \"EnablePolicy\" protocol function. IMPORTANT NOTE: It is strongly recommended that VariablePolicy NEVER be disabled in \"normal, production boot conditions\". It is expected to always be enforced. The most likely reasons to disable are for Manufacturing and Refurbishing scenarios. If in doubt, leave the gEfiMdeModulePkgTokenSpaceGuid.PcdAllowVariablePolicyEnforcementDisable PCD set to FALSE and VariablePolicy will always be enabled.","title":"DisableVariablePolicy"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#isvariablepolicyenabled","text":"Function prototype: EFI_STATUS EFIAPI IsVariablePolicyEnabled ( OUT BOOLEAN * State ); IsVariablePolicyEnabled accepts a pointer to a Boolean in which it will store TRUE if Variable Policy Engine is enabled, or FALSE if Variable Policy Engine is disabled. The function returns EFI_SUCCESS .","title":"IsVariablePolicyEnabled"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#registervariablepolicy","text":"Function prototype: EFI_STATUS EFIAPI RegisterVariablePolicy ( IN CONST VARIABLE_POLICY_ENTRY * PolicyEntry ); RegisterVariablePolicy call accepts a pointer to a policy entry structure and returns the status of policy registration. If the Variable Policy Engine is not locked and the policy structures are valid, the function will return EFI_SUCCESS . If the Variable Policy Engine is locked, RegisterVariablePolicy call will return EFI_WRITE_PROTECTED and will not register the policy entry. Bulk registration is not supported at this time due to the requirements around error handling on each policy registration. Upon successful registration of a policy entry, Variable Policy Engine will then evaluate this entry on subsequent variable access calls (as long as Variable Policy Engine hasn't been disabled).","title":"RegisterVariablePolicy"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#dumpvariablepolicy","text":"Function prototype: EFI_STATUS EFIAPI DumpVariablePolicy ( OUT UINT8 * Policy , IN OUT UINT32 * Size ); DumpVariablePolicy call accepts a pointer to a buffer and a pointer to the size of the buffer as parameters and returns the status of placing the policy into the buffer. On first call to DumpVariablePolicy one should pass NULL as the buffer and a pointer to 0 as the Size variable and DumpVariablePolicy will return EFI_BUFFER_TOO_SMALL and will populate the Size parameter with the size of the needed buffer to store the policy. This way, the caller can allocate the buffer of correct size and call DumpVariablePolicy again. The function will populate the buffer with policy and return EFI_SUCCESS .","title":"DumpVariablePolicy"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#lockvariablepolicy","text":"Function prototype: EFI_STATUS EFIAPI LockVariablePolicy ( VOID ); LockVariablePolicy locks the Variable Policy Engine, i.e. prevents any new policy entries from getting registered in this boot ( RegisterVariablePolicy calls will fail with EFI_WRITE_PROTECTED status code returned).","title":"LockVariablePolicy"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#policy-structure","text":"The structure below is meant for the DXE protocol calling interface, when communicating to the Variable Policy Engine, thus the pragma pack directive. How these policies are stored in memory is up to the implementation. #pragma pack(1) typedef struct { UINT32 Version ; UINT16 Size ; UINT16 OffsetToName ; EFI_GUID Namespace ; UINT32 MinSize ; UINT32 MaxSize ; UINT32 AttributesMustHave ; UINT32 AttributesCantHave ; UINT8 LockPolicyType ; UINT8 Reserved [ 3 ]; // UINT8 LockPolicy[]; // Variable Length Field // CHAR16 Name[]; // Variable Length Field } VARIABLE_POLICY_ENTRY ; The struct VARIABLE_POLICY_ENTRY above describes the layout for a policy entry. The first element, Size , is the size of the policy entry, then followed by OffsetToName -- the number of bytes from the beginning of the struct to the name of the UEFI variable targeted by the policy entry. The name can contain wildcards to match more than one variable, more on this in the Wildcards section. The rest of the struct elements are self-explanatory. #define VARIABLE_POLICY_TYPE_NO_LOCK 0 #define VARIABLE_POLICY_TYPE_LOCK_NOW 1 #define VARIABLE_POLICY_TYPE_LOCK_ON_CREATE 2 #define VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE 3 LockPolicyType can have the following values: VARIABLE_POLICY_TYPE_NO_LOCK -- means that no variable locking is performed. However, the attribute and size constraints are still enforced. LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_NOW -- means that the variable starts being locked immediately after policy entry registration. If the variable doesn't exist at this point, being LockedNow means it cannot be created on this boot. LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_ON_CREATE -- means that the variable starts being locked after it is created. This allows for variable creation and protection after LockVariablePolicy() function has been called. The LockPolicy field is size 0. VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE -- means that the Variable Policy Engine will examine the state/contents of another variable to determine if the variable referenced in the policy entry is locked. typedef struct { EFI_GUID Namespace ; UINT8 Value ; UINT8 Reserved ; // CHAR16 Name[]; // Variable Length Field } VARIABLE_LOCK_ON_VAR_STATE_POLICY ; If LockPolicyType is VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE , then the final element in the policy entry struct is of type VARIABLE_LOCK_ON_VAR_STATE_POLICY , which lists the namespace GUID, name (no wildcards here), and value of the variable which state determines the locking of the variable referenced in the policy entry. The \"locking\" variable must be 1 byte in terms of payload size. If the Referenced variable contents match the Value of the VARIABLE_LOCK_ON_VAR_STATE_POLICY structure, the lock will be considered active and the target variable will be locked. If the Reference variable does not exist (ie. returns EFI_NOT_FOUND ), this policy will be considered inactive.","title":"Policy Structure"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#variable-name-wildcards","text":"Two types of wildcards can be used in the UEFI variable name field in a policy entry: If the Name is a zero-length array (easily checked by comparing fields Size and OffsetToName -- if they're the same, then the Name is zero-length), then all variables in the namespace specified by the provided GUID are targeted by the policy entry. Character \"#\" in the Name corresponds to one numeric character (0-9, A-F, a-f). For example, string \"Boot####\" in the Name field of the policy entry will make it so that the policy entry will target variables named \"Boot0001\", \"Boot0002\", etc. Given the above two types of wildcards, one variable can be targeted by more than one policy entry, thus there is a need to establish the precedence rule: a more specific match is applied. When a variable access operation is performed, Variable Policy Engine should first check the variable being accessed against the policy entries without wildcards, then with 1 wildcard, then with 2 wildcards, etc., followed in the end by policy entries that match the whole namespace. One can still imagine a situation where two policy entries with the same number of wildcards match the same variable -- for example, policy entries with Names \"Boot00##\" and \"Boot##01\" will both match variable \"Boot0001\". Such situation can (and should) be avoided by designing mutually exclusive Name strings with wildcards, however, if it occurs, then the policy entry that was registered first will be used. After the most specific match is selected, all other policies are ignored.","title":"Variable Name Wildcards"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#available-testing","text":"This functionality is current supported by two kinds of tests: there is a host-based unit test for the core business logic (this test accompanies the VariablePolicyLib implementation that lives in MdeModulePkg/Library ) and there is a functional test for the protocol and its interfaces (this test lives in the MdeModulePkg/Test/ShellTest directory).","title":"Available Testing"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#host-based-unit-test","text":"MU_CHANGE This test: MdeModulePkg\\Library\\VariablePolicyLib\\VariablePolicyUnitTest\\VariablePolicyUnitTest.inf can be run as part of the Host-Based Unit Testing infrastructure provided by EDK2 PyTools (documented elsewhere). It will test all internal guarantees and is where you will find test cases for most of the policy matching and security of the Variable Policy Engine.","title":"Host-Based Unit Test"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#shell-based-functional-test","text":"This test -- Variable Policy Functional Unit Test -- can be built as a UEFI Shell application and run to validate that the Variable Policy Engine is correctly installed and enforcing policies on the target system. NOTE: This test must be run prior to calling DisableVariablePolicy for all test cases to pass. For this reason, it is recommended to run this on a test-built FW for complete results, and then again on a production-built FW for release results.","title":"Shell-Based Functional Test"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#use-cases","text":"The below examples are hypothetical scenarios based on real-world requirements that demonstrate how Variable Policies could be constructed to solve various problems.","title":"Use Cases"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#uefi-setup-variables-example-1","text":"Variables containing values of the setup options exposed via UEFI menu (setup variables). These would be locked based on a state of another variable, \"ReadyToBoot\", which would be set to 1 at the ReadyToBoot event. Thus, the policy for the setup variables would be of type LockOnVarState , with the \"ReadyToBoot\" listed as the name of the variable, appropriate GUID listed as the namespace, and 1 as value. Entry into the trusted UEFI menu app doesn't signal ReadyToBoot, but booting to any device does, and the setup variables are write-protected. The \"ReadyToBoot\" variable would need to be locked-on-create. (THIS IS ESSENTIALLY LOCK ON EVENT, BUT SINCE THE POLICY ENGINE IS NOT IN THE UEFI ENVIRONMENT VARIABLES ARE USED) For example, \"AllowPXEBoot\" variable locked by \"ReadyToBoot\" variable. (NOTE: In the below example, the emphasized fields ('Namespace', 'Value', and 'Name') are members of the VARIABLE_LOCK_ON_VAR_STATE_POLICY structure.) Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE Namespace ... Value 1 Name \"ReadyToBoot\" //Name \"AllowPXEBoot\"","title":"UEFI Setup Variables (Example 1)"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#manufacturing-vpd-example-2","text":"Manufacturing Variable Provisioning Data (VPD) is stored in variables and is created while in Manufacturing (MFG) Mode. In MFG Mode Variable Policy Engine is disabled, thus these VPD variables can be created. These variables are locked with lock policy type LockNow , so that these variables can't be tampered with in Customer Mode. To overwrite or clear VPD, the device would need to MFG mode, which is standard practice for refurbishing/remanufacturing scenarios. Example: \"DisplayPanelCalibration\" variable... Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_NOW // Name \"DisplayPanelCalibration\"","title":"Manufacturing VPD (Example 2)"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#3rd-party-calibration-data-example-3","text":"Bluetooth pre-pairing variables are locked-on-create because these get created by an OS application when Variable Policy is in effect. Example: \"KeyboardBTPairing\" variable Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_CREATE // Name \"KeyboardBTPairing\"","title":"3rd Party Calibration Data (Example 3)"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#software-based-variable-policy-example-4","text":"Example: \"Boot####\" variables (a name string with wildcards that will match variables \"Boot0000\" to \"BootFFFF\") locked by \"LockBootOrder\" variable. Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE Namespace ... Value 1 Name \"LockBootOrder\" //Name \"Boot####\"","title":"Software-based Variable Policy (Example 4)"},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/","text":"Variable Policy Unit Tests \u00b6 \ud83d\udd39 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About This Test \u00b6 This test verifies functionality of the Variable Policy Protocol by registering various variable policies and exercising them, as well as tests locking the policy, disabling it, and dumping the policy entries. Only policies that are created as a part of this test will be tested. Try getting test context, if empty then get VP protocol, confirm that VP is not disabled by calling IsVariablePolicyEnabled. Log VP revision. \"No lock\" policies: check minsize enforcement check maxsize enforcement check musthave attr enforcement check canthave attr enforcement check one of the above with empty string policy i.e. name wildcard check another one of the above with a \"#\" containing policy string check policy prioritization by having a namespace-wide policy, a policy with a # wildcard, and a one-var specific policy and testing which one is enforced \"Lock now\" policies (means if the var doesn't exist, it won't be created; if one exists, it can't be updated): test a policy for an already existing variable, verify we can't write into that variable create a policy for a non-existing variable and attempt to register such var \"Lock on create\" policies (means the var can still be created, but no updates later, existing vars can't be updated): create a var, lock it with LockOnCreate, attempt to update its contents create LockOnCreate VP, attempt to create var with invalid size, then invalid attr, then create valid var, attempt to update its contents \"Lock on var state\" policies (means the var protected by this policy can't be created or updated once the trigger is set) create VP, trigger lock with a valid var, attempt to create a locked var, then modify the trigger var, create locked var create VP, create targeted var, modify it, trigger lock, attempt to modify var create VP, trigger lock with invalid (larger than one byte) var, see if VPE allows creation of the locked var (it should allow) create VP, set locking var with wrong value, see if VPE allows creation of the locked var (should allow) Attempt registering invalid policy entries invalid required and banned attributes large min size - let's say 2GB max size equal to 0 invalid policy type Exercise dumping policy. No need to check the validity of the dump blob. Test registering a policy with a random version. Lock VPE, make sure old policies are enforced, new ones can't be registered. Register a LockOnCreate policy Lock VPE Test locking it again. Verify one of the prior policies is enforced Make sure we can create variables even if those are protected by LockOnCreate policy, after locking the VPE Attempt to register new policies Make sure can't disable VPE Cleanup: save context and reboot Disable variable policy and try some things Locate Variable Policy Protocol Make sure VP is enabled Register a policy Disable VPE Call IsVariablePolicyEnabled to confirm it's disabled. Make sure can't lock policy Make sure the policy from a is no longer enforced Final cleanup: delete vars that were created in some earlier test suites","title":"Variable Policy Func Test App"},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/#variable-policy-unit-tests","text":"","title":"Variable Policy Unit Tests"},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"&#x1F539; Copyright"},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/#about-this-test","text":"This test verifies functionality of the Variable Policy Protocol by registering various variable policies and exercising them, as well as tests locking the policy, disabling it, and dumping the policy entries. Only policies that are created as a part of this test will be tested. Try getting test context, if empty then get VP protocol, confirm that VP is not disabled by calling IsVariablePolicyEnabled. Log VP revision. \"No lock\" policies: check minsize enforcement check maxsize enforcement check musthave attr enforcement check canthave attr enforcement check one of the above with empty string policy i.e. name wildcard check another one of the above with a \"#\" containing policy string check policy prioritization by having a namespace-wide policy, a policy with a # wildcard, and a one-var specific policy and testing which one is enforced \"Lock now\" policies (means if the var doesn't exist, it won't be created; if one exists, it can't be updated): test a policy for an already existing variable, verify we can't write into that variable create a policy for a non-existing variable and attempt to register such var \"Lock on create\" policies (means the var can still be created, but no updates later, existing vars can't be updated): create a var, lock it with LockOnCreate, attempt to update its contents create LockOnCreate VP, attempt to create var with invalid size, then invalid attr, then create valid var, attempt to update its contents \"Lock on var state\" policies (means the var protected by this policy can't be created or updated once the trigger is set) create VP, trigger lock with a valid var, attempt to create a locked var, then modify the trigger var, create locked var create VP, create targeted var, modify it, trigger lock, attempt to modify var create VP, trigger lock with invalid (larger than one byte) var, see if VPE allows creation of the locked var (it should allow) create VP, set locking var with wrong value, see if VPE allows creation of the locked var (should allow) Attempt registering invalid policy entries invalid required and banned attributes large min size - let's say 2GB max size equal to 0 invalid policy type Exercise dumping policy. No need to check the validity of the dump blob. Test registering a policy with a random version. Lock VPE, make sure old policies are enforced, new ones can't be registered. Register a LockOnCreate policy Lock VPE Test locking it again. Verify one of the prior policies is enforced Make sure we can create variables even if those are protected by LockOnCreate policy, after locking the VPE Attempt to register new policies Make sure can't disable VPE Cleanup: save context and reboot Disable variable policy and try some things Locate Variable Policy Protocol Make sure VP is enabled Register a policy Disable VPE Call IsVariablePolicyEnabled to confirm it's disabled. Make sure can't lock policy Make sure the policy from a is no longer enforced Final cleanup: delete vars that were created in some earlier test suites","title":"About This Test"},{"location":"dyn/mu_basecore/MdePkg/Library/FltUsedLib/Readme/","text":"FltUsedLib \u00b6 This library provides a global (fltused) that needs to be defined anywhere floating point operations are used. The C compiler produces the _fltused symbol by default, this is just to satisfy the linker. Using \u00b6 To use FltUsedLib, just include it in the INF of the module that uses floating point. [LibraryClasses] BaseLib BaseMemoryLib FltUsedLib","title":"Flt Used Lib"},{"location":"dyn/mu_basecore/MdePkg/Library/FltUsedLib/Readme/#fltusedlib","text":"This library provides a global (fltused) that needs to be defined anywhere floating point operations are used. The C compiler produces the _fltused symbol by default, this is just to satisfy the linker.","title":"FltUsedLib"},{"location":"dyn/mu_basecore/MdePkg/Library/FltUsedLib/Readme/#using","text":"To use FltUsedLib, just include it in the INF of the module that uses floating point. [LibraryClasses] BaseLib BaseMemoryLib FltUsedLib","title":"Using"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/","text":"Memory Attribute Protocol UEFI shell functional Test \u00b6 \ud83d\udd39 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Attribution \u00b6 This test is a modified version of https://github.com/jyao1/edk2/commit/5828d4c755658eba06d838edee9a7b4d72a9f8b3 . About This Test \u00b6 Tests does basic verification of the Memory Attribute Protocol Make sure protocol exists Basic \"good path\" usage of Get/Clear/Set functions Get Attributes of a newly allocated EfiLoaderCode buffer Verify Attributes of running code (this test code)","title":"Memory Attribute Protocol Func Test App"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#memory-attribute-protocol-uefi-shell-functional-test","text":"","title":"Memory Attribute Protocol UEFI shell functional Test"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"&#x1F539; Copyright"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#attribution","text":"This test is a modified version of https://github.com/jyao1/edk2/commit/5828d4c755658eba06d838edee9a7b4d72a9f8b3 .","title":"Attribution"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#about-this-test","text":"Tests does basic verification of the Memory Attribute Protocol Make sure protocol exists Basic \"good path\" usage of Get/Clear/Set functions Get Attributes of a newly allocated EfiLoaderCode buffer Verify Attributes of running code (this test code)","title":"About This Test"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/","text":"SharedNetworking \u00b6 Similar to SharedCrypto ( https://github.com/microsoft/mu_plus/tree/release/201911/SharedCryptoPkg ), SharedNetworking is a collection of pre-built network binaries you can include in your platform or other EDK2 project. SharedNetworking requires SharedCrypto for BaseCryptLib functionality (this only applies to TlsLib and IScsiDxe) The build script for this (SharedNetworkSettings.py) pulls in MU_PLUS as it has a dependency on SharedCrypto (which currently resides in MU_PLUS). This is temporary and will not carry forward to 202002. It also doesn't apply to the remainder of Basecore or CI. The dependency is only pulled in when build SharedNetworking itself, which doesn't happen often. Advantages \u00b6 Faster Compile Times Potentially smaller binary sizes (depending on compression and a variety of other factors) Easier to update and service since network binaries are packaged in an FV. Including it in your project \u00b6 Just !include the SharedNetworking.fdf.inc as the example below shows: [FV.FVDXE] ... !include NetworkPkg/SharedNetworking.fdf.inc","title":"README"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/#sharednetworking","text":"Similar to SharedCrypto ( https://github.com/microsoft/mu_plus/tree/release/201911/SharedCryptoPkg ), SharedNetworking is a collection of pre-built network binaries you can include in your platform or other EDK2 project. SharedNetworking requires SharedCrypto for BaseCryptLib functionality (this only applies to TlsLib and IScsiDxe) The build script for this (SharedNetworkSettings.py) pulls in MU_PLUS as it has a dependency on SharedCrypto (which currently resides in MU_PLUS). This is temporary and will not carry forward to 202002. It also doesn't apply to the remainder of Basecore or CI. The dependency is only pulled in when build SharedNetworking itself, which doesn't happen often.","title":"SharedNetworking"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/#advantages","text":"Faster Compile Times Potentially smaller binary sizes (depending on compression and a variety of other factors) Easier to update and service since network binaries are packaged in an FV.","title":"Advantages"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/#including-it-in-your-project","text":"Just !include the SharedNetworking.fdf.inc as the example below shows: [FV.FVDXE] ... !include NetworkPkg/SharedNetworking.fdf.inc","title":"Including it in your project"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/","text":"Shared Networking DXE \u00b6 What is it \u00b6 Shared Networking is a packaged versions of networking components from EDK II. Similar to SharedCrypto (see the SharedCryptoPkg), it precompiles certain components and allows them to be included in a platform without having to build the underlying library. How it works \u00b6 Since many parts of the network simply publish a protocol (like TlsDxe), it was fairly trivial to compile that into an EFI. This EFI is then downloaded via a NuGet External Dependency (see SharedNetworking_ext_dep.json). Versions are modified in a similar way to SharedCrypto. Versioning \u00b6 A typical version consists of 4 numbers. The year, the month of the EDK II release, the revision number, and the build number. An example of this would be 2019.03.02.01 , which would translate to EDK II 1903 release, the second revision and the first build. This means that there were two code changes within 1903 (either in BaseCryptLib or OpenSSL). Release notes will be provided on the NuGet package page and on this repo. Build numbers are reved whenever there needs to be a recompiled binary due to a mistake on our part or a build flag is tweaked. How to use it \u00b6 There are two ways to use SharedNetworking. For first way is to use the FV, which contains all the networking components needed. The second is to replace individual components with INF's. DSC/INF way \u00b6 Including it in your platform is easy peezy lemon squeezy. In fact, you only need three changes. In the example below we show X64, which happens to correspond with DXE but that could easily be changed. Look at your platform for where Networking is already defined. One thing to note is that each binary is released for two targets, RELEASE and DEBUG. Make sure to include the right INF. DSC Changes \u00b6 Parts need to be replaced on a compoenent by component basis. For example, here is how to move over TlsDxe. You need to remove the reference to TLSLib since we no longer need it (the only consumer is TlsDxe). Then switch the component to the Shared version of TLS. It looks like this: [LibraryClasses.X64] #TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf # remove this line [Components.X64] NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf FDF Changes \u00b6 [FV.FVDXE] INF NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf # Shared_TLS instead of TlsDxe ... FV way \u00b6 This way is still under development, so it maybe subject to change. In your FDF, add these lines. [FV.FVDXE] FILE FV_IMAGE = {GUID} { SECTION FV_IMAGE = NetworkPkg/SharedNetworking/Mu-SharedNetworking_extdep/$(TARGET)/{ARCH of your platform}/FVDXE.fv # Shared_Networking SECTION UI = \"SharedNetworking\" } With {GUID} being a guid you generated. We use E205F779-07E3-4B64-A2E2-EEDE717B0F59. {Arch of your platform} being the platform you're using. We currently support IA32, X64, and AARCH64. as supposered values You'll also need to remove the networking components that were already in your FDF. Why to Use SharedNetworking \u00b6 Depending on your platform, it could net you some small space savings depending on your linker. The main advantage is that when used with SharedCrypto, you can remove the need to compile OpenSSL, reducing compile times. Questions \u00b6 If you have any questions about anything in this package or the universe in general, feel free to comment on our Github or contact the Project Mu team.","title":"Shared Networking"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#shared-networking-dxe","text":"","title":"Shared Networking DXE"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#what-is-it","text":"Shared Networking is a packaged versions of networking components from EDK II. Similar to SharedCrypto (see the SharedCryptoPkg), it precompiles certain components and allows them to be included in a platform without having to build the underlying library.","title":"What is it"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#how-it-works","text":"Since many parts of the network simply publish a protocol (like TlsDxe), it was fairly trivial to compile that into an EFI. This EFI is then downloaded via a NuGet External Dependency (see SharedNetworking_ext_dep.json). Versions are modified in a similar way to SharedCrypto.","title":"How it works"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#versioning","text":"A typical version consists of 4 numbers. The year, the month of the EDK II release, the revision number, and the build number. An example of this would be 2019.03.02.01 , which would translate to EDK II 1903 release, the second revision and the first build. This means that there were two code changes within 1903 (either in BaseCryptLib or OpenSSL). Release notes will be provided on the NuGet package page and on this repo. Build numbers are reved whenever there needs to be a recompiled binary due to a mistake on our part or a build flag is tweaked.","title":"Versioning"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#how-to-use-it","text":"There are two ways to use SharedNetworking. For first way is to use the FV, which contains all the networking components needed. The second is to replace individual components with INF's.","title":"How to use it"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#dscinf-way","text":"Including it in your platform is easy peezy lemon squeezy. In fact, you only need three changes. In the example below we show X64, which happens to correspond with DXE but that could easily be changed. Look at your platform for where Networking is already defined. One thing to note is that each binary is released for two targets, RELEASE and DEBUG. Make sure to include the right INF.","title":"DSC/INF way"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#dsc-changes","text":"Parts need to be replaced on a compoenent by component basis. For example, here is how to move over TlsDxe. You need to remove the reference to TLSLib since we no longer need it (the only consumer is TlsDxe). Then switch the component to the Shared version of TLS. It looks like this: [LibraryClasses.X64] #TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf # remove this line [Components.X64] NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf","title":"DSC Changes"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#fdf-changes","text":"[FV.FVDXE] INF NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf # Shared_TLS instead of TlsDxe ...","title":"FDF Changes"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#fv-way","text":"This way is still under development, so it maybe subject to change. In your FDF, add these lines. [FV.FVDXE] FILE FV_IMAGE = {GUID} { SECTION FV_IMAGE = NetworkPkg/SharedNetworking/Mu-SharedNetworking_extdep/$(TARGET)/{ARCH of your platform}/FVDXE.fv # Shared_Networking SECTION UI = \"SharedNetworking\" } With {GUID} being a guid you generated. We use E205F779-07E3-4B64-A2E2-EEDE717B0F59. {Arch of your platform} being the platform you're using. We currently support IA32, X64, and AARCH64. as supposered values You'll also need to remove the networking components that were already in your FDF.","title":"FV way"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#why-to-use-sharednetworking","text":"Depending on your platform, it could net you some small space savings depending on your linker. The main advantage is that when used with SharedCrypto, you can remove the need to compile OpenSSL, reducing compile times.","title":"Why to Use SharedNetworking"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#questions","text":"If you have any questions about anything in this package or the universe in general, feel free to comment on our Github or contact the Project Mu team.","title":"Questions"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/release_notes/","text":"Shared Network Release Notes \u00b6 This is the packaged version of NetworkPkg. Please see more documentation here: https://github.com/microsoft/mu_basecore/tree/release/201911/NetworkPkg/SharedNetworking","title":"release notes"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/release_notes/#shared-network-release-notes","text":"This is the packaged version of NetworkPkg. Please see more documentation here: https://github.com/microsoft/mu_basecore/tree/release/201911/NetworkPkg/SharedNetworking","title":"Shared Network Release Notes"},{"location":"dyn/mu_basecore/PolicyServicePkg/","text":"Policy Service \u00b6 Documents the interface, design, and implementation of the Policy service split across PEI and DXE modules as well as any supporting libraries or best practices. Overview \u00b6 The generalized policy service, implemented in DXE and PEI, provides interfaces for components to publish and consume generic policies between components in the UEFI environment. This policy takes the form of generic data and it is up to the producer and consumer to agree upon the contents and format of that policy. This document makes recommendations as to best practices to sustainably format policy data, but the service is agnostic to the format or meaning of the policy. Policy is a data block containing configurations or settings relating to the silicon, platform, or feature state of the system. This information can originate from PCD entries, platform/silicon configuration code, user settings, or otherwise determined at runtime. A policy may be entirely defined by a single component or it can be built and transformed by several components each further customizing or locking down the system. Background \u00b6 In UEFI there is a need to share these Policy data blocks across components or phases. This could be specific device configuration, settings data, platform information, etc. The Policy service is intended to give an easy, abstracted, and extensible interface for accomplishing this data publishing. Previous Technologies \u00b6 There are several existing mechanisms that can be used to share configuration and data with the rest of the UEFI environment, but currently these mechanisms either don't perfectly align with the Policy Service's use case or are not suitable for adoption across all platforms. Below is a comparison to some of the currently existing methods for sharing data blocks in UEFI. NVRAM Variables - Because NVRAM will be implemented at the platform level, leveraging across silicon or other base code causes a inverse dependency. Hand Off Blocks - While handoff blocks can be used to share data, they only solve the particular case from where the data is sourced from PEI. HOBs do not provide any robust data management features. Additionally, HOBs can be easily misused, for example by storing direct references to the HOB across memory initialization. Config Blocks - Config blocks serve a similar use case as the Policy service, but is not currently in a position to be used across the UEFI ecosystem. Config Blocks lack some of the features such as data management abilities, or features such as the ability to dispatch and notify on data updates. Additionally Config Blocks lack public documentation to be widely adopted. Platform Configuration Database - PCDs, in particular dynamic PCDs, can also be used to share data across components. However, PCDs are more focused and prescriptive in the data type and use case while also lacking some of the data management features and extensibility. Due to it's dependence on the build system PCDs can also be problematic when integrating pre-compiled binary components. The Policy Service is not intended to replace PCDs, but to provide a more light weight and simple method for components to share data. Data Format \u00b6 The Policy service only implements a generic blob storage and should not be directly used in many scenarios. For managed configuration and data format, see the Policy Library ReadMe . Policy Management Process \u00b6 Policies are uniquely defined by a GUID. This GUID should only be used for a specific data type and purpose. Only one policy may be published under a specific GUID at any given time. Duplicates will overwrite the original policy unless the policy has been finalized via the policy attributes. Policies are managed through a simple Get/Set/Remove interface detailed below. After their creation, policies are universally available to all components and supported environments unless otherwise specified in the policy attributes. Policy Components \u00b6 The policy will be accessed by two types of components: producers and consumers. There may be some components that are both consumers and producers by altering an existing policy, possibly using notifications to alter the policy as soon as it is made available. Producer - Creates original policy |---> [ Consumer / Producer - Alters policy ] |---> Consumer 1 - Reads altered policy |---> Consumer 2 - Reads altered Policy The original policy will often be created in PEI to be available as soon as possible, and may be consumed in PEI or may not be consumed until DXE. Implementors of a new policy should consider what component is the origin of the the data, what components may need to edit the data, and what components will eventually use the data. In the sample code, the PEI sample module is the producer and the DXE sample module is the consumer for the example policy shared from PEI to DXE. Producers may also finalize the policy to prevent future accessors from writing to the data. Finalizing will prevent specialization of a policy and so should be done sparingly in silicon or other low-level components. Attributes \u00b6 Policies can be can be set with attribute flags allowing the policy provider to specify on how the policy is handled. For example, this can be used to finalize the policy making it read-only or can be used to limit access to the policy to a phase of boot. See the PolicyInterface header definitions for full list of attributes. Policy Notification Protocols & PPIs \u00b6 When a policy is set or updated a PPI or Protocol will be installed with the GUID of the policy. Consumers may use this GUID to either set Protocol/PPI notifications, or create a DEPEX dependency so that the consumer is not dispatched until the policy is made available. The protocol/PPI will not contain any useful interface and consumers are expected to use the protocol interface to retrieve the policy data after being notified or dispatched. Policy Interface \u00b6 Both the PEI and DXE implementation provide the following interfaces. SetPolicy \u00b6 Creates a new or overwrites and existing policy. Policies can only be overwritten if the policy has not be finalized. The policy will be copied from the provided buffer to an internal store, so all further edits must be done though additional calls to SetPolicy . GetPolicy \u00b6 Returns a copy of the policy for the provided policy GUID and its current attributes. The caller is responsible for allocating the buffer the policy is copied into. RemovePolicy \u00b6 Removes a policy from the policy list, freeing it when possible. Policy Service Implementation \u00b6 The policy interfaces use a pass-by-copy scheme to ensure that the producers and consumers cannot directly edit the policy data and all interactions are done in transactions. This also allows for attributes such as finalized to be strongly enforced. Internally the PEI and DXE phase implementation have their own method for storing policy data. PEI Phase \u00b6 Policies created during PEI are immediately stored into a HOB. All policy HOBs are given the same well-known GUID, gPolicyHobGuid, with a POLICY_HOB_HEADER header to track it's metadata. When a given policy is requested the PEIM will search the HOBs with the well-known GUID to find the matching policy header. If a policy is removed or made obsolete with a larger version of the policy, the header will be set with the removed flag and will no longer be evaluated by the service. When a policy is created or updated in the PEI phase, a NULL PPI will be installed, or reinstalled, with the GUID of the policy. This PPI is intended to allow for notification and dispatch of consumers when the policy becomes available. DXE Phase \u00b6 During it's initialization, the DXE driver will process the HOB list to discover any valid policies that may exist. These HOB policy blocks will then be added to the DXE driver's linked list structure of the active policies on the system. Any policies created or updated in the DXE phase will be allocated in pool memory and freed when removed or expanded. Like the PEIM, the DXE driver will install/reinstall a NULL protocol with the given policies GUID when it is created or updated to allow for notification and dispatch on the policy availability. YAML Based Policy Definition \u00b6 This section provides an overview of YAML based policy definition and how platform can integrate them. YAML Definition for Policy Structures \u00b6 When used, the YAML based policy definition is treated as the ground truth of policy structure and default data. The YAML parser is largely inheritted from Intel's slim bootloader . Thus, the YAML syntax follows the specification defined in slim bootloader as well. Such YAML definition will be used to generate header files and the field accessors for platform consumption. MU Added Rules \u00b6 In addition to aforementioned YAML specification from slim bootloader, a few extra rules was added to the existing specification to facilitate the adaptation of policy specific usage. These rules will be enforced by a Pre-Build plugin, more details in its implementation section . Each policy definition group must include a POLICY_HEADER_TMPL section, as provided in this template here . This section should include a 64-bit signature, an expected major version, an maximally expected minor version and a size of such structure. This data will mainly be used as metadata instead of policy data. Platforms could !include the provided template for easier inclusion. For each non-header fields defined in the YAML policy file, developers could optionally add a minver field, which denotes at which minor version this field is added. If not added, this field will be treated as 0 for default value. Under the same major value, all new minor fields should only be appended after the fields with lower minor version values, otherwise the build will break. This YAML definition is not created to support UI configuration features, thus no UI related configuration fields will be recognized in the context of policy YAML definition. Field Accessors \u00b6 For each fields defined in YAML structures, 4 accessor functions will be created. These functions will cover the functionality of setting this field to target value or default value, get current or default value from policy handle. All autogen functions will be created under the naming scheme of SET_POLICY_STRUCTURE_NAME_Field_Name , SET_POLICY_STRUCTURE_NAME_Field_Name_default , GET_POLICY_STRUCTURE_NAME_Field_Name and GET_POLICY_STRUCTURE_NAME_Field_Name_default . The internal implementation of these functions are dependent on PolicyLib , specifically the verified policy related functionalities. In order to simplify the usage of policy initialization, a function of SET_POLICY_STRUCTURE_NAME_default is created. This function could be invoked for a platform to initialize the newly created policy handle. Pre-Build Plugin \u00b6 A pre-build plugin is created to enforce rules indicated in the previous section . This plugin requires 3 build environment variable to execute properly: BUILD_OUTPUT_BASE : This is used to create a temporary folder to contain intermediate files UPDATE_SETTINGS : Setting this to false to disable this plugin POLICY_REPORT_FOLDER : This optional variable can be used to indicate where the plugin should output the report. POLICY_IGNORE_PATHS : This optional variable can be used by platform to specify which directories or files the autogen should ignore. Each entry should be relative UEFI path separated by colons (';'). If not supplied this report will be save to the same folder of ACTIVE_PLATFORM . A policy report is the collateral output after codebase analyzing: During pre-build, this plugin will search through all the included package paths for files ending with _policy_def.yaml or _policy_def.yml . Each policy component should have its own *_policy_def.yaml file. i.e. USB_policy_def.yaml for USB policies and PCI_policy_def.yaml for PCI policies. For each discovered policy definition, the plugin will compute a hash value of each defined minor version with the structure and its content. This value will be compared to the value from previously output report, if this report does not exist, the plugin will create one. If the any of the rules does not meet, or any field change is detected, the build will halt and notify the developers to fix the unexpected and update the report file. The plugin will also generate the header file from this YAML definition automatically, which includes the header structure and its accessors. Platform Integration \u00b6 For a platform to integrate the changes, the following needs to be satisfied: Silicon Packages \u00b6 Define and create component policy defintions in YAML. Use autogen accessors and PolicyLib to consume policy values. Platform Packages \u00b6 Use autogen accessors and PolicyLib to publish and/or override policy values. Include POLICY_REPORT.xml for version tracking purpose. Add PolicyLib instances to platform descriptor file.","title":"README"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-service","text":"Documents the interface, design, and implementation of the Policy service split across PEI and DXE modules as well as any supporting libraries or best practices.","title":"Policy Service"},{"location":"dyn/mu_basecore/PolicyServicePkg/#overview","text":"The generalized policy service, implemented in DXE and PEI, provides interfaces for components to publish and consume generic policies between components in the UEFI environment. This policy takes the form of generic data and it is up to the producer and consumer to agree upon the contents and format of that policy. This document makes recommendations as to best practices to sustainably format policy data, but the service is agnostic to the format or meaning of the policy. Policy is a data block containing configurations or settings relating to the silicon, platform, or feature state of the system. This information can originate from PCD entries, platform/silicon configuration code, user settings, or otherwise determined at runtime. A policy may be entirely defined by a single component or it can be built and transformed by several components each further customizing or locking down the system.","title":"Overview"},{"location":"dyn/mu_basecore/PolicyServicePkg/#background","text":"In UEFI there is a need to share these Policy data blocks across components or phases. This could be specific device configuration, settings data, platform information, etc. The Policy service is intended to give an easy, abstracted, and extensible interface for accomplishing this data publishing.","title":"Background"},{"location":"dyn/mu_basecore/PolicyServicePkg/#previous-technologies","text":"There are several existing mechanisms that can be used to share configuration and data with the rest of the UEFI environment, but currently these mechanisms either don't perfectly align with the Policy Service's use case or are not suitable for adoption across all platforms. Below is a comparison to some of the currently existing methods for sharing data blocks in UEFI. NVRAM Variables - Because NVRAM will be implemented at the platform level, leveraging across silicon or other base code causes a inverse dependency. Hand Off Blocks - While handoff blocks can be used to share data, they only solve the particular case from where the data is sourced from PEI. HOBs do not provide any robust data management features. Additionally, HOBs can be easily misused, for example by storing direct references to the HOB across memory initialization. Config Blocks - Config blocks serve a similar use case as the Policy service, but is not currently in a position to be used across the UEFI ecosystem. Config Blocks lack some of the features such as data management abilities, or features such as the ability to dispatch and notify on data updates. Additionally Config Blocks lack public documentation to be widely adopted. Platform Configuration Database - PCDs, in particular dynamic PCDs, can also be used to share data across components. However, PCDs are more focused and prescriptive in the data type and use case while also lacking some of the data management features and extensibility. Due to it's dependence on the build system PCDs can also be problematic when integrating pre-compiled binary components. The Policy Service is not intended to replace PCDs, but to provide a more light weight and simple method for components to share data.","title":"Previous Technologies"},{"location":"dyn/mu_basecore/PolicyServicePkg/#data-format","text":"The Policy service only implements a generic blob storage and should not be directly used in many scenarios. For managed configuration and data format, see the Policy Library ReadMe .","title":"Data Format"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-management-process","text":"Policies are uniquely defined by a GUID. This GUID should only be used for a specific data type and purpose. Only one policy may be published under a specific GUID at any given time. Duplicates will overwrite the original policy unless the policy has been finalized via the policy attributes. Policies are managed through a simple Get/Set/Remove interface detailed below. After their creation, policies are universally available to all components and supported environments unless otherwise specified in the policy attributes.","title":"Policy Management Process"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-components","text":"The policy will be accessed by two types of components: producers and consumers. There may be some components that are both consumers and producers by altering an existing policy, possibly using notifications to alter the policy as soon as it is made available. Producer - Creates original policy |---> [ Consumer / Producer - Alters policy ] |---> Consumer 1 - Reads altered policy |---> Consumer 2 - Reads altered Policy The original policy will often be created in PEI to be available as soon as possible, and may be consumed in PEI or may not be consumed until DXE. Implementors of a new policy should consider what component is the origin of the the data, what components may need to edit the data, and what components will eventually use the data. In the sample code, the PEI sample module is the producer and the DXE sample module is the consumer for the example policy shared from PEI to DXE. Producers may also finalize the policy to prevent future accessors from writing to the data. Finalizing will prevent specialization of a policy and so should be done sparingly in silicon or other low-level components.","title":"Policy Components"},{"location":"dyn/mu_basecore/PolicyServicePkg/#attributes","text":"Policies can be can be set with attribute flags allowing the policy provider to specify on how the policy is handled. For example, this can be used to finalize the policy making it read-only or can be used to limit access to the policy to a phase of boot. See the PolicyInterface header definitions for full list of attributes.","title":"Attributes"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-notification-protocols-ppis","text":"When a policy is set or updated a PPI or Protocol will be installed with the GUID of the policy. Consumers may use this GUID to either set Protocol/PPI notifications, or create a DEPEX dependency so that the consumer is not dispatched until the policy is made available. The protocol/PPI will not contain any useful interface and consumers are expected to use the protocol interface to retrieve the policy data after being notified or dispatched.","title":"Policy Notification Protocols &amp; PPIs"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-interface","text":"Both the PEI and DXE implementation provide the following interfaces.","title":"Policy Interface"},{"location":"dyn/mu_basecore/PolicyServicePkg/#setpolicy","text":"Creates a new or overwrites and existing policy. Policies can only be overwritten if the policy has not be finalized. The policy will be copied from the provided buffer to an internal store, so all further edits must be done though additional calls to SetPolicy .","title":"SetPolicy"},{"location":"dyn/mu_basecore/PolicyServicePkg/#getpolicy","text":"Returns a copy of the policy for the provided policy GUID and its current attributes. The caller is responsible for allocating the buffer the policy is copied into.","title":"GetPolicy"},{"location":"dyn/mu_basecore/PolicyServicePkg/#removepolicy","text":"Removes a policy from the policy list, freeing it when possible.","title":"RemovePolicy"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-service-implementation","text":"The policy interfaces use a pass-by-copy scheme to ensure that the producers and consumers cannot directly edit the policy data and all interactions are done in transactions. This also allows for attributes such as finalized to be strongly enforced. Internally the PEI and DXE phase implementation have their own method for storing policy data.","title":"Policy Service Implementation"},{"location":"dyn/mu_basecore/PolicyServicePkg/#pei-phase","text":"Policies created during PEI are immediately stored into a HOB. All policy HOBs are given the same well-known GUID, gPolicyHobGuid, with a POLICY_HOB_HEADER header to track it's metadata. When a given policy is requested the PEIM will search the HOBs with the well-known GUID to find the matching policy header. If a policy is removed or made obsolete with a larger version of the policy, the header will be set with the removed flag and will no longer be evaluated by the service. When a policy is created or updated in the PEI phase, a NULL PPI will be installed, or reinstalled, with the GUID of the policy. This PPI is intended to allow for notification and dispatch of consumers when the policy becomes available.","title":"PEI Phase"},{"location":"dyn/mu_basecore/PolicyServicePkg/#dxe-phase","text":"During it's initialization, the DXE driver will process the HOB list to discover any valid policies that may exist. These HOB policy blocks will then be added to the DXE driver's linked list structure of the active policies on the system. Any policies created or updated in the DXE phase will be allocated in pool memory and freed when removed or expanded. Like the PEIM, the DXE driver will install/reinstall a NULL protocol with the given policies GUID when it is created or updated to allow for notification and dispatch on the policy availability.","title":"DXE Phase"},{"location":"dyn/mu_basecore/PolicyServicePkg/#yaml-based-policy-definition","text":"This section provides an overview of YAML based policy definition and how platform can integrate them.","title":"YAML Based Policy Definition"},{"location":"dyn/mu_basecore/PolicyServicePkg/#yaml-definition-for-policy-structures","text":"When used, the YAML based policy definition is treated as the ground truth of policy structure and default data. The YAML parser is largely inheritted from Intel's slim bootloader . Thus, the YAML syntax follows the specification defined in slim bootloader as well. Such YAML definition will be used to generate header files and the field accessors for platform consumption.","title":"YAML Definition for Policy Structures"},{"location":"dyn/mu_basecore/PolicyServicePkg/#mu-added-rules","text":"In addition to aforementioned YAML specification from slim bootloader, a few extra rules was added to the existing specification to facilitate the adaptation of policy specific usage. These rules will be enforced by a Pre-Build plugin, more details in its implementation section . Each policy definition group must include a POLICY_HEADER_TMPL section, as provided in this template here . This section should include a 64-bit signature, an expected major version, an maximally expected minor version and a size of such structure. This data will mainly be used as metadata instead of policy data. Platforms could !include the provided template for easier inclusion. For each non-header fields defined in the YAML policy file, developers could optionally add a minver field, which denotes at which minor version this field is added. If not added, this field will be treated as 0 for default value. Under the same major value, all new minor fields should only be appended after the fields with lower minor version values, otherwise the build will break. This YAML definition is not created to support UI configuration features, thus no UI related configuration fields will be recognized in the context of policy YAML definition.","title":"MU Added Rules"},{"location":"dyn/mu_basecore/PolicyServicePkg/#field-accessors","text":"For each fields defined in YAML structures, 4 accessor functions will be created. These functions will cover the functionality of setting this field to target value or default value, get current or default value from policy handle. All autogen functions will be created under the naming scheme of SET_POLICY_STRUCTURE_NAME_Field_Name , SET_POLICY_STRUCTURE_NAME_Field_Name_default , GET_POLICY_STRUCTURE_NAME_Field_Name and GET_POLICY_STRUCTURE_NAME_Field_Name_default . The internal implementation of these functions are dependent on PolicyLib , specifically the verified policy related functionalities. In order to simplify the usage of policy initialization, a function of SET_POLICY_STRUCTURE_NAME_default is created. This function could be invoked for a platform to initialize the newly created policy handle.","title":"Field Accessors"},{"location":"dyn/mu_basecore/PolicyServicePkg/#pre-build-plugin","text":"A pre-build plugin is created to enforce rules indicated in the previous section . This plugin requires 3 build environment variable to execute properly: BUILD_OUTPUT_BASE : This is used to create a temporary folder to contain intermediate files UPDATE_SETTINGS : Setting this to false to disable this plugin POLICY_REPORT_FOLDER : This optional variable can be used to indicate where the plugin should output the report. POLICY_IGNORE_PATHS : This optional variable can be used by platform to specify which directories or files the autogen should ignore. Each entry should be relative UEFI path separated by colons (';'). If not supplied this report will be save to the same folder of ACTIVE_PLATFORM . A policy report is the collateral output after codebase analyzing: During pre-build, this plugin will search through all the included package paths for files ending with _policy_def.yaml or _policy_def.yml . Each policy component should have its own *_policy_def.yaml file. i.e. USB_policy_def.yaml for USB policies and PCI_policy_def.yaml for PCI policies. For each discovered policy definition, the plugin will compute a hash value of each defined minor version with the structure and its content. This value will be compared to the value from previously output report, if this report does not exist, the plugin will create one. If the any of the rules does not meet, or any field change is detected, the build will halt and notify the developers to fix the unexpected and update the report file. The plugin will also generate the header file from this YAML definition automatically, which includes the header structure and its accessors.","title":"Pre-Build Plugin"},{"location":"dyn/mu_basecore/PolicyServicePkg/#platform-integration","text":"For a platform to integrate the changes, the following needs to be satisfied:","title":"Platform Integration"},{"location":"dyn/mu_basecore/PolicyServicePkg/#silicon-packages","text":"Define and create component policy defintions in YAML. Use autogen accessors and PolicyLib to consume policy values.","title":"Silicon Packages"},{"location":"dyn/mu_basecore/PolicyServicePkg/#platform-packages","text":"Use autogen accessors and PolicyLib to publish and/or override policy values. Include POLICY_REPORT.xml for version tracking purpose. Add PolicyLib instances to platform descriptor file.","title":"Platform Packages"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/","text":"Policy Library \u00b6 The policy library is responsible for handling more robust features on top of the basic policy store provided by the policy. The primary use case of this library would be to use verified policies stored in the policy store. Verified Policy Overview \u00b6 Verified policy is a set of library functions and tools around policy that provides a more type and version safe way of sharing data structures between components in different code bases or firmware layers. Using the verified policy functions in the library, combined with a per-data-structure generated header, callers can set and read data from a policy with automatic checks and guarantees to ensure the data being read correctly. This also provides useful concepts such as default values allowing for structure-safe version mismatch. Verified Policy Components \u00b6 The following are a few key components for utilizing verified policies. Policy Guid - As with all policies, a single instance of a policy should have a unique GUID. This GUID is not associated with the policy structure and only represents the data instance, not the data type or structure. Verified Policy Descriptor - The verified policy descriptor is a auto generated structure which describes the expected data structure. This includes a unique tag for the data, version info, size info, etc. The policy library will use this information to check the policy data to ensure it matches the expected type and required version. Attributes - Similar to all other policies, attributes can be used to enforce access restrictions on the policy instance. Verified Policy Handle - To enforce the verified policy abstraction, the caller will not be provided a direct pointer to the data. Instead they will be provided a policy handle which should be used with the auto-generated accessors. This allows for automatic checks to be done to ensure safe access of data. Verified Policy Functions \u00b6 The policy library provides the following functions for accessing verified policy. GetVerifiedPolicy - Retrieves a verified policy from the policy store, checking that the data is the expected type and version. The returned handle references a copy of the policy and so a set is required to store and changes. CreateVerifiedPolicy - Creates a new verified policy data instance. This routine does not add the data to the policy store. SetVerifiedPolicy - Sets the provided verified policy data into the policy store. CloseVerifiedPolicy - Closes the local handle to the verified policy, freeing and resources. ReportVerifiedPolicyAccess - A API used to communicate access between the generated accessors and the generic library. This routine should not be manually called. Generating Verified Policy Headers \u00b6 Details regarding generating verified policies are not yet documented here.","title":"Library"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#policy-library","text":"The policy library is responsible for handling more robust features on top of the basic policy store provided by the policy. The primary use case of this library would be to use verified policies stored in the policy store.","title":"Policy Library"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-overview","text":"Verified policy is a set of library functions and tools around policy that provides a more type and version safe way of sharing data structures between components in different code bases or firmware layers. Using the verified policy functions in the library, combined with a per-data-structure generated header, callers can set and read data from a policy with automatic checks and guarantees to ensure the data being read correctly. This also provides useful concepts such as default values allowing for structure-safe version mismatch.","title":"Verified Policy Overview"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-components","text":"The following are a few key components for utilizing verified policies. Policy Guid - As with all policies, a single instance of a policy should have a unique GUID. This GUID is not associated with the policy structure and only represents the data instance, not the data type or structure. Verified Policy Descriptor - The verified policy descriptor is a auto generated structure which describes the expected data structure. This includes a unique tag for the data, version info, size info, etc. The policy library will use this information to check the policy data to ensure it matches the expected type and required version. Attributes - Similar to all other policies, attributes can be used to enforce access restrictions on the policy instance. Verified Policy Handle - To enforce the verified policy abstraction, the caller will not be provided a direct pointer to the data. Instead they will be provided a policy handle which should be used with the auto-generated accessors. This allows for automatic checks to be done to ensure safe access of data.","title":"Verified Policy Components"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-functions","text":"The policy library provides the following functions for accessing verified policy. GetVerifiedPolicy - Retrieves a verified policy from the policy store, checking that the data is the expected type and version. The returned handle references a copy of the policy and so a set is required to store and changes. CreateVerifiedPolicy - Creates a new verified policy data instance. This routine does not add the data to the policy store. SetVerifiedPolicy - Sets the provided verified policy data into the policy store. CloseVerifiedPolicy - Closes the local handle to the verified policy, freeing and resources. ReportVerifiedPolicyAccess - A API used to communicate access between the generated accessors and the generic library. This routine should not be manually called.","title":"Verified Policy Functions"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#generating-verified-policy-headers","text":"Details regarding generating verified policies are not yet documented here.","title":"Generating Verified Policy Headers"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyDefinitions/","text":"Policy YAML Definition Sample \u00b6 This directory contains sample policy definitions using YAML files to demonstrate a basic use of the policy autogen output. The GFX header file demonstrates all the structures, templates and interfaces generated. The functions are directly invocable from firmware code and template can be used verified policy operations.","title":"Policy Definitions"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyDefinitions/#policy-yaml-definition-sample","text":"This directory contains sample policy definitions using YAML files to demonstrate a basic use of the policy autogen output. The GFX header file demonstrates all the structures, templates and interfaces generated. The functions are directly invocable from firmware code and template can be used verified policy operations.","title":"Policy YAML Definition Sample"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyInterface/","text":"Policy Sample \u00b6 This directory contains sample PEI and DXE modules to demonstrate a basic use of the policy service. The PEI module demonstrates all the interfaces available, and creates a policy to be made available to DXE. The DXE module demonstrates retrieving this policy passed from PEI to DXE. In this example the policy is a simple C struct, but a policy may be in whatever data format the provider/suppliers wish.","title":"Policy Interface"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyInterface/#policy-sample","text":"This directory contains sample PEI and DXE modules to demonstrate a basic use of the policy service. The PEI module demonstrates all the interfaces available, and creates a policy to be made available to DXE. The DXE module demonstrates retrieving this policy passed from PEI to DXE. In this example the policy is a simple C struct, but a policy may be in whatever data format the provider/suppliers wish.","title":"Policy Sample"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/","text":"Unit Test Framework Package \u00b6 About \u00b6 This package adds a unit test framework capable of building tests for multiple contexts including the UEFI shell environment and host-based environments. It allows for unit test development to focus on the tests and leave error logging, result formatting, context persistance, and test running to the framework. The unit test framework works well for low level unit tests as well as system level tests and fits easily in automation frameworks. UnitTestLib \u00b6 The main \"framework\" library. The core of the framework is the Framework object, which can have any number of test cases and test suites registered with it. The Framework object is also what drives test execution. The Framework also provides helper macros and functions for checking test conditions and reporting errors. Status and error info will be logged into the test context. There are a number of Assert macros that make the unit test code friendly to view and easy to understand. Finally, the Framework also supports logging strings during the test execution. This data is logged to the test context and will be available in the test reporting phase. This should be used for logging test details and helpful messages to resolve test failures. UnitTestPersistenceLib \u00b6 Persistence lib has the main job of saving and restoring test context to a storage medium so that for tests that require exiting the active process and then resuming state can be maintained. This is critical in supporting a system reboot in the middle of a test run. UnitTestResultReportLib \u00b6 Library provides function to run at the end of a framework test run and handles formatting the report. This is a common customization point and allows the unit test framework to fit its output reports into other test infrastructure. In this package a simple library instances has been supplied to output test results to the console as plain text. Samples \u00b6 There is a sample unit test provided as both an example of how to write a unit test and leverage many of the features of the framework. This sample can be found in the Test/UnitTest/Sample/SampleUnitTest directory. The sample is provided in PEI, SMM, DXE, and UEFI App flavors. It also has a flavor for the HOST_APPLICATION build type, which can be run on a host system without needing a target. Usage \u00b6 This section is built a lot like a \"Getting Started\". We'll go through some of the components that are needed when constructing a unit test and some of the decisions that are made by the test writer. We'll also describe how to check for expected conditions in test cases and a bit of the logging characteristics. Most of these examples will refer to the SampleUnitTestUefiShell app found in this package. Requirements - INF \u00b6 In our INF file, we'll need to bring in the UnitTestLib library. Conveniently, the interface header for the UnitTestLib is located in MdePkg , so you shouldn't need to depend on any other packages. As long as your DSC file knows where to find the lib implementation that you want to use, you should be good to go. See this example in 'SampleUnitTestUefiShell.inf'... [Packages] MdePkg/MdePkg.dec [LibraryClasses] UefiApplicationEntryPoint BaseLib DebugLib UnitTestLib PrintLib Also, if you want you test to automatically be picked up by the Test Runner plugin, you will need to make sure that the module BASE_NAME contains the word Test ... [Defines] BASE_NAME = SampleUnitTestUefiShell Requirements - Code \u00b6 Not to state the obvious, but let's make sure we have the following include before getting too far along... #include <Library/UnitTestLib.h> Now that we've got that squared away, let's look at our 'Main()'' routine (or DriverEntryPoint() or whatever). Configuring the Framework \u00b6 Everything in the UnitTestPkg framework is built around an object called -- conveniently -- the Framework. This Framework object will contain all the information about our test, the test suites and test cases associated with it, the current location within the test pass, and any results that have been recorded so far. To get started with a test, we must first create a Framework instance. The function for this is InitUnitTestFramework . It takes in CHAR8 strings for the long name, short name, and test version. The long name and version strings are just for user presentation and relatively flexible. The short name will be used to name any cache files and/or test results, so should be a name that makes sense in that context. These strings are copied internally to the Framework, so using stack-allocated or literal strings is fine. In the 'SampleUnitTestUefiShell' app, the module name is used as the short name, so the init looks like this. DEBUG (( DEBUG_INFO , \"%a v%a \\n \" , UNIT_TEST_APP_NAME , UNIT_TEST_APP_VERSION )); // // Start setting up the test framework for running the tests. // Status = InitUnitTestFramework ( & Framework , UNIT_TEST_APP_NAME , gEfiCallerBaseName , UNIT_TEST_APP_VERSION ); The &Framework returned here is the handle to the Framework. If it's successfully returned, we can start adding test suites and test cases. Test suites exist purely to help organize test cases and to differentiate the results in reports. If you're writing a small unit test, you can conceivably put all test cases into a single suite. However, if you end up with 20+ test cases, it may be beneficial to organize them according to purpose. You must have at least one test suite, even if it's just a catch-all. The function to create a test suite is CreateUnitTestSuite . It takes in a handle to the Framework object, a CHAR8 string for the suite title and package name, and optional function pointers for a setup function and a teardown function. The suite title is for user presentation. The package name is for xUnit type reporting and uses a '.'-separated hierarchical format (see 'SampleUnitTestApp' for example). If provided, the setup and teardown functions will be called once at the start of the suite (before any tests have run) and once at the end of the suite (after all tests have run), respectively. If either or both of these are unneeded, pass NULL . The function prototypes are UNIT_TEST_SUITE_SETUP and UNIT_TEST_SUITE_TEARDOWN . Looking at 'SampleUnitTestUefiShell' app, you can see that the first test suite is created as below... // // Populate the SimpleMathTests Unit Test Suite. // Status = CreateUnitTestSuite ( & SimpleMathTests , Fw , \"Simple Math Tests\" , \"Sample.Math\" , NULL , NULL ); This test suite has no setup or teardown functions. The &SimpleMathTests returned here is a handle to the suite and will be used when adding test cases. Great! Now we've finished some of the cruft, red tape, and busy work. We're ready to add some tests. Adding a test to a test suite is accomplished with the -- you guessed it -- AddTestCase function. It takes in the suite handle; a CHAR8 string for the description and class name; a function pointer for the test case itself; additional, optional function pointers for prerequisite check and cleanup routines; and and optional pointer to a context structure. Okay, that's a lot. Let's take it one piece at a time. The description and class name strings are very similar in usage to the suite title and package name strings in the test suites. The former is for user presentation and the latter is for xUnit parsing. The test case function pointer is what is actually executed as the \"test\" and the prototype should be UNIT_TEST_FUNCTION . The last three parameters require a little bit more explaining. The prerequisite check function has a prototype of UNIT_TEST_PREREQUISITE and -- if provided -- will be called immediately before the test case. If this function returns any error, the test case will not be run and will be recorded as UNIT_TEST_ERROR_PREREQUISITE_NOT_MET . The cleanup function (prototype UNIT_TEST_CLEANUP ) will be called immediately after the test case to provide an opportunity to reset any global state that may have been changed in the test case. In the event of a prerequisite failure, the cleanup function will also be skipped. If either of these functions is not needed, pass NULL . The context pointer is entirely case-specific. It will be passed to the test case upon execution. One of the purposes of the context pointer is to allow test case reuse with different input data. (Another use is for testing that wraps around a system reboot, but that's beyond the scope of this guide.) The test case must know how to interpret the context pointer, so it could be a simple value, or it could be a complex structure. If unneeded, pass NULL . In 'SampleUnitTestUefiShell' app, the first test case is added using the code below... AddTestCase ( SimpleMathTests , \"Adding 1 to 1 should produce 2\" , \"Addition\" , OnePlusOneShouldEqualTwo , NULL , NULL , NULL ); This test case calls the function OnePlusOneShouldEqualTwo and has no prerequisite, cleanup, or context. Once all the suites and cases are added, it's time to run the Framework. // // Execute the tests. // Status = RunAllTestSuites ( Framework ); A Simple Test Case \u00b6 We'll take a look at the below test case from 'SampleUnitTestApp'... UNIT_TEST_STATUS EFIAPI OnePlusOneShouldEqualTwo ( IN UNIT_TEST_FRAMEWORK_HANDLE Framework , IN UNIT_TEST_CONTEXT Context ) { UINTN A , B , C ; A = 1 ; B = 1 ; C = A + B ; UT_ASSERT_EQUAL ( C , 2 ); return UNIT_TEST_PASSED ; } // OnePlusOneShouldEqualTwo() The prototype for this function matches the UNIT_TEST_FUNCTION prototype. It takes in a handle to the Framework itself and the context pointer. The context pointer could be cast and interpreted as anything within this test case, which is why it's important to configure contexts carefully. The test case returns a value of UNIT_TEST_STATUS , which will be recorded in the Framework and reported at the end of all suites. In this test case, the UT_ASSERT_EQUAL assertion is being used to establish that the business logic has functioned correctly. There are several assertion macros, and you are encouraged to use one that matches as closely to your intended test criterium as possible, because the logging is specific to the macro and more specific macros have more detailed logs. When in doubt, there are always UT_ASSERT_TRUE and UT_ASSERT_FALSE . Assertion macros that fail their test criterium will immediately return from the test case with UNIT_TEST_ERROR_TEST_FAILED and log an error string. Note that this early return can have implications for memory leakage. At the end, if all test criteria pass, you should return UNIT_TEST_PASSED . More Complex Cases \u00b6 To write more advanced tests, first take a look at all the Assertion and Logging macros provided in the framework. Beyond that, if you're writing host-based tests and want to take a dependency on the UnitTestFrameworkPkg, you can leverage the cmocka.h interface and write tests with all the features of the Cmocka framework. Documentation for Cmocka can be found here: https://api.cmocka.org/ Development \u00b6 Iterating on a Single Test \u00b6 When using the EDK2 Pytools for CI testing, the host-based unit tests will be built and run on any build that includes the NOOPT build target. If you are trying to iterate on a single test, a convenient pattern is to build only that test module. For example, the following command will build only the SafeIntLib host-based test from the MdePkg... stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG = VS2017 -p MdePkg -t NOOPT BUILDMODULE = MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLib.inf Hooking BaseLib \u00b6 Most unit test mocking can be performed by the functions provided in the UnitTestFramework libraries, but since BaseLib is consumed by the Framework itself, it requires different techniques to substitute parts of the functionality. To solve some of this, the UnitTestFramework consumes a special implementation of BaseLib for host-based tests. This implementation contains a hook table that can be used to substitute test functionality for any of the BaseLib functions. By default, this implementation will use the underlying BaseLib implementation, so the unit test writer only has to supply minimal code to test a particular case. Debugging the Framework Itself \u00b6 While most of the tests that are produced by the UnitTestFramework are easy to step through in a debugger, the Framework itself consumes code (mostly Cmocka) that sets its own build flags. These flags cause parts of the Framework to not export symbols and captures exceptions, and as such are harder to debug. We have provided a Stuart parameter to force symbolic debugging to be enabled. You can run a build by adding the BLD_*_UNIT_TESTING_DEBUG=TRUE parameter to enable this build option. stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 -p MdePkg -t NOOPT BLD_*_UNIT_TESTING_DEBUG = TRUE Building and Running Host-Based Tests \u00b6 The EDK2 CI infrastructure provides a convenient way to run all host-based tests -- in the the entire tree or just selected packages -- and aggregate all the the reports, including highlighting any failures. This functionality is provided through the Stuart build system (published by EDK2-PyTools) and the NOOPT build target. Building Locally \u00b6 First, to make sure you're working with the latest PyTools, run the following command: # Would recommend to run this in a Python venv, but that's out of scope for this doc. python -m pip install --upgrade -r ./pip-requirements.txt After that, the following commands will set up the build and run the host-based tests. # Setup repo for building # stuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Mu specific step to clone mu repos required for ci check # stuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Update all binary dependencies # stuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Build and run the tests # stuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> -t NOOPT [-p <Package Name>] stuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 -t NOOPT -p MdePkg Evaluating the Results \u00b6 In your immediate output, any build failures will be highlighted. You can see these below as \"WARNING\" and \"ERROR\" messages. (edk_env) PS C:\\_uefi\\edk2> stuart_ci_build -c .\\.pytool\\CISettings.py TOOL_CHAIN_TAG=VS2019 -t NOOPT -p MdePkg SECTION - Init SDE SECTION - Loading Plugins SECTION - Start Invocable Tool SECTION - Getting Environment SECTION - Loading plugins SECTION - Building MdePkg Package PROGRESS - --Running MdePkg: Host Unit Test Compiler Plugin NOOPT -- WARNING - Allowing Override for key TARGET_ARCH PROGRESS - Start time: 2020-07-27 17:18:08.521672 PROGRESS - Setting up the Environment PROGRESS - Running Pre Build PROGRESS - Running Build NOOPT PROGRESS - Running Post Build SECTION - Run Host based Unit Tests SUBSECTION - Testing for architecture: X64 WARNING - TestBaseSafeIntLibHost.exe Test Failed WARNING - Test SafeInt8ToUint8 - UT_ASSERT_EQUAL(0x5b:5b, Result:5c) c:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure! ERROR - Plugin Failed: Host-Based Unit Test Runner returned 1 CRITICAL - Post Build failed PROGRESS - End time: 2020-07-27 17:18:19.792313 Total time Elapsed: 0:00:11 ERROR - --->Test Failed: Host Unit Test Compiler Plugin NOOPT returned 1 ERROR - Overall Build Status: Error PROGRESS - There were 1 failures out of 1 attempts SECTION - Summary ERROR - Error (edk_env) PS C:\\_uefi\\edk2> If a test fails, you can run it manually to get more details... (edk_env) PS C:\\_uefi\\edk2> .\\Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe Int Safe Lib Unit Test Application v0.1 --------------------------------------------------------- ------------ RUNNING ALL TEST SUITES -------------- --------------------------------------------------------- --------------------------------------------------------- RUNNING TEST SUITE: Int Safe Conversions Test Suite --------------------------------------------------------- [==========] Running 71 test(s). [ RUN ] Test SafeInt8ToUint8 [ ERROR ] --- UT_ASSERT_EQUAL(0x5b:5b, Result:5c) [ LINE ] --- c:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure! [ FAILED ] Test SafeInt8ToUint8 [ RUN ] Test SafeInt8ToUint16 [ OK ] Test SafeInt8ToUint16 [ RUN ] Test SafeInt8ToUint32 [ OK ] Test SafeInt8ToUint32 [ RUN ] Test SafeInt8ToUintn [ OK ] Test SafeInt8ToUintn ... You can also, if you are so inclined, read the output from the exact instance of the test that was run during stuart_ci_build . The ouput file can be found on a path that looks like: Build/<Package>/HostTest/<Arch>/<TestName>.<TestSuiteName>.<Arch>.result.xml A sample of this output looks like: <!-- Excerpt taken from: Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe.Int Safe Conversions Test Suite.X64.result.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <testsuites> <testsuite name= \"Int Safe Conversions Test Suite\" time= \"0.000\" tests= \"71\" failures= \"1\" errors= \"0\" skipped= \"0\" > <testcase name= \"Test SafeInt8ToUint8\" time= \"0.000\" > <failure> <![CDATA[UT_ASSERT_EQUAL(0x5c:5c, Result:5b) c:\\_uefi\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure!]]> </failure> </testcase> <testcase name= \"Test SafeInt8ToUint16\" time= \"0.000\" > </testcase> <testcase name= \"Test SafeInt8ToUint32\" time= \"0.000\" > </testcase> <testcase name= \"Test SafeInt8ToUintn\" time= \"0.000\" > </testcase> XML Reporting Mode \u00b6 Since these applications are built using the CMocka framework, they can also use the following env variables to output in a structured XML rather than text: CMOCKA_MESSAGE_OUTPUT=xml CMOCKA_XML_FILE=<absolute or relative path to output file> This mode is used by the test running plugin to aggregate the results for CI test status reporting in the web view. Code Coverage \u00b6 Host based Unit Tests will automatically include GCC build flags to enable coverage data. This is primarily leveraged for pipeline builds, but this can be leveraged locally using the lcov linux tool, and parsed using the lcov_cobertura python tool. pycobertura is used to covert this coverage data to a human readable HTML file. These tools must be installed to parse code coverage. sudo apt-get install -y lcov pip install lcov_cobertura pip install pycobertura During CI builds, use the CODE_COVERAGE=TRUE flag to generate the code coverage XML files, and additionally use the CC_HTML=TRUE flag to generate the HTML file. This will be generated in Build/coverage.html. There is currently no official guidance or support for code coverage when compiling in Visual Studio at this time. Important Note \u00b6 This works on both Windows and Linux, but is currently limited to x64 architectures. Working on getting others, but we also welcome contributions. Known Limitations \u00b6 PEI, DXE, SMM \u00b6 While sample tests have been provided for these execution environments, only cursory build validation has been performed. Care has been taken while designing the frameworks to allow for execution during boot phases, but only UEFI Shell and host-based tests have been thoroughly evaluated. Full support for PEI, DXE, and SMM is forthcoming, but should be considered beta/staging for now. Host-Based Support vs Other Tests \u00b6 The host-based test framework is powered internally by the Cmocka framework. As such, it has abilities that the target-based tests don't (yet). It would be awesome if this meant that it was a super set of the target-based tests, and it worked just like the target-based tests but with more features. Unfortunately, this is not the case. While care has been taken to keep them as close a possible, there are a few known inconsistencies that we're still ironing out. For example, the logging messages in the target-based tests are cached internally and associated with the running test case. They can be saved later as part of the reporting lib. This isn't currently possible with host-based. Only the assertion failures are logged. We will continue trying to make these as similar as possible. Unit Test Location/Layout Rules \u00b6 Code/Test Location Host-Based Unit Tests for a Library/Protocol/PPI/GUID Interface If what's being tested is an interface (e.g. a library with a public header file, like DebugLib), the test should be scoped to the parent package. Example: MdePkg/Test/UnitTest/[Library/Protocol/Ppi/Guid]/ A real-world example of this is the BaseSafeIntLib test in MdePkg. MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLibHost.inf Host-Based Unit Tests for a Library/Driver (PEI/DXE/SMM) implementation If what's being tested is a specific implementation (e.g. BaseDebugLibSerialPort for DebugLib), the test should be scoped to the implementation directory itself, in a UnitTest subdirectory. Module Example: MdeModulePkg/Universal/EsrtFmpDxe/UnitTest/ Library Example: MdePkg/Library/BaseMemoryLib/UnitTest/ Host-Based Tests for a Functionality or Feature If you're writing a functional test that operates at the module level (i.e. if it's more than a single file or library), the test should be located in the package-level Tests directory under the HostFuncTest subdirectory. For example, if you were writing a test for the entire FMP Device Framework, you might put your test in: FmpDevicePkg/Test/HostFuncTest/FmpDeviceFramework If the feature spans multiple packages, it's location should be determined by the package owners related to the feature. Non-Host-Based (PEI/DXE/SMM/UefiShell) Tests for a Functionality or Feature Similar to Host-Based, if the feature is in one package, should be located in the *Pkg/Test/[UefiShell/Dxe/Smm/Pei]Test directory. If the feature spans multiple packages, it's location should be determined by the package owners related to the feature. USAGE EXAMPLES PEI Example: MP_SERVICE_PPI. Or check MTRR configuration in a notification function. SMM Example: a test in a protocol callback function. (It is different with the solution that SmmAgent+ShellApp) DXE Example: a test in a UEFI event call back to check SPI/SMRAM status. Shell Example: the SMM handler audit test has a shell-based app that interacts with an SMM handler to get information. The SMM paging audit test gathers information about both DXE and SMM. And the SMM paging functional test actually forces errors into SMM via a DXE driver. Example Directory Tree \u00b6 <PackageName>Pkg/ ComponentY/ ComponentY.inf ComponentY.c UnitTest/ ComponentYUnitTestHost.inf # Host-Based Test for Driver Module ComponentYUnitTest.c Library/ GeneralPurposeLibBase/ ... GeneralPurposeLibSerial/ ... SpecificLibDxe/ SpecificLibDxe.c SpecificLibDxe.inf UnitTest/ # Host-Based Test for Specific Library Implementation SpecificLibDxeUnitTest.c SpecificLibDxeUnitTestHost.inf Test/ <Package>HostTest.dsc # Host-Based Test Apps UnitTest/ InterfaceX InterfaceXUnitTestHost.inf # Host-Based App (should be in Test/<Package>HostTest.dsc) InterfaceXUnitTestPei.inf # PEIM Target-Based Test (if applicable) InterfaceXUnitTestDxe.inf # DXE Target-Based Test (if applicable) InterfaceXUnitTestSmm.inf # SMM Target-Based Test (if applicable) InterfaceXUnitTestUefiShell.inf # Shell App Target-Based Test (if applicable) InterfaceXUnitTest.c # Test Logic GeneralPurposeLib/ # Host-Based Test for any implementation of GeneralPurposeLib GeneralPurposeLibTest.c GeneralPurposeLibUnitTestHost.inf <Package>Pkg.dsc # Standard Modules and any Target-Based Test Apps (including in Test/) Future Locations in Consideration \u00b6 We don't know if these types will exist or be applicable yet, but if you write a support library or module that matches the following, please make sure they live in the correct place. Code/Test Location Host-Based Library Implementations Host-Based Implementations of common libraries (eg. MemoryAllocationLibHost) should live in the same package that declares the library interface in its .DEC file in the *Pkg/Test/Library directory. Should have 'Host' in the name. Host-Based Mocks and Stubs Mock and Stub libraries that require test infrastructure should live in the UefiTestFrameworkPkg/Library with either 'Mock' or 'Stub' in the library name. If still in doubt \u00b6 Hop on GitHub and ask @corthon, @mdkinney, or @spbrogan. ;) Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Modules"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unit-test-framework-package","text":"","title":"Unit Test Framework Package"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#about","text":"This package adds a unit test framework capable of building tests for multiple contexts including the UEFI shell environment and host-based environments. It allows for unit test development to focus on the tests and leave error logging, result formatting, context persistance, and test running to the framework. The unit test framework works well for low level unit tests as well as system level tests and fits easily in automation frameworks.","title":"About"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestlib","text":"The main \"framework\" library. The core of the framework is the Framework object, which can have any number of test cases and test suites registered with it. The Framework object is also what drives test execution. The Framework also provides helper macros and functions for checking test conditions and reporting errors. Status and error info will be logged into the test context. There are a number of Assert macros that make the unit test code friendly to view and easy to understand. Finally, the Framework also supports logging strings during the test execution. This data is logged to the test context and will be available in the test reporting phase. This should be used for logging test details and helpful messages to resolve test failures.","title":"UnitTestLib"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestpersistencelib","text":"Persistence lib has the main job of saving and restoring test context to a storage medium so that for tests that require exiting the active process and then resuming state can be maintained. This is critical in supporting a system reboot in the middle of a test run.","title":"UnitTestPersistenceLib"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestresultreportlib","text":"Library provides function to run at the end of a framework test run and handles formatting the report. This is a common customization point and allows the unit test framework to fit its output reports into other test infrastructure. In this package a simple library instances has been supplied to output test results to the console as plain text.","title":"UnitTestResultReportLib"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#samples","text":"There is a sample unit test provided as both an example of how to write a unit test and leverage many of the features of the framework. This sample can be found in the Test/UnitTest/Sample/SampleUnitTest directory. The sample is provided in PEI, SMM, DXE, and UEFI App flavors. It also has a flavor for the HOST_APPLICATION build type, which can be run on a host system without needing a target.","title":"Samples"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#usage","text":"This section is built a lot like a \"Getting Started\". We'll go through some of the components that are needed when constructing a unit test and some of the decisions that are made by the test writer. We'll also describe how to check for expected conditions in test cases and a bit of the logging characteristics. Most of these examples will refer to the SampleUnitTestUefiShell app found in this package.","title":"Usage"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#requirements-inf","text":"In our INF file, we'll need to bring in the UnitTestLib library. Conveniently, the interface header for the UnitTestLib is located in MdePkg , so you shouldn't need to depend on any other packages. As long as your DSC file knows where to find the lib implementation that you want to use, you should be good to go. See this example in 'SampleUnitTestUefiShell.inf'... [Packages] MdePkg/MdePkg.dec [LibraryClasses] UefiApplicationEntryPoint BaseLib DebugLib UnitTestLib PrintLib Also, if you want you test to automatically be picked up by the Test Runner plugin, you will need to make sure that the module BASE_NAME contains the word Test ... [Defines] BASE_NAME = SampleUnitTestUefiShell","title":"Requirements - INF"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#requirements-code","text":"Not to state the obvious, but let's make sure we have the following include before getting too far along... #include <Library/UnitTestLib.h> Now that we've got that squared away, let's look at our 'Main()'' routine (or DriverEntryPoint() or whatever).","title":"Requirements - Code"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#configuring-the-framework","text":"Everything in the UnitTestPkg framework is built around an object called -- conveniently -- the Framework. This Framework object will contain all the information about our test, the test suites and test cases associated with it, the current location within the test pass, and any results that have been recorded so far. To get started with a test, we must first create a Framework instance. The function for this is InitUnitTestFramework . It takes in CHAR8 strings for the long name, short name, and test version. The long name and version strings are just for user presentation and relatively flexible. The short name will be used to name any cache files and/or test results, so should be a name that makes sense in that context. These strings are copied internally to the Framework, so using stack-allocated or literal strings is fine. In the 'SampleUnitTestUefiShell' app, the module name is used as the short name, so the init looks like this. DEBUG (( DEBUG_INFO , \"%a v%a \\n \" , UNIT_TEST_APP_NAME , UNIT_TEST_APP_VERSION )); // // Start setting up the test framework for running the tests. // Status = InitUnitTestFramework ( & Framework , UNIT_TEST_APP_NAME , gEfiCallerBaseName , UNIT_TEST_APP_VERSION ); The &Framework returned here is the handle to the Framework. If it's successfully returned, we can start adding test suites and test cases. Test suites exist purely to help organize test cases and to differentiate the results in reports. If you're writing a small unit test, you can conceivably put all test cases into a single suite. However, if you end up with 20+ test cases, it may be beneficial to organize them according to purpose. You must have at least one test suite, even if it's just a catch-all. The function to create a test suite is CreateUnitTestSuite . It takes in a handle to the Framework object, a CHAR8 string for the suite title and package name, and optional function pointers for a setup function and a teardown function. The suite title is for user presentation. The package name is for xUnit type reporting and uses a '.'-separated hierarchical format (see 'SampleUnitTestApp' for example). If provided, the setup and teardown functions will be called once at the start of the suite (before any tests have run) and once at the end of the suite (after all tests have run), respectively. If either or both of these are unneeded, pass NULL . The function prototypes are UNIT_TEST_SUITE_SETUP and UNIT_TEST_SUITE_TEARDOWN . Looking at 'SampleUnitTestUefiShell' app, you can see that the first test suite is created as below... // // Populate the SimpleMathTests Unit Test Suite. // Status = CreateUnitTestSuite ( & SimpleMathTests , Fw , \"Simple Math Tests\" , \"Sample.Math\" , NULL , NULL ); This test suite has no setup or teardown functions. The &SimpleMathTests returned here is a handle to the suite and will be used when adding test cases. Great! Now we've finished some of the cruft, red tape, and busy work. We're ready to add some tests. Adding a test to a test suite is accomplished with the -- you guessed it -- AddTestCase function. It takes in the suite handle; a CHAR8 string for the description and class name; a function pointer for the test case itself; additional, optional function pointers for prerequisite check and cleanup routines; and and optional pointer to a context structure. Okay, that's a lot. Let's take it one piece at a time. The description and class name strings are very similar in usage to the suite title and package name strings in the test suites. The former is for user presentation and the latter is for xUnit parsing. The test case function pointer is what is actually executed as the \"test\" and the prototype should be UNIT_TEST_FUNCTION . The last three parameters require a little bit more explaining. The prerequisite check function has a prototype of UNIT_TEST_PREREQUISITE and -- if provided -- will be called immediately before the test case. If this function returns any error, the test case will not be run and will be recorded as UNIT_TEST_ERROR_PREREQUISITE_NOT_MET . The cleanup function (prototype UNIT_TEST_CLEANUP ) will be called immediately after the test case to provide an opportunity to reset any global state that may have been changed in the test case. In the event of a prerequisite failure, the cleanup function will also be skipped. If either of these functions is not needed, pass NULL . The context pointer is entirely case-specific. It will be passed to the test case upon execution. One of the purposes of the context pointer is to allow test case reuse with different input data. (Another use is for testing that wraps around a system reboot, but that's beyond the scope of this guide.) The test case must know how to interpret the context pointer, so it could be a simple value, or it could be a complex structure. If unneeded, pass NULL . In 'SampleUnitTestUefiShell' app, the first test case is added using the code below... AddTestCase ( SimpleMathTests , \"Adding 1 to 1 should produce 2\" , \"Addition\" , OnePlusOneShouldEqualTwo , NULL , NULL , NULL ); This test case calls the function OnePlusOneShouldEqualTwo and has no prerequisite, cleanup, or context. Once all the suites and cases are added, it's time to run the Framework. // // Execute the tests. // Status = RunAllTestSuites ( Framework );","title":"Configuring the Framework"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#a-simple-test-case","text":"We'll take a look at the below test case from 'SampleUnitTestApp'... UNIT_TEST_STATUS EFIAPI OnePlusOneShouldEqualTwo ( IN UNIT_TEST_FRAMEWORK_HANDLE Framework , IN UNIT_TEST_CONTEXT Context ) { UINTN A , B , C ; A = 1 ; B = 1 ; C = A + B ; UT_ASSERT_EQUAL ( C , 2 ); return UNIT_TEST_PASSED ; } // OnePlusOneShouldEqualTwo() The prototype for this function matches the UNIT_TEST_FUNCTION prototype. It takes in a handle to the Framework itself and the context pointer. The context pointer could be cast and interpreted as anything within this test case, which is why it's important to configure contexts carefully. The test case returns a value of UNIT_TEST_STATUS , which will be recorded in the Framework and reported at the end of all suites. In this test case, the UT_ASSERT_EQUAL assertion is being used to establish that the business logic has functioned correctly. There are several assertion macros, and you are encouraged to use one that matches as closely to your intended test criterium as possible, because the logging is specific to the macro and more specific macros have more detailed logs. When in doubt, there are always UT_ASSERT_TRUE and UT_ASSERT_FALSE . Assertion macros that fail their test criterium will immediately return from the test case with UNIT_TEST_ERROR_TEST_FAILED and log an error string. Note that this early return can have implications for memory leakage. At the end, if all test criteria pass, you should return UNIT_TEST_PASSED .","title":"A Simple Test Case"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#more-complex-cases","text":"To write more advanced tests, first take a look at all the Assertion and Logging macros provided in the framework. Beyond that, if you're writing host-based tests and want to take a dependency on the UnitTestFrameworkPkg, you can leverage the cmocka.h interface and write tests with all the features of the Cmocka framework. Documentation for Cmocka can be found here: https://api.cmocka.org/","title":"More Complex Cases"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#development","text":"","title":"Development"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#iterating-on-a-single-test","text":"When using the EDK2 Pytools for CI testing, the host-based unit tests will be built and run on any build that includes the NOOPT build target. If you are trying to iterate on a single test, a convenient pattern is to build only that test module. For example, the following command will build only the SafeIntLib host-based test from the MdePkg... stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG = VS2017 -p MdePkg -t NOOPT BUILDMODULE = MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLib.inf","title":"Iterating on a Single Test"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#hooking-baselib","text":"Most unit test mocking can be performed by the functions provided in the UnitTestFramework libraries, but since BaseLib is consumed by the Framework itself, it requires different techniques to substitute parts of the functionality. To solve some of this, the UnitTestFramework consumes a special implementation of BaseLib for host-based tests. This implementation contains a hook table that can be used to substitute test functionality for any of the BaseLib functions. By default, this implementation will use the underlying BaseLib implementation, so the unit test writer only has to supply minimal code to test a particular case.","title":"Hooking BaseLib"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#debugging-the-framework-itself","text":"While most of the tests that are produced by the UnitTestFramework are easy to step through in a debugger, the Framework itself consumes code (mostly Cmocka) that sets its own build flags. These flags cause parts of the Framework to not export symbols and captures exceptions, and as such are harder to debug. We have provided a Stuart parameter to force symbolic debugging to be enabled. You can run a build by adding the BLD_*_UNIT_TESTING_DEBUG=TRUE parameter to enable this build option. stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 -p MdePkg -t NOOPT BLD_*_UNIT_TESTING_DEBUG = TRUE","title":"Debugging the Framework Itself"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#building-and-running-host-based-tests","text":"The EDK2 CI infrastructure provides a convenient way to run all host-based tests -- in the the entire tree or just selected packages -- and aggregate all the the reports, including highlighting any failures. This functionality is provided through the Stuart build system (published by EDK2-PyTools) and the NOOPT build target.","title":"Building and Running Host-Based Tests"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#building-locally","text":"First, to make sure you're working with the latest PyTools, run the following command: # Would recommend to run this in a Python venv, but that's out of scope for this doc. python -m pip install --upgrade -r ./pip-requirements.txt After that, the following commands will set up the build and run the host-based tests. # Setup repo for building # stuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Mu specific step to clone mu repos required for ci check # stuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Update all binary dependencies # stuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> stuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 # Build and run the tests # stuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=<GCC5, VS2019, etc.> -t NOOPT [-p <Package Name>] stuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG = VS2019 -t NOOPT -p MdePkg","title":"Building Locally"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#evaluating-the-results","text":"In your immediate output, any build failures will be highlighted. You can see these below as \"WARNING\" and \"ERROR\" messages. (edk_env) PS C:\\_uefi\\edk2> stuart_ci_build -c .\\.pytool\\CISettings.py TOOL_CHAIN_TAG=VS2019 -t NOOPT -p MdePkg SECTION - Init SDE SECTION - Loading Plugins SECTION - Start Invocable Tool SECTION - Getting Environment SECTION - Loading plugins SECTION - Building MdePkg Package PROGRESS - --Running MdePkg: Host Unit Test Compiler Plugin NOOPT -- WARNING - Allowing Override for key TARGET_ARCH PROGRESS - Start time: 2020-07-27 17:18:08.521672 PROGRESS - Setting up the Environment PROGRESS - Running Pre Build PROGRESS - Running Build NOOPT PROGRESS - Running Post Build SECTION - Run Host based Unit Tests SUBSECTION - Testing for architecture: X64 WARNING - TestBaseSafeIntLibHost.exe Test Failed WARNING - Test SafeInt8ToUint8 - UT_ASSERT_EQUAL(0x5b:5b, Result:5c) c:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure! ERROR - Plugin Failed: Host-Based Unit Test Runner returned 1 CRITICAL - Post Build failed PROGRESS - End time: 2020-07-27 17:18:19.792313 Total time Elapsed: 0:00:11 ERROR - --->Test Failed: Host Unit Test Compiler Plugin NOOPT returned 1 ERROR - Overall Build Status: Error PROGRESS - There were 1 failures out of 1 attempts SECTION - Summary ERROR - Error (edk_env) PS C:\\_uefi\\edk2> If a test fails, you can run it manually to get more details... (edk_env) PS C:\\_uefi\\edk2> .\\Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe Int Safe Lib Unit Test Application v0.1 --------------------------------------------------------- ------------ RUNNING ALL TEST SUITES -------------- --------------------------------------------------------- --------------------------------------------------------- RUNNING TEST SUITE: Int Safe Conversions Test Suite --------------------------------------------------------- [==========] Running 71 test(s). [ RUN ] Test SafeInt8ToUint8 [ ERROR ] --- UT_ASSERT_EQUAL(0x5b:5b, Result:5c) [ LINE ] --- c:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure! [ FAILED ] Test SafeInt8ToUint8 [ RUN ] Test SafeInt8ToUint16 [ OK ] Test SafeInt8ToUint16 [ RUN ] Test SafeInt8ToUint32 [ OK ] Test SafeInt8ToUint32 [ RUN ] Test SafeInt8ToUintn [ OK ] Test SafeInt8ToUintn ... You can also, if you are so inclined, read the output from the exact instance of the test that was run during stuart_ci_build . The ouput file can be found on a path that looks like: Build/<Package>/HostTest/<Arch>/<TestName>.<TestSuiteName>.<Arch>.result.xml A sample of this output looks like: <!-- Excerpt taken from: Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe.Int Safe Conversions Test Suite.X64.result.xml --> <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <testsuites> <testsuite name= \"Int Safe Conversions Test Suite\" time= \"0.000\" tests= \"71\" failures= \"1\" errors= \"0\" skipped= \"0\" > <testcase name= \"Test SafeInt8ToUint8\" time= \"0.000\" > <failure> <![CDATA[UT_ASSERT_EQUAL(0x5c:5c, Result:5b) c:\\_uefi\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure!]]> </failure> </testcase> <testcase name= \"Test SafeInt8ToUint16\" time= \"0.000\" > </testcase> <testcase name= \"Test SafeInt8ToUint32\" time= \"0.000\" > </testcase> <testcase name= \"Test SafeInt8ToUintn\" time= \"0.000\" > </testcase>","title":"Evaluating the Results"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#xml-reporting-mode","text":"Since these applications are built using the CMocka framework, they can also use the following env variables to output in a structured XML rather than text: CMOCKA_MESSAGE_OUTPUT=xml CMOCKA_XML_FILE=<absolute or relative path to output file> This mode is used by the test running plugin to aggregate the results for CI test status reporting in the web view.","title":"XML Reporting Mode"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#code-coverage","text":"Host based Unit Tests will automatically include GCC build flags to enable coverage data. This is primarily leveraged for pipeline builds, but this can be leveraged locally using the lcov linux tool, and parsed using the lcov_cobertura python tool. pycobertura is used to covert this coverage data to a human readable HTML file. These tools must be installed to parse code coverage. sudo apt-get install -y lcov pip install lcov_cobertura pip install pycobertura During CI builds, use the CODE_COVERAGE=TRUE flag to generate the code coverage XML files, and additionally use the CC_HTML=TRUE flag to generate the HTML file. This will be generated in Build/coverage.html. There is currently no official guidance or support for code coverage when compiling in Visual Studio at this time.","title":"Code Coverage"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#important-note","text":"This works on both Windows and Linux, but is currently limited to x64 architectures. Working on getting others, but we also welcome contributions.","title":"Important Note"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#known-limitations","text":"","title":"Known Limitations"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#pei-dxe-smm","text":"While sample tests have been provided for these execution environments, only cursory build validation has been performed. Care has been taken while designing the frameworks to allow for execution during boot phases, but only UEFI Shell and host-based tests have been thoroughly evaluated. Full support for PEI, DXE, and SMM is forthcoming, but should be considered beta/staging for now.","title":"PEI, DXE, SMM"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#host-based-support-vs-other-tests","text":"The host-based test framework is powered internally by the Cmocka framework. As such, it has abilities that the target-based tests don't (yet). It would be awesome if this meant that it was a super set of the target-based tests, and it worked just like the target-based tests but with more features. Unfortunately, this is not the case. While care has been taken to keep them as close a possible, there are a few known inconsistencies that we're still ironing out. For example, the logging messages in the target-based tests are cached internally and associated with the running test case. They can be saved later as part of the reporting lib. This isn't currently possible with host-based. Only the assertion failures are logged. We will continue trying to make these as similar as possible.","title":"Host-Based Support vs Other Tests"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unit-test-locationlayout-rules","text":"Code/Test Location Host-Based Unit Tests for a Library/Protocol/PPI/GUID Interface If what's being tested is an interface (e.g. a library with a public header file, like DebugLib), the test should be scoped to the parent package. Example: MdePkg/Test/UnitTest/[Library/Protocol/Ppi/Guid]/ A real-world example of this is the BaseSafeIntLib test in MdePkg. MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLibHost.inf Host-Based Unit Tests for a Library/Driver (PEI/DXE/SMM) implementation If what's being tested is a specific implementation (e.g. BaseDebugLibSerialPort for DebugLib), the test should be scoped to the implementation directory itself, in a UnitTest subdirectory. Module Example: MdeModulePkg/Universal/EsrtFmpDxe/UnitTest/ Library Example: MdePkg/Library/BaseMemoryLib/UnitTest/ Host-Based Tests for a Functionality or Feature If you're writing a functional test that operates at the module level (i.e. if it's more than a single file or library), the test should be located in the package-level Tests directory under the HostFuncTest subdirectory. For example, if you were writing a test for the entire FMP Device Framework, you might put your test in: FmpDevicePkg/Test/HostFuncTest/FmpDeviceFramework If the feature spans multiple packages, it's location should be determined by the package owners related to the feature. Non-Host-Based (PEI/DXE/SMM/UefiShell) Tests for a Functionality or Feature Similar to Host-Based, if the feature is in one package, should be located in the *Pkg/Test/[UefiShell/Dxe/Smm/Pei]Test directory. If the feature spans multiple packages, it's location should be determined by the package owners related to the feature. USAGE EXAMPLES PEI Example: MP_SERVICE_PPI. Or check MTRR configuration in a notification function. SMM Example: a test in a protocol callback function. (It is different with the solution that SmmAgent+ShellApp) DXE Example: a test in a UEFI event call back to check SPI/SMRAM status. Shell Example: the SMM handler audit test has a shell-based app that interacts with an SMM handler to get information. The SMM paging audit test gathers information about both DXE and SMM. And the SMM paging functional test actually forces errors into SMM via a DXE driver.","title":"Unit Test Location/Layout Rules"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#example-directory-tree","text":"<PackageName>Pkg/ ComponentY/ ComponentY.inf ComponentY.c UnitTest/ ComponentYUnitTestHost.inf # Host-Based Test for Driver Module ComponentYUnitTest.c Library/ GeneralPurposeLibBase/ ... GeneralPurposeLibSerial/ ... SpecificLibDxe/ SpecificLibDxe.c SpecificLibDxe.inf UnitTest/ # Host-Based Test for Specific Library Implementation SpecificLibDxeUnitTest.c SpecificLibDxeUnitTestHost.inf Test/ <Package>HostTest.dsc # Host-Based Test Apps UnitTest/ InterfaceX InterfaceXUnitTestHost.inf # Host-Based App (should be in Test/<Package>HostTest.dsc) InterfaceXUnitTestPei.inf # PEIM Target-Based Test (if applicable) InterfaceXUnitTestDxe.inf # DXE Target-Based Test (if applicable) InterfaceXUnitTestSmm.inf # SMM Target-Based Test (if applicable) InterfaceXUnitTestUefiShell.inf # Shell App Target-Based Test (if applicable) InterfaceXUnitTest.c # Test Logic GeneralPurposeLib/ # Host-Based Test for any implementation of GeneralPurposeLib GeneralPurposeLibTest.c GeneralPurposeLibUnitTestHost.inf <Package>Pkg.dsc # Standard Modules and any Target-Based Test Apps (including in Test/)","title":"Example Directory Tree"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#future-locations-in-consideration","text":"We don't know if these types will exist or be applicable yet, but if you write a support library or module that matches the following, please make sure they live in the correct place. Code/Test Location Host-Based Library Implementations Host-Based Implementations of common libraries (eg. MemoryAllocationLibHost) should live in the same package that declares the library interface in its .DEC file in the *Pkg/Test/Library directory. Should have 'Host' in the name. Host-Based Mocks and Stubs Mock and Stub libraries that require test infrastructure should live in the UefiTestFrameworkPkg/Library with either 'Mock' or 'Stub' in the library name.","title":"Future Locations in Consideration"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#if-still-in-doubt","text":"Hop on GitHub and ask @corthon, @mdkinney, or @spbrogan. ;)","title":"If still in doubt"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/","text":"Character Encoding Check Plugin \u00b6 This CiBuildPlugin scans all the files in a package to make sure each file is correctly encoded and all characters can be read. Improper encoding causes tools to fail in some situations especially in different locals. Configuration \u00b6 The plugin can be configured to ignore certain files. \"CharEncodingCheck\" : { \"IgnoreFiles\" : [] } IgnoreFiles \u00b6 OPTIONAL List of file to ignore.","title":"Char Encoding Check"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/#character-encoding-check-plugin","text":"This CiBuildPlugin scans all the files in a package to make sure each file is correctly encoded and all characters can be read. Improper encoding causes tools to fail in some situations especially in different locals.","title":"Character Encoding Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/#configuration","text":"The plugin can be configured to ignore certain files. \"CharEncodingCheck\" : { \"IgnoreFiles\" : [] }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/#ignorefiles","text":"OPTIONAL List of file to ignore.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/","text":"Compiler Plugin \u00b6 This CiBuildPlugin compiles the package DSC from the package being tested. Configuration \u00b6 The package relative path of the DSC file to build. \"CompilerPlugin\" : { \"DscPath\" : \"<path to dsc from root of pkg>\" } DscPath \u00b6 Package relative path to the DSC file to build.","title":"Compiler Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/#compiler-plugin","text":"This CiBuildPlugin compiles the package DSC from the package being tested.","title":"Compiler Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/#configuration","text":"The package relative path of the DSC file to build. \"CompilerPlugin\" : { \"DscPath\" : \"<path to dsc from root of pkg>\" }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/#dscpath","text":"Package relative path to the DSC file to build.","title":"DscPath"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/","text":"Debug Macro Check \u00b6 This Python application scans all files in a build package for debug macro formatting issues. It is intended to be a fundamental build-time check that is part of a normal developer build process to catch errors right away. As a build plugin, it is capable of finding these errors early in the development process after code is initially written to ensure that all code tested is free of debug macro formatting errors. These errors often creep into debug prints in error conditions that are not frequently executed making debug even more difficult and confusing when they are encountered. In other cases, debug macros with these errors in the main code path can lead to unexpected behavior when executed. As a standalone script, it can be easily run manually or integrated into other CI processes. The plugin is part of a set of debug macro check scripts meant to be relatively portable so they can be applied to additional code bases with minimal effort. 1. BuildPlugin/DebugMacroCheckBuildPlugin.py \u00b6 This is the build plugin. It is discovered within the Stuart Self-Describing Environment (SDE) due to the accompanying file DebugMacroCheck_plugin_in.yaml . Since macro errors are considered a coding bug that should be found and fixed during the build phase of the developer process (before debug and testing), this plugin is run in pre-build. It will run within the scope of the package being compiled. For a platform build, this means it will run against the package being built. In a CI build, it will run in pre-build for each package as each package is built. The build plugin has the following attributes: Registered at global scope. This means it will always run. Called only on compilable build targets (i.e. does nothing on \"NO-TARGET\" ). Runs as a pre-build step. This means it gives results right away to ensure compilation follows on a clean slate. This also means it runs in platform build and CI. It is run in CI as a pre-build step when the CompilerPlugin compiles code. This ensures even if the plugin was not run locally, all code submissions have been checked. Reports any errors in the build log and fails the build upon error making it easy to discover problems. Supports two methods of configuration via \"substitution strings\": By setting a build variable called DEBUG_MACRO_CHECK_SUB_FILE with the name of a substitution YAML file to use. Example: shell_environment . GetBuildVars () . SetValue ( \"DEBUG_MACRO_CHECK_SUB_FILE\" , os . path . join ( self . GetWorkspaceRoot (), \"DebugMacroCheckSub.yaml\" ), \"Set in CISettings.py\" ) Substitution File Content Example: --- # OvmfPkg/CpuHotplugSmm/ApicId.h # Reason: Substitute with macro value FMT_APIC_ID : 0x%08x # DynamicTablesPkg/Include/ConfigurationManagerObject.h # Reason: Substitute with macro value FMT_CM_OBJECT_ID : 0x%lx # OvmfPkg/IntelTdx/TdTcg2Dxe/TdTcg2Dxe.c # Reason: Acknowledging use of two format specifiers in string with one argument # Replace ternary operator in debug string with single specifier 'Index == COLUME_SIZE/2 ? \" | %02x\" : \" %02x\"' : \"%d\" # DynamicTablesPkg/Library/Common/TableHelperLib/ConfigurationManagerObjectParser.c # ShellPkg/Library/UefiShellAcpiViewCommandLib/AcpiParser.c # Reason: Acknowledge that string *should* expand to one specifier # Replace variable with expected number of specifiers (1) Parser[Index].Format : \"%d\" By entering the string substitutions directory into a dictionary called StringSubstitutions in a DebugMacroCheck section of the package CI YAML file. Example: \"DebugMacroCheck\" : { \"StringSubstitutions\" : { \"SUB_A\" : \"%Lx\" } } Debug Macro Check Build Plugin: Simple Disable \u00b6 The build plugin can simply be disabled by setting an environment variable named \"DISABLE_DEBUG_MACRO_CHECK\" . The plugin is disabled on existence of the variable. The contents of the variable are not inspected at this time. 2. DebugMacroCheck.py \u00b6 This is the main Python module containing the implementation logic. The build plugin simply wraps around it. When first running debug macro check against a new, large code base, it is recommended to first run this standalone script and address all of the issues and then enable the build plugin. The module supports a number of configuration parameters to ease debug of errors and to provide flexibility for different build environments. EDK 2 PyTool Library Dependency \u00b6 This script has minimal library dependencies. However, it has one dependency you might not be familiar with on the Tianocore EDK 2 PyTool Library (edk2toollib): from edk2toollib.utility_functions import RunCmd You simply need to install the following pip module to use this library: edk2-pytool-library (e.g. pip install edk2-pytool-library ) More information is available here: PyPI page: edk2-pytool-library GitHub repo: tianocore/edk2-pytool-library If you strongly prefer not including this additional dependency, the functionality imported here is relatively simple to substitute with the Python subprocess built-in module. Examples \u00b6 Simple run against current directory: > python DebugMacroCheck.py -w . Simple run against a single file: > python DebugMacroCheck.py -i filename.c Run against a directory with output placed into a file called \"debug_macro_check.log\": > python DebugMacroCheck.py -w . -l Run against a directory with output placed into a file called \"custom.log\" and debug log messages enabled: > python DebugMacroCheck.py -w . -l custom.log -v Run against a directory with output placed into a file called \"custom.log\", with debug log messages enabled including python script function and line number, use a substitution file called \"file_sub.yaml\", do not show the progress bar, and run against .c and .h files: > python DebugMacroCheck.py -w . -l custom.log -vv -s file_sub.yaml -n -e .c .h Note : It is normally not recommended to run against .h files as they and many other non-.c files normally do not have full DEBUG macro prints. usage: Debug Macro Checker [-h] (-w WORKSPACE_DIRECTORY | -i [INPUT_FILE]) [-l [LOG_FILE]] [-s SUBSTITUTION_FILE] [-v] [-n] [-q] [-u] [-df] [-ds] [-e [EXTENSIONS ...]] Checks for debug macro formatting errors within files recursively located within a given directory. options: -h, --help show this help message and exit -w WORKSPACE_DIRECTORY, --workspace-directory WORKSPACE_DIRECTORY Directory of source files to check. -i [INPUT_FILE], --input-file [INPUT_FILE] File path for an input file to check. Note that some other options do not apply if a single file is specified such as the git options and file extensions. -e [EXTENSIONS ...], --extensions [EXTENSIONS ...] List of file extensions to include. (default: ['.c']) Optional input and output: -l [LOG_FILE], --log-file [LOG_FILE] File path for log output. (default: if the flag is given with no file path then a file called debug_macro_check.log is created and used in the current directory) -s SUBSTITUTION_FILE, --substitution-file SUBSTITUTION_FILE A substitution YAML file specifies string substitutions to perform within the debug macro. This is intended to be a simple mechanism to expand the rare cases of pre-processor macros without directly involving the pre-processor. The file consists of one or more string value pairs where the key is the identifier to replace and the value is the value to replace it with. This can also be used as a method to ignore results by replacing the problematic string with a different string. -v, --verbose-log-file Set file logging verbosity level. - None: Info & > level messages - '-v': + Debug level messages - '-vv': + File name and function - '-vvv': + Line number - '-vvvv': + Timestamp (default: verbose logging is not enabled) -n, --no-progress-bar Disables progress bars. (default: progress bars are used in some places to show progress) -q, --quiet Disables console output. (default: console output is enabled) -u, --utf8w Shows warnings for file UTF-8 decode errors. (default: UTF-8 decode errors are not shown) Optional git control: -df, --do-not-ignore-git-ignore-files Do not ignore git ignored files. (default: files in git ignore files are ignored) -ds, --do-not-ignore-git_submodules Do not ignore files in git submodules. (default: files in git submodules are ignored) String Substitutions \u00b6 DebugMacroCheck currently runs separate from the compiler toolchain. This has the advantage that it is very portable and can run early in the build process, but it also means pre-processor macro expansion does not happen when it is invoked. In practice, it has been very rare that this is an issue for how most debug macros are written. In case it is, a substitution file can be used to inform DebugMacroCheck about the string substitution the pre-processor would perform. This pattern should be taken as a warning. It is just as difficult for humans to keep debug macro specifiers and arguments balanced as it is for DebugMacroCheck pre-processor macro substitution is used. By separating the string from the actual arguments provided, it is more likely for developers to make mistakes matching print specifiers in the string to the arguments. If usage is reasonable, a string substitution can be used as needed. Ignoring Errors \u00b6 Since substitution files perform a straight textual substitution in macros discovered, it can be used to replace problematic text with text that passes allowing errors to be ignored. Python Version Required (3.10) \u00b6 This script is written to take advantage of new Python language features in Python 3.10. If you are not using Python 3.10 or later, you can: Upgrade to Python 3.10 or greater Run this script in a virtual environment with Python 3.10 or greater Customize the script for compatibility with your Python version These are listed in order of recommendation. (1) is the simplest option and will upgrade your environment to a newer, safer, and better Python experience. (2) is the simplest approach to isolate dependencies to what is needed to run this script without impacting the rest of your system environment. (3) creates a one-off fork of the script that, by nature, has a limited lifespan and will make accepting future updates difficult but can be done with relatively minimal effort back to recent Python 3 releases.","title":"Debug Macro Check"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#debug-macro-check","text":"This Python application scans all files in a build package for debug macro formatting issues. It is intended to be a fundamental build-time check that is part of a normal developer build process to catch errors right away. As a build plugin, it is capable of finding these errors early in the development process after code is initially written to ensure that all code tested is free of debug macro formatting errors. These errors often creep into debug prints in error conditions that are not frequently executed making debug even more difficult and confusing when they are encountered. In other cases, debug macros with these errors in the main code path can lead to unexpected behavior when executed. As a standalone script, it can be easily run manually or integrated into other CI processes. The plugin is part of a set of debug macro check scripts meant to be relatively portable so they can be applied to additional code bases with minimal effort.","title":"Debug Macro Check"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#1-buildplugindebugmacrocheckbuildpluginpy","text":"This is the build plugin. It is discovered within the Stuart Self-Describing Environment (SDE) due to the accompanying file DebugMacroCheck_plugin_in.yaml . Since macro errors are considered a coding bug that should be found and fixed during the build phase of the developer process (before debug and testing), this plugin is run in pre-build. It will run within the scope of the package being compiled. For a platform build, this means it will run against the package being built. In a CI build, it will run in pre-build for each package as each package is built. The build plugin has the following attributes: Registered at global scope. This means it will always run. Called only on compilable build targets (i.e. does nothing on \"NO-TARGET\" ). Runs as a pre-build step. This means it gives results right away to ensure compilation follows on a clean slate. This also means it runs in platform build and CI. It is run in CI as a pre-build step when the CompilerPlugin compiles code. This ensures even if the plugin was not run locally, all code submissions have been checked. Reports any errors in the build log and fails the build upon error making it easy to discover problems. Supports two methods of configuration via \"substitution strings\": By setting a build variable called DEBUG_MACRO_CHECK_SUB_FILE with the name of a substitution YAML file to use. Example: shell_environment . GetBuildVars () . SetValue ( \"DEBUG_MACRO_CHECK_SUB_FILE\" , os . path . join ( self . GetWorkspaceRoot (), \"DebugMacroCheckSub.yaml\" ), \"Set in CISettings.py\" ) Substitution File Content Example: --- # OvmfPkg/CpuHotplugSmm/ApicId.h # Reason: Substitute with macro value FMT_APIC_ID : 0x%08x # DynamicTablesPkg/Include/ConfigurationManagerObject.h # Reason: Substitute with macro value FMT_CM_OBJECT_ID : 0x%lx # OvmfPkg/IntelTdx/TdTcg2Dxe/TdTcg2Dxe.c # Reason: Acknowledging use of two format specifiers in string with one argument # Replace ternary operator in debug string with single specifier 'Index == COLUME_SIZE/2 ? \" | %02x\" : \" %02x\"' : \"%d\" # DynamicTablesPkg/Library/Common/TableHelperLib/ConfigurationManagerObjectParser.c # ShellPkg/Library/UefiShellAcpiViewCommandLib/AcpiParser.c # Reason: Acknowledge that string *should* expand to one specifier # Replace variable with expected number of specifiers (1) Parser[Index].Format : \"%d\" By entering the string substitutions directory into a dictionary called StringSubstitutions in a DebugMacroCheck section of the package CI YAML file. Example: \"DebugMacroCheck\" : { \"StringSubstitutions\" : { \"SUB_A\" : \"%Lx\" } }","title":"1. BuildPlugin/DebugMacroCheckBuildPlugin.py"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#debug-macro-check-build-plugin-simple-disable","text":"The build plugin can simply be disabled by setting an environment variable named \"DISABLE_DEBUG_MACRO_CHECK\" . The plugin is disabled on existence of the variable. The contents of the variable are not inspected at this time.","title":"Debug Macro Check Build Plugin: Simple Disable"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#2-debugmacrocheckpy","text":"This is the main Python module containing the implementation logic. The build plugin simply wraps around it. When first running debug macro check against a new, large code base, it is recommended to first run this standalone script and address all of the issues and then enable the build plugin. The module supports a number of configuration parameters to ease debug of errors and to provide flexibility for different build environments.","title":"2. DebugMacroCheck.py"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#edk-2-pytool-library-dependency","text":"This script has minimal library dependencies. However, it has one dependency you might not be familiar with on the Tianocore EDK 2 PyTool Library (edk2toollib): from edk2toollib.utility_functions import RunCmd You simply need to install the following pip module to use this library: edk2-pytool-library (e.g. pip install edk2-pytool-library ) More information is available here: PyPI page: edk2-pytool-library GitHub repo: tianocore/edk2-pytool-library If you strongly prefer not including this additional dependency, the functionality imported here is relatively simple to substitute with the Python subprocess built-in module.","title":"EDK 2 PyTool Library Dependency"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#examples","text":"Simple run against current directory: > python DebugMacroCheck.py -w . Simple run against a single file: > python DebugMacroCheck.py -i filename.c Run against a directory with output placed into a file called \"debug_macro_check.log\": > python DebugMacroCheck.py -w . -l Run against a directory with output placed into a file called \"custom.log\" and debug log messages enabled: > python DebugMacroCheck.py -w . -l custom.log -v Run against a directory with output placed into a file called \"custom.log\", with debug log messages enabled including python script function and line number, use a substitution file called \"file_sub.yaml\", do not show the progress bar, and run against .c and .h files: > python DebugMacroCheck.py -w . -l custom.log -vv -s file_sub.yaml -n -e .c .h Note : It is normally not recommended to run against .h files as they and many other non-.c files normally do not have full DEBUG macro prints. usage: Debug Macro Checker [-h] (-w WORKSPACE_DIRECTORY | -i [INPUT_FILE]) [-l [LOG_FILE]] [-s SUBSTITUTION_FILE] [-v] [-n] [-q] [-u] [-df] [-ds] [-e [EXTENSIONS ...]] Checks for debug macro formatting errors within files recursively located within a given directory. options: -h, --help show this help message and exit -w WORKSPACE_DIRECTORY, --workspace-directory WORKSPACE_DIRECTORY Directory of source files to check. -i [INPUT_FILE], --input-file [INPUT_FILE] File path for an input file to check. Note that some other options do not apply if a single file is specified such as the git options and file extensions. -e [EXTENSIONS ...], --extensions [EXTENSIONS ...] List of file extensions to include. (default: ['.c']) Optional input and output: -l [LOG_FILE], --log-file [LOG_FILE] File path for log output. (default: if the flag is given with no file path then a file called debug_macro_check.log is created and used in the current directory) -s SUBSTITUTION_FILE, --substitution-file SUBSTITUTION_FILE A substitution YAML file specifies string substitutions to perform within the debug macro. This is intended to be a simple mechanism to expand the rare cases of pre-processor macros without directly involving the pre-processor. The file consists of one or more string value pairs where the key is the identifier to replace and the value is the value to replace it with. This can also be used as a method to ignore results by replacing the problematic string with a different string. -v, --verbose-log-file Set file logging verbosity level. - None: Info & > level messages - '-v': + Debug level messages - '-vv': + File name and function - '-vvv': + Line number - '-vvvv': + Timestamp (default: verbose logging is not enabled) -n, --no-progress-bar Disables progress bars. (default: progress bars are used in some places to show progress) -q, --quiet Disables console output. (default: console output is enabled) -u, --utf8w Shows warnings for file UTF-8 decode errors. (default: UTF-8 decode errors are not shown) Optional git control: -df, --do-not-ignore-git-ignore-files Do not ignore git ignored files. (default: files in git ignore files are ignored) -ds, --do-not-ignore-git_submodules Do not ignore files in git submodules. (default: files in git submodules are ignored)","title":"Examples"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#string-substitutions","text":"DebugMacroCheck currently runs separate from the compiler toolchain. This has the advantage that it is very portable and can run early in the build process, but it also means pre-processor macro expansion does not happen when it is invoked. In practice, it has been very rare that this is an issue for how most debug macros are written. In case it is, a substitution file can be used to inform DebugMacroCheck about the string substitution the pre-processor would perform. This pattern should be taken as a warning. It is just as difficult for humans to keep debug macro specifiers and arguments balanced as it is for DebugMacroCheck pre-processor macro substitution is used. By separating the string from the actual arguments provided, it is more likely for developers to make mistakes matching print specifiers in the string to the arguments. If usage is reasonable, a string substitution can be used as needed.","title":"String Substitutions"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#ignoring-errors","text":"Since substitution files perform a straight textual substitution in macros discovered, it can be used to replace problematic text with text that passes allowing errors to be ignored.","title":"Ignoring Errors"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#python-version-required-310","text":"This script is written to take advantage of new Python language features in Python 3.10. If you are not using Python 3.10 or later, you can: Upgrade to Python 3.10 or greater Run this script in a virtual environment with Python 3.10 or greater Customize the script for compatibility with your Python version These are listed in order of recommendation. (1) is the simplest option and will upgrade your environment to a newer, safer, and better Python experience. (2) is the simplest approach to isolate dependencies to what is needed to run this script without impacting the rest of your system environment. (3) creates a one-off fork of the script that, by nature, has a limited lifespan and will make accepting future updates difficult but can be done with relatively minimal effort back to recent Python 3 releases.","title":"Python Version Required (3.10)"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/","text":"Depdendency Check Plugin \u00b6 A CiBuildPlugin that finds all modules (inf files) in a package and reviews the packages used to confirm they are acceptable. This is to help enforce layering and identify improper dependencies between packages. Configuration \u00b6 The plugin must be configured with the acceptabe package dependencies for the package. \"DependencyCheck\" : { \"AcceptableDependencies\" : [], \"AcceptableDependencies-<MODULE_TYPE>\" : [], \"IgnoreInf\" : [] } AcceptableDependencies \u00b6 Package dec files that are allowed in all INFs. Example: MdePkg/MdePkg.dec AcceptableDependencies- \u00b6 OPTIONAL Package dependencies for INFs that have module type . Example: AcceptableDependencies-HOST_APPLICATION. IgnoreInf \u00b6 OPTIONAL list of INFs to ignore for this dependency check.","title":"Dependency Check"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#depdendency-check-plugin","text":"A CiBuildPlugin that finds all modules (inf files) in a package and reviews the packages used to confirm they are acceptable. This is to help enforce layering and identify improper dependencies between packages.","title":"Depdendency Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#configuration","text":"The plugin must be configured with the acceptabe package dependencies for the package. \"DependencyCheck\" : { \"AcceptableDependencies\" : [], \"AcceptableDependencies-<MODULE_TYPE>\" : [], \"IgnoreInf\" : [] }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#acceptabledependencies","text":"Package dec files that are allowed in all INFs. Example: MdePkg/MdePkg.dec","title":"AcceptableDependencies"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#acceptabledependencies-","text":"OPTIONAL Package dependencies for INFs that have module type . Example: AcceptableDependencies-HOST_APPLICATION.","title":"AcceptableDependencies-"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#ignoreinf","text":"OPTIONAL list of INFs to ignore for this dependency check.","title":"IgnoreInf"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/","text":"Dsc Complete Check Plugin \u00b6 This CiBuildPlugin scans all INF files from a package and confirms they are listed in the package level DSC file. The test considers it an error if any INF does not appear in the Components section of the package-level DSC (indicating that it would not be built if the package were built). This is critical because much of the CI infrastructure assumes that all modules will be listed in the DSC and compiled. This test will ignore INFs in the following cases: When MODULE_TYPE = HOST_APPLICATION When a Library instance only supports the HOST_APPLICATION environment Configuration \u00b6 The plugin has a few configuration options to support the UEFI codebase. \"DscCompleteCheck\" : { \"DscPath\" : \"\" , # Path to dsc from root of package \"IgnoreInf\" : [] # Ignore INF if found in filesystem but not dsc } DscPath \u00b6 Path to DSC to consider platform dsc IgnoreInf \u00b6 Ignore error if Inf file is not listed in DSC file","title":"Dsc Complete Check"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#dsc-complete-check-plugin","text":"This CiBuildPlugin scans all INF files from a package and confirms they are listed in the package level DSC file. The test considers it an error if any INF does not appear in the Components section of the package-level DSC (indicating that it would not be built if the package were built). This is critical because much of the CI infrastructure assumes that all modules will be listed in the DSC and compiled. This test will ignore INFs in the following cases: When MODULE_TYPE = HOST_APPLICATION When a Library instance only supports the HOST_APPLICATION environment","title":"Dsc Complete Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#configuration","text":"The plugin has a few configuration options to support the UEFI codebase. \"DscCompleteCheck\" : { \"DscPath\" : \"\" , # Path to dsc from root of package \"IgnoreInf\" : [] # Ignore INF if found in filesystem but not dsc }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#dscpath","text":"Path to DSC to consider platform dsc","title":"DscPath"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#ignoreinf","text":"Ignore error if Inf file is not listed in DSC file","title":"IgnoreInf"},{"location":"dyn/mu_basecore/pytool/Plugin/EccCheck/Readme/","text":"EFI Coding style Check Plugin \u00b6 This CiBuildPlugin finds the Ecc issues of newly added code in pull request. Configuration \u00b6 The plugin can be configured to ignore certain files and issues. \"EccCheck\": { \"ExceptionList\": [], \"IgnoreFiles\": [] }, \"\"\" OPTIONAL List of file to ignore.","title":"Ecc Check"},{"location":"dyn/mu_basecore/pytool/Plugin/EccCheck/Readme/#efi-coding-style-check-plugin","text":"This CiBuildPlugin finds the Ecc issues of newly added code in pull request.","title":"EFI Coding style Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/EccCheck/Readme/#configuration","text":"The plugin can be configured to ignore certain files and issues. \"EccCheck\": { \"ExceptionList\": [], \"IgnoreFiles\": [] }, \"\"\" OPTIONAL List of file to ignore.","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/","text":"Guid Check Plugin \u00b6 This CiBuildPlugin scans all the files in a code tree to find all the GUID definitions. After collection it will then look for duplication in the package under test. Uniqueness of all GUIDs are critical within the UEFI environment. Duplication can cause numerous issues including locating the wrong data structure, calling the wrong function, or decoding the wrong data members. Currently Scanned: INF files are scanned for there Module guid DEC files are scanned for all of their Protocols, PPIs, and Guids as well as the one package GUID. Any GUID value being equal to two names or even just defined in two files is considered an error unless in the ignore list. Any GUID name that is found more than once is an error unless all occurrences are Module GUIDs. Since the Module GUID is assigned to the Module name it is common to have numerous versions of the same module named the same. Configuration \u00b6 The plugin has numerous configuration options to support the UEFI codebase. \"GuidCheck\" : { \"IgnoreGuidName\" : [], \"IgnoreGuidValue\" : [], \"IgnoreFoldersAndFiles\" : [], \"IgnoreDuplicates\" : [] } IgnoreGuidName \u00b6 This list allows strings in two formats. GuidName This will remove any entry with this GuidName from the list of GUIDs therefore ignoring any error associated with this name. GuidName=GuidValue This will also ignore the GUID by name but only if the value equals the GuidValue. GuidValue should be in registry format. This is the suggested format to use as it will limit the ignore to only the defined case. IgnoreGuidValue \u00b6 This list allows strings in guid registry format GuidValue . This will remove any entry with this GuidValue from the list of GUIDs therefore ignoring any error associated with this value. GuidValue must be in registry format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx IgnoreFoldersAndFiles \u00b6 This supports .gitignore file and folder matching strings including wildcards Any folder or file ignored will not be parsed and therefore any GUID defined will be ignored. The plugin will always ignores the following [\"/Build\", \"/Conf\"] IgnoreDuplicates \u00b6 This supports strings in the format of GuidName = GuidName = GuidName For the error with the GuidNames to be ignored the list must match completely with what is found during the code scan. For example if there are two GUIDs that are by design equal within the code tree then it should be GuidName = GuidName If instead there are three GUIDs then it must be GuidName = GuidName = GuidName This is the best ignore list to use because it is the most strict and will catch new problems when new conflicts are introduced. There are numerous places in the UEFI specification in which two GUID names are assigned the same value. These names should be set in this ignore list so that they don't cause an error but any additional duplication would still be caught.","title":"Guid Check"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#guid-check-plugin","text":"This CiBuildPlugin scans all the files in a code tree to find all the GUID definitions. After collection it will then look for duplication in the package under test. Uniqueness of all GUIDs are critical within the UEFI environment. Duplication can cause numerous issues including locating the wrong data structure, calling the wrong function, or decoding the wrong data members. Currently Scanned: INF files are scanned for there Module guid DEC files are scanned for all of their Protocols, PPIs, and Guids as well as the one package GUID. Any GUID value being equal to two names or even just defined in two files is considered an error unless in the ignore list. Any GUID name that is found more than once is an error unless all occurrences are Module GUIDs. Since the Module GUID is assigned to the Module name it is common to have numerous versions of the same module named the same.","title":"Guid Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#configuration","text":"The plugin has numerous configuration options to support the UEFI codebase. \"GuidCheck\" : { \"IgnoreGuidName\" : [], \"IgnoreGuidValue\" : [], \"IgnoreFoldersAndFiles\" : [], \"IgnoreDuplicates\" : [] }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreguidname","text":"This list allows strings in two formats. GuidName This will remove any entry with this GuidName from the list of GUIDs therefore ignoring any error associated with this name. GuidName=GuidValue This will also ignore the GUID by name but only if the value equals the GuidValue. GuidValue should be in registry format. This is the suggested format to use as it will limit the ignore to only the defined case.","title":"IgnoreGuidName"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreguidvalue","text":"This list allows strings in guid registry format GuidValue . This will remove any entry with this GuidValue from the list of GUIDs therefore ignoring any error associated with this value. GuidValue must be in registry format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx","title":"IgnoreGuidValue"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignorefoldersandfiles","text":"This supports .gitignore file and folder matching strings including wildcards Any folder or file ignored will not be parsed and therefore any GUID defined will be ignored. The plugin will always ignores the following [\"/Build\", \"/Conf\"]","title":"IgnoreFoldersAndFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreduplicates","text":"This supports strings in the format of GuidName = GuidName = GuidName For the error with the GuidNames to be ignored the list must match completely with what is found during the code scan. For example if there are two GUIDs that are by design equal within the code tree then it should be GuidName = GuidName If instead there are three GUIDs then it must be GuidName = GuidName = GuidName This is the best ignore list to use because it is the most strict and will catch new problems when new conflicts are introduced. There are numerous places in the UEFI specification in which two GUID names are assigned the same value. These names should be set in this ignore list so that they don't cause an error but any additional duplication would still be caught.","title":"IgnoreDuplicates"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/","text":"Host UnitTest Compiler Plugin \u00b6 A CiBuildPlugin that compiles the dsc for host based unit test apps. An IUefiBuildPlugin may be attached to this plugin that will run the unit tests and collect the results after successful compilation. Configuration \u00b6 The package relative path of the DSC file to build. \"HostUnitTestCompilerPlugin\" : { \"DscPath\" : \"<path to dsc from root of pkg>\" } DscPath \u00b6 Package relative path to the DSC file to build. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Host Unit Test Compiler Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#host-unittest-compiler-plugin","text":"A CiBuildPlugin that compiles the dsc for host based unit test apps. An IUefiBuildPlugin may be attached to this plugin that will run the unit tests and collect the results after successful compilation.","title":"Host UnitTest Compiler Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#configuration","text":"The package relative path of the DSC file to build. \"HostUnitTestCompilerPlugin\" : { \"DscPath\" : \"<path to dsc from root of pkg>\" }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#dscpath","text":"Package relative path to the DSC file to build.","title":"DscPath"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/","text":"Host Unit Test Dsc Complete Check Plugin \u00b6 This CiBuildPlugin scans all INF files from a package for those related to host based unit tests confirms they are listed in the unit test DSC file for the package. The test considers it an error if any INF meeting the requirements does not appear in the Components section of the unit test DSC. This is critical because much of the CI infrastructure assumes that modules will be listed in the DSC and compiled. This test will only require INFs in the following cases: When MODULE_TYPE = HOST_APPLICATION When a Library instance supports the HOST_APPLICATION environment Configuration \u00b6 The plugin has a few configuration options to support the UEFI codebase. \"HostUnitTestDscCompleteCheck\" : { \"DscPath\" : \"\" , # Path to Host based unit test DSC file \"IgnoreInf\" : [] # Ignore INF if found in filesystem but not dsc } DscPath \u00b6 Path to DSC to consider platform dsc IgnoreInf \u00b6 Ignore error if Inf file is not listed in DSC file","title":"Host Unit Test Dsc Complete Check"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#host-unit-test-dsc-complete-check-plugin","text":"This CiBuildPlugin scans all INF files from a package for those related to host based unit tests confirms they are listed in the unit test DSC file for the package. The test considers it an error if any INF meeting the requirements does not appear in the Components section of the unit test DSC. This is critical because much of the CI infrastructure assumes that modules will be listed in the DSC and compiled. This test will only require INFs in the following cases: When MODULE_TYPE = HOST_APPLICATION When a Library instance supports the HOST_APPLICATION environment","title":"Host Unit Test Dsc Complete Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#configuration","text":"The plugin has a few configuration options to support the UEFI codebase. \"HostUnitTestDscCompleteCheck\" : { \"DscPath\" : \"\" , # Path to Host based unit test DSC file \"IgnoreInf\" : [] # Ignore INF if found in filesystem but not dsc }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#dscpath","text":"Path to DSC to consider platform dsc","title":"DscPath"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#ignoreinf","text":"Ignore error if Inf file is not listed in DSC file","title":"IgnoreInf"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/","text":"PECOFF Image Validation - Post Build pe Image Validation Plugin \u00b6 This tool will validate all pe images against a set of tests and their associated requirements as defined below. A configuration file is used to describe different profiles, and their associated requirements. A configuration file path is provided via the command line as PE_VALIDATION_PATH=<PATH> or can be configured in the the PlatformBuild.py within the SetPlatformEnv() method using self.env.SetValue(\"PE_VALIDATION_PATH\", <PATH>, \"Platform Hardcoded\") . A profile is equivalent to the file types defined in the platform's fdf. All profiles must be defined, forcing the developer to acklowedge each, however requirements for each profile do not need to be specified... If one or more requirement does not exist, the \"DEFAULT\" profile requirements will be used. The developer can have default requirements via the \"DEFAULT\" profile then override those requirements in other profiles. An example of a full config file can be seen at the bootom of the readme. Common Errors \u00b6 Profile type is invalid. Exiting... \u00b6 PROFILE_NAME is not specified in the configuration file, but is defined in the platform's fdf. The profile needs to be added to the configuration file, even if the requirements are the same as the DEFAULT requirements. This was a design choice to ensure the platform is not accidently passing due to falling back to the DEFAULT profile if a profile is missing. Test specific failures \u00b6 See the below Tests section for test specific failures. Tests \u00b6 Section Data / Code Separation Verification \u00b6 Description: This test ensures that each section of the binary is not both write-able and execute-able. Sections can only be one or the other (or neither). This test is done by iterating over each section and checking the characteristics label for the Write Mask (0x80000000) and Execute Mask (0x20000000). JSON File Requirements: \"DATA_CODE_SEPARATION\": <True or False> Output: @Success: Only one (or neither) of the two masks (Write, Execute) are present @Fail : Both the Write and Execute flags are present Possible Solution: Update the failed section's characteristics to ensure it is either Write-able or Read-able, but not both. Section Alignment Verification \u00b6 Description: Checks the section alignment value found in the optional header. This value must meet the requirements specified in the config file. JSON File Requirements: An array of dictionaries that contain a Comparison and a value for the particular MachineType and FV file type. See the below example. Can optionally describe an Alignment logic separator when doing multiple comparisons. \"ALIGNMENT_LOGIC_SEP\" : \"OR\" , \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 }, { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] Output: @Success: Image alignment passes all requirements specified in the config file @Warn : Image alignment value is not found in the optional header, or the value is set to 0 @Fail : Image alignment does not meet the requirements specified in the config file Possible Solution: Update the section alignment of the binary to match the requirements specified in the config file. Target Subsystem Type Verification \u00b6 Description: Checks the subsystem value by accessing the optional header, then subsystem value. This value must match the subsystem described in the config file. JSON File Requirements: An updated list of allowed subsystems, using the offical name. See the below example. \"ALLOWED_SUBSYSTEMS\" : [ \"IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\" , \"IMAGE_SUBSYSTEM_EFI_ROM\" ] Output: @Success: Subsystem type found in the optional header matches the subsystem type described in the config file @Warn : Subsystem type is not found in the optional header @Fail : Subsystem type found in the optional header does not match the subsystem type described in the config file Possible Solution: Verify which of the two subsystem type's is incorrect. If it is the subsystem type found in the config file, update the config file. If it is the subsystem type found in the binary, update the machine type in the source code and re-compile. Example \u00b6 \"IMAGE_FILE_MACHINE_ARM64\" : { \"BASE\" : { \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ] }, \"SEC\" : { \"ALIGNMENT\" : [] }, } Writing your own tests \u00b6 If a developer wishes to write their own test, they must implement the interface described in the Test Interface class: class TestInterface : def name ( self ): \"\"\"Returns the name of the test\"\"\" raise NotImplementedError ( \"Must Override Test Interface\" ) def execute ( self , parser , config_data ): \"\"\"Executes the test\"\"\" raise NotImplementedError ( \"Must Override Test Interface\" ) The parser is the parsed pe file that you are testing. Documentation on how to use the parser can be found by looking up the documentation for the pefile module. The config_data provided to the test will is the filtered data from the config file based upon the compilation target and profile. As an example, looking at the above json file, if a pe that is being validated is of type IMAGE_FILE_MACHINE_ARM64 and profile BASE, the config_data provided will be: \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ] The developer also has the ability to provide additional requirements other then ALIGNMENT, and those requirements will also be provided to the test as seen in the below example: \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ], \"OTHER_REQUIREMENT\" : 5 , \"OTHER_REQUIREMENT2\" : { \"Req1\" : 1 , \"Req2\" : 2 } For the test to be executed, provide the test to the test manager using add_test(test) or add_tests(tests) functions Config File Example \u00b6 The config file is used to describe all requirements for the scanned pe file. The configuration data provided to each test is provided to the test by first locating the Compilation Target, then by the optional profile parameter. If no profile parameter is provided, \"DEFAULT\" is used. The current allowed settings are as follows: Top Level Settings \u00b6 TARGET_ARCH \u00b6 This defines a dictionary between the build name using by stuart and the actual Image File Machine Constant name found at https://docs.microsoft.com/en-us/windows/win32/sysinfo/image-file-machine-constants . TARGET_ARCH : { \"<Build Name>\" : \"<Image File Machine Constant>\" } IGNORE_LIST \u00b6 This defines a list of all pe file names that this tool should not execute on. \"IGNORE_LIST\" : [ \"efi1\" , \"efi2\" , \"etc\" ] IMAGE_FILE_MACHINE_XXXX \u00b6 This will be any number of supported Image File Machine Constants that are supported by the build system. This will not be a list (using [ ]), rather a comma separated list of all machine constants. \"IMAGE_FILE_MACHINE_XXX1\" : { \"<Profiles>\" }, \"IMAGE_FILE_MACHINE_XXX2\" : { \"<Profiles>\" }, Machine Level Settings \u00b6 Profiles \u00b6 This will be any number of supported profiles for the particular Image File Machine Constant. This will not be a list (using [ ]), rather a comma separated list of all machine constants. \"Profile1\" : { \"<Settings>\" }, \"Profile2\" : { \"<Settings>\" } Profile Level Settings \u00b6 DATA_CODE_SEPARATION \u00b6 This setting controls if data code separation (cannot be both write and execute) are required for this profile. \"DATA_CODE_SEPARATION\" : <bool> ALLOWED_SUBSYSTEMS \u00b6 This setting allows the developer to specify the type of subsystem the efi should be for a particular profile. Subystems are defined at https://docs.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170 . \"ALLOWED_SUBSYSTEMS\" : [ \"subsystem1\" , \"subsystem2\" , \"etc\" ] ALIGNMENT \u00b6 This setting allows the developer to specify memory alignment requirements for a particular profile as a list of requirements. \"ALIGNMENT\" : [ { \"COMPARISON\" : \"<Comparison Operator>\" , \"VALUE\" : <Value> }, { \"COMPARISON\" : \"<Comparison Operator>\" , \"VALUE\" : <Value> } ] ALIGNMENT_LOGIC_SEP \u00b6 This setting is only used if the alignment requirements specify multiple requirements. It is used to specify how the multiple requirements interact. \"ALIGNMENT_LOGIC_SEP\" : \"<Logical Operator>\" Full Configuration File Example \u00b6 { \"TARGET_ARCH\" : { \"X64\" : \"IMAGE_FILE_MACHINE_AMD64\" , \"IA32\" : \"IMAGE_FILE_MACHINE_I386\" , \"AARCH64\" : \"IMAGE_FILE_MACHINE_ARM64\" , \"ARM\" : \"IMAGE_FILE_MACHINE_ARM\" }, \"IGNORE_LIST\" : [ \"Shell.efi\" ], \"IMAGE_FILE_MACHINE_AMD64\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true , \"ALIGNMENT_LOGIC_SEP\" : \"OR\" , \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 }, { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] }, \"APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ], \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 } ] }, \"UEFI_APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ], \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] } }, \"IMAGE_FILE_MACHINE_ARM\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true } }, \"IMAGE_FILE_MACHINE_ARM64\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true } }, \"IMAGE_FILE_MACHINE_I386\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true , \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 } ] }, \"APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ] } } }","title":"Image Validation"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#pecoff-image-validation-post-build-pe-image-validation-plugin","text":"This tool will validate all pe images against a set of tests and their associated requirements as defined below. A configuration file is used to describe different profiles, and their associated requirements. A configuration file path is provided via the command line as PE_VALIDATION_PATH=<PATH> or can be configured in the the PlatformBuild.py within the SetPlatformEnv() method using self.env.SetValue(\"PE_VALIDATION_PATH\", <PATH>, \"Platform Hardcoded\") . A profile is equivalent to the file types defined in the platform's fdf. All profiles must be defined, forcing the developer to acklowedge each, however requirements for each profile do not need to be specified... If one or more requirement does not exist, the \"DEFAULT\" profile requirements will be used. The developer can have default requirements via the \"DEFAULT\" profile then override those requirements in other profiles. An example of a full config file can be seen at the bootom of the readme.","title":"PECOFF Image Validation - Post Build pe Image Validation Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#common-errors","text":"","title":"Common Errors"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profile-type-is-invalid-exiting","text":"PROFILE_NAME is not specified in the configuration file, but is defined in the platform's fdf. The profile needs to be added to the configuration file, even if the requirements are the same as the DEFAULT requirements. This was a design choice to ensure the platform is not accidently passing due to falling back to the DEFAULT profile if a profile is missing.","title":"Profile type  is invalid. Exiting..."},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#test-specific-failures","text":"See the below Tests section for test specific failures.","title":"Test specific failures"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#tests","text":"","title":"Tests"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#section-data-code-separation-verification","text":"Description: This test ensures that each section of the binary is not both write-able and execute-able. Sections can only be one or the other (or neither). This test is done by iterating over each section and checking the characteristics label for the Write Mask (0x80000000) and Execute Mask (0x20000000). JSON File Requirements: \"DATA_CODE_SEPARATION\": <True or False> Output: @Success: Only one (or neither) of the two masks (Write, Execute) are present @Fail : Both the Write and Execute flags are present Possible Solution: Update the failed section's characteristics to ensure it is either Write-able or Read-able, but not both.","title":"Section Data / Code Separation Verification"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#section-alignment-verification","text":"Description: Checks the section alignment value found in the optional header. This value must meet the requirements specified in the config file. JSON File Requirements: An array of dictionaries that contain a Comparison and a value for the particular MachineType and FV file type. See the below example. Can optionally describe an Alignment logic separator when doing multiple comparisons. \"ALIGNMENT_LOGIC_SEP\" : \"OR\" , \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 }, { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] Output: @Success: Image alignment passes all requirements specified in the config file @Warn : Image alignment value is not found in the optional header, or the value is set to 0 @Fail : Image alignment does not meet the requirements specified in the config file Possible Solution: Update the section alignment of the binary to match the requirements specified in the config file.","title":"Section Alignment Verification"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#target-subsystem-type-verification","text":"Description: Checks the subsystem value by accessing the optional header, then subsystem value. This value must match the subsystem described in the config file. JSON File Requirements: An updated list of allowed subsystems, using the offical name. See the below example. \"ALLOWED_SUBSYSTEMS\" : [ \"IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\" , \"IMAGE_SUBSYSTEM_EFI_ROM\" ] Output: @Success: Subsystem type found in the optional header matches the subsystem type described in the config file @Warn : Subsystem type is not found in the optional header @Fail : Subsystem type found in the optional header does not match the subsystem type described in the config file Possible Solution: Verify which of the two subsystem type's is incorrect. If it is the subsystem type found in the config file, update the config file. If it is the subsystem type found in the binary, update the machine type in the source code and re-compile.","title":"Target Subsystem Type Verification"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#example","text":"\"IMAGE_FILE_MACHINE_ARM64\" : { \"BASE\" : { \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ] }, \"SEC\" : { \"ALIGNMENT\" : [] }, }","title":"Example"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#writing-your-own-tests","text":"If a developer wishes to write their own test, they must implement the interface described in the Test Interface class: class TestInterface : def name ( self ): \"\"\"Returns the name of the test\"\"\" raise NotImplementedError ( \"Must Override Test Interface\" ) def execute ( self , parser , config_data ): \"\"\"Executes the test\"\"\" raise NotImplementedError ( \"Must Override Test Interface\" ) The parser is the parsed pe file that you are testing. Documentation on how to use the parser can be found by looking up the documentation for the pefile module. The config_data provided to the test will is the filtered data from the config file based upon the compilation target and profile. As an example, looking at the above json file, if a pe that is being validated is of type IMAGE_FILE_MACHINE_ARM64 and profile BASE, the config_data provided will be: \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ] The developer also has the ability to provide additional requirements other then ALIGNMENT, and those requirements will also be provided to the test as seen in the below example: \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 }, { \"COMPARISON\" : \"!=\" , \"VALUE\" : 65536 } ], \"OTHER_REQUIREMENT\" : 5 , \"OTHER_REQUIREMENT2\" : { \"Req1\" : 1 , \"Req2\" : 2 } For the test to be executed, provide the test to the test manager using add_test(test) or add_tests(tests) functions","title":"Writing your own tests"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#config-file-example","text":"The config file is used to describe all requirements for the scanned pe file. The configuration data provided to each test is provided to the test by first locating the Compilation Target, then by the optional profile parameter. If no profile parameter is provided, \"DEFAULT\" is used. The current allowed settings are as follows:","title":"Config File Example"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#top-level-settings","text":"","title":"Top Level Settings"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#target_arch","text":"This defines a dictionary between the build name using by stuart and the actual Image File Machine Constant name found at https://docs.microsoft.com/en-us/windows/win32/sysinfo/image-file-machine-constants . TARGET_ARCH : { \"<Build Name>\" : \"<Image File Machine Constant>\" }","title":"TARGET_ARCH"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#ignore_list","text":"This defines a list of all pe file names that this tool should not execute on. \"IGNORE_LIST\" : [ \"efi1\" , \"efi2\" , \"etc\" ]","title":"IGNORE_LIST"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#image_file_machine_xxxx","text":"This will be any number of supported Image File Machine Constants that are supported by the build system. This will not be a list (using [ ]), rather a comma separated list of all machine constants. \"IMAGE_FILE_MACHINE_XXX1\" : { \"<Profiles>\" }, \"IMAGE_FILE_MACHINE_XXX2\" : { \"<Profiles>\" },","title":"IMAGE_FILE_MACHINE_XXXX"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#machine-level-settings","text":"","title":"Machine Level Settings"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profiles","text":"This will be any number of supported profiles for the particular Image File Machine Constant. This will not be a list (using [ ]), rather a comma separated list of all machine constants. \"Profile1\" : { \"<Settings>\" }, \"Profile2\" : { \"<Settings>\" }","title":"Profiles"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profile-level-settings","text":"","title":"Profile Level Settings"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#data_code_separation","text":"This setting controls if data code separation (cannot be both write and execute) are required for this profile. \"DATA_CODE_SEPARATION\" : <bool>","title":"DATA_CODE_SEPARATION"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#allowed_subsystems","text":"This setting allows the developer to specify the type of subsystem the efi should be for a particular profile. Subystems are defined at https://docs.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170 . \"ALLOWED_SUBSYSTEMS\" : [ \"subsystem1\" , \"subsystem2\" , \"etc\" ]","title":"ALLOWED_SUBSYSTEMS"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#alignment","text":"This setting allows the developer to specify memory alignment requirements for a particular profile as a list of requirements. \"ALIGNMENT\" : [ { \"COMPARISON\" : \"<Comparison Operator>\" , \"VALUE\" : <Value> }, { \"COMPARISON\" : \"<Comparison Operator>\" , \"VALUE\" : <Value> } ]","title":"ALIGNMENT"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#alignment_logic_sep","text":"This setting is only used if the alignment requirements specify multiple requirements. It is used to specify how the multiple requirements interact. \"ALIGNMENT_LOGIC_SEP\" : \"<Logical Operator>\"","title":"ALIGNMENT_LOGIC_SEP"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#full-configuration-file-example","text":"{ \"TARGET_ARCH\" : { \"X64\" : \"IMAGE_FILE_MACHINE_AMD64\" , \"IA32\" : \"IMAGE_FILE_MACHINE_I386\" , \"AARCH64\" : \"IMAGE_FILE_MACHINE_ARM64\" , \"ARM\" : \"IMAGE_FILE_MACHINE_ARM\" }, \"IGNORE_LIST\" : [ \"Shell.efi\" ], \"IMAGE_FILE_MACHINE_AMD64\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true , \"ALIGNMENT_LOGIC_SEP\" : \"OR\" , \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 }, { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] }, \"APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ], \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 64 } ] }, \"UEFI_APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ], \"ALIGNMENT\" : [ { \"COMPARISON\" : \"==\" , \"VALUE\" : 32 } ] } }, \"IMAGE_FILE_MACHINE_ARM\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true } }, \"IMAGE_FILE_MACHINE_ARM64\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true } }, \"IMAGE_FILE_MACHINE_I386\" : { \"DEFAULT\" : { \"DATA_CODE_SEPARATION\" : true , \"ALIGNMENT\" : [ { \"COMPARISON\" : \">=\" , \"VALUE\" : 4096 } ] }, \"APPLICATION\" : { \"ALLOWED_SUBSYSTEMS\" : [ \"EFI_APPLICATION\" ] } } }","title":"Full Configuration File Example"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/","text":"Library Class Check Plugin \u00b6 This CiBuildPlugin scans at all library header files found in the Library folders in all of the package's declared include directories and ensures that all files have a matching LibraryClass declaration in the DEC file for the package. Any missing declarations will cause a failure. Configuration \u00b6 The plugin has a few configuration options to support the UEFI codebase. \"LibraryClassCheck\" : { IgnoreHeaderFile : [], # Ignore a file found on disk IgnoreLibraryClass : [] # Ignore a declaration found in dec file } IgnoreHeaderFile \u00b6 Ignore a file found on disk IgnoreLibraryClass \u00b6 Ignore a declaration found in dec file","title":"Library Class Check"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#library-class-check-plugin","text":"This CiBuildPlugin scans at all library header files found in the Library folders in all of the package's declared include directories and ensures that all files have a matching LibraryClass declaration in the DEC file for the package. Any missing declarations will cause a failure.","title":"Library Class Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#configuration","text":"The plugin has a few configuration options to support the UEFI codebase. \"LibraryClassCheck\" : { IgnoreHeaderFile : [], # Ignore a file found on disk IgnoreLibraryClass : [] # Ignore a declaration found in dec file }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#ignoreheaderfile","text":"Ignore a file found on disk","title":"IgnoreHeaderFile"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#ignorelibraryclass","text":"Ignore a declaration found in dec file","title":"IgnoreLibraryClass"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/","text":"License Check Plugin \u00b6 This CiBuildPlugin scans all new added files in a package to make sure code is contributed under BSD-2-Clause-Patent. Configuration \u00b6 The plugin can be configured to ignore certain files. \"LicenseCheck\" : { \"IgnoreFiles\" : [] } IgnoreFiles \u00b6 OPTIONAL List of file to ignore.","title":"License Check"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/#license-check-plugin","text":"This CiBuildPlugin scans all new added files in a package to make sure code is contributed under BSD-2-Clause-Patent.","title":"License Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/#configuration","text":"The plugin can be configured to ignore certain files. \"LicenseCheck\" : { \"IgnoreFiles\" : [] }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/#ignorefiles","text":"OPTIONAL List of file to ignore.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/","text":"Line Ending Check Plugin \u00b6 This CiBuildPlugin scans all the files in a package to verify that the line endings are CRLF. Note: If you encounter a line ending issue found by this plugin, update your development environment to avoid issues again in the future. Most problems are caused by autocrlf=true in git settings, which will automatically adjust line endings upon checkout and commit which distorts the actual line endings from being consistent locally and remotely. In other cases, developing within a Linux workspace will natively use LF by default. It is simplest to set autocrlf=false to prevent manipulation of line endings outside of the actual values and set up your editor to use CRLF line endings within the project. Configuration \u00b6 The plugin can be configured to ignore certain files. \"LineEndingCheck\" : { \"IgnoreFiles\" : [] } IgnoreFiles \u00b6 An optional list of git ignore patterns relative to the package root used to exclude files from being checked.","title":"Line Ending Check"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/#line-ending-check-plugin","text":"This CiBuildPlugin scans all the files in a package to verify that the line endings are CRLF. Note: If you encounter a line ending issue found by this plugin, update your development environment to avoid issues again in the future. Most problems are caused by autocrlf=true in git settings, which will automatically adjust line endings upon checkout and commit which distorts the actual line endings from being consistent locally and remotely. In other cases, developing within a Linux workspace will natively use LF by default. It is simplest to set autocrlf=false to prevent manipulation of line endings outside of the actual values and set up your editor to use CRLF line endings within the project.","title":"Line Ending Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/#configuration","text":"The plugin can be configured to ignore certain files. \"LineEndingCheck\" : { \"IgnoreFiles\" : [] }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/#ignorefiles","text":"An optional list of git ignore patterns relative to the package root used to exclude files from being checked.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/","text":"Markdown Lint Plugin \u00b6 This CiBuildPlugin scans all the markdown files in a given package and checks for linter errors. Requirements \u00b6 The test case in this plugin will be skipped if the requirements are not met. NodeJs installed and on your path markdownlint-cli NodeJs package installed a .markdownlint.yaml config file either at your repository root or package root. NodeJS: https://nodejs.org/en/ markdownlint-cli: https://www.npmjs.com/package/markdownlint-cli Src available: https://github.com/igorshubovych/markdownlint-cli Configuration \u00b6 It is desired to use standard configuration methods so that both local editors (vscode, etc) and the CI process leverage the same configuration. This mostly works but for ignoring files there is currently a small discrepancy. First there is/can be a .markdownlintignore file at root of the repository. This file much like a .gitignore is great for broadly ignoring files with patterns. This works for both editor/ci. But for package based ignores and to keep the control of which files to ignore within the package there is no answer that supports both CI and editors. Open question here https://github.com/DavidAnson/vscode-markdownlint/issues/130 For the CI plugin you can use the IgnoreFiles configuration option described in the Plugin Configuration. Plugin Configuration \u00b6 The plugin has only minimal configuration options to support the UEFI codebase. \"MarkdownLintCheck\" : { \"AuditOnly\" : False , # If True, log all errors and then mark as skipped \"IgnoreFiles\" : [] # package root relative file, folder, or glob pattern to ignore } AuditOnly \u00b6 Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped. This allows visibility into the failures without breaking the build. IgnoreFiles \u00b6 This supports package relative files, folders, and glob patterns to ignore. These are passed to the markdownlint-cli tool as quoted -i parameters. Linter Configuration \u00b6 All configuration options available to the linter can be set in the .markdownlint.yaml . This includes customizing rule options and enforcement. See more details here: https://github.com/DavidAnson/markdownlint#configuration Linter Rules are described here: https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md Rule Overrides \u00b6 There are times when a certain rule should not apply to part of a markdown file. Markdownlint has numerous ways to configure this. See the in file Configuration options described at the links above","title":"Markdown Lint Check"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#markdown-lint-plugin","text":"This CiBuildPlugin scans all the markdown files in a given package and checks for linter errors.","title":"Markdown Lint Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#requirements","text":"The test case in this plugin will be skipped if the requirements are not met. NodeJs installed and on your path markdownlint-cli NodeJs package installed a .markdownlint.yaml config file either at your repository root or package root. NodeJS: https://nodejs.org/en/ markdownlint-cli: https://www.npmjs.com/package/markdownlint-cli Src available: https://github.com/igorshubovych/markdownlint-cli","title":"Requirements"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#configuration","text":"It is desired to use standard configuration methods so that both local editors (vscode, etc) and the CI process leverage the same configuration. This mostly works but for ignoring files there is currently a small discrepancy. First there is/can be a .markdownlintignore file at root of the repository. This file much like a .gitignore is great for broadly ignoring files with patterns. This works for both editor/ci. But for package based ignores and to keep the control of which files to ignore within the package there is no answer that supports both CI and editors. Open question here https://github.com/DavidAnson/vscode-markdownlint/issues/130 For the CI plugin you can use the IgnoreFiles configuration option described in the Plugin Configuration.","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#plugin-configuration","text":"The plugin has only minimal configuration options to support the UEFI codebase. \"MarkdownLintCheck\" : { \"AuditOnly\" : False , # If True, log all errors and then mark as skipped \"IgnoreFiles\" : [] # package root relative file, folder, or glob pattern to ignore }","title":"Plugin Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#auditonly","text":"Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped. This allows visibility into the failures without breaking the build.","title":"AuditOnly"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#ignorefiles","text":"This supports package relative files, folders, and glob patterns to ignore. These are passed to the markdownlint-cli tool as quoted -i parameters.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#linter-configuration","text":"All configuration options available to the linter can be set in the .markdownlint.yaml . This includes customizing rule options and enforcement. See more details here: https://github.com/DavidAnson/markdownlint#configuration Linter Rules are described here: https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md","title":"Linter Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#rule-overrides","text":"There are times when a certain rule should not apply to part of a markdown file. Markdownlint has numerous ways to configure this. See the in file Configuration options described at the links above","title":"Rule Overrides"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/","text":"Spell Check Plugin \u00b6 This CiBuildPlugin scans all the files in a given package and checks for spelling errors. This plugin requires NodeJs and cspell. If the plugin doesn't find its required tools then it will mark the test as skipped. NodeJS: https://nodejs.org/en/ cspell: https://www.npmjs.com/package/cspell Src and doc available: https://github.com/streetsidesoftware/cspell Configuration \u00b6 The plugin has a few configuration options to support the UEFI codebase. \"SpellCheck\" : { \"AuditOnly\" : False , # If True, log all errors and then mark as skipped \"IgnoreFiles\" : [], # use gitignore syntax to ignore errors in matching files \"ExtendWords\" : [], # words to extend to the dictionary for this package \"IgnoreStandardPaths\" : [], # Standard Plugin defined paths that should be ignore \"AdditionalIncludePaths\" : [] # Additional paths to spell check (wildcards supported) } AuditOnly \u00b6 Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped. This allows visibility into the failures without breaking the build. IgnoreFiles \u00b6 This supports .gitignore file and folder matching strings including wildcards All files will be parsed regardless but then any spelling errors found within ignored files will not be reported as an error. Errors in ignored files will still be output to the test results as informational comments. ExtendWords \u00b6 This list allows words to be added to the dictionary for the spell checker when this package is tested. These follow the rules of the cspell config words field. IgnoreStandardPaths \u00b6 This plugin by default will check the below standard paths. If the package would like to ignore any of them list that here. [ # C source \"*.c\" , \"*.h\" , # Assembly files \"*.nasm\" , \"*.asm\" , \"*.masm\" , \"*.s\" , # ACPI source language \"*.asl\" , # Edk2 build files \"*.dsc\" , \"*.dec\" , \"*.fdf\" , \"*.inf\" , # Documentation files \"*.md\" , \"*.txt\" ] AdditionalIncludePaths \u00b6 If the package would to add additional path patterns to be included in spellchecking they can be defined here. Other configuration \u00b6 In the cspell.base.json there are numerous other settings configured. There is no support to override these on a per package basis but future features could make this available. One interesting configuration option is minWordLength . Currently it is set to 5 which means all 2,3, and 4 letter words will be ignored. This helps minimize the number of technical acronyms, register names, and other UEFI specific values that must be ignored. False positives \u00b6 The cspell dictionary is not perfect and there are cases where technical words or acronyms are not found in the dictionary. There are three ways to resolve false positives and the choice for which method should be based on how broadly the word should be accepted. CSpell Base Config file \u00b6 If the change should apply to all UEFI code and documentation then it should be added to the base config file words section. The base config file is adjacent to this file and titled cspell.base.json . This is a list of accepted words for all spell checking operations on all packages. Package Config \u00b6 In the package *.ci.yaml file there is a SpellCheck config section. This section allows files to be ignored as well as words that should be considered valid for all files within this package. Add the desired words to the \"ExtendedWords\" member. In-line File \u00b6 CSpell supports numerous methods to annotate your files to ignore words, sections, etc. This can be found in CSpell documentation. Suggestion here is to use a c-style comment at the top of the file to add words that should be ignored just for this file. Obviously this has the highest maintenance cost so it should only be used for file unique words. // spell-checker:ignore unenroll, word2, word3 or # spell-checker:ignore unenroll, word2, word3","title":"Spell Check"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#spell-check-plugin","text":"This CiBuildPlugin scans all the files in a given package and checks for spelling errors. This plugin requires NodeJs and cspell. If the plugin doesn't find its required tools then it will mark the test as skipped. NodeJS: https://nodejs.org/en/ cspell: https://www.npmjs.com/package/cspell Src and doc available: https://github.com/streetsidesoftware/cspell","title":"Spell Check Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#configuration","text":"The plugin has a few configuration options to support the UEFI codebase. \"SpellCheck\" : { \"AuditOnly\" : False , # If True, log all errors and then mark as skipped \"IgnoreFiles\" : [], # use gitignore syntax to ignore errors in matching files \"ExtendWords\" : [], # words to extend to the dictionary for this package \"IgnoreStandardPaths\" : [], # Standard Plugin defined paths that should be ignore \"AdditionalIncludePaths\" : [] # Additional paths to spell check (wildcards supported) }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#auditonly","text":"Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped. This allows visibility into the failures without breaking the build.","title":"AuditOnly"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#ignorefiles","text":"This supports .gitignore file and folder matching strings including wildcards All files will be parsed regardless but then any spelling errors found within ignored files will not be reported as an error. Errors in ignored files will still be output to the test results as informational comments.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#extendwords","text":"This list allows words to be added to the dictionary for the spell checker when this package is tested. These follow the rules of the cspell config words field.","title":"ExtendWords"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#ignorestandardpaths","text":"This plugin by default will check the below standard paths. If the package would like to ignore any of them list that here. [ # C source \"*.c\" , \"*.h\" , # Assembly files \"*.nasm\" , \"*.asm\" , \"*.masm\" , \"*.s\" , # ACPI source language \"*.asl\" , # Edk2 build files \"*.dsc\" , \"*.dec\" , \"*.fdf\" , \"*.inf\" , # Documentation files \"*.md\" , \"*.txt\" ]","title":"IgnoreStandardPaths"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#additionalincludepaths","text":"If the package would to add additional path patterns to be included in spellchecking they can be defined here.","title":"AdditionalIncludePaths"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#other-configuration","text":"In the cspell.base.json there are numerous other settings configured. There is no support to override these on a per package basis but future features could make this available. One interesting configuration option is minWordLength . Currently it is set to 5 which means all 2,3, and 4 letter words will be ignored. This helps minimize the number of technical acronyms, register names, and other UEFI specific values that must be ignored.","title":"Other configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#false-positives","text":"The cspell dictionary is not perfect and there are cases where technical words or acronyms are not found in the dictionary. There are three ways to resolve false positives and the choice for which method should be based on how broadly the word should be accepted.","title":"False positives"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#cspell-base-config-file","text":"If the change should apply to all UEFI code and documentation then it should be added to the base config file words section. The base config file is adjacent to this file and titled cspell.base.json . This is a list of accepted words for all spell checking operations on all packages.","title":"CSpell Base Config file"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#package-config","text":"In the package *.ci.yaml file there is a SpellCheck config section. This section allows files to be ignored as well as words that should be considered valid for all files within this package. Add the desired words to the \"ExtendedWords\" member.","title":"Package Config"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#in-line-file","text":"CSpell supports numerous methods to annotate your files to ignore words, sections, etc. This can be found in CSpell documentation. Suggestion here is to use a c-style comment at the top of the file to add words that should be ignored just for this file. Obviously this has the highest maintenance cost so it should only be used for file unique words. // spell-checker:ignore unenroll, word2, word3 or # spell-checker:ignore unenroll, word2, word3","title":"In-line File"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/","text":"UncrustifyCheck Plugin \u00b6 This CiBuildPlugin scans all the files in a given package and checks for coding standard compliance issues. This plugin is enabled by default. If a package would like to prevent the plugin from reporting errors, it can do so by enabling AuditOnly mode. This plugin requires the directory containing the Uncrustify executable that should be used for this plugin to be specified in an environment variable named UNCRUSTIFY_CI_PATH . This unique variable name is used to avoid confusion with other paths to Uncrustify which might not be the expected build for use by this plugin. By default, an Uncrustify configuration file named \"uncrustify.cfg\" located in the same directory as the plugin is used. The value can be overridden to a package-specific path with the ConfigFilePath configuration file option. Uncrustify source code and documentation: https://github.com/uncrustify/uncrustify Project Mu Uncrustify fork source code and documentation: https://dev.azure.com/projectmu/Uncrustify Files Checked in a Package \u00b6 By default, this plugin will discover all files in the package with the following default paths: [ # C source \"*.c\" , \"*.h\" ] From this list of files, any files ignored by Git or residing in a Git submodule will be removed. If Git is not found, submodules are not found, or ignored files are not found no changes are made to the list of discovered files. To control the paths checked in a given package, review the configuration options described in this file. Configuration \u00b6 The plugin can be configured with a few optional configuration options. \"UncrustifyCheck\" : { \"AdditionalIncludePaths\" : [], # Additional paths to check formatting (wildcards supported). \"AuditOnly\" : False , # Don't fail the build if there are errors. Just log them. \"ConfigFilePath\" : \"\" , # Custom path to an Uncrustify config file. \"IgnoreFiles\" : [], # A list of file patterns to ignore. \"IgnoreStandardPaths\" : [], # Standard Plugin defined paths that should be ignored. \"OutputFileDiffs\" : True , # Output chunks of formatting diffs in the test case log. # This can significantly slow down the plugin on very large packages. \"SkipGitExclusions\" : False # Don't exclude git ignored files and files in git submodules. } AdditionalIncludePaths \u00b6 A package configuration file can specify any additional paths to be included with this option. At this time, it is recommended all files run against the plugin be written in the C or C++ language. AuditOnly \u00b6 Boolean - Default is False . If True , run the test in an \"audit only mode\" which will log all errors but instead of failing the build, it will set the test as skipped. This allows visibility into the failures without breaking the build. ConfigFilePath \u00b6 String - Default is \"uncrustify.cfg\" When specified in the config file, this is a package relative path to the Uncrustify configuration file. IgnoreFiles \u00b6 This option supports .gitignore file and folder matching strings including wildcards. The files specified by this configuration option will not be processed by Uncrustify. IgnoreStandardPaths \u00b6 This plugin by default will check the below standard paths. A package configuration file can specify any of these paths to be ignored. [ # C source \"*.c\" , \"*.h\" ] OutputFileDiffs \u00b6 Boolean - Default is True . If True , output diffs of formatting changes into the test case log. This is helpful to exactly understand what changes need to be made to the source code in order to fix a coding standard compliance issue. Note that calculating the file diffs on a very large set of of results (e.g. >100 files) can significantly slow down plugin execution. SkipGitExclusions \u00b6 Boolean - Default is False . By default, files in paths matched in a .gitignore file or a recognized git submodule are excluded. If this option is True , the plugin will not attempt to recognize these files and exclude them. UNCRUSTIFY_IN_PLACE=TRUE \u00b6 MU_CHANGE - Feature added. Mu adds support for passing this parameter on the command line when running stuart_ci_build . If passed, it will cause any changes to be made in-place to the files in the workspace, enabling the caller to easily format any failing code before submitting a PR. While this can also be set as an environment variable, it is recommended to only use it as a CLI paramter. NOTE: This is not an option in the config yaml . It is an option passed directly into the tool. High-Level Plugin Operation \u00b6 This plugin generates two main sets of temporary files: A working directory in the directory Build/.pytool/Plugin/Uncrustify For each source file with formatting errors, a sibling file with the .uncrustify_plugin extension The working directory contains temporary files unique to operation of the plugin. All of these files are removed on exit of the plugin including successful or unsuccessful execution (such as a Python exception occurring). If for any reason, any files in the package exist prior to running the plugin with the .uncrustify_plugin extension, the plugin will inform the user to remove these files and exit before running Uncrustify. This is to ensure the accuracy of the results reported from each execution instance of the plugin. The plugin determines the list of relevant files to check with Uncrustify and then invokes Uncrustify with that file list. For any files not compliant to the configuration file provided, Uncrustify will generate a corresponding file with the .uncrustify_plugin extension. The plugin discovers all of these files. If any such files are present, this indicates a formatting issue was found and the test is marked failed (unless AuditOnly mode is enabled). The test case log will contain a report of which files failed to format properly, allowing the user to run Uncrustify against the file locally to fix the issue. If the OutputFileDiffs configuration option is set to True , the plugin will output diff chunks for all code formatting issues in the test case log.","title":"Uncrustify Check"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#uncrustifycheck-plugin","text":"This CiBuildPlugin scans all the files in a given package and checks for coding standard compliance issues. This plugin is enabled by default. If a package would like to prevent the plugin from reporting errors, it can do so by enabling AuditOnly mode. This plugin requires the directory containing the Uncrustify executable that should be used for this plugin to be specified in an environment variable named UNCRUSTIFY_CI_PATH . This unique variable name is used to avoid confusion with other paths to Uncrustify which might not be the expected build for use by this plugin. By default, an Uncrustify configuration file named \"uncrustify.cfg\" located in the same directory as the plugin is used. The value can be overridden to a package-specific path with the ConfigFilePath configuration file option. Uncrustify source code and documentation: https://github.com/uncrustify/uncrustify Project Mu Uncrustify fork source code and documentation: https://dev.azure.com/projectmu/Uncrustify","title":"UncrustifyCheck Plugin"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#files-checked-in-a-package","text":"By default, this plugin will discover all files in the package with the following default paths: [ # C source \"*.c\" , \"*.h\" ] From this list of files, any files ignored by Git or residing in a Git submodule will be removed. If Git is not found, submodules are not found, or ignored files are not found no changes are made to the list of discovered files. To control the paths checked in a given package, review the configuration options described in this file.","title":"Files Checked in a Package"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#configuration","text":"The plugin can be configured with a few optional configuration options. \"UncrustifyCheck\" : { \"AdditionalIncludePaths\" : [], # Additional paths to check formatting (wildcards supported). \"AuditOnly\" : False , # Don't fail the build if there are errors. Just log them. \"ConfigFilePath\" : \"\" , # Custom path to an Uncrustify config file. \"IgnoreFiles\" : [], # A list of file patterns to ignore. \"IgnoreStandardPaths\" : [], # Standard Plugin defined paths that should be ignored. \"OutputFileDiffs\" : True , # Output chunks of formatting diffs in the test case log. # This can significantly slow down the plugin on very large packages. \"SkipGitExclusions\" : False # Don't exclude git ignored files and files in git submodules. }","title":"Configuration"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#additionalincludepaths","text":"A package configuration file can specify any additional paths to be included with this option. At this time, it is recommended all files run against the plugin be written in the C or C++ language.","title":"AdditionalIncludePaths"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#auditonly","text":"Boolean - Default is False . If True , run the test in an \"audit only mode\" which will log all errors but instead of failing the build, it will set the test as skipped. This allows visibility into the failures without breaking the build.","title":"AuditOnly"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#configfilepath","text":"String - Default is \"uncrustify.cfg\" When specified in the config file, this is a package relative path to the Uncrustify configuration file.","title":"ConfigFilePath"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#ignorefiles","text":"This option supports .gitignore file and folder matching strings including wildcards. The files specified by this configuration option will not be processed by Uncrustify.","title":"IgnoreFiles"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#ignorestandardpaths","text":"This plugin by default will check the below standard paths. A package configuration file can specify any of these paths to be ignored. [ # C source \"*.c\" , \"*.h\" ]","title":"IgnoreStandardPaths"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#outputfilediffs","text":"Boolean - Default is True . If True , output diffs of formatting changes into the test case log. This is helpful to exactly understand what changes need to be made to the source code in order to fix a coding standard compliance issue. Note that calculating the file diffs on a very large set of of results (e.g. >100 files) can significantly slow down plugin execution.","title":"OutputFileDiffs"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#skipgitexclusions","text":"Boolean - Default is False . By default, files in paths matched in a .gitignore file or a recognized git submodule are excluded. If this option is True , the plugin will not attempt to recognize these files and exclude them.","title":"SkipGitExclusions"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#uncrustify_in_placetrue","text":"MU_CHANGE - Feature added. Mu adds support for passing this parameter on the command line when running stuart_ci_build . If passed, it will cause any changes to be made in-place to the files in the workspace, enabling the caller to easily format any failing code before submitting a PR. While this can also be set as an environment variable, it is recommended to only use it as a CLI paramter. NOTE: This is not an option in the config yaml . It is an option passed directly into the tool.","title":"UNCRUSTIFY_IN_PLACE=TRUE"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#high-level-plugin-operation","text":"This plugin generates two main sets of temporary files: A working directory in the directory Build/.pytool/Plugin/Uncrustify For each source file with formatting errors, a sibling file with the .uncrustify_plugin extension The working directory contains temporary files unique to operation of the plugin. All of these files are removed on exit of the plugin including successful or unsuccessful execution (such as a Python exception occurring). If for any reason, any files in the package exist prior to running the plugin with the .uncrustify_plugin extension, the plugin will inform the user to remove these files and exit before running Uncrustify. This is to ensure the accuracy of the results reported from each execution instance of the plugin. The plugin determines the list of relevant files to check with Uncrustify and then invokes Uncrustify with that file list. For any files not compliant to the configuration file provided, Uncrustify will generate a corresponding file with the .uncrustify_plugin extension. The plugin discovers all of these files. If any such files are present, this indicates a formatting issue was found and the test is marked failed (unless AuditOnly mode is enabled). The test case log will contain a report of which files failed to format properly, allowing the user to run Uncrustify against the file locally to fix the issue. If the OutputFileDiffs configuration option is set to True , the plugin will output diff chunks for all code formatting issues in the test case log.","title":"High-Level Plugin Operation"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/","text":"Project Mu Common Intel MinPlatform \u00b6 Git Details Repository Url: https://github.com/microsoft/mu_common_intel_min_platform.git Branch: release/202202 Commit: 3f9f29f1d8ca7579c8a679bdaa34ea03b98721b0 Commit Date: 2022-11-14 22:18:52 -0500 This repository contains Project Mu code based on TianoCore edk2 code for Intel MinPlatform. More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"mu common intel min platform"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#project-mu-common-intel-minplatform","text":"Git Details Repository Url: https://github.com/microsoft/mu_common_intel_min_platform.git Branch: release/202202 Commit: 3f9f29f1d8ca7579c8a679bdaa34ea03b98721b0 Commit Date: 2022-11-14 22:18:52 -0500 This repository contains Project Mu code based on TianoCore edk2 code for Intel MinPlatform.","title":"Project Mu Common Intel MinPlatform"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_feature_config/CONTRIBUTING/","text":"Contributing to Project Mu \u00b6 Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation . Asking Questions \u00b6 Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo. Reporting Issues \u00b6 Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section. Identify Where to Report \u00b6 Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary. Look For an Existing Issue \u00b6 Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below. Follow Your Issue \u00b6 Please continue to follow your request after it is submitted to assist with any additional information that might be requested. Thank You \u00b6 Thank you for your interest in Project Mu and taking the time to contribute!","title":"CONTRIBUTING"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#contributing-to-project-mu","text":"Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation .","title":"Contributing to Project Mu"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#asking-questions","text":"Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo.","title":"Asking Questions"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#reporting-issues","text":"Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.","title":"Reporting Issues"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#identify-where-to-report","text":"Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.","title":"Identify Where to Report"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#look-for-an-existing-issue","text":"Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.","title":"Look For an Existing Issue"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#follow-your-issue","text":"Please continue to follow your request after it is submitted to assist with any additional information that might be requested.","title":"Follow Your Issue"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#thank-you","text":"Thank you for your interest in Project Mu and taking the time to contribute!","title":"Thank You"},{"location":"dyn/mu_feature_config/RepoDetails/","text":"Project Mu Configuration Repository \u00b6 Git Details Repository Url: https://github.com/microsoft/mu_feature_config.git Branch: main Commit: 01f4b6f772845272c05f3d958e162c14ea9bf2d3 Commit Date: 2022-11-30 11:23:16 -0500 This MU Configuration feature repo contains the generic Config Editor tools from Intel's Slim Bootloader repo. This code should be consumed as needed for firmware configuration update feature support. Repository Philosophy \u00b6 Like other Project MU feature repositories, the Configuration feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided. Consuming the MU Configuration Feature Package \u00b6 Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_config_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired. { \"scope\" : \"global\" , \"type\" : \"git\" , \"name\" : \"FEATURE_CONFIG\" , \"var_name\" : \"FEATURE_CONFIG_PATH\" , \"source\" : \"https://github.com/microsoft/mu_feature_config.git\" , \"version\" : \"<RELEASE HASH>\" , \"flags\" : [ \"set_build_var\" ] } Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build configurations GetPackagesPath list. shell_environment . GetBuildVars () . GetValue ( \"FEATURE_CONFIG_PATH\" , \"\" ) Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string. After this the package should be discoverable to can be used in the build like any other dependency. Code of Conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct For more information see the Code of Conduct FAQ or contact opencode@microsoft.com <mailto:opencode@microsoft.com> _. with any additional questions or comments. Contributions \u00b6 Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/ Code Requirements Doc Requirements Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Repo Details"},{"location":"dyn/mu_feature_config/RepoDetails/#project-mu-configuration-repository","text":"Git Details Repository Url: https://github.com/microsoft/mu_feature_config.git Branch: main Commit: 01f4b6f772845272c05f3d958e162c14ea9bf2d3 Commit Date: 2022-11-30 11:23:16 -0500 This MU Configuration feature repo contains the generic Config Editor tools from Intel's Slim Bootloader repo. This code should be consumed as needed for firmware configuration update feature support.","title":"Project Mu Configuration Repository"},{"location":"dyn/mu_feature_config/RepoDetails/#repository-philosophy","text":"Like other Project MU feature repositories, the Configuration feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided.","title":"Repository Philosophy"},{"location":"dyn/mu_feature_config/RepoDetails/#consuming-the-mu-configuration-feature-package","text":"Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_config_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired. { \"scope\" : \"global\" , \"type\" : \"git\" , \"name\" : \"FEATURE_CONFIG\" , \"var_name\" : \"FEATURE_CONFIG_PATH\" , \"source\" : \"https://github.com/microsoft/mu_feature_config.git\" , \"version\" : \"<RELEASE HASH>\" , \"flags\" : [ \"set_build_var\" ] } Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build configurations GetPackagesPath list. shell_environment . GetBuildVars () . GetValue ( \"FEATURE_CONFIG_PATH\" , \"\" ) Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string. After this the package should be discoverable to can be used in the build like any other dependency.","title":"Consuming the MU Configuration Feature Package"},{"location":"dyn/mu_feature_config/RepoDetails/#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct For more information see the Code of Conduct FAQ or contact opencode@microsoft.com <mailto:opencode@microsoft.com> _. with any additional questions or comments.","title":"Code of Conduct"},{"location":"dyn/mu_feature_config/RepoDetails/#contributions","text":"Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/ Code Requirements Doc Requirements","title":"Contributions"},{"location":"dyn/mu_feature_config/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_feature_config/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_feature_config/RepoDetails/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_feature_config/SECURITY/","text":"Security \u00b6 Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below. Reporting Security Issues \u00b6 Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs. Preferred Languages \u00b6 We prefer all communications to be in English. Policy \u00b6 Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"SECURITY"},{"location":"dyn/mu_feature_config/SECURITY/#security","text":"Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below.","title":"Security"},{"location":"dyn/mu_feature_config/SECURITY/#reporting-security-issues","text":"Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.","title":"Reporting Security Issues"},{"location":"dyn/mu_feature_config/SECURITY/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"},{"location":"dyn/mu_feature_config/SECURITY/#policy","text":"Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"Policy"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/","text":"Configuration Files Specification \u00b6 Table of Contents \u00b6 Description Revision History Terms Introduction YML Specification Differences XML Specification Merged YAML and XML Operations Description \u00b6 This document is intended to describe the Project MU version of Configuration Files Specification. Revision History \u00b6 Revised by Date Changes Kun Qin 11/29/2021 First draft Oliver Smith-Denny 7/22/2022 Add YAML/XML Merged Support Oliver Smith-Denny 9/15/2022 Add Profile Support Terms \u00b6 Term Description UEFI Unified Extensible Firmware Interface Reference Documents \u00b6 Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps Introduction \u00b6 As Project MU inherits tool set from Slim Bootloader repository to support setup variable feature, certain modifications has been made to improve workflow and architectural abstraction. Although the syntax of configuration YAML files mainly follow Slim Bootloader specification for design simplicity, this document mainly listed the differences between Project MU version and original Slim Bootloader. Additionally, this document describes the XML format that will be accepted. YAML Specification Differences \u00b6 All UI related form fields (i.e. name , type , help , etc.) should be described separately from the data definitions. The UI form set should be named as *_UI following the same directory/name of data form sets (see example below). The intention of this separation is to allow cleaner YAML layout for platform configuration template creation while maintaining the ConfigEditor.py capability of updating configuration offline. CfgDataDef.yaml CfgDataDef_UI.yaml | Template_USB.yaml | Template_USB_UI.yaml For each configuration yaml file set, the data blob header is no longer required. This will be automatically populated by the GenCfgData.py . The total size will be rounded up to 4KB aligned boundary by used size. All CFGHDR_TMPL can be ignored from YAML files. Instead, use a IdTag to denote a normal ID tag value, or ArrayIdTag to denote an array ID tag value. GenCfgData.py will automatically populate the CFGHDR_TMPL content to backend database and generate the same binary data blob. XML Specification \u00b6 See sampleschema.xml for an example XML schema. Configuration will be organized in namespaces, each consisting of various knobs. Knobs may be built of children knobs or be a leaf knob. The XML and artifacts generated from it are not used by the ConfApp or other UEFI components, but support is given to visualize the XML for scenarios that have XML configuration. Supported data types are: uint8_t int8_t uint16_t int16_t uint32_t int32_t uint64_t int64_t float (note that floats are imprecise, doubles are recommend to avoid rounding errors) double bool Config Editor Operations \u00b6 All of these options except for Load Config File are only available after one or more configuration files have been loaded. Variable List Binaries \u00b6 As described in (#merged-yaml-and-xml-operations), the Config Editor can output variable list binaries. These are created by the GenSetupDataBin.py build plugin to generate profiles (see the Profiles doc for more information). Save Config Data to Var List Binary: Create a variable list binary to be used for testing or to load later in the Config Editor tool Load Config Data from Var List Binary: Load a saved variable list binary (of the same format as the loaded YAML/XML file) into the UI. This can be used to load previously stored configuration or validate the output of GenSetupDataBin.py. SVD Files \u00b6 The SVD is intended for use with the UEFI Conf App , which can take the SVD as input and give an SVD describing the current UEFI settings as an output. The SVD is formatted to be compatible with DFCI . Save Full Config Data to SVD File: Saving the entire defined YAML/XML structure into encoded binary settings format. This format is useful when many tags of settings need updating at once, but this will save all configurations defined. Save Config Changes to SVD File: Saving only the changed tag setting into corresponding encoded binary value. This will allow the target system to update only the changed tag setting (i.e. Only disable GFX controllers, and leave USB ports on the same system intact) Load Config Data from SVD File: Once the target system has dumped current configuration from ConfApp, the output data can be viewed in the ConfigEditor on a host system or saved SVDs from the ConfigEditor can be loaded again. Change Files (Delta or CSV) \u00b6 Profiles are represented as delta files on top of the generic profile (for more info see the Profiles doc). In addition, the XML differences between what is set in the UI and the base XML can be saved as CSV files. Save Full Config Data to Change File Save all configuration knobs to the change file, even if they do not have a change over the base YAML/XML. This is helpful to see the whole state of configuration from one file. Save Config Changes to Change File Save only configuration knobs that have a different value from the base YAML/XML to a change file. This is helpful to have smaller change files, but looking just at a change file does not describe the whole state. Load Config from Change File Load a previously save change file into the UI, overwriting any values from the base YAML/XML. It must be loaded onto a YAML/XML that has the configuration knobs present in the change file. Merged YAML and XML Operations \u00b6 One YAML and one XML file may be loaded at the same time via the CLI as such: python ConfigEditor.py sampleschema.xml samplecfg.yaml When saving config changes to delta files, two files will be output: a .dlt file for the YAML config changes and a .csv file for the XML config changes. Either or both of these can be later loaded to modify the current config viewed in the ConfigEditor. As noted above under YAML Specification Differences, the full SVD can be saved in a merged configuration. Config will be stored in individual tags under each variable name. For saving to/loading from a binary file, the merged config will create a list of UEFI variables that will look as such: | XML Var 1 | | XML Var 2 | | ... | | XML Var N | | YML Var 1 | | YML Var 2 | | ... | | YML Var N | (Order not guaranteed) Where XML/YML Var N looks like: | UINT32 Name Size | | UINT32 Data Size | | CHAR16 *Name | | EFI_GUID GUID | | VOID *Data | | UINT32 CRC | YAML only configuration (or XML only) is the same as the above. The ConfApp uses YAML only configuration.","title":"Configuration Files"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#configuration-files-specification","text":"","title":"Configuration Files Specification"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#table-of-contents","text":"Description Revision History Terms Introduction YML Specification Differences XML Specification Merged YAML and XML Operations","title":"Table of Contents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#description","text":"This document is intended to describe the Project MU version of Configuration Files Specification.","title":"Description"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#revision-history","text":"Revised by Date Changes Kun Qin 11/29/2021 First draft Oliver Smith-Denny 7/22/2022 Add YAML/XML Merged Support Oliver Smith-Denny 9/15/2022 Add Profile Support","title":"Revision History"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#terms","text":"Term Description UEFI Unified Extensible Firmware Interface","title":"Terms"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#reference-documents","text":"Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps","title":"Reference Documents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#introduction","text":"As Project MU inherits tool set from Slim Bootloader repository to support setup variable feature, certain modifications has been made to improve workflow and architectural abstraction. Although the syntax of configuration YAML files mainly follow Slim Bootloader specification for design simplicity, this document mainly listed the differences between Project MU version and original Slim Bootloader. Additionally, this document describes the XML format that will be accepted.","title":"Introduction"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#yaml-specification-differences","text":"All UI related form fields (i.e. name , type , help , etc.) should be described separately from the data definitions. The UI form set should be named as *_UI following the same directory/name of data form sets (see example below). The intention of this separation is to allow cleaner YAML layout for platform configuration template creation while maintaining the ConfigEditor.py capability of updating configuration offline. CfgDataDef.yaml CfgDataDef_UI.yaml | Template_USB.yaml | Template_USB_UI.yaml For each configuration yaml file set, the data blob header is no longer required. This will be automatically populated by the GenCfgData.py . The total size will be rounded up to 4KB aligned boundary by used size. All CFGHDR_TMPL can be ignored from YAML files. Instead, use a IdTag to denote a normal ID tag value, or ArrayIdTag to denote an array ID tag value. GenCfgData.py will automatically populate the CFGHDR_TMPL content to backend database and generate the same binary data blob.","title":"YAML Specification Differences"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#xml-specification","text":"See sampleschema.xml for an example XML schema. Configuration will be organized in namespaces, each consisting of various knobs. Knobs may be built of children knobs or be a leaf knob. The XML and artifacts generated from it are not used by the ConfApp or other UEFI components, but support is given to visualize the XML for scenarios that have XML configuration. Supported data types are: uint8_t int8_t uint16_t int16_t uint32_t int32_t uint64_t int64_t float (note that floats are imprecise, doubles are recommend to avoid rounding errors) double bool","title":"XML Specification"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#config-editor-operations","text":"All of these options except for Load Config File are only available after one or more configuration files have been loaded.","title":"Config Editor Operations"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#variable-list-binaries","text":"As described in (#merged-yaml-and-xml-operations), the Config Editor can output variable list binaries. These are created by the GenSetupDataBin.py build plugin to generate profiles (see the Profiles doc for more information). Save Config Data to Var List Binary: Create a variable list binary to be used for testing or to load later in the Config Editor tool Load Config Data from Var List Binary: Load a saved variable list binary (of the same format as the loaded YAML/XML file) into the UI. This can be used to load previously stored configuration or validate the output of GenSetupDataBin.py.","title":"Variable List Binaries"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#svd-files","text":"The SVD is intended for use with the UEFI Conf App , which can take the SVD as input and give an SVD describing the current UEFI settings as an output. The SVD is formatted to be compatible with DFCI . Save Full Config Data to SVD File: Saving the entire defined YAML/XML structure into encoded binary settings format. This format is useful when many tags of settings need updating at once, but this will save all configurations defined. Save Config Changes to SVD File: Saving only the changed tag setting into corresponding encoded binary value. This will allow the target system to update only the changed tag setting (i.e. Only disable GFX controllers, and leave USB ports on the same system intact) Load Config Data from SVD File: Once the target system has dumped current configuration from ConfApp, the output data can be viewed in the ConfigEditor on a host system or saved SVDs from the ConfigEditor can be loaded again.","title":"SVD Files"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#change-files-delta-or-csv","text":"Profiles are represented as delta files on top of the generic profile (for more info see the Profiles doc). In addition, the XML differences between what is set in the UI and the base XML can be saved as CSV files. Save Full Config Data to Change File Save all configuration knobs to the change file, even if they do not have a change over the base YAML/XML. This is helpful to see the whole state of configuration from one file. Save Config Changes to Change File Save only configuration knobs that have a different value from the base YAML/XML to a change file. This is helpful to have smaller change files, but looking just at a change file does not describe the whole state. Load Config from Change File Load a previously save change file into the UI, overwriting any values from the base YAML/XML. It must be loaded onto a YAML/XML that has the configuration knobs present in the change file.","title":"Change Files (Delta or CSV)"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#merged-yaml-and-xml-operations","text":"One YAML and one XML file may be loaded at the same time via the CLI as such: python ConfigEditor.py sampleschema.xml samplecfg.yaml When saving config changes to delta files, two files will be output: a .dlt file for the YAML config changes and a .csv file for the XML config changes. Either or both of these can be later loaded to modify the current config viewed in the ConfigEditor. As noted above under YAML Specification Differences, the full SVD can be saved in a merged configuration. Config will be stored in individual tags under each variable name. For saving to/loading from a binary file, the merged config will create a list of UEFI variables that will look as such: | XML Var 1 | | XML Var 2 | | ... | | XML Var N | | YML Var 1 | | YML Var 2 | | ... | | YML Var N | (Order not guaranteed) Where XML/YML Var N looks like: | UINT32 Name Size | | UINT32 Data Size | | CHAR16 *Name | | EFI_GUID GUID | | VOID *Data | | UINT32 CRC | YAML only configuration (or XML only) is the same as the above. The ConfApp uses YAML only configuration.","title":"Merged YAML and XML Operations"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/","text":"Configuration Applications Design \u00b6 Table of Contents \u00b6 Description Revision History Terms Reference Documents Introduction OS Based Configuration App UEFI Boot Application UEFI Build Tool and Plugin UEFI Code Change Configuration Related UEFI Boot Flow Description \u00b6 This document is intended to describe the Setup Variable design on applicable platforms. Revision History \u00b6 Revised by Date Changes Kun Qin 09/28/2021 First draft Oliver Smith-Denny 7/22/2022 Add Merged YAML/XML Support Oliver Smith-Denny 9/15/2022 Add Profile Support Terms \u00b6 Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface BDS Boot Device Selection Reference Documents \u00b6 Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ DFCI Documents https://microsoft.github.io/mu/dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps Introduction \u00b6 This document is describing how the configuration framework functions and what changes have been made. The proposition of this design intends to facilitate development usage and provide secure usage for production deployment. HII in the system, setup browser in system and/or other advance display capabilities has been convoluted and pertain poor portability. Hence proposed workflow steps away from existing UI applications, HII based form rendering models on the target system and adopts data centric methods to achieve the same results. In addition, tooling workflows are also proposed to enforce security and maintainability rules and best practices for data accessability, version migration, etc. Note: The technical details in this document is meant to reflect the current status of design. Certain topics are still under discussion and subject to change. OS Based Configuration App \u00b6 OS Configuration App Overview \u00b6 The original framework of configuration editor is derived from Intel's open sourced project Slim Bootloader (more information in References ). This framework provides graphical user interface on the host side and extensive flexibility to design and optimize configuration per platform usage. Configuration editor is authored in Python which is host platform architecture independent and easy to update per proprietary requirements per projects need. The configuration is driven by YAML and XML files, which can be designed per platform usage. Per YAML specification, please reference to Configuration YAML Spec in References . The slim bootloader framework provides data structure conversion tooling from YAML to C header files, YAML to binary data blob out of the box. XML extensions have been added to support additional use cases. More extensions, such as output data signing, tooling servicing, will be added during the development process. OS Configuration Workflow \u00b6 Whenever a configuration change is needed, configuration editor can be launched on a local workstation. Through the UI tool, one can update supported option as needed and export updated options as binary blob. Updated options can also be saved as \"profile\" that can be loaded into editor tool for faster configuration deployment The exported binary blob will be encoded and signed with platform designated certificates and formatted to DFCI standard packet. (more about DFCI please see References ). DFCI standard packets can be applied to target system through USB sticks, OS application on target systems, or serial transport through UEFI boot application (more about UEFI configuration app here ) UEFI Boot Application \u00b6 UEFI Boot App Overview \u00b6 As stated in the introduction section , this proposal intends to replace the existing UI applications, HII forms and other advanced display support. Instead, a Configuration UEFI application will be provided in lieu of traditional UI App to configuration system behavior. This application is optimized for serial connection. All input and output would go through UEFI standard console, which is connected to BMC through UART. Note: Available input devices will be: Physical USB Keyboard : This will be used for standard keyboard Virtual USB Keyboard : This will be used with BMC based virtual keyboard for remote KVM. Serial console for SAC : this uses VT100 terminal type for UEFI setup/Windows EMC or SAC. The application will provide basic information regarding system status: Firmware version Date/Time Identities Settings A few critical operations is also provided in this application: Secure Boot enable/disable: Select available boot options: Apply configuration options from OS configuration application: USB Stick Network Serial console UEFI Configuration Workflow \u00b6 With the exported configuration change from OS configuration application, this change can be applied within UEFI app: USB Stick : Store the generated base64 encoded file from previous step and select Update Setup Configuration -> Update from USB Stick from UEFI App. Serial Port : Open the generated base64 encoded file, and select Update Setup Configuration -> Update from Serial port from UEFI App. Then paste the encoded string into serial console. UEFI Build Tool and Plugin \u00b6 Build Tool and Plugin Overview \u00b6 During UEFI build time, toolings will be provided as plugins to integrate configuration related data and enforce best practices. Toolings from Project will cover: Converting designed YAML file into binary blob to be included in UEFI firmware volume. Generate C header files, if requested, for platform code consumption, and populate version transition templates. Build Process \u00b6 During pre-build step, customized platform YAML file will be used by Project MU plugin to derive configuration header files for platform to consume during development/runtime. Platform will hold a hash value in PlatformBuild.py for all YAML derived C header files for this platform. Project MU plugin will generate temporary C header files per build to compare hash match. If hash changed, a template of library will be generated and allow developer to author transition code if needed. If hash match, build can proceed as usual. At post-build, a binary blob with default configuration values will be derived from YAML files and inserted in UEFI firmware volume. UEFI Code Change \u00b6 Project Mu Code \u00b6 BDS : Project MU BDS will provide specific event signals and platform entrypoints that are customized for DFCI settings. DFCI : DFCI framework will be used to accept and validate incoming configuration against platform identity associated certificates. MFCI : The MFCI framework will be used to check what mode the system is in, manufacturing mode or customer mode. Settings Manager : Settings manager together with DFCI framework would apply the configuration data through platform configured settings providers. Policy Manager : Policy manager controls the policy publication and revoke. Silicon policy and platform configuration should all conform to policy setter and getter APIs. Profile Manager : ConfProfileMgrDxe validates and enforces profiles (collections of configuration settings for different use cases) when the system is in MFCI Customer Mode. Platform and Silicon Code \u00b6 Silicon Drivers : Silicon code needs to be updated to pull policy settings from silicon policy data when needed. Platform Policy Drivers : Platform owners will first create PEI modules to populate default silicon policy into Policy managers provided by Project MU. Platform YAML Configurations : Platform owners should then design the configuration YAML files. This would expose certain configuration \"knobs\" from silicon policy to be configurable through setup variable flow. Platform Settings Providers : Accordingly, platform owners will develop modules to parse the configuration data and translate the exposed configurations in YAML file to/from standard silicon policies through the interface of Settings Provider (see example from Project MU ). Profiles \u00b6 See the Profiles doc for details. Configuration Related UEFI Boot Flow \u00b6 Settings Update Boot Flow \u00b6 Formatted update configuration data from USB, serial port or OS application will first be stored to UEFI variable storage, followed by a system reboot. On the next reboot, the formatted configuration data from UEFI variable storage will be authenticated (if the DFCI Unsigned Settings feature is not used) and decoded by DFCI framework. Decoded configuration data will be dispatched to corresponding platform authored setting provider. Platform configuration setting provider will perform sanity check on incoming data and store this data as UEFI variable with the following specifications (source code reference here ), followed by a system reboot: Variable Name Variable GUID Variable Attributes CONF_POLICY_BLOB gSetupConfigPolicyVariableGuid EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS Device.ConfigData.TagID_%08X gSetupConfigPolicyVariableGuid EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS Upon a new boot, entities other than UEFI can consume the aforementioned variable. After entering UEFI firmware, platform policy module will pull previously stored configuration data variable from UEFI variable and parse the data blob based on YAML derived C header files. If any configuration change is required, platform should update the corresponding silicon policy through policy manager. When silicon drivers load, these drivers should fetch latest policy through policy manager and configure hardware resource accordingly.","title":"Overview"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#configuration-applications-design","text":"","title":"Configuration Applications Design"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#table-of-contents","text":"Description Revision History Terms Reference Documents Introduction OS Based Configuration App UEFI Boot Application UEFI Build Tool and Plugin UEFI Code Change Configuration Related UEFI Boot Flow","title":"Table of Contents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#description","text":"This document is intended to describe the Setup Variable design on applicable platforms.","title":"Description"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#revision-history","text":"Revised by Date Changes Kun Qin 09/28/2021 First draft Oliver Smith-Denny 7/22/2022 Add Merged YAML/XML Support Oliver Smith-Denny 9/15/2022 Add Profile Support","title":"Revision History"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#terms","text":"Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface BDS Boot Device Selection","title":"Terms"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#reference-documents","text":"Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ DFCI Documents https://microsoft.github.io/mu/dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps","title":"Reference Documents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#introduction","text":"This document is describing how the configuration framework functions and what changes have been made. The proposition of this design intends to facilitate development usage and provide secure usage for production deployment. HII in the system, setup browser in system and/or other advance display capabilities has been convoluted and pertain poor portability. Hence proposed workflow steps away from existing UI applications, HII based form rendering models on the target system and adopts data centric methods to achieve the same results. In addition, tooling workflows are also proposed to enforce security and maintainability rules and best practices for data accessability, version migration, etc. Note: The technical details in this document is meant to reflect the current status of design. Certain topics are still under discussion and subject to change.","title":"Introduction"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-based-configuration-app","text":"","title":"OS Based Configuration App"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-configuration-app-overview","text":"The original framework of configuration editor is derived from Intel's open sourced project Slim Bootloader (more information in References ). This framework provides graphical user interface on the host side and extensive flexibility to design and optimize configuration per platform usage. Configuration editor is authored in Python which is host platform architecture independent and easy to update per proprietary requirements per projects need. The configuration is driven by YAML and XML files, which can be designed per platform usage. Per YAML specification, please reference to Configuration YAML Spec in References . The slim bootloader framework provides data structure conversion tooling from YAML to C header files, YAML to binary data blob out of the box. XML extensions have been added to support additional use cases. More extensions, such as output data signing, tooling servicing, will be added during the development process.","title":"OS Configuration App Overview"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-configuration-workflow","text":"Whenever a configuration change is needed, configuration editor can be launched on a local workstation. Through the UI tool, one can update supported option as needed and export updated options as binary blob. Updated options can also be saved as \"profile\" that can be loaded into editor tool for faster configuration deployment The exported binary blob will be encoded and signed with platform designated certificates and formatted to DFCI standard packet. (more about DFCI please see References ). DFCI standard packets can be applied to target system through USB sticks, OS application on target systems, or serial transport through UEFI boot application (more about UEFI configuration app here )","title":"OS Configuration Workflow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-boot-application","text":"","title":"UEFI Boot Application"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-boot-app-overview","text":"As stated in the introduction section , this proposal intends to replace the existing UI applications, HII forms and other advanced display support. Instead, a Configuration UEFI application will be provided in lieu of traditional UI App to configuration system behavior. This application is optimized for serial connection. All input and output would go through UEFI standard console, which is connected to BMC through UART. Note: Available input devices will be: Physical USB Keyboard : This will be used for standard keyboard Virtual USB Keyboard : This will be used with BMC based virtual keyboard for remote KVM. Serial console for SAC : this uses VT100 terminal type for UEFI setup/Windows EMC or SAC. The application will provide basic information regarding system status: Firmware version Date/Time Identities Settings A few critical operations is also provided in this application: Secure Boot enable/disable: Select available boot options: Apply configuration options from OS configuration application: USB Stick Network Serial console","title":"UEFI Boot App Overview"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-configuration-workflow","text":"With the exported configuration change from OS configuration application, this change can be applied within UEFI app: USB Stick : Store the generated base64 encoded file from previous step and select Update Setup Configuration -> Update from USB Stick from UEFI App. Serial Port : Open the generated base64 encoded file, and select Update Setup Configuration -> Update from Serial port from UEFI App. Then paste the encoded string into serial console.","title":"UEFI Configuration Workflow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-build-tool-and-plugin","text":"","title":"UEFI Build Tool and Plugin"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#build-tool-and-plugin-overview","text":"During UEFI build time, toolings will be provided as plugins to integrate configuration related data and enforce best practices. Toolings from Project will cover: Converting designed YAML file into binary blob to be included in UEFI firmware volume. Generate C header files, if requested, for platform code consumption, and populate version transition templates.","title":"Build Tool and Plugin Overview"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#build-process","text":"During pre-build step, customized platform YAML file will be used by Project MU plugin to derive configuration header files for platform to consume during development/runtime. Platform will hold a hash value in PlatformBuild.py for all YAML derived C header files for this platform. Project MU plugin will generate temporary C header files per build to compare hash match. If hash changed, a template of library will be generated and allow developer to author transition code if needed. If hash match, build can proceed as usual. At post-build, a binary blob with default configuration values will be derived from YAML files and inserted in UEFI firmware volume.","title":"Build Process"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-code-change","text":"","title":"UEFI Code Change"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#project-mu-code","text":"BDS : Project MU BDS will provide specific event signals and platform entrypoints that are customized for DFCI settings. DFCI : DFCI framework will be used to accept and validate incoming configuration against platform identity associated certificates. MFCI : The MFCI framework will be used to check what mode the system is in, manufacturing mode or customer mode. Settings Manager : Settings manager together with DFCI framework would apply the configuration data through platform configured settings providers. Policy Manager : Policy manager controls the policy publication and revoke. Silicon policy and platform configuration should all conform to policy setter and getter APIs. Profile Manager : ConfProfileMgrDxe validates and enforces profiles (collections of configuration settings for different use cases) when the system is in MFCI Customer Mode.","title":"Project Mu Code"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#platform-and-silicon-code","text":"Silicon Drivers : Silicon code needs to be updated to pull policy settings from silicon policy data when needed. Platform Policy Drivers : Platform owners will first create PEI modules to populate default silicon policy into Policy managers provided by Project MU. Platform YAML Configurations : Platform owners should then design the configuration YAML files. This would expose certain configuration \"knobs\" from silicon policy to be configurable through setup variable flow. Platform Settings Providers : Accordingly, platform owners will develop modules to parse the configuration data and translate the exposed configurations in YAML file to/from standard silicon policies through the interface of Settings Provider (see example from Project MU ).","title":"Platform and Silicon Code"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#profiles","text":"See the Profiles doc for details.","title":"Profiles"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#configuration-related-uefi-boot-flow","text":"","title":"Configuration Related UEFI Boot Flow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#settings-update-boot-flow","text":"Formatted update configuration data from USB, serial port or OS application will first be stored to UEFI variable storage, followed by a system reboot. On the next reboot, the formatted configuration data from UEFI variable storage will be authenticated (if the DFCI Unsigned Settings feature is not used) and decoded by DFCI framework. Decoded configuration data will be dispatched to corresponding platform authored setting provider. Platform configuration setting provider will perform sanity check on incoming data and store this data as UEFI variable with the following specifications (source code reference here ), followed by a system reboot: Variable Name Variable GUID Variable Attributes CONF_POLICY_BLOB gSetupConfigPolicyVariableGuid EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS Device.ConfigData.TagID_%08X gSetupConfigPolicyVariableGuid EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS Upon a new boot, entities other than UEFI can consume the aforementioned variable. After entering UEFI firmware, platform policy module will pull previously stored configuration data variable from UEFI variable and parse the data blob based on YAML derived C header files. If any configuration change is required, platform should update the corresponding silicon policy through policy manager. When silicon drivers load, these drivers should fetch latest policy through policy manager and configure hardware resource accordingly.","title":"Settings Update Boot Flow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/","text":"Configuration Modules Platform Integration \u00b6 The configuration modules source code is intended to be used with some library classes provided by platforms. In order to integrate configuration modules into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces. High-Level Considerations \u00b6 Configuration Apps Changes - The setup variable feature will replace existing UI application and switch to serial base console input/output. All agents will leverage policy framework to set/get hardware configurations. Silicon Code Changes - The silicon firmware may need changes for: Add depex statement for drivers to load after policy database Locate policy protocol/ppis for silicon configuration Platform Data Flow - Modules provided in this package for platform to load/update configuration data. Platform Data Consumption - Description of expected platform workflow on how to consume data from configuration variables convert to policy data. Configuration App Code Integration - How to best integrate the SetupDataPkg collateral into a platform firmware. Profiles Integration - How to integrate Configuration Profiles into platform firmware. Configuration Apps Changes \u00b6 The Configuration Applications are based on the framework of policy services and DFCI from Project MU. Start with the fundamentals of these 2 features from MU_BASECORE and MU_PLUS . Instead of rendering all available options in the UEFI front page, which is backed by HII data and complicated UI frameworks, the configuration applications will focus on configuration data pipeline and actual functionality. All configuration data will originate from platform default silicon policy setup, any configuration data will be applied on top of default values. More of this data flow will be documented in Platform Data Flow section. Silicon Code Changes \u00b6 For each applicable silicon drivers that needs to be configured during UEFI operation, the silicon drivers needs to be updated to pull silicon policy data. For each configurable silicon feature/component/module, one needs to define a structure that contains all necessary settings. These settings will be populated with default value during PEI phase. When silicon module is executed, the consuming module should fetch policy data from database and configure the hardware accordingly. Platform Data Flow \u00b6 There will be few modules provided and library classes defined for platform to define their own configuration data. More of modules needed to this feature, please see Configuration App Code Integration . The default policy should be initialized by platform module during early boot phase policy framework is ready. After initial policy data was populated, platform logic should look up corresponding configuration data, if available, from variable storage for the most up-to-date configuration data. Silicon policies defined in Silicon Code Changes should then be overridden after platform translation. Note: If there is no configuration variable found, the module will attempt to locate default configuration data from UEFI firmware volume blob. During the rest of boot process, the silicon drivers will consume the updated policy data to configure hardware components. With configuration data, config data library can walk through the configuration blob into and dispatch the data with tag based buffer. During DXE phase, ConfDataSettingProvider.inf will be loaded and register one setting provider for receiving full configuration data (designed to reduce configuration transmission overhead), as well as an individual setting provider per define Tag ID, based on holistic Config data blob carried in FV, in the DFCI framework. The holistic settings setter will walk through the incoming binary data blob and dispatch to individual setting providers, whereas the individual settings providers will directly operate on the SINGLE_SETTING_PROVIDER_TEMPLATE formatted UEFI variables for updating, retrieving. Platform Data Consumption \u00b6 In order for drivers provided by this package to function as expected, the platform owners are suggested for authoring the following routines to properly consume configuration data: Platform Policy Initialization \u00b6 Per silicon policy defintion, platforms are responsible for initializing the silicon policy with a default value when configuration when under the circumstance that its corresponding configuration is not present or not even defined. Config Data Translation \u00b6 If the corresponding configuration is defined and exposed, the platform developer should query variable with the format of Device.ConfigData.TagID_%08X or defined as SINGLE_SETTING_PROVIDER_TEMPLATE , where the %08X should be populated with the intended Tag ID defined in the configuration YAML file set. Configuration App Code Integration \u00b6 Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202108\") The prerequisites of this feature is Policy services and Project MU based BDS as well as DFCI features. This guideline will omit the integration steps for these features. For more information about DFCI integration, please see here . Note: A list of the libraries and modules made available by this package is provided in the Software Component Overview . Platform DSC statements \u00b6 Add the DSC sections below. Note: This is change is on top of Project MU based BDS and DFCI feature. [ PcdsFixedAtBuild ] # The GUID of SetupDataPkg/ConfApp/ConfApp.inf: E3624086-4FCD-446E-9D07-B6B913792071 gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile | { 0x86, 0x40, 0x62, 0xe3, 0xcd, 0x4f, 0x6e, 0x44, 0x9d, 0x7, 0xb6, 0xb9, 0x13, 0x79, 0x20, 0x71 } [ LibraryClasses ] ConfigBlobBaseLib | SetupDataPkg/Library/ConfigBlobBaseLib/ConfigBlobBaseLib.inf ConfigDataLib | SetupDataPkg/Library/ConfigDataLib/ConfigDataLib.inf ConfigVariableListLib | SetupDataPkg/Library/ConfigVariableListLib/ConfigVariableListLib.inf [ Components.X64, Components.AARCH64 ] # # Setup variables # SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf { <PcdsFixedAtBuild> gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel | 0x80000000 } SetupDataPkg/ConfApp/ConfApp.inf { <LibraryClasses> JsonLiteParserLib | MsCorePkg/Library/JsonLiteParser/JsonLiteParser.inf } Remove the DSC sections below. [ Components.X64, Components.AARCH64 ] # MdeModulePkg/Application/UiApp/UiApp.inf { # <LibraryClasses> # NULL|MdeModulePkg/Library/DeviceManagerUiLib/DeviceManagerUiLib.inf # NULL|MdeModulePkg/Library/BootManagerUiLib/BootManagerUiLib.inf # NULL|MdeModulePkg/Library/BootMaintenanceManagerUiLib/BootMaintenanceManagerUiLib.inf # PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf # } Platform FDF statements \u00b6 Add the FDF sections below. Note: This is change is on top of Project MU based BDS and DFCI feature. [ FV.YOUR_DXE_FV ] INF SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf INF SetupDataPkg/ConfApp/ConfApp.inf Remove the FDF sections below. [ FV.YOUR_DXE_FV ] # INF MdeModulePkg/Application/UiApp/UiApp.inf Profiles Integration \u00b6 In order to use configuration profiles, the platform must include the above changes as well as include a YAML file that contains the default values for the generic profile. If additional profiles are required, the platform must include YAML delta files for each profile that are overrides on top of the generic profile. These are created through the Config Editor UI tool by choosing Save Config Changes to Change File or Save Full Config to Change File (more details in the Configuration Files doc ). PlatformBuild.py Changes \u00b6 Add or update the PlatformBuild.py environment variables below, where DELTA_CONF_POLICY is a semicolon delimited list of the delta files representing additional profiles. def SetPlatformEnv ( self ) : ... self.env.SetValue ( \"YAML_CONF_FILE\" , self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"CfgDataDef.yaml\" ) , \"Platform Hardcoded\" ) self.env.SetValue ( \"DELTA_CONF_POLICY\" , self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"Profile1.dlt\" ) + \";\" + \\ self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"Profile2.dlt\" ) + \";\" + \\ ... self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"ProfileN.dlt\" ) , \"Platform Hardcoded\" ) ... Platform DEC Changes \u00b6 The platform must define GUIDs for each additional profile beyond the generic profile (which has a defined GUID in SetupDataPkg). [ Guids ] ... ## Example Profile 1 will be stored in FV under this GUID gPlatformPkgProfile1Guid = { SOME_GUID } ## Example Profile 2 will be stored in FV under this GUID gPlatformPkgProfile2Guid = { SOME_GUID } ... ## Example Profile N will be stored in FV under this GUID gPlatformPkgProfileNGuid = { SOME_GUID } ... Platform DSC Changes \u00b6 The platform must add ActiveProfileSelectorLib (whether the null instance or a platform specific instance): [ LibraryClasses ] ... # Platform can override to non-Null Lib ActiveProfileSelectorLib | SetupDataPkg/Library/ActiveProfileSelectorLibNull/ActiveProfileSelectorLibNull.inf ... The platform must build ConfProfileMgrDxe: [ Components.X64, Components.AARCH64 ] ... # Profile Enforcement SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf ... The platform must also override the below PCD: [ PcdsFixedAtBuild ] ... ## List of valid Profile GUIDs ## gSetupDataPkgGenericProfileGuid is defaulted to in case retrieved GUID is not in this list gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList | { GUID ( \"SOME_GUID\" ) , GUID ( \"SOME_GUID\" ) , ..., GUID ( \"SOME_GUID\" ) } ... The platform can optionally override the below default value (only useful if using ActiveProfileSelectorLibNull): [ PcdsDynamicExDefault ] ... # Default this to gSetupDataPkgGenericProfileGuid gSetupDataPkgTokenSpaceGuid.PcdSetupConfigActiveProfileFile | { GUID ( \"SOME_GUID\" ) } ... Platform FDF Changes \u00b6 The platform must add ConfProfileMgrDxe and the profiles to the FDF for each desired profile and the generic profile. [ FV.DXEFV ] ... INF SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf ... FILE FREEFORM = gSetupDataPkgGenericProfileGuid { SECTION RAW = $( CONF_BIN_FILE_0 ) } FILE FREEFORM = gPlatformPkgProfile1Guid { SECTION RAW = $( CONF_BIN_FILE_1 ) } FILE FREEFORM = gPlatformPkgProfile2Guid { SECTION RAW = $( CONF_BIN_FILE_2 ) } ... FILE FREEFORM = gPlatformPkgProfileNGuid { SECTION RAW = $( CONF_BIN_FILE_N ) } ...","title":"Platform Integration Steps"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#configuration-modules-platform-integration","text":"The configuration modules source code is intended to be used with some library classes provided by platforms. In order to integrate configuration modules into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces.","title":"Configuration Modules Platform Integration"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#high-level-considerations","text":"Configuration Apps Changes - The setup variable feature will replace existing UI application and switch to serial base console input/output. All agents will leverage policy framework to set/get hardware configurations. Silicon Code Changes - The silicon firmware may need changes for: Add depex statement for drivers to load after policy database Locate policy protocol/ppis for silicon configuration Platform Data Flow - Modules provided in this package for platform to load/update configuration data. Platform Data Consumption - Description of expected platform workflow on how to consume data from configuration variables convert to policy data. Configuration App Code Integration - How to best integrate the SetupDataPkg collateral into a platform firmware. Profiles Integration - How to integrate Configuration Profiles into platform firmware.","title":"High-Level Considerations"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#configuration-apps-changes","text":"The Configuration Applications are based on the framework of policy services and DFCI from Project MU. Start with the fundamentals of these 2 features from MU_BASECORE and MU_PLUS . Instead of rendering all available options in the UEFI front page, which is backed by HII data and complicated UI frameworks, the configuration applications will focus on configuration data pipeline and actual functionality. All configuration data will originate from platform default silicon policy setup, any configuration data will be applied on top of default values. More of this data flow will be documented in Platform Data Flow section.","title":"Configuration Apps Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#silicon-code-changes","text":"For each applicable silicon drivers that needs to be configured during UEFI operation, the silicon drivers needs to be updated to pull silicon policy data. For each configurable silicon feature/component/module, one needs to define a structure that contains all necessary settings. These settings will be populated with default value during PEI phase. When silicon module is executed, the consuming module should fetch policy data from database and configure the hardware accordingly.","title":"Silicon Code Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-flow","text":"There will be few modules provided and library classes defined for platform to define their own configuration data. More of modules needed to this feature, please see Configuration App Code Integration . The default policy should be initialized by platform module during early boot phase policy framework is ready. After initial policy data was populated, platform logic should look up corresponding configuration data, if available, from variable storage for the most up-to-date configuration data. Silicon policies defined in Silicon Code Changes should then be overridden after platform translation. Note: If there is no configuration variable found, the module will attempt to locate default configuration data from UEFI firmware volume blob. During the rest of boot process, the silicon drivers will consume the updated policy data to configure hardware components. With configuration data, config data library can walk through the configuration blob into and dispatch the data with tag based buffer. During DXE phase, ConfDataSettingProvider.inf will be loaded and register one setting provider for receiving full configuration data (designed to reduce configuration transmission overhead), as well as an individual setting provider per define Tag ID, based on holistic Config data blob carried in FV, in the DFCI framework. The holistic settings setter will walk through the incoming binary data blob and dispatch to individual setting providers, whereas the individual settings providers will directly operate on the SINGLE_SETTING_PROVIDER_TEMPLATE formatted UEFI variables for updating, retrieving.","title":"Platform Data Flow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-consumption","text":"In order for drivers provided by this package to function as expected, the platform owners are suggested for authoring the following routines to properly consume configuration data:","title":"Platform Data Consumption"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-policy-initialization","text":"Per silicon policy defintion, platforms are responsible for initializing the silicon policy with a default value when configuration when under the circumstance that its corresponding configuration is not present or not even defined.","title":"Platform Policy Initialization"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#config-data-translation","text":"If the corresponding configuration is defined and exposed, the platform developer should query variable with the format of Device.ConfigData.TagID_%08X or defined as SINGLE_SETTING_PROVIDER_TEMPLATE , where the %08X should be populated with the intended Tag ID defined in the configuration YAML file set.","title":"Config Data Translation"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#configuration-app-code-integration","text":"Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202108\") The prerequisites of this feature is Policy services and Project MU based BDS as well as DFCI features. This guideline will omit the integration steps for these features. For more information about DFCI integration, please see here . Note: A list of the libraries and modules made available by this package is provided in the Software Component Overview .","title":"Configuration App Code Integration"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-statements","text":"Add the DSC sections below. Note: This is change is on top of Project MU based BDS and DFCI feature. [ PcdsFixedAtBuild ] # The GUID of SetupDataPkg/ConfApp/ConfApp.inf: E3624086-4FCD-446E-9D07-B6B913792071 gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile | { 0x86, 0x40, 0x62, 0xe3, 0xcd, 0x4f, 0x6e, 0x44, 0x9d, 0x7, 0xb6, 0xb9, 0x13, 0x79, 0x20, 0x71 } [ LibraryClasses ] ConfigBlobBaseLib | SetupDataPkg/Library/ConfigBlobBaseLib/ConfigBlobBaseLib.inf ConfigDataLib | SetupDataPkg/Library/ConfigDataLib/ConfigDataLib.inf ConfigVariableListLib | SetupDataPkg/Library/ConfigVariableListLib/ConfigVariableListLib.inf [ Components.X64, Components.AARCH64 ] # # Setup variables # SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf { <PcdsFixedAtBuild> gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel | 0x80000000 } SetupDataPkg/ConfApp/ConfApp.inf { <LibraryClasses> JsonLiteParserLib | MsCorePkg/Library/JsonLiteParser/JsonLiteParser.inf } Remove the DSC sections below. [ Components.X64, Components.AARCH64 ] # MdeModulePkg/Application/UiApp/UiApp.inf { # <LibraryClasses> # NULL|MdeModulePkg/Library/DeviceManagerUiLib/DeviceManagerUiLib.inf # NULL|MdeModulePkg/Library/BootManagerUiLib/BootManagerUiLib.inf # NULL|MdeModulePkg/Library/BootMaintenanceManagerUiLib/BootMaintenanceManagerUiLib.inf # PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf # }","title":"Platform DSC statements"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-statements","text":"Add the FDF sections below. Note: This is change is on top of Project MU based BDS and DFCI feature. [ FV.YOUR_DXE_FV ] INF SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf INF SetupDataPkg/ConfApp/ConfApp.inf Remove the FDF sections below. [ FV.YOUR_DXE_FV ] # INF MdeModulePkg/Application/UiApp/UiApp.inf","title":"Platform FDF statements"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#profiles-integration","text":"In order to use configuration profiles, the platform must include the above changes as well as include a YAML file that contains the default values for the generic profile. If additional profiles are required, the platform must include YAML delta files for each profile that are overrides on top of the generic profile. These are created through the Config Editor UI tool by choosing Save Config Changes to Change File or Save Full Config to Change File (more details in the Configuration Files doc ).","title":"Profiles Integration"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platformbuildpy-changes","text":"Add or update the PlatformBuild.py environment variables below, where DELTA_CONF_POLICY is a semicolon delimited list of the delta files representing additional profiles. def SetPlatformEnv ( self ) : ... self.env.SetValue ( \"YAML_CONF_FILE\" , self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"CfgDataDef.yaml\" ) , \"Platform Hardcoded\" ) self.env.SetValue ( \"DELTA_CONF_POLICY\" , self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"Profile1.dlt\" ) + \";\" + \\ self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"Profile2.dlt\" ) + \";\" + \\ ... self.mws.join ( self.ws, \"PlatformPkg\" , \"CfgData\" , \"ProfileN.dlt\" ) , \"Platform Hardcoded\" ) ...","title":"PlatformBuild.py Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dec-changes","text":"The platform must define GUIDs for each additional profile beyond the generic profile (which has a defined GUID in SetupDataPkg). [ Guids ] ... ## Example Profile 1 will be stored in FV under this GUID gPlatformPkgProfile1Guid = { SOME_GUID } ## Example Profile 2 will be stored in FV under this GUID gPlatformPkgProfile2Guid = { SOME_GUID } ... ## Example Profile N will be stored in FV under this GUID gPlatformPkgProfileNGuid = { SOME_GUID } ...","title":"Platform DEC Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-changes","text":"The platform must add ActiveProfileSelectorLib (whether the null instance or a platform specific instance): [ LibraryClasses ] ... # Platform can override to non-Null Lib ActiveProfileSelectorLib | SetupDataPkg/Library/ActiveProfileSelectorLibNull/ActiveProfileSelectorLibNull.inf ... The platform must build ConfProfileMgrDxe: [ Components.X64, Components.AARCH64 ] ... # Profile Enforcement SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf ... The platform must also override the below PCD: [ PcdsFixedAtBuild ] ... ## List of valid Profile GUIDs ## gSetupDataPkgGenericProfileGuid is defaulted to in case retrieved GUID is not in this list gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList | { GUID ( \"SOME_GUID\" ) , GUID ( \"SOME_GUID\" ) , ..., GUID ( \"SOME_GUID\" ) } ... The platform can optionally override the below default value (only useful if using ActiveProfileSelectorLibNull): [ PcdsDynamicExDefault ] ... # Default this to gSetupDataPkgGenericProfileGuid gSetupDataPkgTokenSpaceGuid.PcdSetupConfigActiveProfileFile | { GUID ( \"SOME_GUID\" ) } ...","title":"Platform DSC Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-changes","text":"The platform must add ConfProfileMgrDxe and the profiles to the FDF for each desired profile and the generic profile. [ FV.DXEFV ] ... INF SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf ... FILE FREEFORM = gSetupDataPkgGenericProfileGuid { SECTION RAW = $( CONF_BIN_FILE_0 ) } FILE FREEFORM = gPlatformPkgProfile1Guid { SECTION RAW = $( CONF_BIN_FILE_1 ) } FILE FREEFORM = gPlatformPkgProfile2Guid { SECTION RAW = $( CONF_BIN_FILE_2 ) } ... FILE FREEFORM = gPlatformPkgProfileNGuid { SECTION RAW = $( CONF_BIN_FILE_N ) } ...","title":"Platform FDF Changes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/","text":"Software Components of the Configuration Modules \u00b6 This section of documentation is focused on the software components of configuration modules that are useful during platform integration. ConfDataSettingProvider is a shim layer that registers setting provider for configuration data. The underneath implementation is operating on top of the per tag ID based configuration blob, either initialized from FV carried original configuration blob or updated through ConfApp. The implementation of walking through configuration data is expected to be provided by platform level module, which initializes the silicon policy for a given platform and ConfigDataLib , which converts configuration data to silicon policy and serialize them into printable strings. ConfApp is a UEFI application that replaces traditional UI application to display basic system information and provide minimal functionalities, including updating system configuration data. ConfProfileMgrDxe is a DXE driver that validates and enforces the active configuration profile in MFCI Customer Mode. For more general background about the steps necessary to integrate the configuration modules, please review the Platform Integration Steps . ActiveProfileSelectorLib is a library class that should be overwritten by the platform. It provides an interface to retrieve the active configuration profile for this boot. DXE Drivers \u00b6 Driver Location ConfDataSettingProvider SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf ConfProfileMgrDxe SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf UEFI Applications \u00b6 Application Location ConfApp SetupDataPkg/ConfApp/ConfApp.inf Library Classes \u00b6 Library Class Location ConfigBlobBaseLib SetupDataPkg/Include/Library/ConfigBlobBaseLib.h ConfigDataLib SetupDataPkg/Include/Library/ConfigDataLib.h ActiveProfileSelectorLib SetupDataPkg/Include/Library/ActiveProfileSelectorLib.h","title":"Software Component Overview"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#software-components-of-the-configuration-modules","text":"This section of documentation is focused on the software components of configuration modules that are useful during platform integration. ConfDataSettingProvider is a shim layer that registers setting provider for configuration data. The underneath implementation is operating on top of the per tag ID based configuration blob, either initialized from FV carried original configuration blob or updated through ConfApp. The implementation of walking through configuration data is expected to be provided by platform level module, which initializes the silicon policy for a given platform and ConfigDataLib , which converts configuration data to silicon policy and serialize them into printable strings. ConfApp is a UEFI application that replaces traditional UI application to display basic system information and provide minimal functionalities, including updating system configuration data. ConfProfileMgrDxe is a DXE driver that validates and enforces the active configuration profile in MFCI Customer Mode. For more general background about the steps necessary to integrate the configuration modules, please review the Platform Integration Steps . ActiveProfileSelectorLib is a library class that should be overwritten by the platform. It provides an interface to retrieve the active configuration profile for this boot.","title":"Software Components of the Configuration Modules"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#dxe-drivers","text":"Driver Location ConfDataSettingProvider SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf ConfProfileMgrDxe SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf","title":"DXE Drivers"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#uefi-applications","text":"Application Location ConfApp SetupDataPkg/ConfApp/ConfApp.inf","title":"UEFI Applications"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#library-classes","text":"Library Class Location ConfigBlobBaseLib SetupDataPkg/Include/Library/ConfigBlobBaseLib.h ConfigDataLib SetupDataPkg/Include/Library/ConfigDataLib.h ActiveProfileSelectorLib SetupDataPkg/Include/Library/ActiveProfileSelectorLib.h","title":"Library Classes"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/","text":"Configuration Profiles (BIOS Flavors) Implementation \u00b6 Table of Contents \u00b6 [[ TOC ]] Description \u00b6 This document describes the requirements, design considerations and APIs for UEFI Configuration Profiles Revision History \u00b6 Revised by Date Changes Oliver Smith-Denny 09/15/2022 Initial design Terms \u00b6 Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface MFCI Manufacturer Firmware Configuration Interface FV Firmware Volume Reference Documents \u00b6 Document Link MFCI Documentation Link DFCI Documentation Link UEFI Variable Policy Whitepaper Link SetupVariable Flow Link Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Introduction \u00b6 Configuration Profiles \u00b6 UEFI Configuration Profiles, historically called BIOS Flavors, are sets of defined values for UEFI configuration variables. Such profiles are useful where different owners may use the same hardware but have different requirements for UEFI configuration variables, such as one owner requiring Secure Boot enabled and SMT disabled and another owner requiring Secure Boot disabled and SMT enabled. Configuration profiles are provided by the FW as a means to allow both groups to use the same hardware and FW, but choosing different profiles with the set of configuration they require. Design \u00b6 Flow \u00b6 There will be one generic profile that describes the default values for all UEFI configuration variables. This generic profile will be generated during build time from one YAML configuration file specified in PlatformBuild.py as YAML_CONF_FILE . Additional profiles will be represented as delta files (.dlt files generated by the ConfigEditor UI tool ) with the profile name as the filename. These will be a semicolon delimited list in PlatformBuild.py under the name DELTA_CONF_POLICY . During build time, the GenSetupDataBin.py build plugin will generate variable list binaries describing each profile under the build variables CONF_BIN_FILE_0 ... CONF_BIN_FILE_N . These are expected to be consumed in the platform FDF under the profile GUIDs, where gSetupDataPkgGenericProfileGuid must have a corresponding entry. The platform will override gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList as a FixedAtBuild PCD in their dsc file with a list of the valid profile GUIDs that exist for that platform. Any received or cached active profile GUIDs will be validated against this list. If they are not in this list, gSetupDataPkgGenericProfileGuid will be used as the active profile GUID. Platform owners can develop a configuration profile for their use case. Following examples and the format provided in the ConfigurationFiles doc , these owners can create a YAML delta file describing the set of configuration variables and their values that are in the profile that differ from the generic profile. The ConfigEditor UI tool may be used to assist in loading the YAML and saving the output into delta files, as well as manipulating the values as necessary. The profiles will be used as overrides to the silicon policy published earlier in the boot. It is the responsibility of the drivers that map platform configuration to silicon policy to consume the platform configuration variables. In DXE, the ActiveProfileSelectorLib library class is queried to return the active profile file GUID to use for this boot. ConfProfileMgrDxe will compare this profile GUID against what is loaded into the variable store. If the profile does not match, ConfProfileMgrDxe will write the chosen profile variables into the variable store and reboot the system. The profiles will define the entire set of UEFI configuration variables. Profile Update \u00b6 Profiles will only be added and have values updated during build time. If a new configuration knob is required to be added to the configuration profile, it must go into the generic profile with a default value in addition to whichever profiles choose to override it. If a configuration knob is required to change to a new value with the same structure, it can simply be updated using the Config Editor UI tool to the new value. If a new structure is required for an existing configuration knob, then it is required that a new configuration knob be added, with the old knob being removed as soon as feasible. Active Profile Selection \u00b6 The ActiveProfileSelectorLib library class is intended to have the platform override the value. It will retrieve the active profile file GUID. If ActiveProfileSelectorLib has a failure or returns a file GUID not in gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList , ConfProfileMgrDxe will attempt to fall back to the last used profile, if one exists. If the cached profile is not found or has an invalid value, ConfProfileDxe will use the generic profile, under the GUID gSetupDataPkgGenericProfileGuid , as the active profile. A given platform should override the ActiveProfileSelectorLib library class to retrieve the active profile file GUID from their source of truth. Profile Enforcement \u00b6 In MFCI Customer Mode, the active profile will be enforced on every boot. If the variable store has any values that are invalid according to the profile, ConfProfileMgrDxe will write the profile values and reset the system. In MFCI Manufacturing Mode, the active profile will not be enforced. ConfProfileMgrDxe will not attempt to validate the variable store contents against the profile values.","title":"Profiles"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#configuration-profiles-bios-flavors-implementation","text":"","title":"Configuration Profiles (BIOS Flavors) Implementation"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#table-of-contents","text":"[[ TOC ]]","title":"Table of Contents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#description","text":"This document describes the requirements, design considerations and APIs for UEFI Configuration Profiles","title":"Description"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#revision-history","text":"Revised by Date Changes Oliver Smith-Denny 09/15/2022 Initial design","title":"Revision History"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#terms","text":"Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface MFCI Manufacturer Firmware Configuration Interface FV Firmware Volume","title":"Terms"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#reference-documents","text":"Document Link MFCI Documentation Link DFCI Documentation Link UEFI Variable Policy Whitepaper Link SetupVariable Flow Link Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained","title":"Reference Documents"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#introduction","text":"","title":"Introduction"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#configuration-profiles","text":"UEFI Configuration Profiles, historically called BIOS Flavors, are sets of defined values for UEFI configuration variables. Such profiles are useful where different owners may use the same hardware but have different requirements for UEFI configuration variables, such as one owner requiring Secure Boot enabled and SMT disabled and another owner requiring Secure Boot disabled and SMT enabled. Configuration profiles are provided by the FW as a means to allow both groups to use the same hardware and FW, but choosing different profiles with the set of configuration they require.","title":"Configuration Profiles"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#design","text":"","title":"Design"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#flow","text":"There will be one generic profile that describes the default values for all UEFI configuration variables. This generic profile will be generated during build time from one YAML configuration file specified in PlatformBuild.py as YAML_CONF_FILE . Additional profiles will be represented as delta files (.dlt files generated by the ConfigEditor UI tool ) with the profile name as the filename. These will be a semicolon delimited list in PlatformBuild.py under the name DELTA_CONF_POLICY . During build time, the GenSetupDataBin.py build plugin will generate variable list binaries describing each profile under the build variables CONF_BIN_FILE_0 ... CONF_BIN_FILE_N . These are expected to be consumed in the platform FDF under the profile GUIDs, where gSetupDataPkgGenericProfileGuid must have a corresponding entry. The platform will override gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList as a FixedAtBuild PCD in their dsc file with a list of the valid profile GUIDs that exist for that platform. Any received or cached active profile GUIDs will be validated against this list. If they are not in this list, gSetupDataPkgGenericProfileGuid will be used as the active profile GUID. Platform owners can develop a configuration profile for their use case. Following examples and the format provided in the ConfigurationFiles doc , these owners can create a YAML delta file describing the set of configuration variables and their values that are in the profile that differ from the generic profile. The ConfigEditor UI tool may be used to assist in loading the YAML and saving the output into delta files, as well as manipulating the values as necessary. The profiles will be used as overrides to the silicon policy published earlier in the boot. It is the responsibility of the drivers that map platform configuration to silicon policy to consume the platform configuration variables. In DXE, the ActiveProfileSelectorLib library class is queried to return the active profile file GUID to use for this boot. ConfProfileMgrDxe will compare this profile GUID against what is loaded into the variable store. If the profile does not match, ConfProfileMgrDxe will write the chosen profile variables into the variable store and reboot the system. The profiles will define the entire set of UEFI configuration variables.","title":"Flow"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#profile-update","text":"Profiles will only be added and have values updated during build time. If a new configuration knob is required to be added to the configuration profile, it must go into the generic profile with a default value in addition to whichever profiles choose to override it. If a configuration knob is required to change to a new value with the same structure, it can simply be updated using the Config Editor UI tool to the new value. If a new structure is required for an existing configuration knob, then it is required that a new configuration knob be added, with the old knob being removed as soon as feasible.","title":"Profile Update"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#active-profile-selection","text":"The ActiveProfileSelectorLib library class is intended to have the platform override the value. It will retrieve the active profile file GUID. If ActiveProfileSelectorLib has a failure or returns a file GUID not in gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList , ConfProfileMgrDxe will attempt to fall back to the last used profile, if one exists. If the cached profile is not found or has an invalid value, ConfProfileDxe will use the generic profile, under the GUID gSetupDataPkgGenericProfileGuid , as the active profile. A given platform should override the ActiveProfileSelectorLib library class to retrieve the active profile file GUID from their source of truth.","title":"Active Profile Selection"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#profile-enforcement","text":"In MFCI Customer Mode, the active profile will be enforced on every boot. If the variable store has any values that are invalid according to the profile, ConfProfileMgrDxe will write the profile values and reset the system. In MFCI Manufacturing Mode, the active profile will not be enforced. ConfProfileMgrDxe will not attempt to validate the variable store contents against the profile values.","title":"Profile Enforcement"},{"location":"dyn/mu_feature_config/github/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"github"},{"location":"dyn/mu_feature_config/github/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation?","title":"Description"},{"location":"dyn/mu_feature_config/github/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_feature_config/github/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/","text":"Contributing to Project Mu \u00b6 Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation . Asking Questions \u00b6 Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo. Reporting Issues \u00b6 Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section. Identify Where to Report \u00b6 Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary. Look For an Existing Issue \u00b6 Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below. Follow Your Issue \u00b6 Please continue to follow your request after it is submitted to assist with any additional information that might be requested. Thank You \u00b6 Thank you for your interest in Project Mu and taking the time to contribute!","title":"CONTRIBUTING"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#contributing-to-project-mu","text":"Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation .","title":"Contributing to Project Mu"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#asking-questions","text":"Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo.","title":"Asking Questions"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#reporting-issues","text":"Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.","title":"Reporting Issues"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#identify-where-to-report","text":"Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.","title":"Identify Where to Report"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#look-for-an-existing-issue","text":"Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.","title":"Look For an Existing Issue"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#follow-your-issue","text":"Please continue to follow your request after it is submitted to assist with any additional information that might be requested.","title":"Follow Your Issue"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#thank-you","text":"Thank you for your interest in Project Mu and taking the time to contribute!","title":"Thank You"},{"location":"dyn/mu_feature_ipmi/RepoDetails/","text":"Project MU IPMI Feature \u00b6 Git Details Repository Url: https://github.com/microsoft/mu_feature_ipmi.git Branch: main Commit: bd091a557d30c831f2ccdb22a7e444d425fd6dba Commit Date: 2022-11-30 11:28:51 -0500 The repo contains the MU implementation for the IPMI feature package based on TianoCore code. This code should be consumed as needed for IPMI feature support.","title":"Repo Details"},{"location":"dyn/mu_feature_ipmi/RepoDetails/#project-mu-ipmi-feature","text":"Git Details Repository Url: https://github.com/microsoft/mu_feature_ipmi.git Branch: main Commit: bd091a557d30c831f2ccdb22a7e444d425fd6dba Commit Date: 2022-11-30 11:28:51 -0500 The repo contains the MU implementation for the IPMI feature package based on TianoCore code. This code should be consumed as needed for IPMI feature support.","title":"Project MU IPMI Feature"},{"location":"dyn/mu_feature_ipmi/SECURITY/","text":"Security \u00b6 Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below. Reporting Security Issues \u00b6 Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs. Preferred Languages \u00b6 We prefer all communications to be in English. Policy \u00b6 Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"SECURITY"},{"location":"dyn/mu_feature_ipmi/SECURITY/#security","text":"Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below.","title":"Security"},{"location":"dyn/mu_feature_ipmi/SECURITY/#reporting-security-issues","text":"Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.","title":"Reporting Security Issues"},{"location":"dyn/mu_feature_ipmi/SECURITY/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"},{"location":"dyn/mu_feature_ipmi/SECURITY/#policy","text":"Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"Policy"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/","text":"IpmiFeaturePkg \u00b6 This package contains core code and features for leveraging IPMI in UEFI. For details on the design of the IPMI package see the IPMI feature documentation . Configuring the IPMI package \u00b6 The IPMI feature package is designed to be customizable to fit the needs of the platform. This can be done through a combination of platform libraries and PCD settings. Important PCDs \u00b6 For the full list of PCDs, see the package DEC file . Generic IPMI PcdIpmiCheckSelfTestResults - Indicates the self-test command should be queried for IPMI initialization. PcdIpmiCommandTimeoutSeconds - Timeout for IPMI command response. PcdBmcTimeoutSeconds - Timeout for initial BMC initialization. IPMI Watchdog PcdFrb2EnabledFlag - Enables use of the FRB2 watchdog for UEFI boot. PcdFrb2TimeoutSeconds - FRB2 timeout in seconds. PcdFrb2TimeoutAction - Action taken on FRB2 timeout. PcdOsWatchdogEnabled - Enables the OS watchdog at exit boot services. PcdOsWatchdogTimeoutSeconds - The timeout for the OS watchdog in seconds. PcdOsWatchdogAction - Action taken on OS watchdog timeout. SEL Library PcdIpmiSelOemManufacturerId - The manufacturer ID used in OEM SEL events. Platform Libraries \u00b6 The primary location for platform customization of the generic IPMI code is in the IPMI Platform library. If the system requires special initialization logic, self-test handling, IO port configuration, etc, then it should be done by implementing this library. Additionally the platform may choice to implement their own IPMI transport library for a non-standard communication method wth the BMC. Samples \u00b6 The samples directory in this package is intended to provide examples of common usage of the IPMI package components that are not suitable for generic implementation. Platforms may choose to use these as a starting point or reference for implementing similar functionality, but these implementations cannot be used as-is.","title":"Readme"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#ipmifeaturepkg","text":"This package contains core code and features for leveraging IPMI in UEFI. For details on the design of the IPMI package see the IPMI feature documentation .","title":"IpmiFeaturePkg"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#configuring-the-ipmi-package","text":"The IPMI feature package is designed to be customizable to fit the needs of the platform. This can be done through a combination of platform libraries and PCD settings.","title":"Configuring the IPMI package"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#important-pcds","text":"For the full list of PCDs, see the package DEC file . Generic IPMI PcdIpmiCheckSelfTestResults - Indicates the self-test command should be queried for IPMI initialization. PcdIpmiCommandTimeoutSeconds - Timeout for IPMI command response. PcdBmcTimeoutSeconds - Timeout for initial BMC initialization. IPMI Watchdog PcdFrb2EnabledFlag - Enables use of the FRB2 watchdog for UEFI boot. PcdFrb2TimeoutSeconds - FRB2 timeout in seconds. PcdFrb2TimeoutAction - Action taken on FRB2 timeout. PcdOsWatchdogEnabled - Enables the OS watchdog at exit boot services. PcdOsWatchdogTimeoutSeconds - The timeout for the OS watchdog in seconds. PcdOsWatchdogAction - Action taken on OS watchdog timeout. SEL Library PcdIpmiSelOemManufacturerId - The manufacturer ID used in OEM SEL events.","title":"Important PCDs"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#platform-libraries","text":"The primary location for platform customization of the generic IPMI code is in the IPMI Platform library. If the system requires special initialization logic, self-test handling, IO port configuration, etc, then it should be done by implementing this library. Additionally the platform may choice to implement their own IPMI transport library for a non-standard communication method wth the BMC.","title":"Platform Libraries"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#samples","text":"The samples directory in this package is intended to provide examples of common usage of the IPMI package components that are not suitable for generic implementation. Platforms may choose to use these as a starting point or reference for implementing similar functionality, but these implementations cannot be used as-is.","title":"Samples"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/","text":"IPMI Boot Options \u00b6 The IPMI boot option commands allows the system to query the BMC for the desired boot device and configuration. This is described in sections 28.11 and 28.12 of the the IPMI Specification 2 nd Generation v2.0 . Much of functionality of these parameters are no longer relevant or are not used in practice. IPMI Boot Option Library \u00b6 The IPMI feature package provides the IPMI Boot Option Library for easily querying the IPMI boot option information. Currently this is abstracted as only retrieving the desired boot device. The library will do the following to determine this device. Query the boot option parameter 5, checking that the parameter and boot flags are valid. Clear the boot flags if the persistance bit is not set. Send and acknowledgement to the BMC that the boot option has been handled by BIOS. Return the queried boot device. The caller is then responsible for ensuring the platform is configured to boot to the proper device for the returned value. Because the IPMI option is abstract, for example saying BootDefaultHardDrive , the caller should determine which specific device path this should correspond to. Because this library potentially clears the boot flags, this library should only be called once per boot. Implementing OEM Boot Options \u00b6 The IPMI feature package only implements standard IPMI boot option parameters with some minor industry updates since the IPMI specification does not reflect more modern devices. Any additional OEM defined parameters can be implemented on top of the base or command libraries and can be used instead of or in conjunction with the standard boot option library.","title":"Ipmi Boot Options"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/#ipmi-boot-options","text":"The IPMI boot option commands allows the system to query the BMC for the desired boot device and configuration. This is described in sections 28.11 and 28.12 of the the IPMI Specification 2 nd Generation v2.0 . Much of functionality of these parameters are no longer relevant or are not used in practice.","title":"IPMI Boot Options"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/#ipmi-boot-option-library","text":"The IPMI feature package provides the IPMI Boot Option Library for easily querying the IPMI boot option information. Currently this is abstracted as only retrieving the desired boot device. The library will do the following to determine this device. Query the boot option parameter 5, checking that the parameter and boot flags are valid. Clear the boot flags if the persistance bit is not set. Send and acknowledgement to the BMC that the boot option has been handled by BIOS. Return the queried boot device. The caller is then responsible for ensuring the platform is configured to boot to the proper device for the returned value. Because the IPMI option is abstract, for example saying BootDefaultHardDrive , the caller should determine which specific device path this should correspond to. Because this library potentially clears the boot flags, this library should only be called once per boot.","title":"IPMI Boot Option Library"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/#implementing-oem-boot-options","text":"The IPMI feature package only implements standard IPMI boot option parameters with some minor industry updates since the IPMI specification does not reflect more modern devices. Any additional OEM defined parameters can be implemented on top of the base or command libraries and can be used instead of or in conjunction with the standard boot option library.","title":"Implementing OEM Boot Options"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/","text":"Ipmi Feature \u00b6 This package implements core-functionality for IPMI as well as several services built on IPMI. See IPMI Specification 2 nd Generation v2.0 for more information. This document details the design on the IPMI feature. For using and configuring this feature package, see the package readme . For specific functionality within this package see the other documents. IPMI Watchdog IPMI Boot Options IPMI System Event Log Purpose \u00b6 The IPMI feature provides firmware functionality that implements behavior described in the IPMI specification. IPMI enables out-of-band and monitoring capabilities independent of the host system's CPU, firmware, and operating system by communicating with the Baseboard Management Controller (BMC). The IPMI feature is intended to be directly used by platforms without the need to customize the core code. Instead platforms should leverage the exposed PCDs and library options to either customize the core functionality or implement their own in the library plugins. Structure \u00b6 The IPMI stack consists of several layers of functionality each with a set API for consumers to leverage. Transport Library - This consists of the KCS and SSIF IPMI transport libraries. These are responsible for implementing the necessary physical transport logic for the platform. This layer does not need to understand the structure of IPMI messages. The transport library definitions are in the transport library header file . Generic IPMI - Implements the generic IPMI in a protocol, PPI, or MM driver. This layer is responsible for taking a high level IPMI request and building the IPMI request and parsing the response. Generic IPMI will rely on the transport library to handle the hardware specifics. External consumers of the IPMI package should consider using the base library. The generic transport interface is defined in the IPMI interface header file but should be considered internal. IPMI Base Library - Supplies a library abstraction for the basic functionality provided by the Generic IPMI component. This is the API surface that should be used for platform components implementing non-standard IPMI messages. The library definitions are in the base library header file . IPMI Command Library - Implements wrappers for specific IPMI functions. This calls into the IPMI base library. This is provided as a convenient wrapper for standard IPMI messages. Supported commands are defined in the command library header file Functional IPMI Drivers - Implements functionality around IPMI. Consists of the drivers such as IpmiWatchdog which rely on the IPMI command library. Extending the IPMI Command Set \u00b6 Platforms may implement custom or specialized IPMI commands and functionality that are not implemented in this repo. In this case, the platform should leverage the IPMI base library to abstract the interface into a single command which they can provide an opaque command and response buffer. Platforms may call directly into the protocols/PPIs if needed, but for consistency it is advised to use the base library. Testing the IPMI feature \u00b6 Because IPMI relies on communication with a BMC, real testing often requires a physical device or complicated virtual environment. To facilitate unit tests and more accessible function tests, this package makes use of a mock IPMI library to test in user mode components or a environment without real IPMI support. This library can either be compiled into a host-based unit test for build time tests or can be used as the transport library for the generic ipmi modules to fake IPMI support in UEFI. When support is added for new IPMI features, support should also be added in the mock library to facilitate unit tests for the new feature.","title":"Ipmi Feature"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#ipmi-feature","text":"This package implements core-functionality for IPMI as well as several services built on IPMI. See IPMI Specification 2 nd Generation v2.0 for more information. This document details the design on the IPMI feature. For using and configuring this feature package, see the package readme . For specific functionality within this package see the other documents. IPMI Watchdog IPMI Boot Options IPMI System Event Log","title":"Ipmi Feature"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#purpose","text":"The IPMI feature provides firmware functionality that implements behavior described in the IPMI specification. IPMI enables out-of-band and monitoring capabilities independent of the host system's CPU, firmware, and operating system by communicating with the Baseboard Management Controller (BMC). The IPMI feature is intended to be directly used by platforms without the need to customize the core code. Instead platforms should leverage the exposed PCDs and library options to either customize the core functionality or implement their own in the library plugins.","title":"Purpose"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#structure","text":"The IPMI stack consists of several layers of functionality each with a set API for consumers to leverage. Transport Library - This consists of the KCS and SSIF IPMI transport libraries. These are responsible for implementing the necessary physical transport logic for the platform. This layer does not need to understand the structure of IPMI messages. The transport library definitions are in the transport library header file . Generic IPMI - Implements the generic IPMI in a protocol, PPI, or MM driver. This layer is responsible for taking a high level IPMI request and building the IPMI request and parsing the response. Generic IPMI will rely on the transport library to handle the hardware specifics. External consumers of the IPMI package should consider using the base library. The generic transport interface is defined in the IPMI interface header file but should be considered internal. IPMI Base Library - Supplies a library abstraction for the basic functionality provided by the Generic IPMI component. This is the API surface that should be used for platform components implementing non-standard IPMI messages. The library definitions are in the base library header file . IPMI Command Library - Implements wrappers for specific IPMI functions. This calls into the IPMI base library. This is provided as a convenient wrapper for standard IPMI messages. Supported commands are defined in the command library header file Functional IPMI Drivers - Implements functionality around IPMI. Consists of the drivers such as IpmiWatchdog which rely on the IPMI command library.","title":"Structure"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#extending-the-ipmi-command-set","text":"Platforms may implement custom or specialized IPMI commands and functionality that are not implemented in this repo. In this case, the platform should leverage the IPMI base library to abstract the interface into a single command which they can provide an opaque command and response buffer. Platforms may call directly into the protocols/PPIs if needed, but for consistency it is advised to use the base library.","title":"Extending the IPMI Command Set"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#testing-the-ipmi-feature","text":"Because IPMI relies on communication with a BMC, real testing often requires a physical device or complicated virtual environment. To facilitate unit tests and more accessible function tests, this package makes use of a mock IPMI library to test in user mode components or a environment without real IPMI support. This library can either be compiled into a host-based unit test for build time tests or can be used as the transport library for the generic ipmi modules to fake IPMI support in UEFI. When support is added for new IPMI features, support should also be added in the mock library to facilitate unit tests for the new feature.","title":"Testing the IPMI feature"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_System_Event_Log/","text":"IPMI System Event Log (SEL) \u00b6 The IPMI System Even Log (SEL) is a persistent logging interface detailed in section 31 of the IPMI specification. This package provides the IPMI SEL Library to allow for easy use of the SEL interface. It is advised that this library be used for creating or reading SEL events.","title":"Ipmi System Event Log"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_System_Event_Log/#ipmi-system-event-log-sel","text":"The IPMI System Even Log (SEL) is a persistent logging interface detailed in section 31 of the IPMI specification. This package provides the IPMI SEL Library to allow for easy use of the SEL interface. It is advised that this library be used for creating or reading SEL events.","title":"IPMI System Event Log (SEL)"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Watchdog/","text":"IPMI Watchdog Timers \u00b6 The IPMI watchdog timers that are typically used are the FRB2 and OS timers. The FRB2 timer is used for UEFI boot and is typically configured during PEI and torn down at ready to boot in the BDS phase. The OS watchdog timer will be configured at exit boot services and will be handed off to the OS to maintain. The IPMI feature package provides two methods for configuring and controlling the watchdog timers. The watchdog lib and the Watchdog modules . The library provides the ability to generically configure, stop, and start a given watchdog timer while the module will do this automatically based on fixed or dynamic PCDs. Platforms that need strong control over the watchdog configuration, either for a particular timer or all may use the library directly. The library and module may be used in tandem, but it may not be desirable to use both the library and module in the same phase to avoid unexpected behavior or timing issues. The PEI implementation of the watchdog timer will configure the FRB2 timer, if enabled, at its entry during PEI. The DXE implementation will check the timer state on entry and set up a callback for ReadyToBoot to disable the FRB2 timer and ExitBootServices to enable the OS watchdog timer. Because the OS watchdog timer is based on dynamic PCDs, this configuration can be dynamically updated at boot time by any platform component so long as it's done before ExitBootServices .","title":"Ipmi Watchdog"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Watchdog/#ipmi-watchdog-timers","text":"The IPMI watchdog timers that are typically used are the FRB2 and OS timers. The FRB2 timer is used for UEFI boot and is typically configured during PEI and torn down at ready to boot in the BDS phase. The OS watchdog timer will be configured at exit boot services and will be handed off to the OS to maintain. The IPMI feature package provides two methods for configuring and controlling the watchdog timers. The watchdog lib and the Watchdog modules . The library provides the ability to generically configure, stop, and start a given watchdog timer while the module will do this automatically based on fixed or dynamic PCDs. Platforms that need strong control over the watchdog configuration, either for a particular timer or all may use the library directly. The library and module may be used in tandem, but it may not be desirable to use both the library and module in the same phase to avoid unexpected behavior or timing issues. The PEI implementation of the watchdog timer will configure the FRB2 timer, if enabled, at its entry during PEI. The DXE implementation will check the timer state on entry and set up a callback for ReadyToBoot to disable the FRB2 timer and ExitBootServices to enable the OS watchdog timer. Because the OS watchdog timer is based on dynamic PCDs, this configuration can be dynamically updated at boot time by any platform component so long as it's done before ExitBootServices .","title":"IPMI Watchdog Timers"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/IpmiTransportLibSsif/Readme/","text":"SSIF Transport Library \u00b6 This library implements the SMBus System Interface (SSIF) logic for communicating IPMI messages. Prerequisites \u00b6 For this transport library to operate, it assumes the platform will provide and implementation of the Simple SMBus library. This library is responsible for implementing the device specifics for the BMC and for accessing the I2C device.","title":"Ipmi Transport Lib Ssif"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/IpmiTransportLibSsif/Readme/#ssif-transport-library","text":"This library implements the SMBus System Interface (SSIF) logic for communicating IPMI messages.","title":"SSIF Transport Library"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/IpmiTransportLibSsif/Readme/#prerequisites","text":"For this transport library to operate, it assumes the platform will provide and implementation of the Simple SMBus library. This library is responsible for implementing the device specifics for the BMC and for accessing the I2C device.","title":"Prerequisites"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/MockIpmi/Readme/","text":"Mock IPMI Library \u00b6 The mock IPMI library is intended to be used to leverage the IPMI stack but without a real BMC providing the IPMI services. Currently, this means that the mock library will attempt to return a valid but often useless reply for most messages. This is useful for platform bring-up and testing new features in the IPMI feature package that may not have hardware support yet. The base library implementation of Mock IPMI is intended for use in host based unit tests of higher level functionality by allowing IPMI functionality without requiring the generic IPMI UEFI modules. To add new functionality to the mock IPMI library, handlers should be created and added to the MockHandlers array at the top of MockIpmi.c . The mock handlers will be provided in command data and the response data buffers. Failures should be reflected in the returned CompletionCode and the response size should always be set to the size of the returned structure.","title":"Mock Ipmi"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/MockIpmi/Readme/#mock-ipmi-library","text":"The mock IPMI library is intended to be used to leverage the IPMI stack but without a real BMC providing the IPMI services. Currently, this means that the mock library will attempt to return a valid but often useless reply for most messages. This is useful for platform bring-up and testing new features in the IPMI feature package that may not have hardware support yet. The base library implementation of Mock IPMI is intended for use in host based unit tests of higher level functionality by allowing IPMI functionality without requiring the generic IPMI UEFI modules. To add new functionality to the mock IPMI library, handlers should be created and added to the MockHandlers array at the top of MockIpmi.c . The mock handlers will be provided in command data and the response data buffers. Failures should be reflected in the returned CompletionCode and the response size should always be set to the size of the returned structure.","title":"Mock IPMI Library"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Samples/Readme/","text":"IPMI Package Samples \u00b6 This directory contains various sample implementations of modules and libraries that demonstrate common usage of the IPMI components, but may not be suitable for direct usage. Often this is because the ultimate functionality of the code is very platform specific and is not suitable for a generalize implementation. Instead, platforms consumers may wish to copy or use this code as reference for their own implementations. IPMI Status Reporter - This module is a sample for using the generic Status Code reporting mechanism in UEFI for logging events to the SEL.","title":"Samples"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Samples/Readme/#ipmi-package-samples","text":"This directory contains various sample implementations of modules and libraries that demonstrate common usage of the IPMI components, but may not be suitable for direct usage. Often this is because the ultimate functionality of the code is very platform specific and is not suitable for a generalize implementation. Instead, platforms consumers may wish to copy or use this code as reference for their own implementations. IPMI Status Reporter - This module is a sample for using the generic Status Code reporting mechanism in UEFI for logging events to the SEL.","title":"IPMI Package Samples"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"github"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation?","title":"Description"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/","text":"Contributing to Project Mu \u00b6 Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation . Asking Questions \u00b6 Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo. Reporting Issues \u00b6 Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section. Identify Where to Report \u00b6 Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary. Look For an Existing Issue \u00b6 Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below. Follow Your Issue \u00b6 Please continue to follow your request after it is submitted to assist with any additional information that might be requested. Thank You \u00b6 Thank you for your interest in Project Mu and taking the time to contribute!","title":"CONTRIBUTING"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#contributing-to-project-mu","text":"Welcome, and thank you for your interest in contributing to Project Mu! There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation .","title":"Contributing to Project Mu"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#asking-questions","text":"Have a question? Rather than opening an issue, please post your question under the Q&A category in the Discussions section of the relevant Project Mu GitHub repo.","title":"Asking Questions"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#reporting-issues","text":"Every Project Mu repo has an Issues section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.","title":"Reporting Issues"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#identify-where-to-report","text":"Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic. Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.","title":"Identify Where to Report"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#look-for-an-existing-issue","text":"Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed. If you find your issue already exists, make relevant comments and add your reaction . Use a reaction in place of a \"+1\" comment: \ud83d\udc4d - upvote \ud83d\udc4e - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.","title":"Look For an Existing Issue"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#follow-your-issue","text":"Please continue to follow your request after it is submitted to assist with any additional information that might be requested.","title":"Follow Your Issue"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#thank-you","text":"Thank you for your interest in Project Mu and taking the time to contribute!","title":"Thank You"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/","text":"Microsoft MM Supervisor \u00b6 Git Details Repository Url: https://github.com/microsoft/mu_feature_mm_supv.git Branch: main Commit: ee08b0be429392bd69b7e9dbde9af0e18a00eb60 Commit Date: 2022-11-30 15:05:17 -0500 Repository Philosophy \u00b6 Like other Project MU feature repositories, the Project MU MM Supervisor feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided. Consuming the MM Supervisor Feature Package \u00b6 Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_mm_supv_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired. { \"scope\" : \"global\" , \"type\" : \"git\" , \"name\" : \"FEATURE_MM_SUPV\" , \"var_name\" : \"FEATURE_MM_SUPV_PATH\" , \"source\" : \"https://github.com/microsoft/mu_feature_mm_supv.git\" , \"version\" : \"<RELEASE HASH>\" , \"flags\" : [ \"set_build_var\" ] } Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build MM supervisor GetPackagesPath list. shell_environment . GetBuildVars () . GetValue ( \"FEATURE_MM_SUPV_PATH\" , \"\" ) Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string. After this the package should be discoverable to can be used in the build like any other dependency. Code of Conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct https://opensource.microsoft.com/codeofconduct/ For more information see the Code of Conduct FAQ https://opensource.microsoft.com/codeofconduct/faq/ or contact opencode@microsoft.com <mailto:opencode@microsoft.com> _. with any additional questions or comments. Contributions \u00b6 Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/ Code Requirements Doc Requirements Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Repo Details"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#microsoft-mm-supervisor","text":"Git Details Repository Url: https://github.com/microsoft/mu_feature_mm_supv.git Branch: main Commit: ee08b0be429392bd69b7e9dbde9af0e18a00eb60 Commit Date: 2022-11-30 15:05:17 -0500","title":"Microsoft MM Supervisor"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#repository-philosophy","text":"Like other Project MU feature repositories, the Project MU MM Supervisor feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided.","title":"Repository Philosophy"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#consuming-the-mm-supervisor-feature-package","text":"Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_mm_supv_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired. { \"scope\" : \"global\" , \"type\" : \"git\" , \"name\" : \"FEATURE_MM_SUPV\" , \"var_name\" : \"FEATURE_MM_SUPV_PATH\" , \"source\" : \"https://github.com/microsoft/mu_feature_mm_supv.git\" , \"version\" : \"<RELEASE HASH>\" , \"flags\" : [ \"set_build_var\" ] } Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build MM supervisor GetPackagesPath list. shell_environment . GetBuildVars () . GetValue ( \"FEATURE_MM_SUPV_PATH\" , \"\" ) Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string. After this the package should be discoverable to can be used in the build like any other dependency.","title":"Consuming the MM Supervisor Feature Package"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct https://opensource.microsoft.com/codeofconduct/ For more information see the Code of Conduct FAQ https://opensource.microsoft.com/codeofconduct/faq/ or contact opencode@microsoft.com <mailto:opencode@microsoft.com> _. with any additional questions or comments.","title":"Code of Conduct"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#contributions","text":"Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/ Code Requirements Doc Requirements","title":"Contributions"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/","text":"Microsoft MM Supervisor Introduction \u00b6 Overview \u00b6 The Microsoft MM Supervisor brings new levels of security and usability to PC management mode. It is a new feature of UEFI that enables platform adaptive isolation protection under MM environment. The MM Supervisor intends to leverage standalone MM framework and CPU privilege level management to implement Kernel and User mode software environment for MM handler drivers. The objective is to enable platform MM isolation with binary release model for MM Supervisor and its loader. Why Isolating System Management Mode \u00b6 Traditional UEFI system management mode work flow is described in Traditional SMM Framework Flow . This solution has various drawbacks listed below: Late loading in the boot phase, so that other malicious DXE code may cause damage before SMM framework was set up Excessive interaction with boot code, which involves entangled database with DXE core, exposing extra attack interfaces SMI handlers run under Kernel mode, thus highly privileged code execution requires SMI handler author proceed with extra precaution More detailed introduction to existed SMM framework setup flow is included in (MmSupervisorDesign/mm_supervisor_design.md) Existed Intermediate Solutions \u00b6 Different silicon partners have their own solutions: Intel: ??? (Need some description here) AMD: SMM supervisor that will stick to traditional boot flow but change SMI entry point code to demote execution to CPL3 starting from gEfiDxeSmmReadyToLockProtocolGuid event and screen MSR, IO and memory access by attested platform policy. QC: ??? (Need some description here) MM Supervisor Mechanism \u00b6 MM foundation initialized early in the boot process and has isolated protocol and configuration table database MM supervisor mechanism holds separate service database MM drivers and handlers execute under user mode (CPL3) OEM Enablement Summary \u00b6 MM Isolation enablement is comprised of: MM Supervisor UEFI BIOS integration MM drivers implementation/conversion Platform specific isolation policy configuration MM Supervisor UEFI BIOS Integration \u00b6 The objective is to binary release MM Supervisor as core component. Thus ideally there should be platform dsc and fdf file change to include these entries into the UEFI code base for core capabilities. There are 4 essential drivers to be added to the device UEFI code base: StandaloneMmUnblockMem.efi PiSmmIpl.efi MmSupervisorCore.efi MmSupervisorRing3Broker.efi One requirement is that both of the drivers above and other MM drivers should reside in the same firmware volume. For current design, the MM Supervisor will not look for extra FVs once it has exited its entry point. MM Drivers Implementation/Conversion \u00b6 This section targets the SMM handler drivers of which module types are DXE_SMM_DRIVER. All gSmst table entries will have a one-to-one mapped field in gMmst. But there are still some limitations for currently existed SMM handler drivers. Once MM Supervisor is loaded, the data it can consume soly come from hob list, meaning SMM handlers drivers(type DXE_SMM_DRIVER) will not be able to consume the protocols, dependencies or event notification from DXE drivers unless relayed by a combination of one DXE driver communicate to one MM handler. Due to the above reason, there some functionalities that will not be provided in MM environment: Dynamic PCD consumption gBS services, i.e. memory allocation and free, get DXE memory map gDS services, i.e. install or check configuration tables For MM drivers that needs to access non-MMRAM region, an explicit MmUnblockMemoryRequest call needs to be invoke prior to its usage. Knowing the limitations listed below: When installation of MM foundation occurs in DXE phase, the MmUnblockMemoryRequest will not be available from the beginning in DXE till gEfiMmBaseProtocolGuid is installed. It is suggested to advance the unblock request as early as PEI if necessary. When MM foundation is installed in PEI, TBD... MmSupervisorRing3Broker driver has to be the first user mode driver loaded, assuming all user mode driver relies on gMmst. Thus the libraries linked to this driver can neither have any dependency on MmServicesTableLib nor attempt to access the EFI_MM_SYSTEM_TABLE passed in from library constructors. Platform Specific Isolation Policy Configuration \u00b6 This section describes how a platform can choose to add or remove protected MSRs, IO, memory region and instruction execution (if supported) based on platform needs. There is a minimum requirement for SMM isolation policy published by Microsoft where each platform has to block certain MSR, IO and memory region accesses to meet the criteria for Level 3 Secured Core PC environment. So a platform has to fullfil these requirements. (TODO: Link TBD) If platform has other resources would like to protect, i.e. proprietary MSR for special purpose, MMIO region for secure device, etc, platform can elect to add these entries to the corresponding section of policy file. Specific policy definition can be found here . UEFI Implementation Details \u00b6 Design: Proposed MM Supervisor boot flow and isolation mechanism Tradition: Introduction to traditional SMM implementation OEM Integration Guide \u00b6 Integration: MM Supervisor Integration Guides","title":"Mm Supervisor Feature"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#microsoft-mm-supervisor-introduction","text":"","title":"Microsoft MM Supervisor Introduction"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#overview","text":"The Microsoft MM Supervisor brings new levels of security and usability to PC management mode. It is a new feature of UEFI that enables platform adaptive isolation protection under MM environment. The MM Supervisor intends to leverage standalone MM framework and CPU privilege level management to implement Kernel and User mode software environment for MM handler drivers. The objective is to enable platform MM isolation with binary release model for MM Supervisor and its loader.","title":"Overview"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#why-isolating-system-management-mode","text":"Traditional UEFI system management mode work flow is described in Traditional SMM Framework Flow . This solution has various drawbacks listed below: Late loading in the boot phase, so that other malicious DXE code may cause damage before SMM framework was set up Excessive interaction with boot code, which involves entangled database with DXE core, exposing extra attack interfaces SMI handlers run under Kernel mode, thus highly privileged code execution requires SMI handler author proceed with extra precaution More detailed introduction to existed SMM framework setup flow is included in (MmSupervisorDesign/mm_supervisor_design.md)","title":"Why Isolating System Management Mode"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#existed-intermediate-solutions","text":"Different silicon partners have their own solutions: Intel: ??? (Need some description here) AMD: SMM supervisor that will stick to traditional boot flow but change SMI entry point code to demote execution to CPL3 starting from gEfiDxeSmmReadyToLockProtocolGuid event and screen MSR, IO and memory access by attested platform policy. QC: ??? (Need some description here)","title":"Existed Intermediate Solutions"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-supervisor-mechanism","text":"MM foundation initialized early in the boot process and has isolated protocol and configuration table database MM supervisor mechanism holds separate service database MM drivers and handlers execute under user mode (CPL3)","title":"MM Supervisor Mechanism"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#oem-enablement-summary","text":"MM Isolation enablement is comprised of: MM Supervisor UEFI BIOS integration MM drivers implementation/conversion Platform specific isolation policy configuration","title":"OEM Enablement Summary"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-supervisor-uefi-bios-integration","text":"The objective is to binary release MM Supervisor as core component. Thus ideally there should be platform dsc and fdf file change to include these entries into the UEFI code base for core capabilities. There are 4 essential drivers to be added to the device UEFI code base: StandaloneMmUnblockMem.efi PiSmmIpl.efi MmSupervisorCore.efi MmSupervisorRing3Broker.efi One requirement is that both of the drivers above and other MM drivers should reside in the same firmware volume. For current design, the MM Supervisor will not look for extra FVs once it has exited its entry point.","title":"MM Supervisor UEFI BIOS Integration"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-drivers-implementationconversion","text":"This section targets the SMM handler drivers of which module types are DXE_SMM_DRIVER. All gSmst table entries will have a one-to-one mapped field in gMmst. But there are still some limitations for currently existed SMM handler drivers. Once MM Supervisor is loaded, the data it can consume soly come from hob list, meaning SMM handlers drivers(type DXE_SMM_DRIVER) will not be able to consume the protocols, dependencies or event notification from DXE drivers unless relayed by a combination of one DXE driver communicate to one MM handler. Due to the above reason, there some functionalities that will not be provided in MM environment: Dynamic PCD consumption gBS services, i.e. memory allocation and free, get DXE memory map gDS services, i.e. install or check configuration tables For MM drivers that needs to access non-MMRAM region, an explicit MmUnblockMemoryRequest call needs to be invoke prior to its usage. Knowing the limitations listed below: When installation of MM foundation occurs in DXE phase, the MmUnblockMemoryRequest will not be available from the beginning in DXE till gEfiMmBaseProtocolGuid is installed. It is suggested to advance the unblock request as early as PEI if necessary. When MM foundation is installed in PEI, TBD... MmSupervisorRing3Broker driver has to be the first user mode driver loaded, assuming all user mode driver relies on gMmst. Thus the libraries linked to this driver can neither have any dependency on MmServicesTableLib nor attempt to access the EFI_MM_SYSTEM_TABLE passed in from library constructors.","title":"MM Drivers Implementation/Conversion"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#platform-specific-isolation-policy-configuration","text":"This section describes how a platform can choose to add or remove protected MSRs, IO, memory region and instruction execution (if supported) based on platform needs. There is a minimum requirement for SMM isolation policy published by Microsoft where each platform has to block certain MSR, IO and memory region accesses to meet the criteria for Level 3 Secured Core PC environment. So a platform has to fullfil these requirements. (TODO: Link TBD) If platform has other resources would like to protect, i.e. proprietary MSR for special purpose, MMIO region for secure device, etc, platform can elect to add these entries to the corresponding section of policy file. Specific policy definition can be found here .","title":"Platform Specific Isolation Policy Configuration"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#uefi-implementation-details","text":"Design: Proposed MM Supervisor boot flow and isolation mechanism Tradition: Introduction to traditional SMM implementation","title":"UEFI Implementation Details"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#oem-integration-guide","text":"Integration: MM Supervisor Integration Guides","title":"OEM Integration Guide"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/","text":"Proposed Flow of MM Supervisor \u00b6 The proposed flow currently supports 2 platforms for development: OVMF Virtual Platform: Intel Q35 based virtual platform from Tianocore. It can be run on QEMU simulator AMD Renoir Reference Platform: AMD Renoir based CRB platform, requiring NDA with AMD Note : Please see Resources section for more links and tutorials Objective \u00b6 MM foundation initialized early in the boot process and has isolated protocol and configuration table database MM supervisor mechanism holds separate service database MM drivers and handlers execute under user mode (CPL3) Binary release model Standalone MM Hob (PEIM) Creates Necessary Hobs Serving as Placeholder \u00b6 EfiSystemTable MM Core private data ACPI communication buffer address TCG NVS address from Tpm ACPI table Memory Map for DXE environment In DXE, at MM IPL entry point \u00b6 Populates Hobs 1 and 2 Prior to Loading MM Supervisor Memory Map as of now is still populated only in ready to lock Hobs 3 and 4 are populated in their separate drivers during their loading TODO: the ideal process would be all these hob population can be moved to null library and IPL can stay out of it Finds the largest available MMRAM region and copy MM Supervisor to this region and load it After MM Supervisor loading, close SMRAM to prevent SMRAM access Before publishing Supervisor communication, IPL should test communication to Supervisor to query Supervisor version and verify the returned version and patch level is non-zero AND meets other system requirements. Known limitations for GCC toolchain: Patch level information, which should be embedded into image version of built Pe/Coff header cannot be integrated when using GCC toolchain. User builds with GCC tools are welcome to reach out to MsCoreUefi@microsoft.com for technical discussion in that regards. Driver version embedded into subsystem version of Pe/Coff header is being parsed by objcopy when using GCC toolchain. This tool would parse input numeric strings with implicit base (i.e. strings beginning with 0s will be parsed as octal numbers). However, MSFT linker specifically only parse it as decimal numbers. Publish protocol to be used by DXE drivers for brokage pipeline Send brokage command to MM Supervisor to load the rest of MM drivers (this is done so that all drivers can be transitioned to CPL3 under MM environment instead of DXE environment) Core Responsibility By MM Supervisor \u00b6 Provide memory service Provide protocol publication and notification Provide MMI handler register and unregister Provide gMmst table for usage Relocate MMI entry for x64 architecture Setup GDT, IDT, exception handlers for MMI environment Setup stack for each CPU in MMI environment Setup DXE to MM Supervisor brokage pipeline This will be a MM Supervisor registered handler that run under CPL0 for DXE to demand special commands from MM Supervisor (i.e. dispatch MM drivers, query version or configuration information, fetch isolation policy) This will be provided as DXE_DRIVER type library API for consumption Mark supervisor pages corresponds to data consumed by MM Supervisor as well as Supervisor code and lock MM control registers if applicable Return to DXE MM foundation isolation \u00b6 Page table: Once MM foundation sets up MMI environment, the foundation data and code needs to be marked as supervisor pages. More data allocated internally will also be marked as supervisor pages. Memory services from subsequent drivers will be marked as user pages. At ready to lock event, ring 0 GDT and IDT and page table itself will be patched to read only Privilege level: MM foundation will execute at CPL0 to access all data and code if allowed by page table Before loading MM drivers, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP After MM driver returns, call far will return to the original return address from call gate set up For MMI. Before dispatching each MMI handlers, if prior to ready to lock, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP. Note: this will need to be in APHandler for APs and around MMI handler dispatching for BSP After MMI returns, call far will return to the original return address from call gate set up Syscall (see the flow chart) to enforce all services needs to execute under CPL0 from CPL3 must go through syscall interface: Core services provided through gMmst provided under CPL3 will be a syscall shim, it implements most gMmst service by invoking syscall and have core service replay the request. Certain privileged instructions such as IO read/write, MSR read/write, and INT, WBI, HLT will be evaluated through policy gate before proceeding. An example defined by AMD for v1 SMM isolation can be found in SmmSupervisorPkg here Telemetry records: when prohibited syscall occurs, core service will jump to preset variable service in Ring 3, write NV variable and long jump back to the point where Ring 3 is enforced. Individual MMI Input Flow \u00b6 At the MMI entry point, each core will setup their MSR of STARs to point to core syscall center in MM core. And restore MSR back before rsm from MMI. Each core will still go through SmiRendezvous flow. BSP will go all the way to MMI handler dispatcher and transition to Ring 3, then run the handler code in Ring 3. And then come back to Ring 0 upon returning. AP will wait at idle state, till notified that there are schedules in the queue. Before loading the function pointers, AP will transition to Ring 3 and then execute procedures in Ring 3. And then come back to Ring 0 upon returning. Prior to dispatching individual MMI handlers, MM supervisor will copy incoming communicate buffers into MMRAM region, marked with proper memory attributes (user vs. kernel). The copied buffers will be dispatched to MMI handlers. Note that when ring level changes, the stack switch will occur as well. Thus when setting up stack, the Ring 3 stack needs to be allocated separately. MM Core <-> Driver Interface \u00b6 Between MM drivers and MM Supervisor, a shim driver will be loaded first to publish a shim gMmst, which will implement some of the real gMmst function through syscall request. This driver will also manage protocol data base in Ring 3, meaning the entire protocol publication, notification, location will be under Ring 3 and application level. And there will be no protocol published from MM core. The driver will also need to refresh the content of table when there is potential to change the values in the table (number of configuration table entries, etc) Also between MM drivers and MM Supervisor, syscall version of BaseLib, CpuLib and IoLib for MM EFI drivers. This will provide a direct interface to request privileged information from MM core. Between DXE drivers and MM Supervisor, a brokage pipeline (special MM handler) will be set up for information querying and driver dispatching Launch MM in PEI \u00b6 At the entrypoint of MM PEI IPL, the PEIM will go over system prerequisites to make sure MM foundation is ready to settle. These requirements include designated MM communication buffers for both user and supervisor, MM control PPI to trigger MMI, MM access PPI to coalesce all available MMRAM regions and lock/close them once MM foundation is set. MM PEI IPL will iterate through all available MMRAMs and load the located MM core (supervisor in this case) into MMRAM. If the system operates PEI in 32-bit mode where as MM foundation needs to run in X64, MM PEI IPL will load a MM IPL X64 relay module, which runs similar to the CapsuleX64.inf from MdeModulePkg. MM PEI IPL will cache system context then switch the operation mode to X64 to execute X64 relay module. Although X64 relay module is a PEIM module in UEFI environment, but it does not have PEI services like other PEIMs MM core is loaded and relocated in normal PEI environment. X64 relay routine will only execute the core entrypoint with supplied hob start pointer. After MM core foundation is setup, the system will, fist return to 32-bit mode with cached context information if applicable, close and lock all available MMRAM regions. MM PEI IPL initiate test communication to Supervisor by querying Supervisor version before proceeding. MM PEI IPL then install MM communicate and MM supervisor communicate PPIs for usage in the rest of PEI phase. Once DXE environment is launched, a MM DXE IPL that depends on MM control protocol will test communication to MM supervisor by querying supervisor version. Entities that publish MM control protocol might need to avoid double-initialization Once test communication is successful, MM DXE IPL will publish MM communicate and MM supervisor communicate protocols for further usage in UEFI DXE or runtime. Resources \u00b6 Project MU Repositories: https://github.com/topics/projectmu Standalone MM Specification: Vol. 4: Management Mode Core Interface, UEFI Platform Initialization (PI) Specification 1.7 A MU Q35 Platform: https://github.com/microsoft/mu_tiano_platforms QEMU Instructions: https://github.com/tianocore/edk2/blob/master/OvmfPkg/PlatformCI/ReadMe.md","title":"Mm Supervisor Design"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#proposed-flow-of-mm-supervisor","text":"The proposed flow currently supports 2 platforms for development: OVMF Virtual Platform: Intel Q35 based virtual platform from Tianocore. It can be run on QEMU simulator AMD Renoir Reference Platform: AMD Renoir based CRB platform, requiring NDA with AMD Note : Please see Resources section for more links and tutorials","title":"Proposed Flow of MM Supervisor"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#objective","text":"MM foundation initialized early in the boot process and has isolated protocol and configuration table database MM supervisor mechanism holds separate service database MM drivers and handlers execute under user mode (CPL3) Binary release model","title":"Objective"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#standalone-mm-hob-peim-creates-necessary-hobs-serving-as-placeholder","text":"EfiSystemTable MM Core private data ACPI communication buffer address TCG NVS address from Tpm ACPI table Memory Map for DXE environment","title":"Standalone MM Hob (PEIM) Creates Necessary Hobs Serving as Placeholder"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#in-dxe-at-mm-ipl-entry-point","text":"Populates Hobs 1 and 2 Prior to Loading MM Supervisor Memory Map as of now is still populated only in ready to lock Hobs 3 and 4 are populated in their separate drivers during their loading TODO: the ideal process would be all these hob population can be moved to null library and IPL can stay out of it Finds the largest available MMRAM region and copy MM Supervisor to this region and load it After MM Supervisor loading, close SMRAM to prevent SMRAM access Before publishing Supervisor communication, IPL should test communication to Supervisor to query Supervisor version and verify the returned version and patch level is non-zero AND meets other system requirements. Known limitations for GCC toolchain: Patch level information, which should be embedded into image version of built Pe/Coff header cannot be integrated when using GCC toolchain. User builds with GCC tools are welcome to reach out to MsCoreUefi@microsoft.com for technical discussion in that regards. Driver version embedded into subsystem version of Pe/Coff header is being parsed by objcopy when using GCC toolchain. This tool would parse input numeric strings with implicit base (i.e. strings beginning with 0s will be parsed as octal numbers). However, MSFT linker specifically only parse it as decimal numbers. Publish protocol to be used by DXE drivers for brokage pipeline Send brokage command to MM Supervisor to load the rest of MM drivers (this is done so that all drivers can be transitioned to CPL3 under MM environment instead of DXE environment)","title":"In DXE, at MM IPL entry point"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#core-responsibility-by-mm-supervisor","text":"Provide memory service Provide protocol publication and notification Provide MMI handler register and unregister Provide gMmst table for usage Relocate MMI entry for x64 architecture Setup GDT, IDT, exception handlers for MMI environment Setup stack for each CPU in MMI environment Setup DXE to MM Supervisor brokage pipeline This will be a MM Supervisor registered handler that run under CPL0 for DXE to demand special commands from MM Supervisor (i.e. dispatch MM drivers, query version or configuration information, fetch isolation policy) This will be provided as DXE_DRIVER type library API for consumption Mark supervisor pages corresponds to data consumed by MM Supervisor as well as Supervisor code and lock MM control registers if applicable Return to DXE","title":"Core Responsibility By MM Supervisor"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#mm-foundation-isolation","text":"Page table: Once MM foundation sets up MMI environment, the foundation data and code needs to be marked as supervisor pages. More data allocated internally will also be marked as supervisor pages. Memory services from subsequent drivers will be marked as user pages. At ready to lock event, ring 0 GDT and IDT and page table itself will be patched to read only Privilege level: MM foundation will execute at CPL0 to access all data and code if allowed by page table Before loading MM drivers, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP After MM driver returns, call far will return to the original return address from call gate set up For MMI. Before dispatching each MMI handlers, if prior to ready to lock, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP. Note: this will need to be in APHandler for APs and around MMI handler dispatching for BSP After MMI returns, call far will return to the original return address from call gate set up Syscall (see the flow chart) to enforce all services needs to execute under CPL0 from CPL3 must go through syscall interface: Core services provided through gMmst provided under CPL3 will be a syscall shim, it implements most gMmst service by invoking syscall and have core service replay the request. Certain privileged instructions such as IO read/write, MSR read/write, and INT, WBI, HLT will be evaluated through policy gate before proceeding. An example defined by AMD for v1 SMM isolation can be found in SmmSupervisorPkg here Telemetry records: when prohibited syscall occurs, core service will jump to preset variable service in Ring 3, write NV variable and long jump back to the point where Ring 3 is enforced.","title":"MM foundation isolation"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#individual-mmi-input-flow","text":"At the MMI entry point, each core will setup their MSR of STARs to point to core syscall center in MM core. And restore MSR back before rsm from MMI. Each core will still go through SmiRendezvous flow. BSP will go all the way to MMI handler dispatcher and transition to Ring 3, then run the handler code in Ring 3. And then come back to Ring 0 upon returning. AP will wait at idle state, till notified that there are schedules in the queue. Before loading the function pointers, AP will transition to Ring 3 and then execute procedures in Ring 3. And then come back to Ring 0 upon returning. Prior to dispatching individual MMI handlers, MM supervisor will copy incoming communicate buffers into MMRAM region, marked with proper memory attributes (user vs. kernel). The copied buffers will be dispatched to MMI handlers. Note that when ring level changes, the stack switch will occur as well. Thus when setting up stack, the Ring 3 stack needs to be allocated separately.","title":"Individual MMI Input Flow"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#mm-core-driver-interface","text":"Between MM drivers and MM Supervisor, a shim driver will be loaded first to publish a shim gMmst, which will implement some of the real gMmst function through syscall request. This driver will also manage protocol data base in Ring 3, meaning the entire protocol publication, notification, location will be under Ring 3 and application level. And there will be no protocol published from MM core. The driver will also need to refresh the content of table when there is potential to change the values in the table (number of configuration table entries, etc) Also between MM drivers and MM Supervisor, syscall version of BaseLib, CpuLib and IoLib for MM EFI drivers. This will provide a direct interface to request privileged information from MM core. Between DXE drivers and MM Supervisor, a brokage pipeline (special MM handler) will be set up for information querying and driver dispatching","title":"MM Core &lt;-&gt; Driver Interface"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#launch-mm-in-pei","text":"At the entrypoint of MM PEI IPL, the PEIM will go over system prerequisites to make sure MM foundation is ready to settle. These requirements include designated MM communication buffers for both user and supervisor, MM control PPI to trigger MMI, MM access PPI to coalesce all available MMRAM regions and lock/close them once MM foundation is set. MM PEI IPL will iterate through all available MMRAMs and load the located MM core (supervisor in this case) into MMRAM. If the system operates PEI in 32-bit mode where as MM foundation needs to run in X64, MM PEI IPL will load a MM IPL X64 relay module, which runs similar to the CapsuleX64.inf from MdeModulePkg. MM PEI IPL will cache system context then switch the operation mode to X64 to execute X64 relay module. Although X64 relay module is a PEIM module in UEFI environment, but it does not have PEI services like other PEIMs MM core is loaded and relocated in normal PEI environment. X64 relay routine will only execute the core entrypoint with supplied hob start pointer. After MM core foundation is setup, the system will, fist return to 32-bit mode with cached context information if applicable, close and lock all available MMRAM regions. MM PEI IPL initiate test communication to Supervisor by querying Supervisor version before proceeding. MM PEI IPL then install MM communicate and MM supervisor communicate PPIs for usage in the rest of PEI phase. Once DXE environment is launched, a MM DXE IPL that depends on MM control protocol will test communication to MM supervisor by querying supervisor version. Entities that publish MM control protocol might need to avoid double-initialization Once test communication is successful, MM DXE IPL will publish MM communicate and MM supervisor communicate protocols for further usage in UEFI DXE or runtime.","title":"Launch MM in PEI"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#resources","text":"Project MU Repositories: https://github.com/topics/projectmu Standalone MM Specification: Vol. 4: Management Mode Core Interface, UEFI Platform Initialization (PI) Specification 1.7 A MU Q35 Platform: https://github.com/microsoft/mu_tiano_platforms QEMU Instructions: https://github.com/tianocore/edk2/blob/master/OvmfPkg/PlatformCI/ReadMe.md","title":"Resources"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/","text":"MM Supervisor Platform Integration \u00b6 The MM Supervisor source code is intended to be used as-is by platforms. In order to integrate the MM Supervisor into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces. High-Level Considerations \u00b6 Standalone MM Changes - The supervisor will use Standalone MM as opposed to Traditional MM. SMM modules and libraries will need to be converted to be compatible with Standalone MM. Silicon Vendor Changes - The silicon vendor firmware may need changes for: Standalone MM compatibility Privilege constraints imposed by the supervisor Platform Data Requirements - The MM Supervisor requires a new set of industry standard defined data structures in addition to supervisor-specific data structures to be produced by the platform. Platform API Calls - Services that might need to be called by a platform. MM Supervisor Code Integration - How to best integrate the MmSupervisorPkg collateral into a platform firmware. Known Issues - Known issues that need to be taken into account. Platform Security Goals - The MM Supervisor aims to improve security. It is important to understand the goals of the supervisor and how that aligns with the platform security goals. MM Driver Load Process - The platform might need to organize MM modules differently for the MM IPL than what was previously used for Traditional MM. Standalone MM Changes \u00b6 Begin by reading the Standalone MM section of the Platform Initialization (PI) Specification to gain a basic understanding of Standalone MM. The following basic steps can be used to convert a Traditional MM library/module to Standalone MM: Change the driver entry point prototype from the Traditional MM API to the Standalone MM API. The system table should be of type EFI_MM_SYSTEM_TABLE The driver will now use StandaloneMmDriverEntryPoint In target INF files, use MM_STANDALONE as MODULE_TYPE In target INF files, set PI_SPECIFICATION version to 0x00010032 Update any DXE_SMM_DRIVER libraries that will now be ported for the Standalone MM environment, add support for the MM_STANDALONE and MM_CORE_STANDALONE driver types For packages that contains libraries/modules shared with consumers that will be a mix of Traditional MM and Standalone MM, consider the file path. In many cases, code sharing can be maximized for both cases by providing a Traditional MM INF and a Standalone MM INF in the same directory. Where common code is placed in a .c file included in both INF files and each INF has a corresponding .c file unique to its module type (e.g. different entry point type). This also has the benefit that the INF file path remains constant so it does not break present consumers while the new Standalone MM INF can be called XxxStandaloneMm.inf . Use MemoryAllocationLib functions to allocate and free memory as opposed to gSmst or gMmst directly. This can improve portability between the two services tables Find an alternative solution for gBS , gDS , and other DXE environment accesses Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the Standalone MM environment Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are still met. Determine the TSEG size needed. After changing the fundamental SMM core, additional TSEG size may be required. MM handlers should start to use MmCommBufferValid interface to validate incoming communicate buffers, instead of traditionally used MmIsBufferOutsideMmValid . Silicon Vendor Changes \u00b6 First, determine whether the silicon vendor code already supports Standalone MM. If it does not, the platform owner will either need to port the silicon vendor code directly (if practical) or work with the silicon vendor to enable Standalone MM support. In addition to the conversion guidelines in Standalone MM Changes , the silicon code should also consider the hardware access limitations that will be enforced by the MM Supervisor policy. Conversely, the MM Supervisor policy for the platform should consider the unique enforcements that should be applied for a given silicon architecture/design. Platform Data Requirements \u00b6 The platform needs to produce the data structures in this section. The structures are consumed by MM Supervisor code to acquire platform-specific details. HOBs Required by MM IPL \u00b6 gMpInformationHobGuid - Basic MP information. StandaloneMmPkg/Include/Guid/MpInformation.h Note that PeiStandaloneMmHobProductionLib can be used to help produce this HOB. gEfiMmPeiMmramMemoryReserveGuid / gEfiSmmSmramMemoryGuid - Describes MMRAM regions present. MdePkg/Include/Guid/SmramMemoryReserve.h Resource descriptor HOBs with MMIO regions identified - Required to allow MM access to MMIO. By default, the MM Supervisor will apply page table attributes based on the memory described by EFI_HOB_TYPE_RESOURCE_DESCRIPTOR HOBs. In order for MMIO to be accessible from MM, the MMIO range must be described in a resource descriptor HOB where the EFI_RESOURCE_TYPE field of the HOB is set to EFI_RESOURCE_MEMORY_MAPPED_IO or EFI_RESOURCE_FIRMWARE_DEVICE . [ Optional ] gMmProtectedRegionHobGuid - Any protected MMIO regions such as IOMMU can be described in HOBs with this GUID to prevent access from MM. Note that the PEI module MmSupervisorPkg/Drivers/StandaloneMmHob will produce gMmCoreDataHobGuid which is used to hold MM_CORE_PRIVATE_DATA and gMmCoreMmProfileGuid which is used to hold MM_CORE_MM_PROFILE_DATA as defined in MmSupervisorPkg . PPIs Required for PEI MM IPL \u00b6 MM Access PPI ( gEfiPeiMmAccessPpiGuid ) MM Control PPI ( gEfiPeiMmControlPpiGuid ) MM Policy \u00b6 The MM Supervisor policy is a data structure used to communicate the restrictions applied to certain hardware resources such as I/O ports, MSRs, CPU instructions, and CPU Save State. The policy should be reviewed for each platform in order as the hardware resources that might need to be restricted will vary across silicon families and platform-specific security goals. In order to verify the policy was discovered and read properly, the policy can be verified in debug output. Below is an example of debug policy output: [InitializePolicy] Discovered policy file in FV at 0x7D4BB6D0. SMM_SUPV_SECURE_POLICY_DATA_V1_0: Version Major:1 Version Minor:0 Size:0x1E8 MemoryPolicyOffset:0x0 MemoryPolicyCount:0x0 Flags:0 Capabilities:0 PolicyRootOffset:0x28 PolicyRootCount:0x5 Policy Root: Version: 1 PolicyRootSize: 18 Type: 2 Offset: A0 Count: 2 AccessAttr: DENY IO: [CF8-CFB] . W IO: [CFC-CFF] . W Policy Root: Version: 1 PolicyRootSize: 18 Type: 3 Offset: B0 Count: 20 AccessAttr: DENY MSR: [C0000080-C0000080] R W MSR: [C0000081-C0000084] R W MSR: [9E-9E] R W MSR: [1D9-1D9] R W MSR: [DA0-DA0] R W MSR: [6A0-6A0] R W MSR: [6A2-6A2] R W MSR: [6A4-6A8] R W MSR: [E4-E4] R W MSR: [600-600] R W MSR: [652-652] R W MSR: [653-653] R W MSR: [655-655] R W MSR: [656-656] R W MSR: [658-658] R W MSR: [700-700] R W MSR: [701-701] R W MSR: [706-706] R W MSR: [707-707] R W MSR: [710-710] R W MSR: [711-711] R W MSR: [716-716] R W MSR: [717-717] R W MSR: [720-720] R W MSR: [721-721] R W MSR: [726-726] R W MSR: [727-727] R W MSR: [730-730] R W MSR: [731-731] R W MSR: [736-736] R W MSR: [737-737] R W MSR: [570-570] R W Policy Root: Version: 1 PolicyRootSize: 18 Type: 4 Offset: 1B0 Count: 3 AccessAttr: ALLOW INSTRUCTION: [0] X INSTRUCTION: [1] X INSTRUCTION: [2] X Policy Root: Version: 1 PolicyRootSize: 18 Type: 5 Offset: 1C8 Count: 2 AccessAttr: ALLOW SAVESTATE: [0] 10 IoWrite SAVESTATE: [1] 1 Unconditional Policy Root: Version: 1 PolicyRootSize: 18 Type: 1 Offset: 1E8 Count: 0 AccessAttr: DENY SecurityPolicyCheck - Policy overlap check entry ... SecurityPolicyCheck - Policy overlap check exit ... For more information about creating a policy and inserting the policy binary into firmware, see the MM Policy File instructions. Platform API Calls \u00b6 These are APIs provided by MmSupervisorPkg that the platform might need to invoke if it needs to make use of the service provided. MmSupervisorUnblockMemoryLib - By default, the MM Supervisor will block all memory resources outside of MMRAM. Regions that need to be accessed must be requested to be unblocked by the MM Supervisor. MM Supervisor Code Integration \u00b6 Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202102\") Include this repo as a submodule for your platform repos and set the folder path as Common/MU_MM_SUPV (also add Common/MU_MM_SUPV to required repos and module packages in the platform build script): https://windowspartners.visualstudio.com/MsCoreUefi_Thanos/_git/msft_mmsupervisor Note: A list of the libraries and modules made available by this package is provided in the Software Component Overview . Platform DSC statements \u00b6 Add the DSC sections below. Note: There might be other silicon specific drivers/libraries a platform will need for these sections, i.e. SPI flash drivers, SW MMI dispatcher drivers, etc. [ PcdsFixedAtBuild ] gEfiSecurityPkgTokenSpaceGuid.PcdUserPhysicalPresence | FALSE [ LibraryClasses.IA32 ] MmSupervisorUnblockMemoryLib | MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf [ LibraryClasses.X64 ] MmSupervisorUnblockMemoryLib | MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf [ LibraryClasses.X64.MM_CORE_STANDALONE ] PcdLib | MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf DebugLib | MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf # Note: Make sure ACPI timer is properly programmed at load time TimerLib | PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf ExtractGuidedSectionLib | MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf FvLib | StandaloneMmPkg/Library/FvLib/FvLib.inf HobLib | StandaloneMmPkg/Library/StandaloneMmCoreHobLib/StandaloneMmCoreHobLib.inf MemoryAllocationLib | StandaloneMmPkg/Library/StandaloneMmCoreMemoryAllocationLib/StandaloneMmCoreMemoryAllocationLib.inf MemLib | MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorCoreMemLib.inf ReportStatusCodeLib | MdePkg/Library/BaseReportStatusCodeLibNull/BaseReportStatusCodeLibNull.inf StandaloneMmCoreEntryPoint | StandaloneMmPkg/Library/StandaloneMmCoreEntryPoint/StandaloneMmCoreEntryPoint.inf CpuExceptionHandlerLib | UefiCpuPkg/Library/CpuExceptionHandlerLib/SmmCpuExceptionHandlerLib.inf DevicePathLib | MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf # Note: This API will be removed from core soon, leave the empty shell here SmmCpuPlatformHookLib | UefiCpuPkg/Library/SmmCpuPlatformHookLibNull/SmmCpuPlatformHookLibNull.inf IhvMmSaveStateSupervisionLib | MmSupervisorPkg/Library/IhvMmSaveStateSupervisionLib/IhvMmSaveStateSupervisionLib.inf [ LibraryClasses.X64.MM_STANDALONE ] DebugLib | MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf TimerLib | PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf MmServicesTableLib | MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf MemoryAllocationLib | StandaloneMmPkg/Library/StandaloneMmMemoryAllocationLib/StandaloneMmMemoryAllocationLib.inf HobLib | MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf ReportStatusCodeLib | MdeModulePkg/Library/SmmReportStatusCodeLib/StandaloneMmReportStatusCodeLib.inf HwResetSystemLib | PcAtChipsetPkg/Library/ResetSystemLib/ResetSystemLib.inf StandaloneMmDriverEntryPoint | MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf PcdLib | MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf BaseCryptLib | CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf OpensslLib | CryptoPkg/Library/OpensslLib/OpensslLib.inf IntrinsicLib | CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf AdvLoggerAccessLib | MdeModulePkg/Library/AdvLoggerAccessLibNull/AdvLoggerAccessLib.inf DevicePathLib | MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf LockBoxLib | MdeModulePkg/Library/SmmLockBoxLib/SmmLockBoxStandaloneMmLib.inf MemLib | MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorMemLibSyscall.inf Tcg2PhysicalPresenceLib | SecurityPkg/Library/SmmTcg2PhysicalPresenceLib/StandaloneMmTcg2PhysicalPresenceLib.inf PlatformSecureLib | SecurityPkg/Library/PlatformSecureLibNull/PlatformSecureLibNull.inf BaseLib | MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf IoLib | MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf SysCallLib | MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf [ Components.IA32 ] MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf !endif [ Components.X64 ] MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE # Note: MmIplX64Relay is a 64-bit PEI module. # - Any libraries linked to this module should not make 32-bit PEI assumptions # - Any libraries linked to this module should not use PEI Services MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf { <LibraryClasses> NULL | StandaloneMmPkg/Library/VariableMmDependency/VariableMmDependency.inf } !else MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf !endif MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf MmSupervisorPkg/Core/MmSupervisorCore.inf { <LibraryClasses> # Note that this should be whatever suits the target platform + MM standalone conversion for constructor input arguments SmmCpuFeaturesLib | $( PLATFORM_SI_PACKAGE ) /Library/SmmCpuFeaturesLib/SmmCpuFeaturesLib.inf } MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf { <LibraryClasses> NULL | MdeModulePkg/Universal/Variable/UefiVariablePolicy/Library/VarCheckPolicyLib/VarCheckPolicyLibStandaloneMm.inf NULL | MdeModulePkg/Library/VarCheckUefiLib/VarCheckUefiLib.inf } MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf { <LibraryClasses> Tpm2DeviceLib | SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpmStandaloneMm.inf } # Optional MsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf [ BuildOptions.common.EDKII.MM_STANDALONE, BuildOptions.common.EDKII.MM_CORE_STANDALONE ] #DLink flags to cut out project names from binaries MSFT:*_*_*_DLINK_FLAGS = /ALIGN:4096 Remove the DSC sections below. [ Components.X64 ] # MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf # MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf # UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf # MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf # MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf # UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf # MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf # UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf # MsCorePkg/Universal/StatusCodeHandler/Serial/Smm/SerialStatusCodeHandlerSmm.inf # SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf # MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf # MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf Given that current Standalone MM environment does not support dynamic PCDs, the SMM drivers currently consuming dynamic PCDs need to be configured to avoid this. Be aware that if the platform previously loaded the MM IPL in DXE, the MM initialization drivers such as the MM Control driver might assume the environment is not initialized and clear registers that were set up in the PEI phase. Modify the drivers as appropriate to avoid losing initialization performed in PEI. Platform FDF statements \u00b6 Add the FDF sections below. Note: There might be other silicon specific drivers a platform will need for these sections [ FV.YOUR_PEI_FV ] INF MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf INF MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf !endif [ FV.YOUR_POST_MEM_PEI_FV ] !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf INF MmSupervisorPkg/Core/MmSupervisorCore.inf FILE FREEFORM = gMmSupervisorPolicyFileGuid { SECTION RAW = $( POLICY_BIN_PATH ) } !endif [ FV.YOUR_DXE_FV ] !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf !else INF MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf INF MmSupervisorPkg/Core/MmSupervisorCore.inf FILE FREEFORM = gMmSupervisorPolicyFileGuid { SECTION RAW = $( POLICY_BIN_PATH ) } !endif INF MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf INF MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf INF MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf INF MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf INF MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf INF UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf INF MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf INF MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf INF RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf INF SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf # Optional INF MsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf INF MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf INF MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf [ Rule.Common.MM_CORE_STANDALONE ] FILE MM_CORE_STANDALONE = $( NAMED_GUID ) { PE32 PE32 $( INF_OUTPUT ) / $( MODULE_NAME ) .efi UI STRING = \" $( MODULE_NAME ) \" Optional VERSION STRING = \" $( INF_VERSION ) \" Optional BUILD_NUM = $( BUILD_NUMBER ) } [ Rule.Common.MM_STANDALONE ] FILE MM_STANDALONE = $( NAMED_GUID ) { SMM_DEPEX SMM_DEPEX Optional $( INF_OUTPUT ) / $( MODULE_NAME ) .depex PE32 PE32 $( INF_OUTPUT ) / $( MODULE_NAME ) .efi UI STRING = \" $( MODULE_NAME ) \" Optional VERSION STRING = \" $( INF_VERSION ) \" Optional BUILD_NUM = $( BUILD_NUMBER ) } Remove the FDF sections below. [ FV.YOUR_DXE_FV ] # INF MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf # INF MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf # INF UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf # INF MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf # INF MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf # INF MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf # INF UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf # INF UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf # INF MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf # INF MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf # INF RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf MM Policy File \u00b6 Create secure policy binary file using MmSupervisorPkg/SupervisorPolicyTools/SupervisorPolicyMaker.py per platform needs (an example can be found in SupervisorPolicyTools folder ). Place the created secure policy as a FREEFORM binary in the FDF file within the same FV as the MmSupervisor image. The file should be GUIDed as gMmSupervisorPolicyFileGuid so it can be discovered by the MM Supervisor. MM Policy XML File Schema \u00b6 An example can be found in SupervisorPolicyTools folder . All XML files should use the <SmmIsolationPolicy> as the root tag. Under the root, all supported protection categories should listed under <SmmCategory> nodes, with a name attribute denoting the specific category. Currently ony support 'MSR', 'IO', 'INSTRUCTION' and 'SAVESTATE' There should be only one <SmmCategory> node for each category in a single XML file. For each protection category group, a <PolicyAccessAttribute> must be included to indicate the corresponding policy entries belong to a deny list or allow list. In addition to policy attributes, multiple <PolicyEntry> nodes coud be included in a <SmmCategory> group. This will be an individual policy protection entry. For MSR protection group, each entry should be described with the following 3 children nodes: <StartAddress Value= \"0xC0000080\" /> <!-- The starting base address of MSR --> <Size Value= \"0x2\" /> <!-- The range of MSRs to be protected. In this example, MSR 0xC0000080 and 0xC0000081 will be protected. --> <SecurityAttributes Value= \"Read | Write\" /> <!-- Indicate the intended MSR access type to be protected. Only Read, Write or their combination are accepted. --> For IO protection group, each entry should be described with the following 3 children nodes: <StartAddress Value= \"0xCF8\" /> <!-- The IO port to be protected --> <Size Value= \"0x4\" /> <!-- The width of IO ports access to be protected. --> <SecurityAttributes Value= \"Read | Write | StrictWidth\" /> <!-- Indicate the intended IO access type to be protected. Only Read, Write, StrictWidth or their combination are accepted. Note that when StrictWidth is indicated, only the access of StartAddress with specific Size width will be protected. Otherwise, it will be similar to MSR policy entry --> For INSTRUCTION protection group, each entry should be described with the following 3 children nodes: <Instruction Value= \"HLT\" /> <!-- The instruction name to be protected, only HLT, WBINVD and CLI are supported. --> <Size Value= \"0x4\" /> <!-- The width of IO ports access to be protected. --> <SecurityAttributes Value= \"Execute\" /> <!-- Only execute attribute is allowed here. --> For SAVESTATE protection group, each entry should be described with the following 3 children nodes: <SaveStateField Value= \"IO_TRAP\" /> <!-- The save state register name to be protected, only IO_TRAP and RAX are supported. --> <SecurityAttributes Value= \"Read\" /> <!-- Indicate the intended save state access type to be protected. Only Read and LimitedRead are accepted. Note that when LimitedRead is indicated, the AccessCondition node must be supplied. --> <AccessCondition Value= \"IoWrite\" /> <!-- Optional node to indicate what condition of LimitedRead can be accepted. Only IoWrite is accepted for RAX LimitedRead entry. -->","title":"Platform Integration Steps"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-supervisor-platform-integration","text":"The MM Supervisor source code is intended to be used as-is by platforms. In order to integrate the MM Supervisor into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces.","title":"MM Supervisor Platform Integration"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#high-level-considerations","text":"Standalone MM Changes - The supervisor will use Standalone MM as opposed to Traditional MM. SMM modules and libraries will need to be converted to be compatible with Standalone MM. Silicon Vendor Changes - The silicon vendor firmware may need changes for: Standalone MM compatibility Privilege constraints imposed by the supervisor Platform Data Requirements - The MM Supervisor requires a new set of industry standard defined data structures in addition to supervisor-specific data structures to be produced by the platform. Platform API Calls - Services that might need to be called by a platform. MM Supervisor Code Integration - How to best integrate the MmSupervisorPkg collateral into a platform firmware. Known Issues - Known issues that need to be taken into account. Platform Security Goals - The MM Supervisor aims to improve security. It is important to understand the goals of the supervisor and how that aligns with the platform security goals. MM Driver Load Process - The platform might need to organize MM modules differently for the MM IPL than what was previously used for Traditional MM.","title":"High-Level Considerations"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#standalone-mm-changes","text":"Begin by reading the Standalone MM section of the Platform Initialization (PI) Specification to gain a basic understanding of Standalone MM. The following basic steps can be used to convert a Traditional MM library/module to Standalone MM: Change the driver entry point prototype from the Traditional MM API to the Standalone MM API. The system table should be of type EFI_MM_SYSTEM_TABLE The driver will now use StandaloneMmDriverEntryPoint In target INF files, use MM_STANDALONE as MODULE_TYPE In target INF files, set PI_SPECIFICATION version to 0x00010032 Update any DXE_SMM_DRIVER libraries that will now be ported for the Standalone MM environment, add support for the MM_STANDALONE and MM_CORE_STANDALONE driver types For packages that contains libraries/modules shared with consumers that will be a mix of Traditional MM and Standalone MM, consider the file path. In many cases, code sharing can be maximized for both cases by providing a Traditional MM INF and a Standalone MM INF in the same directory. Where common code is placed in a .c file included in both INF files and each INF has a corresponding .c file unique to its module type (e.g. different entry point type). This also has the benefit that the INF file path remains constant so it does not break present consumers while the new Standalone MM INF can be called XxxStandaloneMm.inf . Use MemoryAllocationLib functions to allocate and free memory as opposed to gSmst or gMmst directly. This can improve portability between the two services tables Find an alternative solution for gBS , gDS , and other DXE environment accesses Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the Standalone MM environment Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are still met. Determine the TSEG size needed. After changing the fundamental SMM core, additional TSEG size may be required. MM handlers should start to use MmCommBufferValid interface to validate incoming communicate buffers, instead of traditionally used MmIsBufferOutsideMmValid .","title":"Standalone MM Changes"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#silicon-vendor-changes","text":"First, determine whether the silicon vendor code already supports Standalone MM. If it does not, the platform owner will either need to port the silicon vendor code directly (if practical) or work with the silicon vendor to enable Standalone MM support. In addition to the conversion guidelines in Standalone MM Changes , the silicon code should also consider the hardware access limitations that will be enforced by the MM Supervisor policy. Conversely, the MM Supervisor policy for the platform should consider the unique enforcements that should be applied for a given silicon architecture/design.","title":"Silicon Vendor Changes"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-requirements","text":"The platform needs to produce the data structures in this section. The structures are consumed by MM Supervisor code to acquire platform-specific details.","title":"Platform Data Requirements"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#hobs-required-by-mm-ipl","text":"gMpInformationHobGuid - Basic MP information. StandaloneMmPkg/Include/Guid/MpInformation.h Note that PeiStandaloneMmHobProductionLib can be used to help produce this HOB. gEfiMmPeiMmramMemoryReserveGuid / gEfiSmmSmramMemoryGuid - Describes MMRAM regions present. MdePkg/Include/Guid/SmramMemoryReserve.h Resource descriptor HOBs with MMIO regions identified - Required to allow MM access to MMIO. By default, the MM Supervisor will apply page table attributes based on the memory described by EFI_HOB_TYPE_RESOURCE_DESCRIPTOR HOBs. In order for MMIO to be accessible from MM, the MMIO range must be described in a resource descriptor HOB where the EFI_RESOURCE_TYPE field of the HOB is set to EFI_RESOURCE_MEMORY_MAPPED_IO or EFI_RESOURCE_FIRMWARE_DEVICE . [ Optional ] gMmProtectedRegionHobGuid - Any protected MMIO regions such as IOMMU can be described in HOBs with this GUID to prevent access from MM. Note that the PEI module MmSupervisorPkg/Drivers/StandaloneMmHob will produce gMmCoreDataHobGuid which is used to hold MM_CORE_PRIVATE_DATA and gMmCoreMmProfileGuid which is used to hold MM_CORE_MM_PROFILE_DATA as defined in MmSupervisorPkg .","title":"HOBs Required by MM IPL"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#ppis-required-for-pei-mm-ipl","text":"MM Access PPI ( gEfiPeiMmAccessPpiGuid ) MM Control PPI ( gEfiPeiMmControlPpiGuid )","title":"PPIs Required for PEI MM IPL"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy","text":"The MM Supervisor policy is a data structure used to communicate the restrictions applied to certain hardware resources such as I/O ports, MSRs, CPU instructions, and CPU Save State. The policy should be reviewed for each platform in order as the hardware resources that might need to be restricted will vary across silicon families and platform-specific security goals. In order to verify the policy was discovered and read properly, the policy can be verified in debug output. Below is an example of debug policy output: [InitializePolicy] Discovered policy file in FV at 0x7D4BB6D0. SMM_SUPV_SECURE_POLICY_DATA_V1_0: Version Major:1 Version Minor:0 Size:0x1E8 MemoryPolicyOffset:0x0 MemoryPolicyCount:0x0 Flags:0 Capabilities:0 PolicyRootOffset:0x28 PolicyRootCount:0x5 Policy Root: Version: 1 PolicyRootSize: 18 Type: 2 Offset: A0 Count: 2 AccessAttr: DENY IO: [CF8-CFB] . W IO: [CFC-CFF] . W Policy Root: Version: 1 PolicyRootSize: 18 Type: 3 Offset: B0 Count: 20 AccessAttr: DENY MSR: [C0000080-C0000080] R W MSR: [C0000081-C0000084] R W MSR: [9E-9E] R W MSR: [1D9-1D9] R W MSR: [DA0-DA0] R W MSR: [6A0-6A0] R W MSR: [6A2-6A2] R W MSR: [6A4-6A8] R W MSR: [E4-E4] R W MSR: [600-600] R W MSR: [652-652] R W MSR: [653-653] R W MSR: [655-655] R W MSR: [656-656] R W MSR: [658-658] R W MSR: [700-700] R W MSR: [701-701] R W MSR: [706-706] R W MSR: [707-707] R W MSR: [710-710] R W MSR: [711-711] R W MSR: [716-716] R W MSR: [717-717] R W MSR: [720-720] R W MSR: [721-721] R W MSR: [726-726] R W MSR: [727-727] R W MSR: [730-730] R W MSR: [731-731] R W MSR: [736-736] R W MSR: [737-737] R W MSR: [570-570] R W Policy Root: Version: 1 PolicyRootSize: 18 Type: 4 Offset: 1B0 Count: 3 AccessAttr: ALLOW INSTRUCTION: [0] X INSTRUCTION: [1] X INSTRUCTION: [2] X Policy Root: Version: 1 PolicyRootSize: 18 Type: 5 Offset: 1C8 Count: 2 AccessAttr: ALLOW SAVESTATE: [0] 10 IoWrite SAVESTATE: [1] 1 Unconditional Policy Root: Version: 1 PolicyRootSize: 18 Type: 1 Offset: 1E8 Count: 0 AccessAttr: DENY SecurityPolicyCheck - Policy overlap check entry ... SecurityPolicyCheck - Policy overlap check exit ... For more information about creating a policy and inserting the policy binary into firmware, see the MM Policy File instructions.","title":"MM Policy"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-api-calls","text":"These are APIs provided by MmSupervisorPkg that the platform might need to invoke if it needs to make use of the service provided. MmSupervisorUnblockMemoryLib - By default, the MM Supervisor will block all memory resources outside of MMRAM. Regions that need to be accessed must be requested to be unblocked by the MM Supervisor.","title":"Platform API Calls"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-supervisor-code-integration","text":"Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202102\") Include this repo as a submodule for your platform repos and set the folder path as Common/MU_MM_SUPV (also add Common/MU_MM_SUPV to required repos and module packages in the platform build script): https://windowspartners.visualstudio.com/MsCoreUefi_Thanos/_git/msft_mmsupervisor Note: A list of the libraries and modules made available by this package is provided in the Software Component Overview .","title":"MM Supervisor Code Integration"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-statements","text":"Add the DSC sections below. Note: There might be other silicon specific drivers/libraries a platform will need for these sections, i.e. SPI flash drivers, SW MMI dispatcher drivers, etc. [ PcdsFixedAtBuild ] gEfiSecurityPkgTokenSpaceGuid.PcdUserPhysicalPresence | FALSE [ LibraryClasses.IA32 ] MmSupervisorUnblockMemoryLib | MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf [ LibraryClasses.X64 ] MmSupervisorUnblockMemoryLib | MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf [ LibraryClasses.X64.MM_CORE_STANDALONE ] PcdLib | MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf DebugLib | MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf # Note: Make sure ACPI timer is properly programmed at load time TimerLib | PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf ExtractGuidedSectionLib | MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf FvLib | StandaloneMmPkg/Library/FvLib/FvLib.inf HobLib | StandaloneMmPkg/Library/StandaloneMmCoreHobLib/StandaloneMmCoreHobLib.inf MemoryAllocationLib | StandaloneMmPkg/Library/StandaloneMmCoreMemoryAllocationLib/StandaloneMmCoreMemoryAllocationLib.inf MemLib | MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorCoreMemLib.inf ReportStatusCodeLib | MdePkg/Library/BaseReportStatusCodeLibNull/BaseReportStatusCodeLibNull.inf StandaloneMmCoreEntryPoint | StandaloneMmPkg/Library/StandaloneMmCoreEntryPoint/StandaloneMmCoreEntryPoint.inf CpuExceptionHandlerLib | UefiCpuPkg/Library/CpuExceptionHandlerLib/SmmCpuExceptionHandlerLib.inf DevicePathLib | MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf # Note: This API will be removed from core soon, leave the empty shell here SmmCpuPlatformHookLib | UefiCpuPkg/Library/SmmCpuPlatformHookLibNull/SmmCpuPlatformHookLibNull.inf IhvMmSaveStateSupervisionLib | MmSupervisorPkg/Library/IhvMmSaveStateSupervisionLib/IhvMmSaveStateSupervisionLib.inf [ LibraryClasses.X64.MM_STANDALONE ] DebugLib | MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf TimerLib | PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf MmServicesTableLib | MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf MemoryAllocationLib | StandaloneMmPkg/Library/StandaloneMmMemoryAllocationLib/StandaloneMmMemoryAllocationLib.inf HobLib | MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf ReportStatusCodeLib | MdeModulePkg/Library/SmmReportStatusCodeLib/StandaloneMmReportStatusCodeLib.inf HwResetSystemLib | PcAtChipsetPkg/Library/ResetSystemLib/ResetSystemLib.inf StandaloneMmDriverEntryPoint | MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf PcdLib | MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf BaseCryptLib | CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf OpensslLib | CryptoPkg/Library/OpensslLib/OpensslLib.inf IntrinsicLib | CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf AdvLoggerAccessLib | MdeModulePkg/Library/AdvLoggerAccessLibNull/AdvLoggerAccessLib.inf DevicePathLib | MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf LockBoxLib | MdeModulePkg/Library/SmmLockBoxLib/SmmLockBoxStandaloneMmLib.inf MemLib | MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorMemLibSyscall.inf Tcg2PhysicalPresenceLib | SecurityPkg/Library/SmmTcg2PhysicalPresenceLib/StandaloneMmTcg2PhysicalPresenceLib.inf PlatformSecureLib | SecurityPkg/Library/PlatformSecureLibNull/PlatformSecureLibNull.inf BaseLib | MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf IoLib | MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf SysCallLib | MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf [ Components.IA32 ] MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf !endif [ Components.X64 ] MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE # Note: MmIplX64Relay is a 64-bit PEI module. # - Any libraries linked to this module should not make 32-bit PEI assumptions # - Any libraries linked to this module should not use PEI Services MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf { <LibraryClasses> NULL | StandaloneMmPkg/Library/VariableMmDependency/VariableMmDependency.inf } !else MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf !endif MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf MmSupervisorPkg/Core/MmSupervisorCore.inf { <LibraryClasses> # Note that this should be whatever suits the target platform + MM standalone conversion for constructor input arguments SmmCpuFeaturesLib | $( PLATFORM_SI_PACKAGE ) /Library/SmmCpuFeaturesLib/SmmCpuFeaturesLib.inf } MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf { <LibraryClasses> NULL | MdeModulePkg/Universal/Variable/UefiVariablePolicy/Library/VarCheckPolicyLib/VarCheckPolicyLibStandaloneMm.inf NULL | MdeModulePkg/Library/VarCheckUefiLib/VarCheckUefiLib.inf } MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf { <LibraryClasses> Tpm2DeviceLib | SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpmStandaloneMm.inf } # Optional MsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf [ BuildOptions.common.EDKII.MM_STANDALONE, BuildOptions.common.EDKII.MM_CORE_STANDALONE ] #DLink flags to cut out project names from binaries MSFT:*_*_*_DLINK_FLAGS = /ALIGN:4096 Remove the DSC sections below. [ Components.X64 ] # MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf # MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf # UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf # MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf # MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf # UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf # MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf # UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf # MsCorePkg/Universal/StatusCodeHandler/Serial/Smm/SerialStatusCodeHandlerSmm.inf # SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf # MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf # MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf Given that current Standalone MM environment does not support dynamic PCDs, the SMM drivers currently consuming dynamic PCDs need to be configured to avoid this. Be aware that if the platform previously loaded the MM IPL in DXE, the MM initialization drivers such as the MM Control driver might assume the environment is not initialized and clear registers that were set up in the PEI phase. Modify the drivers as appropriate to avoid losing initialization performed in PEI.","title":"Platform DSC statements"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-statements","text":"Add the FDF sections below. Note: There might be other silicon specific drivers a platform will need for these sections [ FV.YOUR_PEI_FV ] INF MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf INF MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf !endif [ FV.YOUR_POST_MEM_PEI_FV ] !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf INF MmSupervisorPkg/Core/MmSupervisorCore.inf FILE FREEFORM = gMmSupervisorPolicyFileGuid { SECTION RAW = $( POLICY_BIN_PATH ) } !endif [ FV.YOUR_DXE_FV ] !if $( PEI_MM_IPL_ENABLED ) == TRUE INF MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf !else INF MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf INF MmSupervisorPkg/Core/MmSupervisorCore.inf FILE FREEFORM = gMmSupervisorPolicyFileGuid { SECTION RAW = $( POLICY_BIN_PATH ) } !endif INF MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf INF MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf INF MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf INF MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf INF MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf INF UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf INF MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf INF MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf INF RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf INF SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf # Optional INF MsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf INF MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf INF MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf [ Rule.Common.MM_CORE_STANDALONE ] FILE MM_CORE_STANDALONE = $( NAMED_GUID ) { PE32 PE32 $( INF_OUTPUT ) / $( MODULE_NAME ) .efi UI STRING = \" $( MODULE_NAME ) \" Optional VERSION STRING = \" $( INF_VERSION ) \" Optional BUILD_NUM = $( BUILD_NUMBER ) } [ Rule.Common.MM_STANDALONE ] FILE MM_STANDALONE = $( NAMED_GUID ) { SMM_DEPEX SMM_DEPEX Optional $( INF_OUTPUT ) / $( MODULE_NAME ) .depex PE32 PE32 $( INF_OUTPUT ) / $( MODULE_NAME ) .efi UI STRING = \" $( MODULE_NAME ) \" Optional VERSION STRING = \" $( INF_VERSION ) \" Optional BUILD_NUM = $( BUILD_NUMBER ) } Remove the FDF sections below. [ FV.YOUR_DXE_FV ] # INF MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf # INF MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf # INF UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf # INF MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf # INF MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf # INF MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf # INF UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf # INF UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf # INF MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf # INF MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf # INF RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf","title":"Platform FDF statements"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy-file","text":"Create secure policy binary file using MmSupervisorPkg/SupervisorPolicyTools/SupervisorPolicyMaker.py per platform needs (an example can be found in SupervisorPolicyTools folder ). Place the created secure policy as a FREEFORM binary in the FDF file within the same FV as the MmSupervisor image. The file should be GUIDed as gMmSupervisorPolicyFileGuid so it can be discovered by the MM Supervisor.","title":"MM Policy File"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy-xml-file-schema","text":"An example can be found in SupervisorPolicyTools folder . All XML files should use the <SmmIsolationPolicy> as the root tag. Under the root, all supported protection categories should listed under <SmmCategory> nodes, with a name attribute denoting the specific category. Currently ony support 'MSR', 'IO', 'INSTRUCTION' and 'SAVESTATE' There should be only one <SmmCategory> node for each category in a single XML file. For each protection category group, a <PolicyAccessAttribute> must be included to indicate the corresponding policy entries belong to a deny list or allow list. In addition to policy attributes, multiple <PolicyEntry> nodes coud be included in a <SmmCategory> group. This will be an individual policy protection entry. For MSR protection group, each entry should be described with the following 3 children nodes: <StartAddress Value= \"0xC0000080\" /> <!-- The starting base address of MSR --> <Size Value= \"0x2\" /> <!-- The range of MSRs to be protected. In this example, MSR 0xC0000080 and 0xC0000081 will be protected. --> <SecurityAttributes Value= \"Read | Write\" /> <!-- Indicate the intended MSR access type to be protected. Only Read, Write or their combination are accepted. --> For IO protection group, each entry should be described with the following 3 children nodes: <StartAddress Value= \"0xCF8\" /> <!-- The IO port to be protected --> <Size Value= \"0x4\" /> <!-- The width of IO ports access to be protected. --> <SecurityAttributes Value= \"Read | Write | StrictWidth\" /> <!-- Indicate the intended IO access type to be protected. Only Read, Write, StrictWidth or their combination are accepted. Note that when StrictWidth is indicated, only the access of StartAddress with specific Size width will be protected. Otherwise, it will be similar to MSR policy entry --> For INSTRUCTION protection group, each entry should be described with the following 3 children nodes: <Instruction Value= \"HLT\" /> <!-- The instruction name to be protected, only HLT, WBINVD and CLI are supported. --> <Size Value= \"0x4\" /> <!-- The width of IO ports access to be protected. --> <SecurityAttributes Value= \"Execute\" /> <!-- Only execute attribute is allowed here. --> For SAVESTATE protection group, each entry should be described with the following 3 children nodes: <SaveStateField Value= \"IO_TRAP\" /> <!-- The save state register name to be protected, only IO_TRAP and RAX are supported. --> <SecurityAttributes Value= \"Read\" /> <!-- Indicate the intended save state access type to be protected. Only Read and LimitedRead are accepted. Note that when LimitedRead is indicated, the AccessCondition node must be supplied. --> <AccessCondition Value= \"IoWrite\" /> <!-- Optional node to indicate what condition of LimitedRead can be accepted. Only IoWrite is accepted for RAX LimitedRead entry. -->","title":"MM Policy XML File Schema"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/","text":"Software Components of the MM Supervisor \u00b6 This section of documentation is focused on the software components of the MM Supervisor that are useful during platform integration. The MM Supervisor provides a software implementation that installs the MM foundation for X64. In order to load MM Supervisor properly, certain software prerequisites (libraries, drivers, hobs, etc.) needs to be met, most of which are included in this package. By including the proper software components, a platform can ensure the MM Supervisor features function as intended and the platform can meet Secured Core PC specification requirements. To enable an end-to-end Standalone MM based Secured Core solution, custom requirements may exist in adjacent UEFI firmware components. For more general background about the steps necessary to integrate the MM Supervisor, please review the Platform Integration Steps . MM Standalone Mode PEI Modules \u00b6 PEI Module Location StandaloneMmHob MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf MM PEI Libraries \u00b6 PEI Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf MM Standalone Mode DXE Drivers \u00b6 DXE Driver Location PiSmmIpl MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf StandaloneMmUnblockMem MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf MM DXE Libraries \u00b6 DXE Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf MM Standalone Mode MM Core \u00b6 MM Driver Location MmSupervisorCore MmSupervisorPkg/Core/MmSupervisorCore.inf MM Standalone Mode MM Drivers \u00b6 MM Driver Location MmSupervisorRing3Broker MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf MmSupervisorErrorReport MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf MM Standalone User Mode Libraries \u00b6 These MM User Mode libraries are expected to be used as is and linked to other MM standalone drivers for standard functionality. Library Location BaseIoLibIntrinsic MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf BaseLib MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf StandaloneMmCommunicationLib MmSupervisorPkg/Library/StandaloneMmCommunicationLib/StandaloneMmCommunicationLib.inf StandaloneMmDriverEntryPoint MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf StandaloneMmHobLibSyscall MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf StandaloneMmMemMapLib MmSupervisorPkg/Library/StandaloneMmMemMapLib/StandaloneMmMemMapLib.inf StandaloneMmServicesTableLib MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf StandaloneMmSystemTableLib MmSupervisorPkg/Library/StandaloneMmSystemTableLib/StandaloneMmSystemTableLib.inf SysCallLib MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf","title":"Software Component Overview"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#software-components-of-the-mm-supervisor","text":"This section of documentation is focused on the software components of the MM Supervisor that are useful during platform integration. The MM Supervisor provides a software implementation that installs the MM foundation for X64. In order to load MM Supervisor properly, certain software prerequisites (libraries, drivers, hobs, etc.) needs to be met, most of which are included in this package. By including the proper software components, a platform can ensure the MM Supervisor features function as intended and the platform can meet Secured Core PC specification requirements. To enable an end-to-end Standalone MM based Secured Core solution, custom requirements may exist in adjacent UEFI firmware components. For more general background about the steps necessary to integrate the MM Supervisor, please review the Platform Integration Steps .","title":"Software Components of the MM Supervisor"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-pei-modules","text":"PEI Module Location StandaloneMmHob MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf","title":"MM Standalone Mode PEI Modules"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-pei-libraries","text":"PEI Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf","title":"MM PEI Libraries"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-dxe-drivers","text":"DXE Driver Location PiSmmIpl MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf StandaloneMmUnblockMem MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf","title":"MM Standalone Mode DXE Drivers"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-dxe-libraries","text":"DXE Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf","title":"MM DXE Libraries"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-mm-core","text":"MM Driver Location MmSupervisorCore MmSupervisorPkg/Core/MmSupervisorCore.inf","title":"MM Standalone Mode MM Core"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-mm-drivers","text":"MM Driver Location MmSupervisorRing3Broker MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf MmSupervisorErrorReport MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf","title":"MM Standalone Mode MM Drivers"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-user-mode-libraries","text":"These MM User Mode libraries are expected to be used as is and linked to other MM standalone drivers for standard functionality. Library Location BaseIoLibIntrinsic MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf BaseLib MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf StandaloneMmCommunicationLib MmSupervisorPkg/Library/StandaloneMmCommunicationLib/StandaloneMmCommunicationLib.inf StandaloneMmDriverEntryPoint MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf StandaloneMmHobLibSyscall MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf StandaloneMmMemMapLib MmSupervisorPkg/Library/StandaloneMmMemMapLib/StandaloneMmMemMapLib.inf StandaloneMmServicesTableLib MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf StandaloneMmSystemTableLib MmSupervisorPkg/Library/StandaloneMmSystemTableLib/StandaloneMmSystemTableLib.inf SysCallLib MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf","title":"MM Standalone User Mode Libraries"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SwitchingToDenyByDefault/","text":"Switching MSR and IO MmPolicy from allow by default to deny by default \u00b6 Individual platform MmPolicy can be edited in the corresponding \"YourPlatform\"MmPolicy.xml with an example in this repo at MmSupervisorPkg/SupervisorPolicyTools/MmIsolationPoliciesExample.xml. MSR and IO policy in this example uses a deny list to list ports that a platform cannot use. This document describes how to go about switching to an allow list instead. Transition process \u00b6 Without changing any policies add the PCD gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsEnable to your platform .dsc file and set it to true. Adding gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsMaxSize to FixedPcd allows you to change the max dictionary size if necessary and is 50 by default. This will print out all the MSR and IO ports currently being used in MM including their address and size which are required for making MM policies. Switch to an allow list by switching the PolicyAccessAttribute to \"Allow\". Create the allow list by following the list structure in your corresponding .xml file (refer to MmIsolationPoliciesExample.xml) and the address and size information from step 1. Example: Allow by default: <!-- This policy denies the IO at port 0xADAA read and write access --> <PolicyEntry> <!-- Junk address and port--> <StartAddress Value= \"0xADAA\" /> <Size Value= \"0x2\" /> <SecurityAttributes Value= \"Read | Write\" /> </PolicyEntry> Deny by default: <!-- IO Policies required for level 20 start --> <SmmCategory name= \"IO\" > <!-- All IO policy entries listed here are allowed --> <PolicyAccessAttribute Value= \"Allow\" /> <!-- This policy allows the IO at port 0xADAA to have read and write access --> <PolicyEntry> <!-- Junk address and port--> <StartAddress Value= \"0xADAA\" /> <Size Value= \"0x2\" /> <SecurityAttributes Value= \"Read | Write\" /> </PolicyEntry> It's recommended to also look into each of the MSR and IO port addresses that you\u2019re adding to the allow list and leave a describing comment about them. This can either be done by going through spec documentation describing the addresses and bits or by looking through the code itself and finding references to the addresses. For posterity you should then look for additional MSR and IO ports that you might want to add to the allow list as well. A couple of ways to do this (with examples from intel systems) would be: Look for a file listing MSRs that you can comb over. When doing step 3 you'll probably run across the file. An example for intel systems is 'CommonMsr.h'. Look around the location of defined MSR and IO ports that you're currently allowing. There might be other relevant IO and MSR defintions that you\u2019d want to have on the allow list that currently are not being used. There might be an allow list for other mm used. If so it's an excellent point of reference for relevant MSR and IO ports An example from intel systems isSmmIoMsrAccess.h. A whitelist for intel Smm MSR and IO ports. After compiling your list of MSR and IO ports make sure that you aren't violating the previous deny list or FASR requirements. Some of these ports that you thought are relevant might have been explicitly denied by the previous deny list. Make sure you don't put them on the allow list. To finish things off make sure that things boot correctly and if so you're done.","title":"Switching To Deny By Default"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SwitchingToDenyByDefault/#switching-msr-and-io-mmpolicy-from-allow-by-default-to-deny-by-default","text":"Individual platform MmPolicy can be edited in the corresponding \"YourPlatform\"MmPolicy.xml with an example in this repo at MmSupervisorPkg/SupervisorPolicyTools/MmIsolationPoliciesExample.xml. MSR and IO policy in this example uses a deny list to list ports that a platform cannot use. This document describes how to go about switching to an allow list instead.","title":"Switching MSR and IO MmPolicy from allow by default to deny by default"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SwitchingToDenyByDefault/#transition-process","text":"Without changing any policies add the PCD gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsEnable to your platform .dsc file and set it to true. Adding gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsMaxSize to FixedPcd allows you to change the max dictionary size if necessary and is 50 by default. This will print out all the MSR and IO ports currently being used in MM including their address and size which are required for making MM policies. Switch to an allow list by switching the PolicyAccessAttribute to \"Allow\". Create the allow list by following the list structure in your corresponding .xml file (refer to MmIsolationPoliciesExample.xml) and the address and size information from step 1. Example: Allow by default: <!-- This policy denies the IO at port 0xADAA read and write access --> <PolicyEntry> <!-- Junk address and port--> <StartAddress Value= \"0xADAA\" /> <Size Value= \"0x2\" /> <SecurityAttributes Value= \"Read | Write\" /> </PolicyEntry> Deny by default: <!-- IO Policies required for level 20 start --> <SmmCategory name= \"IO\" > <!-- All IO policy entries listed here are allowed --> <PolicyAccessAttribute Value= \"Allow\" /> <!-- This policy allows the IO at port 0xADAA to have read and write access --> <PolicyEntry> <!-- Junk address and port--> <StartAddress Value= \"0xADAA\" /> <Size Value= \"0x2\" /> <SecurityAttributes Value= \"Read | Write\" /> </PolicyEntry> It's recommended to also look into each of the MSR and IO port addresses that you\u2019re adding to the allow list and leave a describing comment about them. This can either be done by going through spec documentation describing the addresses and bits or by looking through the code itself and finding references to the addresses. For posterity you should then look for additional MSR and IO ports that you might want to add to the allow list as well. A couple of ways to do this (with examples from intel systems) would be: Look for a file listing MSRs that you can comb over. When doing step 3 you'll probably run across the file. An example for intel systems is 'CommonMsr.h'. Look around the location of defined MSR and IO ports that you're currently allowing. There might be other relevant IO and MSR defintions that you\u2019d want to have on the allow list that currently are not being used. There might be an allow list for other mm used. If so it's an excellent point of reference for relevant MSR and IO ports An example from intel systems isSmmIoMsrAccess.h. A whitelist for intel Smm MSR and IO ports. After compiling your list of MSR and IO ports make sure that you aren't violating the previous deny list or FASR requirements. Some of these ports that you thought are relevant might have been explicitly denied by the previous deny list. Make sure you don't put them on the allow list. To finish things off make sure that things boot correctly and if so you're done.","title":"Transition process"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/","text":"Standalone MM \u00b6 This document summarizes some of the benefits gained by adopting Standalone MM versus Traditional MM. For general background on Management Mode (MM), review the Platform Initialization (PI) specifications. In particular, Volume 4: Management Mode Core Interface. As noted in the PI specification, MM is a generic term used to describe a secure execution environment provided by the CPU and related silicon that is entered when the CPU detects a Management Mode Interrupt (MMI). x86 systems implement MM with System Management Mode (SMM) and ARM systems do so with TrustZone (TZ). This document exclusively focuses on the x86 architecture. Two MM \"modes\" are defined in the PI specification \u2013 (1) Traditional MM and (2) Standalone MM. Traditional MM is equivalent to the SMM software model historically used in PI-compliant firmware. Standalone MM is a relatively new mode that revises the historical model to improve security of the MM environment and prevent common mistakes made in Traditional MM implementations that led to numerous portability and security challenges over the years. A detailed comparison of the Traditional MM and Standalone MM load process is described in the PI Specification sections \"Initializing Management Mode in MM Traditional Mode\" and \"Initializing Management Mode in Standalone Mode\" respectively. It should be noted that both modes leverage the same hardware capabilities. No special hardware is required to transition a firmware to Standalone MM. Further, nearly all existing SMM code can be reused in Standalone MM with no change. Most mandatory changes either involve minimally changing small portions of code such as an entry point function signature or the module type or making changes that are not allowed in Standalone MM because they were violating security practices in Traditional MM. For example, compare the \"MM Traditional Driver Runtime\" section of the PI Specification with the \"MM Standalone Driver Runtime\" section. Instances of code in silicon code today violates the \"soft restrictions\" described in the traditional section. Traditional MM Versus Standalone MM \u00b6 This section compares the main differences between Traditional MM and Standalone MM. MM Driver Initialization and Runtime Phases \u00b6 Traditional MM typically launched in DXE and the DXE and Traditional MM environments closely interacted throughout driver dispatch. During MM dispatch, drivers execute in two phases \u2013 (1) initialization and (2) runtime. Traditional MM Initialization Standalone MM Initialization Starts When the driver is loaded into MMRAM and the driver\u2019s entry point is called When the driver is loaded into MMRAM and the driver\u2019s entry point is called Ends The driver\u2019s entry point returns The driver\u2019s entry point returns Protocol Access UEFI - Boot services - DXE services - Runtime services - DXE protocols MM - MM Services - MM protocols Note: The PI specification states drivers should not call Exit() or ExitBootServices() during the initialization phase MM - MM Services - MM protocols Note: Drivers do not have access to interfaces outside the MM environment. Traditional MM Runtime Standalone MM Runtime Starts After the initialization phase ends Starts after the initialization phase ends Protocol Access MM - MM Services - MM protocols Note: The PI specification states drivers should not call UEFI interfaces and services which were located during the initialization phase. MM - MM Services - MM protocols Note: Drivers do not have access to interfaces outside the MM environment. Given the initialization phase in Traditional MM occurred in DXE, in addition to the DXE_SMM_DRIVER driver type, EFI_FV_FILETYPE_COMBINED_MM_DXE driver types are also supported. Combination MM/DXE drivers are especially problematic for writing portable and secure code. They are launched twice, once by the DXE dispatcher as a normal DXE driver (outside MMRAM) that uses the EFI_SECTION_DXE_DEPEX section and again in Traditional MM (in MMRAM) where the EFI_SECTION_MM_DEPEX is used. In contrast, MM_STANDALONE drivers are launched once is Standalone MM only with access to the MM services and protocols. Traditional MM and Standalone MM Dispatch Overview \u00b6 Because the Standalone MM environment inherently has less coupling with DXE, it is much easier to launch Standalone MM code earlier in the boot flow which contributes to reducing the overall TCB. In addition, MM drivers cannot depend on implementation specific DXE protocols and interfaces increasing their portability. For example, this can force MM code design to be more reusable across silicon generations and client and server codebases. Problems with Traditional MM \u00b6 Standalone MM can largely be considered a more disciplined approach to software execution in SMM. This discipline contributes to reduced likelihood of security issues, increased portability, and more flexibility in how to launch the MM environment. For a silicon vendor such as Intel and AMD, all of this improves the ability of partners to better integrate silicon reference code into their designs. Some key issues with Traditional MM are noted below. Late launch \u2013 Launching in DXE means another execution environment must be trusted after PEI to establish the MM environment. Excessive DXE coupling \u2013 Traditional MM is architecturally dependent on DXE. MM driver writers often make mistakes and cache interface pointers not allowed in the initialization phase. This is a frequent source of security issues. MM drivers are dependent on DXE interfaces in their initialization phase. This makes it more difficult to execute these drivers in an environment where DXE is not present. Much as MM drivers have dependencies on the load order of the DXE environment, DXE drivers do on MM drivers. For example, many DXE drivers have a dependency on the UEFI variable architectural protocol and/or the UEFI variable write architectural protocol. When MM is launched earlier in boot, such as PEI, the MM environment is already set up and ready making DXE dispatch more reliable. Delayed MM locking \u2013 Some system locks are delayed longer than necessary because the MM initialization phase is open throughout all of DXE. Broad memory access \u2013 Traditionally, SMM can access any memory buffer allocated prior to SmmReadyToLock. This presents security issues in which a freed buffer can be reassigned after the lock event and much more memory is exposed than necessary. It is recommended to use Standalone MM in combination with explicit memory ranges to be unblocked for MM access. The MmUnblockMemoryLib API provides a mechanism for callers outside MM to permit explicit ranges to be accessible. Launching the MM Foundation earlier brings other benefits such as the ability to use the read/write variable service in MM while in PEI. Because DXE is not involved, the MM Foundation can be entirely loaded and operational before launching payloads after PEI other than DXE. Alignment With Silicon Partner Initiatives \u00b6 Standalone MM launch in PEI naturally aligns with other silicon partner planned work such as: 64-bit PEI \u2013 Thunking is not necessary between a 32-bit PEI and 64-bit MM environment. Enabling Options \u00b6 Standalone MM provides flexibility in how to enable it. For example, if desired, a platform can simultaneously support both Traditional MM and Standalone MM modes with a build switch. Launch Phase \u00b6 Standalone MM can be launched in PEI which is preferred but it can also be launched in DXE at a similar point in the boot flow to Traditional MM to minimize deviation between the initialization point of the two modes. A high-level proposed Standalone MM IPL process in PEI is described below. Dispatch the Standalone MM PEI IPL in post-memory PEI. In the entry point of the Standalone MM PEI IPL, verify system pre-requisites are satisfied to set up the MM foundation in MMRAM. Example: the MM Control PPI and MM Access PPI are installed and sufficiently large MMRAM regions are reported. Because in Standalone MM, the platform cannot provide information via DXE interfaces, it is expected a platform will have to provide data in HOBs that must be present when the Standalone MM PEI IPL is executed. In general, this is considered a more ordered and structured approach to providing data into MM. Check if the system PEI is 32-bit. If so, cache the system execution context and then switch to X64 mode to load a X64 relay module (similar to CapsuleX64.inf). The X64 relay module can execute the Standalone MM core entry point with a supplied HOB start address. During the Standalone MM Foundation initialization, all Standalone MM drivers are loaded into MMRAM. No further drivers will be loaded from outside MMRAM during the boot. To better organize this process and focus relevant module exposure to the corresponding dispatchers, all Standalone MM drivers can be consolidated in a single firmware volume. After the Standalone MM Core Foundation is setup, the system will return to 32-bit mode restoring the cached context information, if applicable, and closing and locking all MMRAM regions. The Standalone MM PEI IPL installs the MM Communication PPI for PEIM usage in the remainder of the PEI phase. Once DXE is launched, the DXE MM Communication Protocol will be installed for DXE drivers to communicate with Standalone MM drivers. MM Module Dual Mode Support \u00b6 All Traditional MM modules can continue to be supported with most of the code shared between the Traditional MM and Standalone MM instances. Typically, modules end up in the following state: A Traditional MM INF file A Standalone MM INF file A Common MM C file \u2013 where the actual module implementation is written A Traditional MM C file \u2013 usually with just the Traditional MM entry point function that calls into the common C code A Standalone MM C file \u2013 usually with just the Standalone MM entry point function that calls into the common C code Therefore, the Traditional MM module is not lost, and its implementation can simultaneously stay current with the Standalone MM driver. Even for a driver as complex as the UEFI variable driver, this pattern reveals the small touch necessary to support Standalone MM: INF files Traditional MM: edk2/VariableSmm.inf at master \u00b7 tianocore/edk2 (github.com) Standalone MM: edk2/VariableStandaloneMm.inf at master \u00b7 tianocore/edk2 (github.com) C entry point files Traditional MM: edk2/VariableStandaloneMm.c at master \u00b7 tianocore/edk2 (github.com) Standalone MM: edk2/VariableTraditionalMm.c at master \u00b7 tianocore/edk2 (github.com) Common Steps to Port Traditional MM to Standalone MM \u00b6 Change the driver entry point prototype from the Traditional MM API to the Standalone MM API. The driver will now use StandaloneMmDriverEntryPoint. The system table should be of type \"EFI_MM_SYSTEM_TABLE\". In target INF files, use \"MM_STANDALONE\" as \"MODULE_TYPE\". In target INF files, set \"PI_SPECIFICATION\" version to \"0x00010032\". Update any \"DXE_SMM_DRIVER\" libraries that will now be ported for the Standalone MM environment, add support for the \"MM_STANDALONE\" and \"MM_CORE_STANDALONE\" driver types. To minimize impact on packages like ClientOneSiliconPkg that are used by many different products, the file paths to the pre-existing module INF file remain unchanged. For example, PchSmiDispatcher is still called PchSmiDispatcher. However, in many cases, a new Standalone MM INF file accompanies the original SMM driver INF that has minor differences such as specifying the MODULE_TYPE as MM_STANDALONE and using a different module entry point API. In cases where backward compatibility is not a concern, such as a .C source file name (as opposed to the INF file name), it is generally preferred to update terminology to \"traditional MM\". Use MemoryAllocationLib functions to allocate and free memory as opposed to gSmst or gMmst directly. This can improve portability between the two services tables. Find an alternative solution for gBS, gDS, and other DXE environment accesses. Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the Standalone MM environment. Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are still met. Standalone MM at Microsoft \u00b6 Microsoft has already implemented a POC on Tiger Lake that enables Standalone MM. We plan to ship code based on this Standalone MM implementation for Tiger Lake based products. It would greatly help reduce engineering effort within Microsoft if silicon partners would update silicon reference code to include Standalone MM support. Note: A Traditional MM option would be unnecessary for Microsoft if Standalone MM is fully supported.","title":"Standalone Mm Overview"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#standalone-mm","text":"This document summarizes some of the benefits gained by adopting Standalone MM versus Traditional MM. For general background on Management Mode (MM), review the Platform Initialization (PI) specifications. In particular, Volume 4: Management Mode Core Interface. As noted in the PI specification, MM is a generic term used to describe a secure execution environment provided by the CPU and related silicon that is entered when the CPU detects a Management Mode Interrupt (MMI). x86 systems implement MM with System Management Mode (SMM) and ARM systems do so with TrustZone (TZ). This document exclusively focuses on the x86 architecture. Two MM \"modes\" are defined in the PI specification \u2013 (1) Traditional MM and (2) Standalone MM. Traditional MM is equivalent to the SMM software model historically used in PI-compliant firmware. Standalone MM is a relatively new mode that revises the historical model to improve security of the MM environment and prevent common mistakes made in Traditional MM implementations that led to numerous portability and security challenges over the years. A detailed comparison of the Traditional MM and Standalone MM load process is described in the PI Specification sections \"Initializing Management Mode in MM Traditional Mode\" and \"Initializing Management Mode in Standalone Mode\" respectively. It should be noted that both modes leverage the same hardware capabilities. No special hardware is required to transition a firmware to Standalone MM. Further, nearly all existing SMM code can be reused in Standalone MM with no change. Most mandatory changes either involve minimally changing small portions of code such as an entry point function signature or the module type or making changes that are not allowed in Standalone MM because they were violating security practices in Traditional MM. For example, compare the \"MM Traditional Driver Runtime\" section of the PI Specification with the \"MM Standalone Driver Runtime\" section. Instances of code in silicon code today violates the \"soft restrictions\" described in the traditional section.","title":"Standalone MM"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#traditional-mm-versus-standalone-mm","text":"This section compares the main differences between Traditional MM and Standalone MM.","title":"Traditional MM Versus Standalone MM"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#mm-driver-initialization-and-runtime-phases","text":"Traditional MM typically launched in DXE and the DXE and Traditional MM environments closely interacted throughout driver dispatch. During MM dispatch, drivers execute in two phases \u2013 (1) initialization and (2) runtime. Traditional MM Initialization Standalone MM Initialization Starts When the driver is loaded into MMRAM and the driver\u2019s entry point is called When the driver is loaded into MMRAM and the driver\u2019s entry point is called Ends The driver\u2019s entry point returns The driver\u2019s entry point returns Protocol Access UEFI - Boot services - DXE services - Runtime services - DXE protocols MM - MM Services - MM protocols Note: The PI specification states drivers should not call Exit() or ExitBootServices() during the initialization phase MM - MM Services - MM protocols Note: Drivers do not have access to interfaces outside the MM environment. Traditional MM Runtime Standalone MM Runtime Starts After the initialization phase ends Starts after the initialization phase ends Protocol Access MM - MM Services - MM protocols Note: The PI specification states drivers should not call UEFI interfaces and services which were located during the initialization phase. MM - MM Services - MM protocols Note: Drivers do not have access to interfaces outside the MM environment. Given the initialization phase in Traditional MM occurred in DXE, in addition to the DXE_SMM_DRIVER driver type, EFI_FV_FILETYPE_COMBINED_MM_DXE driver types are also supported. Combination MM/DXE drivers are especially problematic for writing portable and secure code. They are launched twice, once by the DXE dispatcher as a normal DXE driver (outside MMRAM) that uses the EFI_SECTION_DXE_DEPEX section and again in Traditional MM (in MMRAM) where the EFI_SECTION_MM_DEPEX is used. In contrast, MM_STANDALONE drivers are launched once is Standalone MM only with access to the MM services and protocols.","title":"MM Driver Initialization and Runtime Phases"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#traditional-mm-and-standalone-mm-dispatch-overview","text":"Because the Standalone MM environment inherently has less coupling with DXE, it is much easier to launch Standalone MM code earlier in the boot flow which contributes to reducing the overall TCB. In addition, MM drivers cannot depend on implementation specific DXE protocols and interfaces increasing their portability. For example, this can force MM code design to be more reusable across silicon generations and client and server codebases.","title":"Traditional MM and Standalone MM Dispatch Overview"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#problems-with-traditional-mm","text":"Standalone MM can largely be considered a more disciplined approach to software execution in SMM. This discipline contributes to reduced likelihood of security issues, increased portability, and more flexibility in how to launch the MM environment. For a silicon vendor such as Intel and AMD, all of this improves the ability of partners to better integrate silicon reference code into their designs. Some key issues with Traditional MM are noted below. Late launch \u2013 Launching in DXE means another execution environment must be trusted after PEI to establish the MM environment. Excessive DXE coupling \u2013 Traditional MM is architecturally dependent on DXE. MM driver writers often make mistakes and cache interface pointers not allowed in the initialization phase. This is a frequent source of security issues. MM drivers are dependent on DXE interfaces in their initialization phase. This makes it more difficult to execute these drivers in an environment where DXE is not present. Much as MM drivers have dependencies on the load order of the DXE environment, DXE drivers do on MM drivers. For example, many DXE drivers have a dependency on the UEFI variable architectural protocol and/or the UEFI variable write architectural protocol. When MM is launched earlier in boot, such as PEI, the MM environment is already set up and ready making DXE dispatch more reliable. Delayed MM locking \u2013 Some system locks are delayed longer than necessary because the MM initialization phase is open throughout all of DXE. Broad memory access \u2013 Traditionally, SMM can access any memory buffer allocated prior to SmmReadyToLock. This presents security issues in which a freed buffer can be reassigned after the lock event and much more memory is exposed than necessary. It is recommended to use Standalone MM in combination with explicit memory ranges to be unblocked for MM access. The MmUnblockMemoryLib API provides a mechanism for callers outside MM to permit explicit ranges to be accessible. Launching the MM Foundation earlier brings other benefits such as the ability to use the read/write variable service in MM while in PEI. Because DXE is not involved, the MM Foundation can be entirely loaded and operational before launching payloads after PEI other than DXE.","title":"Problems with Traditional MM"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#alignment-with-silicon-partner-initiatives","text":"Standalone MM launch in PEI naturally aligns with other silicon partner planned work such as: 64-bit PEI \u2013 Thunking is not necessary between a 32-bit PEI and 64-bit MM environment.","title":"Alignment With Silicon Partner Initiatives"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#enabling-options","text":"Standalone MM provides flexibility in how to enable it. For example, if desired, a platform can simultaneously support both Traditional MM and Standalone MM modes with a build switch.","title":"Enabling Options"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#launch-phase","text":"Standalone MM can be launched in PEI which is preferred but it can also be launched in DXE at a similar point in the boot flow to Traditional MM to minimize deviation between the initialization point of the two modes. A high-level proposed Standalone MM IPL process in PEI is described below. Dispatch the Standalone MM PEI IPL in post-memory PEI. In the entry point of the Standalone MM PEI IPL, verify system pre-requisites are satisfied to set up the MM foundation in MMRAM. Example: the MM Control PPI and MM Access PPI are installed and sufficiently large MMRAM regions are reported. Because in Standalone MM, the platform cannot provide information via DXE interfaces, it is expected a platform will have to provide data in HOBs that must be present when the Standalone MM PEI IPL is executed. In general, this is considered a more ordered and structured approach to providing data into MM. Check if the system PEI is 32-bit. If so, cache the system execution context and then switch to X64 mode to load a X64 relay module (similar to CapsuleX64.inf). The X64 relay module can execute the Standalone MM core entry point with a supplied HOB start address. During the Standalone MM Foundation initialization, all Standalone MM drivers are loaded into MMRAM. No further drivers will be loaded from outside MMRAM during the boot. To better organize this process and focus relevant module exposure to the corresponding dispatchers, all Standalone MM drivers can be consolidated in a single firmware volume. After the Standalone MM Core Foundation is setup, the system will return to 32-bit mode restoring the cached context information, if applicable, and closing and locking all MMRAM regions. The Standalone MM PEI IPL installs the MM Communication PPI for PEIM usage in the remainder of the PEI phase. Once DXE is launched, the DXE MM Communication Protocol will be installed for DXE drivers to communicate with Standalone MM drivers.","title":"Launch Phase"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#mm-module-dual-mode-support","text":"All Traditional MM modules can continue to be supported with most of the code shared between the Traditional MM and Standalone MM instances. Typically, modules end up in the following state: A Traditional MM INF file A Standalone MM INF file A Common MM C file \u2013 where the actual module implementation is written A Traditional MM C file \u2013 usually with just the Traditional MM entry point function that calls into the common C code A Standalone MM C file \u2013 usually with just the Standalone MM entry point function that calls into the common C code Therefore, the Traditional MM module is not lost, and its implementation can simultaneously stay current with the Standalone MM driver. Even for a driver as complex as the UEFI variable driver, this pattern reveals the small touch necessary to support Standalone MM: INF files Traditional MM: edk2/VariableSmm.inf at master \u00b7 tianocore/edk2 (github.com) Standalone MM: edk2/VariableStandaloneMm.inf at master \u00b7 tianocore/edk2 (github.com) C entry point files Traditional MM: edk2/VariableStandaloneMm.c at master \u00b7 tianocore/edk2 (github.com) Standalone MM: edk2/VariableTraditionalMm.c at master \u00b7 tianocore/edk2 (github.com)","title":"MM Module Dual Mode Support"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#common-steps-to-port-traditional-mm-to-standalone-mm","text":"Change the driver entry point prototype from the Traditional MM API to the Standalone MM API. The driver will now use StandaloneMmDriverEntryPoint. The system table should be of type \"EFI_MM_SYSTEM_TABLE\". In target INF files, use \"MM_STANDALONE\" as \"MODULE_TYPE\". In target INF files, set \"PI_SPECIFICATION\" version to \"0x00010032\". Update any \"DXE_SMM_DRIVER\" libraries that will now be ported for the Standalone MM environment, add support for the \"MM_STANDALONE\" and \"MM_CORE_STANDALONE\" driver types. To minimize impact on packages like ClientOneSiliconPkg that are used by many different products, the file paths to the pre-existing module INF file remain unchanged. For example, PchSmiDispatcher is still called PchSmiDispatcher. However, in many cases, a new Standalone MM INF file accompanies the original SMM driver INF that has minor differences such as specifying the MODULE_TYPE as MM_STANDALONE and using a different module entry point API. In cases where backward compatibility is not a concern, such as a .C source file name (as opposed to the INF file name), it is generally preferred to update terminology to \"traditional MM\". Use MemoryAllocationLib functions to allocate and free memory as opposed to gSmst or gMmst directly. This can improve portability between the two services tables. Find an alternative solution for gBS, gDS, and other DXE environment accesses. Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the Standalone MM environment. Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are still met.","title":"Common Steps to Port Traditional MM to Standalone MM"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#standalone-mm-at-microsoft","text":"Microsoft has already implemented a POC on Tiger Lake that enables Standalone MM. We plan to ship code based on this Standalone MM implementation for Tiger Lake based products. It would greatly help reduce engineering effort within Microsoft if silicon partners would update silicon reference code to include Standalone MM support. Note: A Traditional MM option would be unnecessary for Microsoft if Standalone MM is fully supported.","title":"Standalone MM at Microsoft"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/","text":"Traditional SMM framework implementation ( not Secured Core compliant ) \u00b6 SMM framework modules \u00b6 4 main modules consist of SMM framework (all in post-PEI phase): PiSmmIpl will search for available SMRAM regions and load PiSmmCore. PiSmmCore will load SMM handler drivers during boot, provide memory allocation and free service, manage protocol and SMM handler database, provide protocol and/or event notification services, and dispatch registered SMM handles from SMM Handler drivers PiSmmCpuDxeSmm will relocate SMM base address, configure SMI entry code, set up GDT, IDT, page table protection. Smm Handler drivers , the drivers OEM authored for highly privileged jobs, such as power management. These drivers will register handlers through PiSmmCore services and get dispatched during SMI events. SMM framework boot flow \u00b6 SMM framework boot flow is illustrated above. (The color of each subprocess activation block matches the first block in the corresponding flow) During the system boot, PiSmmIpl will be loaded by DXE core. This driver will: Open and find the largest available SMRAM range Copy PiSmmCore into SMRAM and load it from SMRAM. NOTE that SMI entry is not setup yet, thus PiSmmCore entrypoint is not executed in SMI environment Share certain private data with PiSmmCore (mSmmCorePrivateData). At the entrypoint of PiSmmCore : PiSmmCore provides gSmst, a global table of service consumable from SMM handler drivers, including memory allocation, protocol publication, handler registration and waking up APs PiSmmCore register required SMI handler to itself, including gEfiEventDxeDispatchGuid, which is signaled on every round of DXE dispatching. SMM handler drivers are dispatched from this internal SMI handler, publishing protocols and signalling events consumable by other DXE and SMM drivers. During the SMM handler driver dispatch, PiSmmCpuDxeSmm will be loaded to set up SMBASE and SMI entry. At the entrypoint of PiSmmCpuDxeSmm Allocate buffer for SMM save state and SMI entry as described in git book by EDK2 Allocate stacks for SMI environment Setup GDT for code segment management and IDT for exception handling Relocate SMBASE to allocated SmiEntry code block SMI interrupt flow \u00b6 Upon a SMI input, CPU will pause currently running software and start from SMM base address, which was relocated by PiSmmCpuDxeSmm . At initial entry point, system will start from legacy (16-bit) mode. SMI entry code block is responsible to bring the system up to 64-bit mode before handing over to SmiRendezvous , a routine to synchronize all cores on a processor inside PiSmmCpuDxeSmm . This process includes stack initialization, configure IDT, GDT and TSS to the ones initialized in PiSmmCpuDxeSmm entry point. SmiRendezvous will put all APs stand by for multi-processor job, and release BSP to SMM framework routine SmmCoreEntry , which will manage PiSmmCore SMI private data and dispatch all handlers registered by other SMM handler drivers. If this SMI happens immediately after gEfiDxeSmmReadyToLockProtocolGuid event, the system will apply page table attributes and prevent further paging modification from this point and on.","title":"Traditional Smm Framework"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#traditional-smm-framework-implementation-not-secured-core-compliant","text":"","title":"Traditional SMM framework implementation (not Secured Core compliant)"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smm-framework-modules","text":"4 main modules consist of SMM framework (all in post-PEI phase): PiSmmIpl will search for available SMRAM regions and load PiSmmCore. PiSmmCore will load SMM handler drivers during boot, provide memory allocation and free service, manage protocol and SMM handler database, provide protocol and/or event notification services, and dispatch registered SMM handles from SMM Handler drivers PiSmmCpuDxeSmm will relocate SMM base address, configure SMI entry code, set up GDT, IDT, page table protection. Smm Handler drivers , the drivers OEM authored for highly privileged jobs, such as power management. These drivers will register handlers through PiSmmCore services and get dispatched during SMI events.","title":"SMM framework modules"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smm-framework-boot-flow","text":"SMM framework boot flow is illustrated above. (The color of each subprocess activation block matches the first block in the corresponding flow) During the system boot, PiSmmIpl will be loaded by DXE core. This driver will: Open and find the largest available SMRAM range Copy PiSmmCore into SMRAM and load it from SMRAM. NOTE that SMI entry is not setup yet, thus PiSmmCore entrypoint is not executed in SMI environment Share certain private data with PiSmmCore (mSmmCorePrivateData). At the entrypoint of PiSmmCore : PiSmmCore provides gSmst, a global table of service consumable from SMM handler drivers, including memory allocation, protocol publication, handler registration and waking up APs PiSmmCore register required SMI handler to itself, including gEfiEventDxeDispatchGuid, which is signaled on every round of DXE dispatching. SMM handler drivers are dispatched from this internal SMI handler, publishing protocols and signalling events consumable by other DXE and SMM drivers. During the SMM handler driver dispatch, PiSmmCpuDxeSmm will be loaded to set up SMBASE and SMI entry. At the entrypoint of PiSmmCpuDxeSmm Allocate buffer for SMM save state and SMI entry as described in git book by EDK2 Allocate stacks for SMI environment Setup GDT for code segment management and IDT for exception handling Relocate SMBASE to allocated SmiEntry code block","title":"SMM framework boot flow"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smi-interrupt-flow","text":"Upon a SMI input, CPU will pause currently running software and start from SMM base address, which was relocated by PiSmmCpuDxeSmm . At initial entry point, system will start from legacy (16-bit) mode. SMI entry code block is responsible to bring the system up to 64-bit mode before handing over to SmiRendezvous , a routine to synchronize all cores on a processor inside PiSmmCpuDxeSmm . This process includes stack initialization, configure IDT, GDT and TSS to the ones initialized in PiSmmCpuDxeSmm entry point. SmiRendezvous will put all APs stand by for multi-processor job, and release BSP to SMM framework routine SmmCoreEntry , which will manage PiSmmCore SMI private data and dispatch all handlers registered by other SMM handler drivers. If this SMI happens immediately after gEfiDxeSmmReadyToLockProtocolGuid event, the system will apply page table attributes and prevent further paging modification from this point and on.","title":"SMI interrupt flow"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"github"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > For each item, place an \"x\" in between [ and ] if true. Example: [x] . (you can also check items in the GitHub UI) Impacts functionality? Impacts security? Breaking change? Includes tests? Includes documentation?","title":"Description"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/","text":"OemPkg \u00b6 OemPkg contains the logic required to use Project Mu. Though this package should be bootable with some extra care from a developer, the code should be fully tailored to meet the needs of the product. Below is a short summary of each piece to the Project Mu puzzle to help jump-start the customization process. FrontPage \u00b6 FrontPage is Project Mu's UEFI landing page. From here, the user can access items like system information, boot menu, and DFCI management settings. There's a significant amount of logic contained within. FrontPage.c is the actual implementation of the FrontPage. It includes all the logic required to call, update, and populate the FrontPage with system information. Adding or removing elements from the FrontPage can be done by editing mFormMap. FrontPageConfigAccess.c implements trivial versions of RouteConfig and ExtractConfig to satisfy dependencies. FrontPageStrings.uni contains all static strings displayed on the UEFI FrontPage. FrontPageUi.c handles updates to the FrontPage UI including updates to the current page and info/popup boxes. FrontPageVfr.Vfr A VFR (Visual Forms Representation) file defines the layout of a UI and, in this case, FrontPage. FrontPageVfr.h contains guid definitions used in VFR files. String.c contains the logic for fetching strings using HII (Human Interface Infrastructure) protocols. HII is detailed in the UEFI Spec v2.8 on page 1731. FrontpageButtonsVolumeUp \u00b6 By default, booting to UEFI requires holding down the volume up (or equivalent) button on the device. It's unlikely that the volume up button will be appropriate or applicable to most devices, so it's recommended to alter the trigger for booting to UEFI. This module simulates holding down the volume up button on every boot so the UEFI FrontPage is loaded every boot. BootMenu \u00b6 The BootMenu on the UEFI FrontPage is under the Boot configuration tab. It defines the boot order for the device and advanced options which can potentially be managed through DFCI . BootMenu.c contains all logic required by the BootMenu including changing settings (assuming they are not locked through DFCI) and rebuilding the boot order. BootMenuStrings.uni contains all static strings displayed on the BootMenu. BootMenuVfr.Vfr defines the layout of the BootMenu UI. BootMenu.h contains guid definitions used in the VFR file. DeviceStatePei \u00b6 This module sets the Device State bits in the PEI phase so they are available prior to display in the DXE phase. Possible Device States include Manufacturing Mode Enabled/Disabled, Unit Test Mode, Secure Boot Enabled/Disabled, etc. Include(s) \u00b6 As is standard across EDK2 , the Include/ directory contains header files for functionality under the Library/ directory (not to be confused with Include/Library/) and is available for inclusion in other modules. MsNVBootReason.h provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage. PasswordStoreVariable.h defines the GUID and variable names for a variable-backed PasswordStore. PasswordPolicyLib.h contains the interface for storing and hashing an administrator password. ButtonServices.h is the header for FrontpageButtonsVolumeUp.c MsFrontPageAuthTokenProtocol.h is required to access the authentication token generated when FrontPage is launched. This token is used in all FrontPage applications to retrieve data from the settings provider. FrontPageSettings.h contains some variables correlating with settings on FrontPage. Library \u00b6 As is standard across EDK2 , the Library/ directory contains actual implementations of functionality provided/required by this module. BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume. DfciDeviceIdSupportLib provides access to platform data that becomes the DFCI Device ID which include the manufacturer name, product name, and serial number. Device IDs are used to target devices with DFCI settings management. DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here . DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non secure environment is available. MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device. MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). MsSecureBootModeSettingLib sets and gets the Secure Boot mode value during the DXE phase of execution. MsUefiVersionLib simply provides platform version information. PasswordPolicyLib contains the logic for storing and hashing an administrator password. PasswordPolicyLibNull is the NULL version of PasswordPolicyLib used when the actual functionality is unnecessary but some other component requires the library definition to successfully build. PasswordStoreLib manages storage location for the platform administrator password. PlatformKeyLibNull is the NULL implementation of PlatformKeyLib to satisfy dependencies. Override \u00b6 The Override/ directory contains overrides for EDK2 components. These overrides are sometimes required for things like bug fixes, functionality addition and removal. In this case, the only override is for BootManagerPolicyDxe to preserve some functionality of the original in case it is changed in the EDK2 upstream. Others \u00b6 .dec and .dsc files are required by the build process for any package in EDK2, hence the inclusion of OemPkg.dsc and OemPkg.dec . The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. The DEC file consists of sections delineated by section tags enclosed within square brackets which are used to generate AutoGen.c and AutoGen.h files for the EDK2 build infrastructure. For a more in-depth look at DSC and DEC files, check out the DSC specification and the DEC specification .","title":"Oem Pkg"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#oempkg","text":"OemPkg contains the logic required to use Project Mu. Though this package should be bootable with some extra care from a developer, the code should be fully tailored to meet the needs of the product. Below is a short summary of each piece to the Project Mu puzzle to help jump-start the customization process.","title":"OemPkg"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#frontpage","text":"FrontPage is Project Mu's UEFI landing page. From here, the user can access items like system information, boot menu, and DFCI management settings. There's a significant amount of logic contained within. FrontPage.c is the actual implementation of the FrontPage. It includes all the logic required to call, update, and populate the FrontPage with system information. Adding or removing elements from the FrontPage can be done by editing mFormMap. FrontPageConfigAccess.c implements trivial versions of RouteConfig and ExtractConfig to satisfy dependencies. FrontPageStrings.uni contains all static strings displayed on the UEFI FrontPage. FrontPageUi.c handles updates to the FrontPage UI including updates to the current page and info/popup boxes. FrontPageVfr.Vfr A VFR (Visual Forms Representation) file defines the layout of a UI and, in this case, FrontPage. FrontPageVfr.h contains guid definitions used in VFR files. String.c contains the logic for fetching strings using HII (Human Interface Infrastructure) protocols. HII is detailed in the UEFI Spec v2.8 on page 1731.","title":"FrontPage"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#frontpagebuttonsvolumeup","text":"By default, booting to UEFI requires holding down the volume up (or equivalent) button on the device. It's unlikely that the volume up button will be appropriate or applicable to most devices, so it's recommended to alter the trigger for booting to UEFI. This module simulates holding down the volume up button on every boot so the UEFI FrontPage is loaded every boot.","title":"FrontpageButtonsVolumeUp"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#bootmenu","text":"The BootMenu on the UEFI FrontPage is under the Boot configuration tab. It defines the boot order for the device and advanced options which can potentially be managed through DFCI . BootMenu.c contains all logic required by the BootMenu including changing settings (assuming they are not locked through DFCI) and rebuilding the boot order. BootMenuStrings.uni contains all static strings displayed on the BootMenu. BootMenuVfr.Vfr defines the layout of the BootMenu UI. BootMenu.h contains guid definitions used in the VFR file.","title":"BootMenu"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#devicestatepei","text":"This module sets the Device State bits in the PEI phase so they are available prior to display in the DXE phase. Possible Device States include Manufacturing Mode Enabled/Disabled, Unit Test Mode, Secure Boot Enabled/Disabled, etc.","title":"DeviceStatePei"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#includes","text":"As is standard across EDK2 , the Include/ directory contains header files for functionality under the Library/ directory (not to be confused with Include/Library/) and is available for inclusion in other modules. MsNVBootReason.h provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage. PasswordStoreVariable.h defines the GUID and variable names for a variable-backed PasswordStore. PasswordPolicyLib.h contains the interface for storing and hashing an administrator password. ButtonServices.h is the header for FrontpageButtonsVolumeUp.c MsFrontPageAuthTokenProtocol.h is required to access the authentication token generated when FrontPage is launched. This token is used in all FrontPage applications to retrieve data from the settings provider. FrontPageSettings.h contains some variables correlating with settings on FrontPage.","title":"Include(s)"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#library","text":"As is standard across EDK2 , the Library/ directory contains actual implementations of functionality provided/required by this module. BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume. DfciDeviceIdSupportLib provides access to platform data that becomes the DFCI Device ID which include the manufacturer name, product name, and serial number. Device IDs are used to target devices with DFCI settings management. DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here . DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non secure environment is available. MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device. MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). MsSecureBootModeSettingLib sets and gets the Secure Boot mode value during the DXE phase of execution. MsUefiVersionLib simply provides platform version information. PasswordPolicyLib contains the logic for storing and hashing an administrator password. PasswordPolicyLibNull is the NULL version of PasswordPolicyLib used when the actual functionality is unnecessary but some other component requires the library definition to successfully build. PasswordStoreLib manages storage location for the platform administrator password. PlatformKeyLibNull is the NULL implementation of PlatformKeyLib to satisfy dependencies.","title":"Library"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#override","text":"The Override/ directory contains overrides for EDK2 components. These overrides are sometimes required for things like bug fixes, functionality addition and removal. In this case, the only override is for BootManagerPolicyDxe to preserve some functionality of the original in case it is changed in the EDK2 upstream.","title":"Override"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#others","text":".dec and .dsc files are required by the build process for any package in EDK2, hence the inclusion of OemPkg.dsc and OemPkg.dec . The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. The DEC file consists of sections delineated by section tags enclosed within square brackets which are used to generate AutoGen.c and AutoGen.h files for the EDK2 build infrastructure. For a more in-depth look at DSC and DEC files, check out the DSC specification and the DEC specification .","title":"Others"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/","text":"Project Mu Oem Sample Repository \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_oem_sample.git Branch: release/202202 Commit: 0124d6f3cc4823fab9298fdb81ba7c3cded2fc42 Commit Date: 2022-10-21 22:37:24 -0400 This repository is considered sample code for any entity building devices using Project Mu. It is likely that any device manufacturer will want to customize the device behavior by changing the modules in this package. Numerous libraries to support UEFI Boot Device Selection phase (BDS) Firmware Version information UI App / \"FrontPage\" application support as well as example More Info \u00b6 FrontpageDsc and FrontpageFdf that can be included so you don't have to unravel all of the libraries and protocols that are required to get started with FrontPage. Includes contain comments for clarity, and there is a more extensive explanation for each library in the Docs/Frontpage_Includes. Please see the Project Mu docs for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Per Platform Libraries \u00b6 NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included in the DSC file. An example can be found in the NXP iMX8 platform . Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements PR-Gate Builds \u00b6 pip install --upgrade -r requirements.txt mu_build -c corebuild.mu.json Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Repo Details"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#project-mu-oem-sample-repository","text":"Git Details Repository Url: https://github.com/Microsoft/mu_oem_sample.git Branch: release/202202 Commit: 0124d6f3cc4823fab9298fdb81ba7c3cded2fc42 Commit Date: 2022-10-21 22:37:24 -0400 This repository is considered sample code for any entity building devices using Project Mu. It is likely that any device manufacturer will want to customize the device behavior by changing the modules in this package. Numerous libraries to support UEFI Boot Device Selection phase (BDS) Firmware Version information UI App / \"FrontPage\" application support as well as example","title":"Project Mu Oem Sample Repository"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#more-info","text":"FrontpageDsc and FrontpageFdf that can be included so you don't have to unravel all of the libraries and protocols that are required to get started with FrontPage. Includes contain comments for clarity, and there is a more extensive explanation for each library in the Docs/Frontpage_Includes. Please see the Project Mu docs for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#per-platform-libraries","text":"NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included in the DSC file. An example can be found in the NXP iMX8 platform .","title":"Per Platform Libraries"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#pr-gate-builds","text":"pip install --upgrade -r requirements.txt mu_build -c corebuild.mu.json","title":"PR-Gate Builds"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Copyright &amp; License"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/","text":"DSC Include File in Detail \u00b6 This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage. Preliminaries \u00b6 What is a DSC File \u00b6 The .dsc filetype is an EDK2 Platform Description file format. The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. To learn more about it, check the specification on the tianocore-docs github. What is an INF File \u00b6 The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github. How do I Include a DSC File \u00b6 This file will be included in the DSC file for the platform being built. The syntax for including a file is: !include path/to/dsc/include/file What are NULL Libs \u00b6 A NULL lib is one which satisfies a dependency but doesn't implement the required functions. They're used when a package requires the definition of a library but the way in which the package is being used does not actually necessitate that library. Instead of reworking the package to remove dependencies on the unused library, a NULL version of that libraray can be created which fits the specification but returns the trivial result when called. What is DFCI \u00b6 From the feature document : The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu. Libraries included \u00b6 NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included either here or in the main DSC file. An example can be found in the NXP iMX8 platform . in the Library/ directory. Shell libraries \u00b6 From the frontpage, the shell can be loaded from frontpage using the boot menu. ShellLib provides the main functionality for shell commands and applications. ShellCommandLib provides the internal support for ShellLib. ShellCEntryLib enables a C-style main function with traditional argc and argv parameters. HandleParsingLib supports the parsing the handle and protocol database from the shell. BcfgCommandLib enables the usage of the bcfg command in the shell. Information about bcfg can be found in the UEFI Shell Specification v2.2 on page 96. NetLib provides basic network functionality. ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf ShellCommandLib|ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf ShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf HandleParsingLib|ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf BcfgCommandLib|ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf NetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf Intrinsics for crypto operations \u00b6 IntrinsicLib is an intrinsic memory routines wrapper implementation for an OpenSSL -based cryptographic library. IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf NULL routines to support DFCI UI operations \u00b6 Info on DfciUiSupportLib can be found here DfciUiSupportLib|DfciPkg/Library/DfciUiSupportLibNull/DfciUiSupportLibNull.inf Crypto support functions for the DFCI recovery feature \u00b6 Info on DfciRecoveryLib can be found here DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf OpenSSL Library \u00b6 OpensslLib is an open-source implementation of the SSL and TLS protocols. This library is used by BaseCryptLib. OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf Stub functions that should contain base logic for querying, setting, and verifying user passwords \u00b6 BaseCryptLib provides basic library functions for cryptographic primitives. BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf Supports DFCI Groups \u00b6 DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here . XmlTreeQueryLib and XmlTreeLib introduce some xml support into UEFI. Info on the Xml Support Package can be found here . DfciGroupLib|DfciPkg/Library/DfciGroupLibNull/DfciGroups.inf XmlTreeQueryLib|XmlSupportPkg/Library/XmlTreeQueryLib/XmlTreeQueryLib.inf XmlTreeLib|XmlSupportPkg/Library/XmlTreeLib/XmlTreeLib.inf Backwards compatibility with DFCI V1 functions \u00b6 DfciV1SupportLib (or rather its NULL instance) translates V1 DFCI strings into V2 DFCI strings. FltUsedLib provides a global (fltused) that needs to be defined anywhere floating point operations are used. DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf FltUsedLib|MdePkg/Library/FltUsedLib/FltUsedLib.inf Library instances which understand the MsXml Settings Schema \u00b6 DfciXmlSettingSchemaSupportLib supports the xml schema used to store/define settings in DFCI . DfciXmlPermissionSchemaSupportLib supports the xml format used to store permissions. More information on DFCI Permissions can be found here . DfciXmlDeviceIdSchemaSupportLib and DfciXmlIdentitySchemaSupportLib support the xml format used to store Device Identities.More info on the DFCI Identity Manager can be found here DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf Support for Zero Touch \u00b6 The term Zero Touch is used in DFCI to describe managing device settings remotely. ZeroTouchSettingsLib is a library instance for ZeroTouch to support enabling, display, and deleting the Zero Touch Certificate. SafeIntLib is a simple integer mathematics library which guards against integer overflow . BmpSupportLib supports the use of bitmap files. ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf SafeIntLib|MdePkg/Library/BaseSafeIntLib/BaseSafeIntLib.inf BmpSupportLib|MdeModulePkg/Library/BaseBmpSupportLib/BaseBmpSupportLib.inf NULL library for displaying device state \u00b6 DisplayDeviceStateLib usually supplies a function to display all active device states. This NULL implementation satisfies dependencies on this function, but no non-null version of this lib exists in Project Mu. DisplayDeviceStateLib|MsGraphicsPkg/Library/DisplayDeviceStateLibNull/DisplayDeviceStateLibNull.inf Libraries supporting boot graphics \u00b6 BootGraphicsLib is used by BDS to draw and the main boot graphics to the screen. In the case of Microsoft Surface products, this is usually the Windows logo. BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume. BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf BootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf Support libary for MS_UI_THEME \u00b6 The MS_UI_THEME is the theme used by our FrontPage. MsUiThemeCopyLib is used by the graphics package to copy the stored theme into a buffer. MsUiThemeCopyLib|MsGraphicsPkg/Library/MsUiThemeCopyLib/MsUiThemeCopyLib.inf Version Support Library \u00b6 MuUefiVersionLib is a simple library which returns the current UEFI version. MuUefiVersionLib|OemPkg/Library/MuUefiVersionLib/MuUefiVersionLib.inf Thermal Support \u00b6 This NULL implementation of the ThermalServicesLib satisfies a dependency from DeviceBootManagerlib . Because there is no universal API for fetching thermal state, ThermalServicesLib requires a platform specific implementation to function. ThermalServicesLib|PcBdsPkg/Library/ThermalServicesLibNull/ThermalServicesLibNull.inf Platform power services \u00b6 Note that these are both NULL implementations. PowerServicesLib supports Platforms that don't have a battery. MsPlatformPowerCheckLib allows platform code to configure CPU power limits. PowerServicesLib|PcBdsPkg/Library/PowerServicesLibNull/PowerServicesLibNull.inf MsPlatformPowerCheckLib|PcBdsPkg/Library/MsPlatformPowerCheckLibNull/MsPlatformPowerCheckLibNull.inf Console Message Library \u00b6 ConsoleMsgLib offers functionality to display platform specific debug messages. Platforms are responsible for implementing this interface (this is a NULL implementation) ConsoleMsgLib|PcBdsPkg/Library/ConsoleMsgLibNull/ConsoleMsgLibNull.inf Console Configuration \u00b6 GraphicsConsoleHelperLib enables the setting of the graphics console resolution to known values (ex. native resolution, low resolution, etc.). GraphicsConsoleHelperLib|PcBdsPkg/Library/GraphicsConsoleHelperLib/GraphicsConsoleHelper.inf Device State Support \u00b6 DeviceStateLib is a simple interface for getting and setting the device state (ex. Manufacturing Mode, Unit Test Mode, etc.). DisplayDeviceStateLib uses color bards to display device states during boot. For example, the following color bar displayed at the top of the screen implies Secure Boot is disabled DeviceStateLib|MsCorePkg/Library/DeviceStateLib/DeviceStateLib.inf DisplayDeviceStateLib|MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ColorBarDisplayDeviceStateLib.inf Device specific boot actions supporting PlatformBootManagerLib \u00b6 DeviceBootManagerLib provides extensions for BdsDxe which is responsible for producing the protocol gEfiBdsArchProtocolGuid which is used to transition between DXE and BDS phases. DeviceBootManagerLib|PcBdsPkg/Library/DeviceBootManagerLib/DeviceBootManagerLib.inf Rectangle Primitives Library \u00b6 UiRectangleLib enables the drawing of rectangles with different fills and borders. UiRectangleLib|MsGraphicsPkg/Library/BaseUiRectangleLib/BaseUiRectangleLib.inf Boot Management \u00b6 MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device. MsBootOptionsLib extends BdsDxe to allow booting from specific storage devices or to the shell. MsAltBootLib|OemPkg/Library/MsAltBootLib/MsAltBootLib.inf MsBootOptionsLib|PcBdsPkg/Library/MsBootOptionsLib/MsBootOptionsLib.inf Color Support \u00b6 MsColorTableLib is a simple library of colors MsColorTableLib|MsGraphicsPkg/Library/MsColorTableLib/MsColorTableLib.inf Networking Support \u00b6 MsNetworkDependencyLib is used by the boot manager to start the networking stack. MsNetworkDependencyLib|PcBdsPkg/Library/MsNetworkDependencyLib/MsNetworkDependencyLib.inf Library to access reboot reason \u00b6 MsNVBootReasonLib provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage. MsNVBootReasonLib|OemPkg/Library/MsNVBootReasonLib/MsNVBootReasonLib.inf Math Library \u00b6 MathLib provides an architecture agnostic math library offering reasonable approximations for various functions in software. MathLib|MsCorePkg/Library/MathLib/MathLib.inf System Boot Graphics Support \u00b6 BootGraphicsLib is intended only to be used by BDS to draw the main boot graphics on the screen. (ex. the Microsoft logo). BootGraphicsProviderLib uses PCDs to retrieve BMP files from firmware volumes. BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf BootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf Boot Manager Settings Access \u00b6 MsBootManagerSettingsLib provides get and set access for boot manager settings. MsBootManagerSettingsLib|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf Simple Window Manager Dialogs \u00b6 SwmDialogsLib enables the display of dialog boxes such as a password input box. SwmDialogsLib|MsGraphicsPkg/Library/SwmDialogsLib/SwmDialogs.inf Platform Specific Boot Policy \u00b6 MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). MsBootPolicyLib|OemPkg/Library/MsBootPolicyLib/MsBootPolicyLib.inf UI Support \u00b6 MsUiThemeLib Supplies the theme for this platform to the UEFI settings UI. UIToolKitLib initializes toolkit required for UI display. MsUiThemeLib|MsGraphicsPkg/Library/MsUiThemeLib/Dxe/MsUiThemeLib.inf UIToolKitLib|MsGraphicsPkg/Library/SimpleUIToolKit/SimpleUIToolKit.inf Security Support \u00b6 ResetUtilityLib contains various helper functions for resetting the system. BaseBinSecurityLib is a NULL implementation of a library for initializing security cookies. SecurityLockAuditLib is another NULL implementation to satisfy compilation dependencies. The implemented version supplies necessary functions for logging hardware and software security locks. ResetUtilityLib|MdeModulePkg/Library/ResetUtilityLib/ResetUtilityLib.inf BaseBinSecurityLib|MdePkg/Library/BaseBinSecurityLibNull/BaseBinSecurityLibNull.inf SecurityLockAuditLib|MdeModulePkg/Library/SecurityLockAuditLibNull/SecurityLockAuditLibNull.inf PCDs included \u00b6 Set to TRUE so Console In (ConIn. ex. keyboard) is only connected once a console input is requested (ex. when a device is plugged). gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|TRUE Sets maximum printable number of characters to 16000 gEfiMdePkgTokenSpaceGuid.PcdUefiLibMaxPrintBufferSize|16000 Used to control the profiles available in the shell. 0x1f sets all profiles to available. gEfiShellPkgTokenSpaceGuid.PcdShellProfileMask|0x1f # All profiles If TRUE, MsUiTheme is built in DXE . This should be TRUE for platforms that don't have a PPI ( PEI module to PEI module Interface). Otherwise, the theme will be generated in PEI and it will be located on a HOB. gMsGraphicsPkgTokenSpaceGuid.PcdUiThemeInDxe|TRUE If TRUE, the Boot Manager will be in the boot order list. gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerInBootOrder|TRUE If TRUE, the BDS supports Platform Recovery gEfiMdeModulePkgTokenSpaceGuid.PcdPlatformRecoverySupport|FALSE Set to the guid associated with the Mu Frontpage. gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ 0x8A, 0x70, 0x42, 0x40, 0x2D, 0x0F, 0x23, 0x48, 0xAC, 0x60, 0x0D, 0x77, 0xB3, 0x11, 0x18, 0x89 } Components \u00b6 Spoofs button press to automatically boot to FrontPage. OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf Application that presents and manages FrontPage. OemPkg/FrontPage/FrontPage.inf Application that presents & manages the Boot Menu Setup on Front Page. OemPkg/BootMenu/BootMenu.inf Enables MsBootPolicy. See the Platform Specific Boot Policy Library PcBdsPkg/MsBootPolicy/MsBootPolicy.inf A module which produces Boot Manager Policy protocol. MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf A regular expression library to support Remote/IT/Admin Settings such as DFCI . MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf Main component of DFCI which manages and enforces all DFCI settings DfciPkg/SettingsManager/SettingsManagerDxe.inf { # Platform should add all it settings libs here <LibraryClasses> NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf NULL|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE } AuthManager provides authentication for DFCI . DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf Processes ingoing and outgoing DFCI settings requests DfciPkg/DfciManager/DfciManager.inf Manages windows and fonts to be drawn by the rendering engine MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf Produces EfiGraphicsOutputProtocol to draw graphics to the screen MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one. MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf Driver for On Screen Keyboard. MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf Installs protocol to share the UI theme. MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf Produces gEdkiiFormDisplayEngineProtocolGuid protocol. Handles input, displays strings MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf Enables the Shell ShellPkg/Application/Shell/Shell.inf { <LibraryClasses> NULL|ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf NULL|ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf NULL|ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf NULL|ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf NULL|ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf NULL|ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf NULL|ShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf <PcdsFixedAtBuild> gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE }","title":"Frontpage DSC Include"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#dsc-include-file-in-detail","text":"This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage.","title":"DSC Include File in Detail"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#preliminaries","text":"","title":"Preliminaries"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-a-dsc-file","text":"The .dsc filetype is an EDK2 Platform Description file format. The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. To learn more about it, check the specification on the tianocore-docs github.","title":"What is a DSC File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-an-inf-file","text":"The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github.","title":"What is an INF File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#how-do-i-include-a-dsc-file","text":"This file will be included in the DSC file for the platform being built. The syntax for including a file is: !include path/to/dsc/include/file","title":"How do I Include a DSC File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-are-null-libs","text":"A NULL lib is one which satisfies a dependency but doesn't implement the required functions. They're used when a package requires the definition of a library but the way in which the package is being used does not actually necessitate that library. Instead of reworking the package to remove dependencies on the unused library, a NULL version of that libraray can be created which fits the specification but returns the trivial result when called.","title":"What are NULL Libs"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-dfci","text":"From the feature document : The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu.","title":"What is DFCI"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#libraries-included","text":"NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included either here or in the main DSC file. An example can be found in the NXP iMX8 platform . in the Library/ directory.","title":"Libraries included"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#shell-libraries","text":"From the frontpage, the shell can be loaded from frontpage using the boot menu. ShellLib provides the main functionality for shell commands and applications. ShellCommandLib provides the internal support for ShellLib. ShellCEntryLib enables a C-style main function with traditional argc and argv parameters. HandleParsingLib supports the parsing the handle and protocol database from the shell. BcfgCommandLib enables the usage of the bcfg command in the shell. Information about bcfg can be found in the UEFI Shell Specification v2.2 on page 96. NetLib provides basic network functionality. ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf ShellCommandLib|ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf ShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf HandleParsingLib|ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf BcfgCommandLib|ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf NetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf","title":"Shell libraries"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#intrinsics-for-crypto-operations","text":"IntrinsicLib is an intrinsic memory routines wrapper implementation for an OpenSSL -based cryptographic library. IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf","title":"Intrinsics for crypto operations"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#null-routines-to-support-dfci-ui-operations","text":"Info on DfciUiSupportLib can be found here DfciUiSupportLib|DfciPkg/Library/DfciUiSupportLibNull/DfciUiSupportLibNull.inf","title":"NULL routines to support DFCI UI operations"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#crypto-support-functions-for-the-dfci-recovery-feature","text":"Info on DfciRecoveryLib can be found here DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf","title":"Crypto support functions for the DFCI recovery feature"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#openssl-library","text":"OpensslLib is an open-source implementation of the SSL and TLS protocols. This library is used by BaseCryptLib. OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf","title":"OpenSSL Library"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#stub-functions-that-should-contain-base-logic-for-querying-setting-and-verifying-user-passwords","text":"BaseCryptLib provides basic library functions for cryptographic primitives. BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf","title":"Stub functions that should contain base logic for querying, setting, and verifying user passwords"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#supports-dfci-groups","text":"DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here . XmlTreeQueryLib and XmlTreeLib introduce some xml support into UEFI. Info on the Xml Support Package can be found here . DfciGroupLib|DfciPkg/Library/DfciGroupLibNull/DfciGroups.inf XmlTreeQueryLib|XmlSupportPkg/Library/XmlTreeQueryLib/XmlTreeQueryLib.inf XmlTreeLib|XmlSupportPkg/Library/XmlTreeLib/XmlTreeLib.inf","title":"Supports DFCI Groups"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#backwards-compatibility-with-dfci-v1-functions","text":"DfciV1SupportLib (or rather its NULL instance) translates V1 DFCI strings into V2 DFCI strings. FltUsedLib provides a global (fltused) that needs to be defined anywhere floating point operations are used. DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf FltUsedLib|MdePkg/Library/FltUsedLib/FltUsedLib.inf","title":"Backwards compatibility with DFCI V1 functions"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#library-instances-which-understand-the-msxml-settings-schema","text":"DfciXmlSettingSchemaSupportLib supports the xml schema used to store/define settings in DFCI . DfciXmlPermissionSchemaSupportLib supports the xml format used to store permissions. More information on DFCI Permissions can be found here . DfciXmlDeviceIdSchemaSupportLib and DfciXmlIdentitySchemaSupportLib support the xml format used to store Device Identities.More info on the DFCI Identity Manager can be found here DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf","title":"Library instances which understand the MsXml Settings Schema"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#support-for-zero-touch","text":"The term Zero Touch is used in DFCI to describe managing device settings remotely. ZeroTouchSettingsLib is a library instance for ZeroTouch to support enabling, display, and deleting the Zero Touch Certificate. SafeIntLib is a simple integer mathematics library which guards against integer overflow . BmpSupportLib supports the use of bitmap files. ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf SafeIntLib|MdePkg/Library/BaseSafeIntLib/BaseSafeIntLib.inf BmpSupportLib|MdeModulePkg/Library/BaseBmpSupportLib/BaseBmpSupportLib.inf","title":"Support for Zero Touch"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#null-library-for-displaying-device-state","text":"DisplayDeviceStateLib usually supplies a function to display all active device states. This NULL implementation satisfies dependencies on this function, but no non-null version of this lib exists in Project Mu. DisplayDeviceStateLib|MsGraphicsPkg/Library/DisplayDeviceStateLibNull/DisplayDeviceStateLibNull.inf","title":"NULL library for displaying device state"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#libraries-supporting-boot-graphics","text":"BootGraphicsLib is used by BDS to draw and the main boot graphics to the screen. In the case of Microsoft Surface products, this is usually the Windows logo. BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume. BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf BootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf","title":"Libraries supporting boot graphics"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#support-libary-for-ms_ui_theme","text":"The MS_UI_THEME is the theme used by our FrontPage. MsUiThemeCopyLib is used by the graphics package to copy the stored theme into a buffer. MsUiThemeCopyLib|MsGraphicsPkg/Library/MsUiThemeCopyLib/MsUiThemeCopyLib.inf","title":"Support libary for MS_UI_THEME"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#version-support-library","text":"MuUefiVersionLib is a simple library which returns the current UEFI version. MuUefiVersionLib|OemPkg/Library/MuUefiVersionLib/MuUefiVersionLib.inf","title":"Version Support Library"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#thermal-support","text":"This NULL implementation of the ThermalServicesLib satisfies a dependency from DeviceBootManagerlib . Because there is no universal API for fetching thermal state, ThermalServicesLib requires a platform specific implementation to function. ThermalServicesLib|PcBdsPkg/Library/ThermalServicesLibNull/ThermalServicesLibNull.inf","title":"Thermal Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#platform-power-services","text":"Note that these are both NULL implementations. PowerServicesLib supports Platforms that don't have a battery. MsPlatformPowerCheckLib allows platform code to configure CPU power limits. PowerServicesLib|PcBdsPkg/Library/PowerServicesLibNull/PowerServicesLibNull.inf MsPlatformPowerCheckLib|PcBdsPkg/Library/MsPlatformPowerCheckLibNull/MsPlatformPowerCheckLibNull.inf","title":"Platform power services"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#console-message-library","text":"ConsoleMsgLib offers functionality to display platform specific debug messages. Platforms are responsible for implementing this interface (this is a NULL implementation) ConsoleMsgLib|PcBdsPkg/Library/ConsoleMsgLibNull/ConsoleMsgLibNull.inf","title":"Console Message Library"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#console-configuration","text":"GraphicsConsoleHelperLib enables the setting of the graphics console resolution to known values (ex. native resolution, low resolution, etc.). GraphicsConsoleHelperLib|PcBdsPkg/Library/GraphicsConsoleHelperLib/GraphicsConsoleHelper.inf","title":"Console Configuration"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#device-state-support","text":"DeviceStateLib is a simple interface for getting and setting the device state (ex. Manufacturing Mode, Unit Test Mode, etc.). DisplayDeviceStateLib uses color bards to display device states during boot. For example, the following color bar displayed at the top of the screen implies Secure Boot is disabled DeviceStateLib|MsCorePkg/Library/DeviceStateLib/DeviceStateLib.inf DisplayDeviceStateLib|MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ColorBarDisplayDeviceStateLib.inf","title":"Device State Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#device-specific-boot-actions-supporting-platformbootmanagerlib","text":"DeviceBootManagerLib provides extensions for BdsDxe which is responsible for producing the protocol gEfiBdsArchProtocolGuid which is used to transition between DXE and BDS phases. DeviceBootManagerLib|PcBdsPkg/Library/DeviceBootManagerLib/DeviceBootManagerLib.inf","title":"Device specific boot actions supporting PlatformBootManagerLib"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#rectangle-primitives-library","text":"UiRectangleLib enables the drawing of rectangles with different fills and borders. UiRectangleLib|MsGraphicsPkg/Library/BaseUiRectangleLib/BaseUiRectangleLib.inf","title":"Rectangle Primitives Library"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#boot-management","text":"MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device. MsBootOptionsLib extends BdsDxe to allow booting from specific storage devices or to the shell. MsAltBootLib|OemPkg/Library/MsAltBootLib/MsAltBootLib.inf MsBootOptionsLib|PcBdsPkg/Library/MsBootOptionsLib/MsBootOptionsLib.inf","title":"Boot Management"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#color-support","text":"MsColorTableLib is a simple library of colors MsColorTableLib|MsGraphicsPkg/Library/MsColorTableLib/MsColorTableLib.inf","title":"Color Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#networking-support","text":"MsNetworkDependencyLib is used by the boot manager to start the networking stack. MsNetworkDependencyLib|PcBdsPkg/Library/MsNetworkDependencyLib/MsNetworkDependencyLib.inf","title":"Networking Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#library-to-access-reboot-reason","text":"MsNVBootReasonLib provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage. MsNVBootReasonLib|OemPkg/Library/MsNVBootReasonLib/MsNVBootReasonLib.inf","title":"Library to access reboot reason"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#math-library","text":"MathLib provides an architecture agnostic math library offering reasonable approximations for various functions in software. MathLib|MsCorePkg/Library/MathLib/MathLib.inf","title":"Math Library"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#system-boot-graphics-support","text":"BootGraphicsLib is intended only to be used by BDS to draw the main boot graphics on the screen. (ex. the Microsoft logo). BootGraphicsProviderLib uses PCDs to retrieve BMP files from firmware volumes. BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf BootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf","title":"System Boot Graphics Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#boot-manager-settings-access","text":"MsBootManagerSettingsLib provides get and set access for boot manager settings. MsBootManagerSettingsLib|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf","title":"Boot Manager Settings Access"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#simple-window-manager-dialogs","text":"SwmDialogsLib enables the display of dialog boxes such as a password input box. SwmDialogsLib|MsGraphicsPkg/Library/SwmDialogsLib/SwmDialogs.inf","title":"Simple Window Manager Dialogs"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#platform-specific-boot-policy","text":"MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). MsBootPolicyLib|OemPkg/Library/MsBootPolicyLib/MsBootPolicyLib.inf","title":"Platform Specific Boot Policy"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#ui-support","text":"MsUiThemeLib Supplies the theme for this platform to the UEFI settings UI. UIToolKitLib initializes toolkit required for UI display. MsUiThemeLib|MsGraphicsPkg/Library/MsUiThemeLib/Dxe/MsUiThemeLib.inf UIToolKitLib|MsGraphicsPkg/Library/SimpleUIToolKit/SimpleUIToolKit.inf","title":"UI Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#security-support","text":"ResetUtilityLib contains various helper functions for resetting the system. BaseBinSecurityLib is a NULL implementation of a library for initializing security cookies. SecurityLockAuditLib is another NULL implementation to satisfy compilation dependencies. The implemented version supplies necessary functions for logging hardware and software security locks. ResetUtilityLib|MdeModulePkg/Library/ResetUtilityLib/ResetUtilityLib.inf BaseBinSecurityLib|MdePkg/Library/BaseBinSecurityLibNull/BaseBinSecurityLibNull.inf SecurityLockAuditLib|MdeModulePkg/Library/SecurityLockAuditLibNull/SecurityLockAuditLibNull.inf","title":"Security Support"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#pcds-included","text":"Set to TRUE so Console In (ConIn. ex. keyboard) is only connected once a console input is requested (ex. when a device is plugged). gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|TRUE Sets maximum printable number of characters to 16000 gEfiMdePkgTokenSpaceGuid.PcdUefiLibMaxPrintBufferSize|16000 Used to control the profiles available in the shell. 0x1f sets all profiles to available. gEfiShellPkgTokenSpaceGuid.PcdShellProfileMask|0x1f # All profiles If TRUE, MsUiTheme is built in DXE . This should be TRUE for platforms that don't have a PPI ( PEI module to PEI module Interface). Otherwise, the theme will be generated in PEI and it will be located on a HOB. gMsGraphicsPkgTokenSpaceGuid.PcdUiThemeInDxe|TRUE If TRUE, the Boot Manager will be in the boot order list. gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerInBootOrder|TRUE If TRUE, the BDS supports Platform Recovery gEfiMdeModulePkgTokenSpaceGuid.PcdPlatformRecoverySupport|FALSE Set to the guid associated with the Mu Frontpage. gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ 0x8A, 0x70, 0x42, 0x40, 0x2D, 0x0F, 0x23, 0x48, 0xAC, 0x60, 0x0D, 0x77, 0xB3, 0x11, 0x18, 0x89 }","title":"PCDs included"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#components","text":"Spoofs button press to automatically boot to FrontPage. OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf Application that presents and manages FrontPage. OemPkg/FrontPage/FrontPage.inf Application that presents & manages the Boot Menu Setup on Front Page. OemPkg/BootMenu/BootMenu.inf Enables MsBootPolicy. See the Platform Specific Boot Policy Library PcBdsPkg/MsBootPolicy/MsBootPolicy.inf A module which produces Boot Manager Policy protocol. MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf A regular expression library to support Remote/IT/Admin Settings such as DFCI . MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf Main component of DFCI which manages and enforces all DFCI settings DfciPkg/SettingsManager/SettingsManagerDxe.inf { # Platform should add all it settings libs here <LibraryClasses> NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf NULL|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE } AuthManager provides authentication for DFCI . DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf Processes ingoing and outgoing DFCI settings requests DfciPkg/DfciManager/DfciManager.inf Manages windows and fonts to be drawn by the rendering engine MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf Produces EfiGraphicsOutputProtocol to draw graphics to the screen MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one. MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf Driver for On Screen Keyboard. MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf Installs protocol to share the UI theme. MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf Produces gEdkiiFormDisplayEngineProtocolGuid protocol. Handles input, displays strings MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf Enables the Shell ShellPkg/Application/Shell/Shell.inf { <LibraryClasses> NULL|ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf NULL|ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf NULL|ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf NULL|ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf NULL|ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf NULL|ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf NULL|ShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf <PcdsFixedAtBuild> gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE }","title":"Components"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/","text":"FDF Include File in Detail \u00b6 This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage. Preliminaries \u00b6 What is an FDF File \u00b6 The .fdf filetype is an EDK2 Platform Description file format. The FDF file is used to describe the content and layout of binary images. It is used in conjunction with an EDK2 DSC file to generate bootable images, option ROM images, and update capsules for bootable images that comply with the UEFI specifications. To learn more about FDF files, look at the specification on the tianocore-docs github. What is an INF File \u00b6 The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github. How do I Include an FDF File \u00b6 This file will be included in the DSC file for the platform being built. The syntax for including a file is: !include path/to/fdf/inc/file What is DFCI \u00b6 From the feature document : The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu. FDF Breakdown \u00b6 This first line is a comment simply alerting the dev to include this file at some point under the [FV.FvMain] section of the platform FDF file. # Continuation of [FV.FvMain] Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one. INF MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf AuthManager provides authentication for DFCI . INF DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf The main component of DFCI which manages and enforces all DFCI settings INF DfciPkg/SettingsManager/SettingsManagerDxe.inf Installs protocol to share the UI theme. INF MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf Produces EfiGraphicsOutputProtocol to draw graphics to the screen INF MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf Produces gEdkiiFormDisplayEngineProtocolGuid protocol which handles input and displays strings INF MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf Application that presents & manages the Boot Menu Setup on Front Page. INF OemPkg/BootMenu/BootMenu.inf Application that presents and manages FrontPage. INF OemPkg/FrontPage/FrontPage.inf Enables MsBootPolicy which implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). INF PcBdsPkg/MsBootPolicy/MsBootPolicy.inf A module which produces Boot Manager Policy protocol. INF MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf A regular expression library to support Remote/IT/Admin Settings such as DFCI . INF MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf Processes ingoing and outgoing DFCI settings requests INF DfciPkg/DfciManager/DfciManager.inf Driver for On Screen Keyboard. INF MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf Spoofs button press to automatically boot to FrontPage. INF OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf Manages windows and fonts to be drawn by the rendering engine INF MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf This final bit places the bmp files and shell.efi file within this firmware volume so they can be accessed by UEFI drivers. FILE APPLICATION = PCD ( gPcBdsPkgTokenSpaceGuid.PcdShellFile ) { SECTION PE32 = $( OUTPUT_DIRECTORY ) / $( TARGET ) _ $( TOOL_CHAIN_TAG ) /AARCH64/Shell.efi SECTION UI = \"EdkShell\" } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdLogoFile ) { SECTION RAW = OemPkg/FrontPage/Resources/BootLogo.bmp SECTION UI = \"Logo\" } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdFrontPageLogoFile ) { SECTION RAW = OemPkg/FrontPage/Resources/FrontpageLogo.bmp } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdLowBatteryFile ) { SECTION RAW = OemPkg/FrontPage/Resources/LBAT.bmp } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdThermalFile ) { SECTION RAW = OemPkg/FrontPage/Resources/THOT.bmp }","title":"Frontpage FDF Include"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#fdf-include-file-in-detail","text":"This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage.","title":"FDF Include File in Detail"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#preliminaries","text":"","title":"Preliminaries"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-an-fdf-file","text":"The .fdf filetype is an EDK2 Platform Description file format. The FDF file is used to describe the content and layout of binary images. It is used in conjunction with an EDK2 DSC file to generate bootable images, option ROM images, and update capsules for bootable images that comply with the UEFI specifications. To learn more about FDF files, look at the specification on the tianocore-docs github.","title":"What is an FDF File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-an-inf-file","text":"The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github.","title":"What is an INF File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#how-do-i-include-an-fdf-file","text":"This file will be included in the DSC file for the platform being built. The syntax for including a file is: !include path/to/fdf/inc/file","title":"How do I Include an FDF File"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-dfci","text":"From the feature document : The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu.","title":"What is DFCI"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#fdf-breakdown","text":"This first line is a comment simply alerting the dev to include this file at some point under the [FV.FvMain] section of the platform FDF file. # Continuation of [FV.FvMain] Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one. INF MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf AuthManager provides authentication for DFCI . INF DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf The main component of DFCI which manages and enforces all DFCI settings INF DfciPkg/SettingsManager/SettingsManagerDxe.inf Installs protocol to share the UI theme. INF MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf Produces EfiGraphicsOutputProtocol to draw graphics to the screen INF MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf Produces gEdkiiFormDisplayEngineProtocolGuid protocol which handles input and displays strings INF MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf Application that presents & manages the Boot Menu Setup on Front Page. INF OemPkg/BootMenu/BootMenu.inf Application that presents and manages FrontPage. INF OemPkg/FrontPage/FrontPage.inf Enables MsBootPolicy which implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB). INF PcBdsPkg/MsBootPolicy/MsBootPolicy.inf A module which produces Boot Manager Policy protocol. INF MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf A regular expression library to support Remote/IT/Admin Settings such as DFCI . INF MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf Processes ingoing and outgoing DFCI settings requests INF DfciPkg/DfciManager/DfciManager.inf Driver for On Screen Keyboard. INF MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf Spoofs button press to automatically boot to FrontPage. INF OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf Manages windows and fonts to be drawn by the rendering engine INF MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf This final bit places the bmp files and shell.efi file within this firmware volume so they can be accessed by UEFI drivers. FILE APPLICATION = PCD ( gPcBdsPkgTokenSpaceGuid.PcdShellFile ) { SECTION PE32 = $( OUTPUT_DIRECTORY ) / $( TARGET ) _ $( TOOL_CHAIN_TAG ) /AARCH64/Shell.efi SECTION UI = \"EdkShell\" } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdLogoFile ) { SECTION RAW = OemPkg/FrontPage/Resources/BootLogo.bmp SECTION UI = \"Logo\" } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdFrontPageLogoFile ) { SECTION RAW = OemPkg/FrontPage/Resources/FrontpageLogo.bmp } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdLowBatteryFile ) { SECTION RAW = OemPkg/FrontPage/Resources/LBAT.bmp } FILE FREEFORM = PCD ( gOemPkgTokenSpaceGuid.PcdThermalFile ) { SECTION RAW = OemPkg/FrontPage/Resources/THOT.bmp }","title":"FDF Breakdown"},{"location":"dyn/mu_plus/RepoDetails/","text":"Project Mu Common Plus \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_plus.git Branch: release/202202 Commit: 8074202a82d05bb28385fe5c6052b37a965819f4 Commit Date: 2022-11-08 06:21:20 -0800 This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. For full documentation. More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Repo Details"},{"location":"dyn/mu_plus/RepoDetails/#project-mu-common-plus","text":"Git Details Repository Url: https://github.com/Microsoft/mu_plus.git Branch: release/202202 Commit: 8074202a82d05bb28385fe5c6052b37a965819f4 Commit Date: 2022-11-08 06:21:20 -0800 This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. For full documentation.","title":"Project Mu Common Plus"},{"location":"dyn/mu_plus/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_plus/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_plus/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_plus/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_plus/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_plus/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"pull request template"},{"location":"dyn/mu_plus/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken?","title":"Description"},{"location":"dyn/mu_plus/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_plus/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/","text":"Advanced File Logger \u00b6 About \u00b6 The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services. An eligible file system is one with a Logs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem. To enable the Advanced File Logger, the following change is needed in the .dsc: [Components.<ArchOfDXE>] AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Advanced File Logger"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/#advanced-file-logger","text":"","title":"Advanced File Logger"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/#about","text":"The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services. An eligible file system is one with a Logs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem. To enable the Advanced File Logger, the following change is needed in the .dsc: [Components.<ArchOfDXE>] AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf","title":"About"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/","text":"Advanced Serial Logger \u00b6 About \u00b6 The Advanced Serial Logger starts, the memory log is flushed to the serial port. As more log is appended, the serial logger flushes it out to the serial port. To enable the Advanced Serial Logger, the following change is needed in the .dsc: [Components.<ArchOfDXE>] AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Advanced Serial Logger"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/#advanced-serial-logger","text":"","title":"Advanced Serial Logger"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/#about","text":"The Advanced Serial Logger starts, the memory log is flushed to the serial port. As more log is appended, the serial logger flushes it out to the serial port. To enable the Advanced Serial Logger, the following change is needed in the .dsc: [Components.<ArchOfDXE>] AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf","title":"About"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/","text":"AdvLoggerPkg - DecodeUefiLog \u00b6 DecodeUefiLog is used to get the Uefi debug log that is stored by UEFI in system memory. About \u00b6 Advanced Logger stores the debug log file in memory, with additional data for each line. At runtime, if the Advanced Logger is enabled, this in memory log is available through the UEFI Variable store. As the log in memory has additional metadata and alignment structure, DecodeUefiLog parses the on memory UefiLog to a text stream and writes the decoded log to a local file. Usage \u00b6 Copy the two files, DecideUefiLog.py and UefiVariablesSupportLib.py, to the system that has the Advanced Logger enabled. The simplest case: DecodeUefiLog -o NewLogFile.txt Decode lines after a starting line number and send them to the file specified by -o: DecodeUefiLog -s 5000 -o NewLogFile.txt Copy the raw in memory log to a binary file. DecodeUfieLog -r RawLog.bin Decode a raw file into a text file: DecodeUefiLog -l RawLog.bin -o NewLogFIle.txt Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Decode Uefi Log"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#advloggerpkg-decodeuefilog","text":"DecodeUefiLog is used to get the Uefi debug log that is stored by UEFI in system memory.","title":"AdvLoggerPkg - DecodeUefiLog"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#about","text":"Advanced Logger stores the debug log file in memory, with additional data for each line. At runtime, if the Advanced Logger is enabled, this in memory log is available through the UEFI Variable store. As the log in memory has additional metadata and alignment structure, DecodeUefiLog parses the on memory UefiLog to a text stream and writes the decoded log to a local file.","title":"About"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#usage","text":"Copy the two files, DecideUefiLog.py and UefiVariablesSupportLib.py, to the system that has the Advanced Logger enabled. The simplest case: DecodeUefiLog -o NewLogFile.txt Decode lines after a starting line number and send them to the file specified by -o: DecodeUefiLog -s 5000 -o NewLogFile.txt Copy the raw in memory log to a binary file. DecodeUfieLog -r RawLog.bin Decode a raw file into a text file: DecodeUefiLog -l RawLog.bin -o NewLogFIle.txt","title":"Usage"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/","text":"AdvLoggerPkg - Advanced Logger Package \u00b6 About \u00b6 The AdvancedLogger logs all debug messages into memory. At certain points, the log may be flushed to disk. The in memory log data is also available during runtime. Configuration \u00b6 The following configurations are supported: Phase Usage DXE Only Uses DxeCore, DxeRuntime, and Dxe AdvancedLoggerLib libraries for logging from start of DXE CORE through Exit Boot Services. Accepts the PEI Advanced Logger Hob if one is generated. Produces the AdvancedLogger protocol. DXE+SMM Requires DXE modules above, and adds the Smm AdvancedLoggerLib library. Collects SMM generated messages in the in memory log. PEI Uses PeiCore and Pei AdvancedLoggerLib libraries. Creates the Advanced Logger Hob if PcdAdvancedLoggerPeiInRAM is set. SEC Uses the Sec Advanced Logger Library. SEC requires a fixed load address, so it piggy backs on the Temporary RAM PCD information. Produces a Fixed Address temporary RAM log. When memory is added, the Sec Advanced Logger library converts the Temporary RAM logging information to the PEI Advanced Logger Hob. PEI64 Uses Pei64 Advanced Logger Library. Requires the SEC fixed address temporary log information in order to log Pei64 bit DEBUG messages. MM Standalone MM - Loads during PEI phase. MMARM Standalone MM that loads prior to UEFI with a fixed memory block shared with UEFI. PCD's used by Advanced Logger PCD Function of the PCD PcdAdvancedLoggerForceEnable The default operation is to check if a Logs directory is present in the root of the filesystem. If the UefiLogs directory is present, logging is enabled. When PcdAdvancedLoggerForceEnable is TRUE, and the device is not a USB device, a UefiLogs directory will be created and logging is enabled. When logging is enabled, the proper log files will be created if not already preset. PcdAdvancedLoggerPeiInRAM For systems that have memory at PeiCore entry. The full in memory log buffer if PcdAdvancedLoggerPages is allocated in the Pei Core constructor and PcdAdvancedLoggerPreMemPages is ignored. PcdAdvancedLoggerFixedInRAM For systems that have a fixed memory buffer prior to UEFI. The full in memory log buffer is assumed. PcdAdvancedHdwLoggerDebugPrintErrorLevel The standard debug flags filter which log messages are produced. This PCD allow a subset of log messages to be forwarded to the Hdw Port Lib. PcdAdvancedHdwLoggerDisable Specifies when to disable writing to the Hdw Port. PcdAdvancedLoggerPreMemPages Amount of temporary RAM used for the debug log. PcdAdvancedLoggerPages Amount of system RAM used for the debug log PcdAdvancedLoggerLocator When enabled, the AdvLogger creates a variable \"AdvLoggerLocator\" with the address of the LoggerInfo buffer Libraries \u00b6 The following libraries are used with AdvancedLogger: Library Function of the Library AdvancedLoggerAccessLib Used to access the memory log - used by FileLogger and Serial/Dxe/Logger AdvancedLoggerLib One per module type - used to provide access to the in memory log buffer AdvLoggerSmmAccessLib Used to intercept GetVariable in order to provide an OS utility the ability to read the log BaseDebugLibAdvancedLogger Basic Dxe etc DebugLib DebugAgent Used to intercept SEC initialization PeiDebugLibAdvancedLogger Basic Pei DebugLib AdvancedLoggerHdwPortLib Hook for a hardware port to capture debug messages as they are written to the log. Platform notes \u00b6 IA32/X64 \u00b6 The SEC version of the Advanced Logger uses the temporary RAM block. This block is fixed in size and location, and this temporary RAM block needs to be adjusted to make room for the Advanced Logger buffer. There may be cases where the processor cache size is too small to enable the Advanced Logger during SEC. The PEI versions of Advanced Logger work together to save space. Rather than have the Debug Print libraries linked in all the PEIM's, only PEI_CORE has the Debug Print libraries. The PEI version of AdvancedLoggerLib uses the IDT to access a pointer to the PEI_CORE routines. The following changes are needed in the .dsc for IA32/X64. [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf [LibraryClasses.IA32.SEC] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Sec/AdvancedLoggerLib.inf DebugAgentLib|AdvLoggerPkg/Library/DebugAgent/Sec/AdvancedLoggerSecDebugAgent.inf [LibraryClasses.IA32.PEI_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf [LibraryClasses.IA32.PEIM] DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf [LibraryClasses.X64.PEIM] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei64/AdvancedLoggerLib.inf [LibraryClasses.X64] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf [LibraryClasses.X64.DXE_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf [LibraryClasses.X64.DXE_SMM_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf [LibraryClasses.X64.SMM_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf [LibraryClasses.X64.DXE_RUNTIME_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf [PcdsFeatureFlag] ## Build Example if your build environment differentiates customer builds from internal test builds !if $(SHIP_MODE) == FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE !else gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE !endif The following changes should be in the family .dsc where the processor specific changes are specified [PcdsFixedAtBuild.common] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages|24 #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFA000000 # Must be TemporaryRamBase gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerCarBase | 0xFA200000 # Address for CAR memory gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages | 256 # Size is 1MB gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 1024 # Size is 4MB ARM with Security Processor \u00b6 UEFI \u00b6 In this configuration, the Advanced Logger memory buffer is preallocated and setup from the BL31 (secure partition loader) at a known address. This simplifies SEC and PEI as memory has already been configured. Due to the memory block being at a known address, the SEC, PEI_CORE, and PEI modules link to the BaseArm version of AdvancedLoggerLib. While the BaseArm version includes the Debug Print libraries, it is assumed that there are few PEI components in the ARM with Security Processor configuration. ################################################################ # # Advanced Logger Configurations # ################################################################ [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf [LibraryClasses.common.SEC] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf [LibraryClasses.common.PEI_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf [LibraryClasses.common.PEIM] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei/AdvancedLoggerLib.inf DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf [LibraryClasses.common.DXE_DRIVER, LibraryClasses.common.UEFI_DRIVER, LibraryClasses.common.UEFI_APPLICATION] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf [LibraryClasses.common.DXE_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf [LibraryClasses.common.DXE_RUNTIME_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf [PcdsFeatureFlag] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02). gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03 The following changes should be in the family .dsc where the processor specific changes are specified [PcdsFixedAtBuild.common] #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFF622000 # Buffer address gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 0x400 # Size is 4MB MM Standalone Arm with security processor \u00b6 In this configuration, the MM code needs to initialize the common buffer that was allocated from the BL31 (secure partition loader) in order to provide log messages prior to UEFI starting. [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf [LibraryClasses.common.MM_CORE_STANDALONE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/MmCoreArm/AdvancedLoggerLib.inf [LibraryClasses.common.MM_STANDALONE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf AdvLoggerAccessLib|AdvLoggerPkg/Library/AdvLoggerMmAccessLib/AdvLoggerMmAccessLib.inf [PcdsFeatureFlag] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02). gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03 [PcdsFixedAtBuild.common] #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFF622000 # Buffer address gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 0x400 # Size is 4MB Advanced File Logger \u00b6 The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services. An eligible file system is one with a UefiLogs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem. To enable the Advanced File Logger, the following change is needed in the .dsc: [Components.<YourFvDXE>] AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf Hardware Logging Level \u00b6 The v3 data header supports a new field of hardware debugging level to support setting the serial print configurable during boot time. The default value will be initialized to the value of PcdAdvancedLoggerHdwPortDebugPrintErrorLevel in the PEI core, DXE core, or MM core, whichever comes first during the boot process. To override the initialized hardware print level, user needs to first get the advanced logger info region, this could be done, depending on the boot phase of consumer, through the PcdAdvancedLoggerBase in SEC phase and/or if PcdAdvancedLoggerFixedInRAM is set, or gAdvancedLoggerHobGuid HOB if setup in PEI phase. Note: This change will require all the firmware entities to update to v3 of advanced logger together. Torn state will result in hardware printing not functional. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Package Overview"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#advloggerpkg-advanced-logger-package","text":"","title":"AdvLoggerPkg - Advanced Logger Package"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#about","text":"The AdvancedLogger logs all debug messages into memory. At certain points, the log may be flushed to disk. The in memory log data is also available during runtime.","title":"About"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#configuration","text":"The following configurations are supported: Phase Usage DXE Only Uses DxeCore, DxeRuntime, and Dxe AdvancedLoggerLib libraries for logging from start of DXE CORE through Exit Boot Services. Accepts the PEI Advanced Logger Hob if one is generated. Produces the AdvancedLogger protocol. DXE+SMM Requires DXE modules above, and adds the Smm AdvancedLoggerLib library. Collects SMM generated messages in the in memory log. PEI Uses PeiCore and Pei AdvancedLoggerLib libraries. Creates the Advanced Logger Hob if PcdAdvancedLoggerPeiInRAM is set. SEC Uses the Sec Advanced Logger Library. SEC requires a fixed load address, so it piggy backs on the Temporary RAM PCD information. Produces a Fixed Address temporary RAM log. When memory is added, the Sec Advanced Logger library converts the Temporary RAM logging information to the PEI Advanced Logger Hob. PEI64 Uses Pei64 Advanced Logger Library. Requires the SEC fixed address temporary log information in order to log Pei64 bit DEBUG messages. MM Standalone MM - Loads during PEI phase. MMARM Standalone MM that loads prior to UEFI with a fixed memory block shared with UEFI. PCD's used by Advanced Logger PCD Function of the PCD PcdAdvancedLoggerForceEnable The default operation is to check if a Logs directory is present in the root of the filesystem. If the UefiLogs directory is present, logging is enabled. When PcdAdvancedLoggerForceEnable is TRUE, and the device is not a USB device, a UefiLogs directory will be created and logging is enabled. When logging is enabled, the proper log files will be created if not already preset. PcdAdvancedLoggerPeiInRAM For systems that have memory at PeiCore entry. The full in memory log buffer if PcdAdvancedLoggerPages is allocated in the Pei Core constructor and PcdAdvancedLoggerPreMemPages is ignored. PcdAdvancedLoggerFixedInRAM For systems that have a fixed memory buffer prior to UEFI. The full in memory log buffer is assumed. PcdAdvancedHdwLoggerDebugPrintErrorLevel The standard debug flags filter which log messages are produced. This PCD allow a subset of log messages to be forwarded to the Hdw Port Lib. PcdAdvancedHdwLoggerDisable Specifies when to disable writing to the Hdw Port. PcdAdvancedLoggerPreMemPages Amount of temporary RAM used for the debug log. PcdAdvancedLoggerPages Amount of system RAM used for the debug log PcdAdvancedLoggerLocator When enabled, the AdvLogger creates a variable \"AdvLoggerLocator\" with the address of the LoggerInfo buffer","title":"Configuration"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#libraries","text":"The following libraries are used with AdvancedLogger: Library Function of the Library AdvancedLoggerAccessLib Used to access the memory log - used by FileLogger and Serial/Dxe/Logger AdvancedLoggerLib One per module type - used to provide access to the in memory log buffer AdvLoggerSmmAccessLib Used to intercept GetVariable in order to provide an OS utility the ability to read the log BaseDebugLibAdvancedLogger Basic Dxe etc DebugLib DebugAgent Used to intercept SEC initialization PeiDebugLibAdvancedLogger Basic Pei DebugLib AdvancedLoggerHdwPortLib Hook for a hardware port to capture debug messages as they are written to the log.","title":"Libraries"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#platform-notes","text":"","title":"Platform notes"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#ia32x64","text":"The SEC version of the Advanced Logger uses the temporary RAM block. This block is fixed in size and location, and this temporary RAM block needs to be adjusted to make room for the Advanced Logger buffer. There may be cases where the processor cache size is too small to enable the Advanced Logger during SEC. The PEI versions of Advanced Logger work together to save space. Rather than have the Debug Print libraries linked in all the PEIM's, only PEI_CORE has the Debug Print libraries. The PEI version of AdvancedLoggerLib uses the IDT to access a pointer to the PEI_CORE routines. The following changes are needed in the .dsc for IA32/X64. [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf [LibraryClasses.IA32.SEC] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Sec/AdvancedLoggerLib.inf DebugAgentLib|AdvLoggerPkg/Library/DebugAgent/Sec/AdvancedLoggerSecDebugAgent.inf [LibraryClasses.IA32.PEI_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf [LibraryClasses.IA32.PEIM] DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf [LibraryClasses.X64.PEIM] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei64/AdvancedLoggerLib.inf [LibraryClasses.X64] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf [LibraryClasses.X64.DXE_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf [LibraryClasses.X64.DXE_SMM_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf [LibraryClasses.X64.SMM_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf [LibraryClasses.X64.DXE_RUNTIME_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf [PcdsFeatureFlag] ## Build Example if your build environment differentiates customer builds from internal test builds !if $(SHIP_MODE) == FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE !else gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE !endif The following changes should be in the family .dsc where the processor specific changes are specified [PcdsFixedAtBuild.common] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages|24 #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFA000000 # Must be TemporaryRamBase gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerCarBase | 0xFA200000 # Address for CAR memory gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages | 256 # Size is 1MB gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 1024 # Size is 4MB","title":"IA32/X64"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#arm-with-security-processor","text":"","title":"ARM with Security Processor"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#uefi","text":"In this configuration, the Advanced Logger memory buffer is preallocated and setup from the BL31 (secure partition loader) at a known address. This simplifies SEC and PEI as memory has already been configured. Due to the memory block being at a known address, the SEC, PEI_CORE, and PEI modules link to the BaseArm version of AdvancedLoggerLib. While the BaseArm version includes the Debug Print libraries, it is assumed that there are few PEI components in the ARM with Security Processor configuration. ################################################################ # # Advanced Logger Configurations # ################################################################ [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf [LibraryClasses.common.SEC] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf [LibraryClasses.common.PEI_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf [LibraryClasses.common.PEIM] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei/AdvancedLoggerLib.inf DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf [LibraryClasses.common.DXE_DRIVER, LibraryClasses.common.UEFI_DRIVER, LibraryClasses.common.UEFI_APPLICATION] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf [LibraryClasses.common.DXE_CORE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf [LibraryClasses.common.DXE_RUNTIME_DRIVER] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf [PcdsFeatureFlag] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02). gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03 The following changes should be in the family .dsc where the processor specific changes are specified [PcdsFixedAtBuild.common] #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFF622000 # Buffer address gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 0x400 # Size is 4MB","title":"UEFI"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#mm-standalone-arm-with-security-processor","text":"In this configuration, the MM code needs to initialize the common buffer that was allocated from the BL31 (secure partition loader) in order to provide log messages prior to UEFI starting. [LibraryClasses.common] DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf [LibraryClasses.common.MM_CORE_STANDALONE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/MmCoreArm/AdvancedLoggerLib.inf [LibraryClasses.common.MM_STANDALONE] AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf AdvLoggerAccessLib|AdvLoggerPkg/Library/AdvLoggerMmAccessLib/AdvLoggerMmAccessLib.inf [PcdsFeatureFlag] gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02). gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03 [PcdsFixedAtBuild.common] #Advanced Logger configuration gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase | 0xFF622000 # Buffer address gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages | 0x400 # Size is 4MB","title":"MM Standalone Arm with security processor"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#advanced-file-logger","text":"The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services. An eligible file system is one with a UefiLogs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem. To enable the Advanced File Logger, the following change is needed in the .dsc: [Components.<YourFvDXE>] AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf and the follow change is needed in the .fdf: [Components.FV.<YourFvDXE>] INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf","title":"Advanced File Logger"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#hardware-logging-level","text":"The v3 data header supports a new field of hardware debugging level to support setting the serial print configurable during boot time. The default value will be initialized to the value of PcdAdvancedLoggerHdwPortDebugPrintErrorLevel in the PEI core, DXE core, or MM core, whichever comes first during the boot process. To override the initialized hardware print level, user needs to first get the advanced logger info region, this could be done, depending on the boot phase of consumer, through the PcdAdvancedLoggerBase in SEC phase and/or if PcdAdvancedLoggerFixedInRAM is set, or gAdvancedLoggerHobGuid HOB if setup in PEI phase. Note: This change will require all the firmware entities to update to v3 of advanced logger together. Torn state will result in hardware printing not functional.","title":"Hardware Logging Level"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/","text":"Verify Line Parser function for development \u00b6 This test is to model the Line Parser in the AdvancedFileLogger. The internal message log is in units of DEBUG(()). While most messages are a complete and end with a '\\n', there are some debug messages that are built with multiple DEBUG(()) operations. The line parser builds a debug line by copying one or more DEBUG(()) segments into a line, and prepends the time stamp. About \u00b6 These tests verify that the LineParser is functional. LineParserTestApp \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Line Parser"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#verify-line-parser-function-for-development","text":"This test is to model the Line Parser in the AdvancedFileLogger. The internal message log is in units of DEBUG(()). While most messages are a complete and end with a '\\n', there are some debug messages that are built with multiple DEBUG(()) operations. The line parser builds a debug line by copying one or more DEBUG(()) segments into a line, and prepends the time stamp.","title":"Verify Line Parser function for development"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#about","text":"These tests verify that the LineParser is functional.","title":"About"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#lineparsertestapp","text":"","title":"LineParserTestApp"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Application/DfciMenu/ReadMe/","text":"DFCI Stand Alone Recovery shell application \u00b6 Overview \u00b6 DFCI Stand Alone Recovery is the same code as the menu item Refresh From Network, and is used to execute the Refresh From Network operation with DEBUG prints routed to the console. Building the DfciSARecovery module \u00b6 To get the debug lib output to the console, build DfciSARecovery with the UefiDebugLibConOut library, add the following to your platform build .dsc file: DfciPkg/Application/DfciMenu/DfciSARecovery.inf { <LibraryClasses> DebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf } Running the DfciSARecovery application \u00b6 In order to run the DfciSARecovery application, the system must be able to boot to the Shell. Insure that any device settings that disable booting from USB are set to enable booting from USB. In addition, the InTune setting Dfci.BootExternalMedia.Enable must be enabled. Prepare a USB drive that will boot to the UEFI Shell. It is beyond the scope of this document to describe how to build the shell itself, or how to create a USB drive that boots to the shell. For information on the UEFI shell, visit: https://github.com/tianocore/tianocore.github.io/wiki/ShellPkg Copy the DfciSARecovery.efi application to the USB Drive. Using your platform mechanism, boot to the USB drive just created. At the Shell> prompt, log into the USB drive and run DfciSARecovery. For example: fs0: DfciSARecovery >a RefreshLog.txt","title":"Dfci Menu"},{"location":"dyn/mu_plus/DfciPkg/Application/DfciMenu/ReadMe/#dfci-stand-alone-recovery-shell-application","text":"","title":"DFCI Stand Alone Recovery shell application"},{"location":"dyn/mu_plus/DfciPkg/Application/DfciMenu/ReadMe/#overview","text":"DFCI Stand Alone Recovery is the same code as the menu item Refresh From Network, and is used to execute the Refresh From Network operation with DEBUG prints routed to the console.","title":"Overview"},{"location":"dyn/mu_plus/DfciPkg/Application/DfciMenu/ReadMe/#building-the-dfcisarecovery-module","text":"To get the debug lib output to the console, build DfciSARecovery with the UefiDebugLibConOut library, add the following to your platform build .dsc file: DfciPkg/Application/DfciMenu/DfciSARecovery.inf { <LibraryClasses> DebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf }","title":"Building the DfciSARecovery module"},{"location":"dyn/mu_plus/DfciPkg/Application/DfciMenu/ReadMe/#running-the-dfcisarecovery-application","text":"In order to run the DfciSARecovery application, the system must be able to boot to the Shell. Insure that any device settings that disable booting from USB are set to enable booting from USB. In addition, the InTune setting Dfci.BootExternalMedia.Enable must be enabled. Prepare a USB drive that will boot to the UEFI Shell. It is beyond the scope of this document to describe how to build the shell itself, or how to create a USB drive that boots to the shell. For information on the UEFI shell, visit: https://github.com/tianocore/tianocore.github.io/wiki/ShellPkg Copy the DfciSARecovery.efi application to the USB Drive. Using your platform mechanism, boot to the USB drive just created. At the Shell> prompt, log into the USB drive and run DfciSARecovery. For example: fs0: DfciSARecovery >a RefreshLog.txt","title":"Running the DfciSARecovery application"},{"location":"dyn/mu_plus/DfciPkg/AuthManagerNull/","text":"AuthManagerNull \u00b6 Purposes \u00b6 Do not use in production! FrontPage during device bringup \u00b6 This driver can be a stand in for IdentityAndAuthManager, which requires RngLib, to allow FrontPage development if RngLib is not yet functional. Unit Testing \u00b6 With further development, this \"Null\" driver could be an effective stub for IdentityAndAuthManager, allowing detailed unit testing of DFCI.","title":"Auth Manager Null"},{"location":"dyn/mu_plus/DfciPkg/AuthManagerNull/#authmanagernull","text":"","title":"AuthManagerNull"},{"location":"dyn/mu_plus/DfciPkg/AuthManagerNull/#purposes","text":"Do not use in production!","title":"Purposes"},{"location":"dyn/mu_plus/DfciPkg/AuthManagerNull/#frontpage-during-device-bringup","text":"This driver can be a stand in for IdentityAndAuthManager, which requires RngLib, to allow FrontPage development if RngLib is not yet functional.","title":"FrontPage during device bringup"},{"location":"dyn/mu_plus/DfciPkg/AuthManagerNull/#unit-testing","text":"With further development, this \"Null\" driver could be an effective stub for IdentityAndAuthManager, allowing detailed unit testing of DFCI.","title":"Unit Testing"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/","text":"Device Firmware Configuration Interface (DFCI) Introduction \u00b6 Overview \u00b6 The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu by a human. High value configuration can be moved to UEFI BIOS where it is resilient against malware, rootkits, and non-persistent physical tampering. Whereas traditional UEFI security implementations required a physical touch, DFCI securely enables zero-touch remote configuration of these settings built upon Microsoft Intune and authorized by Windows Autopilot . DFCI can provide additional assurance by configuring and locking hardware security features before launching the OS (e.g. disabling microphones or radios). Note that for management of servers in a datacenter, DFCI does not presume to be the solution. Redfish may be a more suitable solution for the datacenter. Why Zero Touch \u00b6 Traditional UEFI management solutions were either not secure, allowing malware to control them, or not scalable, requiring a physical touch by IT or OEM for authentication. DFCI is zero touch, leveraging the existing Windows Autopilot device registration for DFCI authorization. Why should I configure my UEFI BIOS \u00b6 PC configuration is typically performed via Active Directory Group Policy, System Center Configuration Manager (SCCM), or Modern Device Management (MDM) such as Microsoft Intune . All of these solutions store their managed configuration in the OS disk partition. Unfortunately, this configuration can be bypassed by the PCs default ability to boot other operating system instances via external media (e.g. USB), network (e.g. PXE), & alternate disk partitions, or by simply re-installing the OS. Device Firmware Configuration Interface (DFCI) places high value configuration settings into PCs UEFI BIOS. UEFI DFCI storage is both visible to all OS instances, persistent, surviving OS reinstalls and disk reformats, and tamper-resistant, defending itself from malware and rootkits. UEFI executes before the OS and can disallow booting of specified devices, for example USB or network PXE. Further, DFCI can leverage hardware security to enforce some policies with higher assurance than typical OS configuration. For example, it could disable power to cameras or radios in a way that they could not be re-enabled by an OS, malware, or rootkit. Popular Usages \u00b6 Disabling cameras, microphones, and/or radios in manufacturing and other secure facilities Disabling boot to USB and network for single purpose and KIOSK devices Disabling local user access to all UEFI settings to maintain the out of box configuration OEM Enablement Summary \u00b6 DFCI enablement is comprised of: UEFI BIOS implementation Windows Autopilot participation If an OEM or its Partners already participate in the Windows Autopilot program, no additional Autopilot work is required, the only remaining work should be the UEFI BIOS implementation. Windows Autopilot Implementation \u00b6 The pre-existing Windows Autopilot device registration workflows remain unchanged for DFCI, no additional work is required. It should be noted that Autopilot self-registrations are not trusted for the purpose of DFCI management (e.g. from Intune, Microsoft Store for Business, & Business 365). UEFI BIOS Implementation \u00b6 DFCI enablement in UEFI BIOS requires implementation of DFCI interfaces and semantics, and inclusion of a public Microsoft certificate. There is precisely one (1) Microsoft zero-touch certificate that is shared by all DFCI-enabled systems to authenticate zero-touch provisioning requests. Thus there is no requirement to inject the certificate at manufacturing, it may simply be included in the UEFI BIOS image. The DFCI source code and public certificate are available on GitHub under a permissive open source license (SPDX-License-Identifier: BSD-2-Clause-Patent). https://github.com/microsoft/mu_plus/tree/dev/201908/DfciPkg https://github.com/microsoft/mu_plus/tree/dev/201908/ZeroTouchPkg There is also an example UEFI BIOS menu that demonstrates how to integrate DFCI: https://github.com/microsoft/mu_oem_sample/search?q=dfci&unscoped_q=dfci Unsigned Settings \u00b6 Some platforms may choose to implement less secure deployment methods for certain settings. DFCI allows a platform to supply either an allow list, or a disallow list, of a set of settings that may be deployed using unsigned packets. Unsigned settings may only be deployed when no DFCI Owner has been enrolled in the system unless that DFCI owner has specifically allowed certain settings to be set by unsigned packets. See the section on platform integRation for more information. UEFI Implementation Details \u00b6 Scenarios: Building the Microsoft Scenarios with DFCI Integration: Integrating DFCI code into your platforms Architecture: DFCI Code Internals Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dfci Feature"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#device-firmware-configuration-interface-dfci-introduction","text":"","title":"Device Firmware Configuration Interface (DFCI) Introduction"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#overview","text":"The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu by a human. High value configuration can be moved to UEFI BIOS where it is resilient against malware, rootkits, and non-persistent physical tampering. Whereas traditional UEFI security implementations required a physical touch, DFCI securely enables zero-touch remote configuration of these settings built upon Microsoft Intune and authorized by Windows Autopilot . DFCI can provide additional assurance by configuring and locking hardware security features before launching the OS (e.g. disabling microphones or radios). Note that for management of servers in a datacenter, DFCI does not presume to be the solution. Redfish may be a more suitable solution for the datacenter.","title":"Overview"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#why-zero-touch","text":"Traditional UEFI management solutions were either not secure, allowing malware to control them, or not scalable, requiring a physical touch by IT or OEM for authentication. DFCI is zero touch, leveraging the existing Windows Autopilot device registration for DFCI authorization.","title":"Why Zero Touch"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#why-should-i-configure-my-uefi-bios","text":"PC configuration is typically performed via Active Directory Group Policy, System Center Configuration Manager (SCCM), or Modern Device Management (MDM) such as Microsoft Intune . All of these solutions store their managed configuration in the OS disk partition. Unfortunately, this configuration can be bypassed by the PCs default ability to boot other operating system instances via external media (e.g. USB), network (e.g. PXE), & alternate disk partitions, or by simply re-installing the OS. Device Firmware Configuration Interface (DFCI) places high value configuration settings into PCs UEFI BIOS. UEFI DFCI storage is both visible to all OS instances, persistent, surviving OS reinstalls and disk reformats, and tamper-resistant, defending itself from malware and rootkits. UEFI executes before the OS and can disallow booting of specified devices, for example USB or network PXE. Further, DFCI can leverage hardware security to enforce some policies with higher assurance than typical OS configuration. For example, it could disable power to cameras or radios in a way that they could not be re-enabled by an OS, malware, or rootkit.","title":"Why should I configure my UEFI BIOS"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#popular-usages","text":"Disabling cameras, microphones, and/or radios in manufacturing and other secure facilities Disabling boot to USB and network for single purpose and KIOSK devices Disabling local user access to all UEFI settings to maintain the out of box configuration","title":"Popular Usages"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#oem-enablement-summary","text":"DFCI enablement is comprised of: UEFI BIOS implementation Windows Autopilot participation If an OEM or its Partners already participate in the Windows Autopilot program, no additional Autopilot work is required, the only remaining work should be the UEFI BIOS implementation.","title":"OEM Enablement Summary"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#windows-autopilot-implementation","text":"The pre-existing Windows Autopilot device registration workflows remain unchanged for DFCI, no additional work is required. It should be noted that Autopilot self-registrations are not trusted for the purpose of DFCI management (e.g. from Intune, Microsoft Store for Business, & Business 365).","title":"Windows Autopilot Implementation"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#uefi-bios-implementation","text":"DFCI enablement in UEFI BIOS requires implementation of DFCI interfaces and semantics, and inclusion of a public Microsoft certificate. There is precisely one (1) Microsoft zero-touch certificate that is shared by all DFCI-enabled systems to authenticate zero-touch provisioning requests. Thus there is no requirement to inject the certificate at manufacturing, it may simply be included in the UEFI BIOS image. The DFCI source code and public certificate are available on GitHub under a permissive open source license (SPDX-License-Identifier: BSD-2-Clause-Patent). https://github.com/microsoft/mu_plus/tree/dev/201908/DfciPkg https://github.com/microsoft/mu_plus/tree/dev/201908/ZeroTouchPkg There is also an example UEFI BIOS menu that demonstrates how to integrate DFCI: https://github.com/microsoft/mu_oem_sample/search?q=dfci&unscoped_q=dfci","title":"UEFI BIOS Implementation"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#unsigned-settings","text":"Some platforms may choose to implement less secure deployment methods for certain settings. DFCI allows a platform to supply either an allow list, or a disallow list, of a set of settings that may be deployed using unsigned packets. Unsigned settings may only be deployed when no DFCI Owner has been enrolled in the system unless that DFCI owner has specifically allowed certain settings to be set by unsigned packets. See the section on platform integRation for more information.","title":"Unsigned Settings"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#uefi-implementation-details","text":"Scenarios: Building the Microsoft Scenarios with DFCI Integration: Integrating DFCI code into your platforms Architecture: DFCI Code Internals","title":"UEFI Implementation Details"},{"location":"dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/","text":"DFCI Internals \u00b6 This section describes the internal operations of DFCI. Communications with Provider \u00b6 DFCI communicates with a controlling identity. One of the controlling identities could be Microsoft Intune. The communications path from the controlling identity is though the use of UEFI variables. DFCI processes the mailbox variables during a system restart. Identity Manager \u00b6 In the source code, the Identity manager is implemented in IdentityAndAuthManager is defined in the DfciPkg located in the mu_plus repository https://github.com/microsoft/mu_plus/ . Identity and Auth Manager is responsible for managing the Identities. The initial state of the system has the Local User with full authentication to make changes to any of the available settings. There are seven Identities known by DFCI: Identity Owner Mask Use of the Identity Owner 0x80 The system owner. Used by a controlling agent - that authorizes Use to control some settings User 0x40 A delegated user. Used by Microsoft Intune. User1 0x20 Not currently used User2 0x10 Not currently used Zero Touch 0x08 Limited use Identity to allow an Enroll from a controlling agent. The system has the Zero Touch Certificate installed during manufacturing. Zero Touch cannot be enrolled through the normal enroll operation. Zero Touch has no use when a system is enrolled. Reserved 0x04 Unsigned 0x02 Not a certificate - Limited use Identity used as the Identity processing unsigned settings packets Local User 0x01 Not a certificate - just a known, default, user The Identity Manager reads the incoming mailbox to process a Identity enroll, Identity certificate update, and Identity unenroll operations. Except for the Local User, when an Identity is enrolled, it means adding a Certificate that will be used to validate incoming settings. The Identity Manager verifies that the incoming identity mailbox packet: Is signed by one of the Identities The signed identity has permission to update the target identity. Target information in the packet matches the system information The one exception is when an new Owner is being enrolled, no Identities validate the mailbox packet, and the Local User has permission to enroll an owner, DFCI will pause booting to prompt the Local User for permission to do the enroll. The user will be asked to validate the enrollment by entering the last two characters of the new owners certificate hash. When installed by the manufacturer of the system, the Zero Touch certificate will have permission to allow the Zero Touch owner packet to be enrolled without user intervention. Hence, the term Zero Touch enrollment. Permissions Manager \u00b6 The permission manager processes incoming permission mailbox packets. Permission packets must be signed by one of Owner, User, User1 or User2. When processing the incoming permissions XML, the signer permissions are used to enable adding or changing a permission. Settings Manager \u00b6 The settings manager processes incoming settings mailbox packets. Settings packets must be signed by one of Owner, User, User1 or User2. When processing the incoming settings XML, the signer permissions are used to change a setting. Identity Packet Formats \u00b6 An Identity packet consists of a binary header, a DER encoded certificate file, a test signature validating the signing capability, and the signature of the packet: The Test Signature is the detached signature of signing the public key certificate by the private key of the public key certificate. The Signature field of the packet is the detached signature of signing Header-PublicCert-TestSignature by: Operation Signing Key Enroll The private key of the matching Public Key Certificate Roll The private key matching the public cert of the Identity being rolled. Unenroll The private key matching the public cert of the Identity being unenrolled. Permission Packet Formats \u00b6 A Permission packet consists of a binary header, an XML payload, and a signature: Sample permission packet: <?xml version=\"1.0\" encoding=\"utf-8\"?> <PermissionsPacket xmlns= \"urn:UefiSettings-Schema\" > <CreatedBy> Cloud Controller </CreatedBy> <CreatedOn> 2018-03-28 </CreatedOn> <Version> 1 </Version> <LowestSupportedVersion> 1 </LowestSupportedVersion> <Permissions Default= \"129\" Delegated= \"192\" Append= \"False\" > <!-- Sample DDS initial enroll permissions Permission Mask - 128 (0x80) = Owner 64 (0x40) = User 32 (0x20) = User1 16 (0x10) = User2 8 (0X08) = ZTD 2 (0X02) = Unsigned Settings 1 (0x01) = Local User Owner keeps the following settings for itself --> <Permission> <Id> Dfci.OwnerKey.Enum </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.Recovery.Enable </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <!-- Needs 128 (Owner Permission) to set the key, Needs 64 (User Permission) for User to roll the key --> <Id> Dfci.UserKey.Enum </Id> <PMask> 192 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.RecoveryBootstrapUrl.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.RecoveryUrl.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.Hwid.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> </Permissions> </PermissionsPacket> Settings Packet Formats \u00b6 Sample settings payload: <?xml version=\"1.0\" encoding=\"utf-8\"?> <SettingsPacket xmlns= \"urn:UefiSettings-Schema\" > <CreatedBy> Mike Turner </CreatedBy> <CreatedOn> 2019-03-06 10:10:00 </CreatedOn> <Version> 2 </Version> <!-- Make sure you edit DfciSettingsPattern.xml and then run BuildSettings.bat to generate the DfciSettings.xml --> <LowestSupportedVersion> 2 </LowestSupportedVersion> <Settings> <Setting> <Id> Dfci.RecoveryBootstrapUrl.String </Id> <Value> http://some URL to access recovery cert updates/ </Value> </Setting> <Setting> <Id> Dfci.RecoveryUrl.String </Id> <Value> https://some URL to access recovery update packets/ </Value> </Setting> <Setting> <Id> Dfci.HttpsCert.Binary </Id> <Value> <!-- This is where a BASE64 encoded string of the certificate used for HTTPS operations is stored. --> wA== </Value> </Setting> <Setting> <Id> Dfci.RegistrationId.String </Id> <Value> 12345678-1234-5678-1234-012345674321 </Value> </Setting> <Setting> <Id> Dfci.TenantId.String </Id> <Value> 98765432-1234-5678-1234-012345674321 </Value> </Setting> </Settings> </SettingsPacket> Packet Processing \u00b6 In order to minimize rebooting when accepting packets from the owner, there are 6 mailboxes for DFCI There are two for each Identity, Permission, and Settings. We call them: Identity Identity2 Permission Permission2 Settings Settings2 Only packets of the correct type are processed out of each mailbox. Packets are processed in the following order: Enroll Identity Enroll Identity2 Apply Permission Apply Permission2 At this point, if there is a severe error, the Identities and Permissions are reverted to what they were before processing the packets. The following are still processed, in order. Settings Settings2 Unenroll Identity 2 Unenroll Identity UEFI CSP \u00b6 Intune accesses the variables through the UEFI CSP provider. Out of band recovery \u00b6 Normally, the cloud provider would just send unenroll packets through the OS to the UEFICsp. However, if Windows is unable to boot, the UEFI front page application has a method to contact the owner via HTTPS. Setting Provider \u00b6 Settings providers provide an interface for DFCI to access platform settings. The OEM is responsible for providing one or more settings providers for platform settings. The OEM is required to implement an instance of DfciGroupLib that maps DFCI-standard settings to OEM platform settings. While DFCI-standard settings are abstract (eg. Dfci.OnboardAudio.Enable), a platform may have multiple settings that cover portions of audio. For example, there may be a microphone or other input setting, and a setting to enable or disable the audio output. Using the DfciGroup lib, the individual platform settings can be mapped to the DFCI-standard settings. For more information on groups, see Dfci Groups Setting Provider expected return codes \u00b6 Return Code Reason to return this code EFI_SUCCESS Operation of get or set was successful, and the returned value, if any, is valid EFI_NOT_FOUND Returned by DFCI if a setting provider is not found. See notes EFI_UNSUPPORTED Particular operation is not supported. See notes EFI_BUFFER_TOO_SMALL Get operation called with 0 size to get the size of a buffer to allocate EFI_INVALID_PARAMETER Coding error that provided incorrect parameters EFI_OUT_OF_RESOURCES Possibly out of memory, or some other lower function error Notes on EFI NOT FOUND \u00b6 There are two expected reasons a settings provider could return EFI_NOT_FOUND. The first is that the settings is a DFCI standard setting from a newer version of DFCI than was implemented in the platform. The second is that the setting does not apply to the platform because it does not contain the feature. For example, if a platform has no cameras at all, it should not implement a Settings Provider for them. When EFI_NOT_FOUND is returned, Intune will additionally compare the DFCI version reported to determine compliance. For example, a platform reporting DFCI v1, and which has no cameras, returns EFI_NOT_FOUND on a request to disable all cameras. Intune infers that the lack of a standard settings provider for a given version of DFCI indicates that a setting is not relevant. On attempts to enable or disable this setting, Intune remaps this error reporting compliant or not-applicable. On a request to disable WPBT (a DFCI version 2 feature), the same platform would return EFI_NOT_FOUND because it lacks a DFCI version 2 Standard WPBT settings provider. Intune would observe the DFCI version, and report non-compliant, because the platform cannot manage or reliably report the status of the requested setting. Notes on EFI UNSUPPORTED \u00b6 There are reasons for an operation to be not supported. One example is that a platform may provide a setting provider that has a setting that is always disabled, and return EFI_UNSUPPORTED when there is an attempt to enable that setting. Another case is if the hardware doesn't support the setting, or the OEM has chosen not to allow certain settings. Settings provider for enabled features without platform control \u00b6 Please refer to the DfciVirtualizationSettings provider in Project mu_plus for this section. A platform may conform to a Enabled setting, but have no method to control this setting. The CPU and I/O virtualization setting is one of those. The table below indicates the return code for specific cases of of this type of provider: Return Code Reason to return this code EFI_SUCCESS Operation of get was successful, and the returned value is valid EFI_UNSUPPORTED A Set operation is not allowed Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Internals"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#dfci-internals","text":"This section describes the internal operations of DFCI.","title":"DFCI Internals"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#communications-with-provider","text":"DFCI communicates with a controlling identity. One of the controlling identities could be Microsoft Intune. The communications path from the controlling identity is though the use of UEFI variables. DFCI processes the mailbox variables during a system restart.","title":"Communications with Provider"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#identity-manager","text":"In the source code, the Identity manager is implemented in IdentityAndAuthManager is defined in the DfciPkg located in the mu_plus repository https://github.com/microsoft/mu_plus/ . Identity and Auth Manager is responsible for managing the Identities. The initial state of the system has the Local User with full authentication to make changes to any of the available settings. There are seven Identities known by DFCI: Identity Owner Mask Use of the Identity Owner 0x80 The system owner. Used by a controlling agent - that authorizes Use to control some settings User 0x40 A delegated user. Used by Microsoft Intune. User1 0x20 Not currently used User2 0x10 Not currently used Zero Touch 0x08 Limited use Identity to allow an Enroll from a controlling agent. The system has the Zero Touch Certificate installed during manufacturing. Zero Touch cannot be enrolled through the normal enroll operation. Zero Touch has no use when a system is enrolled. Reserved 0x04 Unsigned 0x02 Not a certificate - Limited use Identity used as the Identity processing unsigned settings packets Local User 0x01 Not a certificate - just a known, default, user The Identity Manager reads the incoming mailbox to process a Identity enroll, Identity certificate update, and Identity unenroll operations. Except for the Local User, when an Identity is enrolled, it means adding a Certificate that will be used to validate incoming settings. The Identity Manager verifies that the incoming identity mailbox packet: Is signed by one of the Identities The signed identity has permission to update the target identity. Target information in the packet matches the system information The one exception is when an new Owner is being enrolled, no Identities validate the mailbox packet, and the Local User has permission to enroll an owner, DFCI will pause booting to prompt the Local User for permission to do the enroll. The user will be asked to validate the enrollment by entering the last two characters of the new owners certificate hash. When installed by the manufacturer of the system, the Zero Touch certificate will have permission to allow the Zero Touch owner packet to be enrolled without user intervention. Hence, the term Zero Touch enrollment.","title":"Identity Manager"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#permissions-manager","text":"The permission manager processes incoming permission mailbox packets. Permission packets must be signed by one of Owner, User, User1 or User2. When processing the incoming permissions XML, the signer permissions are used to enable adding or changing a permission.","title":"Permissions Manager"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#settings-manager","text":"The settings manager processes incoming settings mailbox packets. Settings packets must be signed by one of Owner, User, User1 or User2. When processing the incoming settings XML, the signer permissions are used to change a setting.","title":"Settings Manager"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#identity-packet-formats","text":"An Identity packet consists of a binary header, a DER encoded certificate file, a test signature validating the signing capability, and the signature of the packet: The Test Signature is the detached signature of signing the public key certificate by the private key of the public key certificate. The Signature field of the packet is the detached signature of signing Header-PublicCert-TestSignature by: Operation Signing Key Enroll The private key of the matching Public Key Certificate Roll The private key matching the public cert of the Identity being rolled. Unenroll The private key matching the public cert of the Identity being unenrolled.","title":"Identity Packet Formats"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#permission-packet-formats","text":"A Permission packet consists of a binary header, an XML payload, and a signature: Sample permission packet: <?xml version=\"1.0\" encoding=\"utf-8\"?> <PermissionsPacket xmlns= \"urn:UefiSettings-Schema\" > <CreatedBy> Cloud Controller </CreatedBy> <CreatedOn> 2018-03-28 </CreatedOn> <Version> 1 </Version> <LowestSupportedVersion> 1 </LowestSupportedVersion> <Permissions Default= \"129\" Delegated= \"192\" Append= \"False\" > <!-- Sample DDS initial enroll permissions Permission Mask - 128 (0x80) = Owner 64 (0x40) = User 32 (0x20) = User1 16 (0x10) = User2 8 (0X08) = ZTD 2 (0X02) = Unsigned Settings 1 (0x01) = Local User Owner keeps the following settings for itself --> <Permission> <Id> Dfci.OwnerKey.Enum </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.Recovery.Enable </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <!-- Needs 128 (Owner Permission) to set the key, Needs 64 (User Permission) for User to roll the key --> <Id> Dfci.UserKey.Enum </Id> <PMask> 192 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.RecoveryBootstrapUrl.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.RecoveryUrl.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> <Permission> <Id> Dfci.Hwid.String </Id> <PMask> 128 </PMask> <DMask> 128 </DMask> </Permission> </Permissions> </PermissionsPacket>","title":"Permission Packet Formats"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#settings-packet-formats","text":"Sample settings payload: <?xml version=\"1.0\" encoding=\"utf-8\"?> <SettingsPacket xmlns= \"urn:UefiSettings-Schema\" > <CreatedBy> Mike Turner </CreatedBy> <CreatedOn> 2019-03-06 10:10:00 </CreatedOn> <Version> 2 </Version> <!-- Make sure you edit DfciSettingsPattern.xml and then run BuildSettings.bat to generate the DfciSettings.xml --> <LowestSupportedVersion> 2 </LowestSupportedVersion> <Settings> <Setting> <Id> Dfci.RecoveryBootstrapUrl.String </Id> <Value> http://some URL to access recovery cert updates/ </Value> </Setting> <Setting> <Id> Dfci.RecoveryUrl.String </Id> <Value> https://some URL to access recovery update packets/ </Value> </Setting> <Setting> <Id> Dfci.HttpsCert.Binary </Id> <Value> <!-- This is where a BASE64 encoded string of the certificate used for HTTPS operations is stored. --> wA== </Value> </Setting> <Setting> <Id> Dfci.RegistrationId.String </Id> <Value> 12345678-1234-5678-1234-012345674321 </Value> </Setting> <Setting> <Id> Dfci.TenantId.String </Id> <Value> 98765432-1234-5678-1234-012345674321 </Value> </Setting> </Settings> </SettingsPacket>","title":"Settings Packet Formats"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#packet-processing","text":"In order to minimize rebooting when accepting packets from the owner, there are 6 mailboxes for DFCI There are two for each Identity, Permission, and Settings. We call them: Identity Identity2 Permission Permission2 Settings Settings2 Only packets of the correct type are processed out of each mailbox. Packets are processed in the following order: Enroll Identity Enroll Identity2 Apply Permission Apply Permission2 At this point, if there is a severe error, the Identities and Permissions are reverted to what they were before processing the packets. The following are still processed, in order. Settings Settings2 Unenroll Identity 2 Unenroll Identity","title":"Packet Processing"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#uefi-csp","text":"Intune accesses the variables through the UEFI CSP provider.","title":"UEFI CSP"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#out-of-band-recovery","text":"Normally, the cloud provider would just send unenroll packets through the OS to the UEFICsp. However, if Windows is unable to boot, the UEFI front page application has a method to contact the owner via HTTPS.","title":"Out of band recovery"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#setting-provider","text":"Settings providers provide an interface for DFCI to access platform settings. The OEM is responsible for providing one or more settings providers for platform settings. The OEM is required to implement an instance of DfciGroupLib that maps DFCI-standard settings to OEM platform settings. While DFCI-standard settings are abstract (eg. Dfci.OnboardAudio.Enable), a platform may have multiple settings that cover portions of audio. For example, there may be a microphone or other input setting, and a setting to enable or disable the audio output. Using the DfciGroup lib, the individual platform settings can be mapped to the DFCI-standard settings. For more information on groups, see Dfci Groups","title":"Setting Provider"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#setting-provider-expected-return-codes","text":"Return Code Reason to return this code EFI_SUCCESS Operation of get or set was successful, and the returned value, if any, is valid EFI_NOT_FOUND Returned by DFCI if a setting provider is not found. See notes EFI_UNSUPPORTED Particular operation is not supported. See notes EFI_BUFFER_TOO_SMALL Get operation called with 0 size to get the size of a buffer to allocate EFI_INVALID_PARAMETER Coding error that provided incorrect parameters EFI_OUT_OF_RESOURCES Possibly out of memory, or some other lower function error","title":"Setting Provider expected return codes"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#notes-on-efi-not-found","text":"There are two expected reasons a settings provider could return EFI_NOT_FOUND. The first is that the settings is a DFCI standard setting from a newer version of DFCI than was implemented in the platform. The second is that the setting does not apply to the platform because it does not contain the feature. For example, if a platform has no cameras at all, it should not implement a Settings Provider for them. When EFI_NOT_FOUND is returned, Intune will additionally compare the DFCI version reported to determine compliance. For example, a platform reporting DFCI v1, and which has no cameras, returns EFI_NOT_FOUND on a request to disable all cameras. Intune infers that the lack of a standard settings provider for a given version of DFCI indicates that a setting is not relevant. On attempts to enable or disable this setting, Intune remaps this error reporting compliant or not-applicable. On a request to disable WPBT (a DFCI version 2 feature), the same platform would return EFI_NOT_FOUND because it lacks a DFCI version 2 Standard WPBT settings provider. Intune would observe the DFCI version, and report non-compliant, because the platform cannot manage or reliably report the status of the requested setting.","title":"Notes on EFI NOT FOUND"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#notes-on-efi-unsupported","text":"There are reasons for an operation to be not supported. One example is that a platform may provide a setting provider that has a setting that is always disabled, and return EFI_UNSUPPORTED when there is an attempt to enable that setting. Another case is if the hardware doesn't support the setting, or the OEM has chosen not to allow certain settings.","title":"Notes on EFI UNSUPPORTED"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#settings-provider-for-enabled-features-without-platform-control","text":"Please refer to the DfciVirtualizationSettings provider in Project mu_plus for this section. A platform may conform to a Enabled setting, but have no method to control this setting. The CPU and I/O virtualization setting is one of those. The table below indicates the return code for specific cases of of this type of provider: Return Code Reason to return this code EFI_SUCCESS Operation of get was successful, and the returned value is valid EFI_UNSUPPORTED A Set operation is not allowed","title":"Settings provider for enabled features without platform control"},{"location":"dyn/mu_plus/DfciPkg/Docs/Internals/DfciInternals/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/","text":"DfciDeviceIdSupportLib \u00b6 DfciDeviceIdSupportLib provides DFCI with three platform strings: Manufacturer name Product name Serial number Restrictions on Device Identifier strings \u00b6 Null terminated CHAR8 strings Maximum of 64 CHAR8 values plus a NULL terminator, for a maximum size of 65 bytes. The following five characters are not allowed & ' \" < > UTF-8, as per Wikipedia UTF-8 , are allowed within the 64 CHAR limit and the character set limitations. Interfaces \u00b6 Interface Function DfciIdSupportV1GetSerialNumber DEPRECATED. Always return 0. Will be removed. DfciIdSupportGetManufacturer Returns an allocated buffer with the system manufacturer name. DfciIdSupportGetProductName Returns an allocated buffer with the system product name. DfciIdSupportGetSerialNumber Returns an allocated buffer with the system serial number. Additional Details \u00b6 These fields and their values are critical to the security of DFCI. These values should not be user configurable and should be protected from tampering. Testing Requirements \u00b6 Your DfciDeviceIdSupportLib implementation must be linked with the included DeviceIdTest shell application. This shell application must be run on a system with production product strings for the product strings to be validated. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dfci Device Id Support Lib"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#dfcideviceidsupportlib","text":"DfciDeviceIdSupportLib provides DFCI with three platform strings: Manufacturer name Product name Serial number","title":"DfciDeviceIdSupportLib"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#restrictions-on-device-identifier-strings","text":"Null terminated CHAR8 strings Maximum of 64 CHAR8 values plus a NULL terminator, for a maximum size of 65 bytes. The following five characters are not allowed & ' \" < > UTF-8, as per Wikipedia UTF-8 , are allowed within the 64 CHAR limit and the character set limitations.","title":"Restrictions on Device Identifier strings"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#interfaces","text":"Interface Function DfciIdSupportV1GetSerialNumber DEPRECATED. Always return 0. Will be removed. DfciIdSupportGetManufacturer Returns an allocated buffer with the system manufacturer name. DfciIdSupportGetProductName Returns an allocated buffer with the system product name. DfciIdSupportGetSerialNumber Returns an allocated buffer with the system serial number.","title":"Interfaces"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#additional-details","text":"These fields and their values are critical to the security of DFCI. These values should not be user configurable and should be protected from tampering.","title":"Additional Details"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#testing-requirements","text":"Your DfciDeviceIdSupportLib implementation must be linked with the included DeviceIdTest shell application. This shell application must be run on a system with production product strings for the product strings to be validated.","title":"Testing Requirements"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/","text":"DFCI Groups \u00b6 DFCI Groups allow numerous like typed settings to be managed together. Groups can also be used to provide multiple names for the same setting. This allows actual device settings to be mapped into a different namespaces for settings. One such example from the Microsoft scenario is Dfci.OnboardCameras.Enable. This group setting is used to manage the state of all onboard cameras and gives the management entity an ability to control all cameras regardless of how many each platform has. A platform may have Device.FrontCamera.Enable and Device.RearCamera.Enable settings. Adding those settings to the group Dfci.OnboardCameras.Enable allows a general purpose management entity to control both. Handling State Reporting \u00b6 If all of the settings of the group have the same value then that value will be returned (ie Enabled or Disabled for an Enable type setting). If they are not the same then Inconsistent will be returned. Unknown will be returned if there are no members in a group. Restrictions on group names \u00b6 Group names and settings names are in the same name space and duplicate names are not allowed. Like settings names, group names are limited to 96 characters in length, and are null terminated CHAR8 strings. DfciGroupLib \u00b6 The DfciGroupLib is how groups are managed. This library separates the grouping configuration from the setting providers to allow better flexibility and better maintainability. DfciGroupLib is defined in the DfciPkg located in mu_plus repository https://github.com/microsoft/mu_plus/ Library Interfaces \u00b6 Interfaces Usage DfciGetGroupEntries DfciGetGroupEntries returns an array of groups, and each group points to a list of settings that are members of the group. DFCI Standard Groups for OEM extension \u00b6 Group Setting String Description \"Dfci.OnboardCameras.Enable\" Enable/Disable all built-in cameras \"Dfci.OnboardAudio.Enable\" Enable/Disable all built-in microphones & speakers \"Dfci.OnboardRadios.Enable\" Enable/Disable all built-in radios (e.g. Wi-Fi, BlueTooth, NFC, Mobile Broadband...) \"Dfci.BootExternalMedia.Enable\" Enable/disable boot from external media \"Dfci.BootOnboardNetwork.Enable\" Enable/disable boot from built-in network adapters \"Dfci.CpuAndIoVirtualization.Enable\" Enable/disable both CPU & IO Virtualization (i.e. prerequisite for Windows Virtualization Based Security (a.k.a. Device Guard, Core Isolation, Secured Core) Setting Provider for group settings \u00b6 The individual setting providers that are part of a group are expected to be of type DFCI_SETTING_TYPE_ENABLE. Sample for mapping multiple OEM device settings to a group setting: Declare names for all individual BIOS settings that may be modified by the DFCI-standard settings. The DFCI-standard string values are prefixed with \" Dfci. .\" A naming convention for device-specific setting strings is proposed as \" Device. ,\" as follows: // Cameras // // Group setting \"Dfci.OnboardCameras.Enable\" #define DEVICE_SETTING_ID__FRONT_CAMERA \"Device.FrontCamera.Enable\" #define DEVICE_SETTING_ID__REAR_CAMERA \"Device.RearCamera.Enable\" #define DEVICE_SETTING_ID__IR_CAMERA \"Device.IRCamera.Enable\" Map the individual settings to the DFCI groups, an example DfciGroups.c is as follows: STATIC DFCI_SETTING_ID_STRING mAllCameraSettings [] = { DEVICE_SETTING_ID__FRONT_CAMERA , DEVICE_SETTING_ID__REAR_CAMERA , DEVICE_SETTING_ID__IR_CAMERA , NULL }; STATIC DFCI_SETTING_ID_STRING mAllCpuAndIoVirtSettings [] = { DEVICE_SETTING_ID__ENABLE_VIRT_SETTINGS , NULL }; STATIC DFCI_GROUP_ENTRY mMyGroups [] = { { DFCI_SETTING_ID__ALL_CAMERAS , ( DFCI_SETTING_ID_STRING * ) & mAllCameraSettings }, { DFCI_SETTING_ID__ALL_AUDIO , ( DFCI_SETTING_ID_STRING * ) & mAllAudioSettings }, { DFCI_SETTING_ID__ALL_RADIOS , ( DFCI_SETTING_ID_STRING * ) & mAllRadiosSettings }, { DFCI_SETTING_ID__EXTERNAL_MEDIA , ( DFCI_SETTING_ID_STRING * ) & mExternalMediaSettings }, { DFCI_SETTING_ID__ENABLE_NETWORK , ( DFCI_SETTING_ID_STRING * ) & mOnboardNetworkSettings }, { DFCI_SETTING_ID__ALL_CPU_IO_VIRT , ( DFCI_SETTING_ID_STRING * ) & mAllCpuAndIoVirtSettings }, { NULL , NULL } }; /** * Return a pointer to the Group Array to DFCI * */ DFCI_GROUP_ENTRY * EFIAPI DfciGetGroupEntries ( VOID ) { return ( DFCI_GROUP_ENTRY * ) & mMyGroups ; } Group settings results \u00b6 When a group setting is accessed, DFCI enumerates the individual settings of the group. The actual return code to the caller is modified by DFCI depending on the individual settings providers return values. Each of the individual settings will be listed in the Settings Result variable, along with the return code from each setting provider. The return value for the group setting will be one of the following: Return Value from DFCI Reason to return this value \"Enabled\" All providers returned the boolean value TRUE \"Disabled\" All providers in the group returned the boolean value FALSE \"Inconsistent\" Different results were returned from the providers Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dfci Groups"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#dfci-groups","text":"DFCI Groups allow numerous like typed settings to be managed together. Groups can also be used to provide multiple names for the same setting. This allows actual device settings to be mapped into a different namespaces for settings. One such example from the Microsoft scenario is Dfci.OnboardCameras.Enable. This group setting is used to manage the state of all onboard cameras and gives the management entity an ability to control all cameras regardless of how many each platform has. A platform may have Device.FrontCamera.Enable and Device.RearCamera.Enable settings. Adding those settings to the group Dfci.OnboardCameras.Enable allows a general purpose management entity to control both.","title":"DFCI Groups"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#handling-state-reporting","text":"If all of the settings of the group have the same value then that value will be returned (ie Enabled or Disabled for an Enable type setting). If they are not the same then Inconsistent will be returned. Unknown will be returned if there are no members in a group.","title":"Handling State Reporting"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#restrictions-on-group-names","text":"Group names and settings names are in the same name space and duplicate names are not allowed. Like settings names, group names are limited to 96 characters in length, and are null terminated CHAR8 strings.","title":"Restrictions on group names"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#dfcigrouplib","text":"The DfciGroupLib is how groups are managed. This library separates the grouping configuration from the setting providers to allow better flexibility and better maintainability. DfciGroupLib is defined in the DfciPkg located in mu_plus repository https://github.com/microsoft/mu_plus/","title":"DfciGroupLib"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#library-interfaces","text":"Interfaces Usage DfciGetGroupEntries DfciGetGroupEntries returns an array of groups, and each group points to a list of settings that are members of the group.","title":"Library Interfaces"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#dfci-standard-groups-for-oem-extension","text":"Group Setting String Description \"Dfci.OnboardCameras.Enable\" Enable/Disable all built-in cameras \"Dfci.OnboardAudio.Enable\" Enable/Disable all built-in microphones & speakers \"Dfci.OnboardRadios.Enable\" Enable/Disable all built-in radios (e.g. Wi-Fi, BlueTooth, NFC, Mobile Broadband...) \"Dfci.BootExternalMedia.Enable\" Enable/disable boot from external media \"Dfci.BootOnboardNetwork.Enable\" Enable/disable boot from built-in network adapters \"Dfci.CpuAndIoVirtualization.Enable\" Enable/disable both CPU & IO Virtualization (i.e. prerequisite for Windows Virtualization Based Security (a.k.a. Device Guard, Core Isolation, Secured Core)","title":"DFCI Standard Groups for OEM extension"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#setting-provider-for-group-settings","text":"The individual setting providers that are part of a group are expected to be of type DFCI_SETTING_TYPE_ENABLE. Sample for mapping multiple OEM device settings to a group setting: Declare names for all individual BIOS settings that may be modified by the DFCI-standard settings. The DFCI-standard string values are prefixed with \" Dfci. .\" A naming convention for device-specific setting strings is proposed as \" Device. ,\" as follows: // Cameras // // Group setting \"Dfci.OnboardCameras.Enable\" #define DEVICE_SETTING_ID__FRONT_CAMERA \"Device.FrontCamera.Enable\" #define DEVICE_SETTING_ID__REAR_CAMERA \"Device.RearCamera.Enable\" #define DEVICE_SETTING_ID__IR_CAMERA \"Device.IRCamera.Enable\" Map the individual settings to the DFCI groups, an example DfciGroups.c is as follows: STATIC DFCI_SETTING_ID_STRING mAllCameraSettings [] = { DEVICE_SETTING_ID__FRONT_CAMERA , DEVICE_SETTING_ID__REAR_CAMERA , DEVICE_SETTING_ID__IR_CAMERA , NULL }; STATIC DFCI_SETTING_ID_STRING mAllCpuAndIoVirtSettings [] = { DEVICE_SETTING_ID__ENABLE_VIRT_SETTINGS , NULL }; STATIC DFCI_GROUP_ENTRY mMyGroups [] = { { DFCI_SETTING_ID__ALL_CAMERAS , ( DFCI_SETTING_ID_STRING * ) & mAllCameraSettings }, { DFCI_SETTING_ID__ALL_AUDIO , ( DFCI_SETTING_ID_STRING * ) & mAllAudioSettings }, { DFCI_SETTING_ID__ALL_RADIOS , ( DFCI_SETTING_ID_STRING * ) & mAllRadiosSettings }, { DFCI_SETTING_ID__EXTERNAL_MEDIA , ( DFCI_SETTING_ID_STRING * ) & mExternalMediaSettings }, { DFCI_SETTING_ID__ENABLE_NETWORK , ( DFCI_SETTING_ID_STRING * ) & mOnboardNetworkSettings }, { DFCI_SETTING_ID__ALL_CPU_IO_VIRT , ( DFCI_SETTING_ID_STRING * ) & mAllCpuAndIoVirtSettings }, { NULL , NULL } }; /** * Return a pointer to the Group Array to DFCI * */ DFCI_GROUP_ENTRY * EFIAPI DfciGetGroupEntries ( VOID ) { return ( DFCI_GROUP_ENTRY * ) & mMyGroups ; }","title":"Setting Provider for group settings"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#group-settings-results","text":"When a group setting is accessed, DFCI enumerates the individual settings of the group. The actual return code to the caller is modified by DFCI depending on the individual settings providers return values. Each of the individual settings will be listed in the Settings Result variable, along with the return code from each setting provider. The return value for the group setting will be one of the following: Return Value from DFCI Reason to return this value \"Enabled\" All providers returned the boolean value TRUE \"Disabled\" All providers in the group returned the boolean value FALSE \"Inconsistent\" Different results were returned from the providers","title":"Group settings results"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciGroups/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/","text":"DFCI Settings Providers \u00b6 Settings providers are the foundation of DFCI. Settings providers provide a common method to get and apply a setting. All of the setting providers are linked to the Settings Manager,which published the Setting Access Protocol. All updates to settings that are provided by an anonymous DFCI settings library should be through the Setting Access protocol. The Setting Access protocol will validate the permission of the setting before allowing the setting to be changed. Overview \u00b6 A setting provider may publish more than one settings. Multiple setting providers are aggregated and accessed through the DFCI Setting Access Protocol as shown below: Lets look at what is needed for a single setting in the Setting Provider environment. A setting provider is an anonymous library linked with the Settings Manager DXE driver. Here is how the DfciSampleProvider library is linked with the Settings Manager as an anonymous library: DfciPkg/SettingsManager/SettingsManagerDxe.inf { <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE <LibraryClasses> NULL|DfciPkg/Library/DfciSampleProvider/DfciSampleProviderLib.inf } Any number of anonymous libraries can be linked with the Settings Manager. Referring to the DfciSampleProvider code, a setting provider defines a setting as: DFCI_SETTING_PROVIDER mDfciSampleProviderProviderSetting1 = { MY_SETTING_ID__SETTING1 , DFCI_SETTING_TYPE_ENABLE , DFCI_SETTING_FLAGS_NO_PREBOOT_UI , // NO UI element for user to change DfciSampleProviderSet , DfciSampleProviderGet , DfciSampleProviderGetDefault , DfciSampleProviderSetDefault }; This particular setting is a ENABLE/DISABLE type of setting, and is telling DFCI that there is no UI element for this setting. When there is no UI element for a setting, DFCI will set the value to the setting Default Value when DFCI is unenrolled. Each setting provider library must have a constructor with code that checks the PCD gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider. When the constructor is called with the InstallProvider PCD set to TRUE, the setting provider needs to register for a notification of the Settings Provider Support Protocol. When that notification is called, the Settings Provider calls the RegisterProvider method with each setting that the setting provider provides. The constructor looks like: if ( FeaturePcdGet ( PcdSettingsManagerInstallProvider )) { //Install callback on the SettingsManager gDfciSettingsProviderSupportProtocolGuid protocol mDfciSampleProviderProviderSupportInstallEvent = EfiCreateProtocolNotifyEvent ( & gDfciSettingsProviderSupportProtocolGuid , TPL_CALLBACK , DfciSampleProviderProviderSupportProtocolNotify , NULL , & mDfciSampleProviderProviderSupportInstallEventRegistration ); DEBUG (( DEBUG_INFO , \"%a: Event Registered. \\n \" , __FUNCTION__ )); //Initialize the settings store Status = InitializeSettingStore (); if ( EFI_ERROR ( Status )) { DEBUG (( DEBUG_ERROR , \"%a: Initialize Store failed. %r. \\n \" , __FUNCTION__ , Status )); } } return EFI_SUCCESS ; The notify routine looks like: //locate protocol Status = gBS -> LocateProtocol ( & gDfciSettingsProviderSupportProtocolGuid , NULL , ( VOID ** ) & sp ); if ( EFI_ERROR ( Status )) { if (( CallCount ++ != 0 ) || ( Status != EFI_NOT_FOUND )) { DEBUG (( DEBUG_ERROR , \"%a() - Failed to locate gDfciSettingsProviderSupportProtocolGuid in notify. Status = %r \\n \" , __FUNCTION__ , Status )); } return ; } Status = sp -> RegisterProvider ( sp , & mDfciSampleProviderProviderSetting1 ); if ( EFI_ERROR ( Status )) { DEBUG (( DEBUG_ERROR , \"Failed to Register %a. Status = %r \\n \" , mDfciSampleProviderProviderSetting1 . Id , Status )); } //We got here, this means all protocols were installed and we didn't exit early. //close the event as we don't need to be signaled again. (shouldn't happen anyway) gBS -> CloseEvent ( Event ); Setting Provider \u00b6 When you are writing your setting provider, keep in mind that other, similarly written libraries, are linked together. Define each common routine as STATIC to avoid conflicts with other providers. Refer to the UEFI general timeline here: Quite a few settings are only needed in late DXE, BDS or FrontPage. You may need access to settings values in PEI or in DXE prior to the starting of SettingsManager. To do this, add private methods to your settings library. Doing this will keep a single piece of code that accesses the nonvolatile storage for the settings. Here is a sample local setting function in the Dfci Sample Provider: // Here is where you would have private interfaces to get and or set a settings value EFI_STATUS OEM_GetSampleSetting1 ( OUT UINT8 * LocalSetting ) { UINTN LocalSettingsSize ; EFI_STATUS Status ; LocalSettingSize = sizeof ( * LocalSetting ); Status = DfciSampleProviderGet ( & mDfciSampleProviderProviderSetting1 , & LocalSettingSize , & LocalSetting ); return Status ; } Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dfci Setting Providers"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#dfci-settings-providers","text":"Settings providers are the foundation of DFCI. Settings providers provide a common method to get and apply a setting. All of the setting providers are linked to the Settings Manager,which published the Setting Access Protocol. All updates to settings that are provided by an anonymous DFCI settings library should be through the Setting Access protocol. The Setting Access protocol will validate the permission of the setting before allowing the setting to be changed.","title":"DFCI Settings Providers"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#overview","text":"A setting provider may publish more than one settings. Multiple setting providers are aggregated and accessed through the DFCI Setting Access Protocol as shown below: Lets look at what is needed for a single setting in the Setting Provider environment. A setting provider is an anonymous library linked with the Settings Manager DXE driver. Here is how the DfciSampleProvider library is linked with the Settings Manager as an anonymous library: DfciPkg/SettingsManager/SettingsManagerDxe.inf { <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE <LibraryClasses> NULL|DfciPkg/Library/DfciSampleProvider/DfciSampleProviderLib.inf } Any number of anonymous libraries can be linked with the Settings Manager. Referring to the DfciSampleProvider code, a setting provider defines a setting as: DFCI_SETTING_PROVIDER mDfciSampleProviderProviderSetting1 = { MY_SETTING_ID__SETTING1 , DFCI_SETTING_TYPE_ENABLE , DFCI_SETTING_FLAGS_NO_PREBOOT_UI , // NO UI element for user to change DfciSampleProviderSet , DfciSampleProviderGet , DfciSampleProviderGetDefault , DfciSampleProviderSetDefault }; This particular setting is a ENABLE/DISABLE type of setting, and is telling DFCI that there is no UI element for this setting. When there is no UI element for a setting, DFCI will set the value to the setting Default Value when DFCI is unenrolled. Each setting provider library must have a constructor with code that checks the PCD gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider. When the constructor is called with the InstallProvider PCD set to TRUE, the setting provider needs to register for a notification of the Settings Provider Support Protocol. When that notification is called, the Settings Provider calls the RegisterProvider method with each setting that the setting provider provides. The constructor looks like: if ( FeaturePcdGet ( PcdSettingsManagerInstallProvider )) { //Install callback on the SettingsManager gDfciSettingsProviderSupportProtocolGuid protocol mDfciSampleProviderProviderSupportInstallEvent = EfiCreateProtocolNotifyEvent ( & gDfciSettingsProviderSupportProtocolGuid , TPL_CALLBACK , DfciSampleProviderProviderSupportProtocolNotify , NULL , & mDfciSampleProviderProviderSupportInstallEventRegistration ); DEBUG (( DEBUG_INFO , \"%a: Event Registered. \\n \" , __FUNCTION__ )); //Initialize the settings store Status = InitializeSettingStore (); if ( EFI_ERROR ( Status )) { DEBUG (( DEBUG_ERROR , \"%a: Initialize Store failed. %r. \\n \" , __FUNCTION__ , Status )); } } return EFI_SUCCESS ; The notify routine looks like: //locate protocol Status = gBS -> LocateProtocol ( & gDfciSettingsProviderSupportProtocolGuid , NULL , ( VOID ** ) & sp ); if ( EFI_ERROR ( Status )) { if (( CallCount ++ != 0 ) || ( Status != EFI_NOT_FOUND )) { DEBUG (( DEBUG_ERROR , \"%a() - Failed to locate gDfciSettingsProviderSupportProtocolGuid in notify. Status = %r \\n \" , __FUNCTION__ , Status )); } return ; } Status = sp -> RegisterProvider ( sp , & mDfciSampleProviderProviderSetting1 ); if ( EFI_ERROR ( Status )) { DEBUG (( DEBUG_ERROR , \"Failed to Register %a. Status = %r \\n \" , mDfciSampleProviderProviderSetting1 . Id , Status )); } //We got here, this means all protocols were installed and we didn't exit early. //close the event as we don't need to be signaled again. (shouldn't happen anyway) gBS -> CloseEvent ( Event );","title":"Overview"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#setting-provider","text":"When you are writing your setting provider, keep in mind that other, similarly written libraries, are linked together. Define each common routine as STATIC to avoid conflicts with other providers. Refer to the UEFI general timeline here: Quite a few settings are only needed in late DXE, BDS or FrontPage. You may need access to settings values in PEI or in DXE prior to the starting of SettingsManager. To do this, add private methods to your settings library. Doing this will keep a single piece of code that accesses the nonvolatile storage for the settings. Here is a sample local setting function in the Dfci Sample Provider: // Here is where you would have private interfaces to get and or set a settings value EFI_STATUS OEM_GetSampleSetting1 ( OUT UINT8 * LocalSetting ) { UINTN LocalSettingsSize ; EFI_STATUS Status ; LocalSettingSize = sizeof ( * LocalSetting ); Status = DfciSampleProviderGet ( & mDfciSampleProviderProviderSetting1 , & LocalSettingSize , & LocalSetting ); return Status ; }","title":"Setting Provider"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciUiSupportLib/","text":"DfciUiSupportLib \u00b6 DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non-secure environment is available. Interfaces \u00b6 Interface Usage DfciUiIsManufacturingMode Returns TRUE or FALSE. Used to self OptIn a cert used for zero touch enrollment. If the device doesn't support a manufacturing mode, return FALSE. DfciUiIsAvailable For one touch enrollment, the user has to authorize the enrollment. Since DFCI normally runs before consoles are started, DFCI will wait until END_OF_DXE and then make sure the User Interface (UI) is available. If no UI is available at that time, the enrollment will fail. DfciUiDisplayMessageBox Displays a message box DfciUiDisplayPasswordDialog Displays a prompt for the ADMIN password DfciUiDisplayAuthDialog Displays a prompt for confirmation of an enrolling certificate. The response is the last two characters of the thumbprint. If there is an ADMIN password set, then this dialog will also request the ADMIN password. DfciUiExitSecurityBoundary The platform settings application usually runs in a secure state before variables are locked. The DFCI Menu application will call ExitSecurityBoundary before starting the network or performing USB operations to minimize the security risks associated with external accesses.","title":"Dfci Ui Support Lib"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciUiSupportLib/#dfciuisupportlib","text":"DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non-secure environment is available.","title":"DfciUiSupportLib"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/DfciUiSupportLib/#interfaces","text":"Interface Usage DfciUiIsManufacturingMode Returns TRUE or FALSE. Used to self OptIn a cert used for zero touch enrollment. If the device doesn't support a manufacturing mode, return FALSE. DfciUiIsAvailable For one touch enrollment, the user has to authorize the enrollment. Since DFCI normally runs before consoles are started, DFCI will wait until END_OF_DXE and then make sure the User Interface (UI) is available. If no UI is available at that time, the enrollment will fail. DfciUiDisplayMessageBox Displays a message box DfciUiDisplayPasswordDialog Displays a prompt for the ADMIN password DfciUiDisplayAuthDialog Displays a prompt for confirmation of an enrolling certificate. The response is the last two characters of the thumbprint. If there is an ADMIN password set, then this dialog will also request the ADMIN password. DfciUiExitSecurityBoundary The platform settings application usually runs in a secure state before variables are locked. The DFCI Menu application will call ExitSecurityBoundary before starting the network or performing USB operations to minimize the security risks associated with external accesses.","title":"Interfaces"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/","text":"Platform Integration of DFCI \u00b6 This section of documentation is focused on UEFI firmware developers and helping them enable their platforms with the DFCI feature. DFCI consists mostly of a software feature that is written in the DXE phase of UEFI. It has numerous architecture and platform independent modules with only a few required platform libraries. It also requires the platform adhere to and use the DFCI components to ensure the DFCI features work as designed. Finally to enable an End-To-End management scenario there maybe custom requirements in adjacent UEFI firmware components. Dfci Menu application \u00b6 The DfciMenu application is optimized for mu_plus MsGraphicsPkg . It is VFR but since many platforms use custom layouts and graphical representation this area might need some adjustments. The DfciMenu application publishes a HII formset that should be located by your pre-boot UEFI menu application (e.g. \"FrontPage\") and displayed. Formset GUID: gDfciMenuFormsetGuid = {0x3b82283d, 0x7add, 0x4c6a, {0xad, 0x2b, 0x71, 0x9b, 0x8d, 0x7b, 0x77, 0xc9 }} Entry Form: #define DFCI_MENU_FORM_ID 0x2000 Source Location: DfciPkg\\Application\\DfciMenu DFCI DXE Drivers \u00b6 Dxe Driver Location DfciManager.efi DfciPkg/DfciManager/DfciManager.inf IdentityAndAuthManager.efi DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf SettingsManager.efi DfciPkg/SettingsManager/SettingsManagerDxe.inf DfciMenu.inf DfciPkg/Application/DfciMenu/DfciMenu.inf DFCI Core Libraries \u00b6 These DFCI Standard libraries are expected to be used as is for standard functionality. Library Location DfciRecoveryLib DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf DfciSettingsLib DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciV1SupportLib DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf DfciXmlDeviceIdSchemaSupportLib DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlSettingSchemaSupportLib DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf ZeroTouchSettingsLib ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf DfciSettingPermissionLib DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf DFCI Platform provided libraries \u00b6 The following libraries have to be provided by the platform: Library Documentation Function DfciDeviceIdSupportLib Documentation Provides SMBIOS information - Manufacturer, Product, and Serial number DfciGroupLib Documentation Provides lists of platform settings that are in the Dfci group settings. DfciUiSupportLib Documentation Provides UI for various user interactions DFCI Setting Providers \u00b6 Setting providers is how a platform provides a setting to DFCI Setting detailed overview Mu Changes \u00b6 DFCI Recovery service uses HTTPS certificates with Subject Alternative Names. This requires a source modification to NetworkPkg, removal of EFI_TLS_VERIFY_FLAG_NO_WILDCARDS from TlsConfigureSession() . Configure OpenSSL to support modern TLS ciphers Platform DSC statements \u00b6 Adding DFCI to your system consists of: Write your settings providers. Use DfciPkg/Library/DfciSampleProvider . Writing three library classes for the DfciDeviceIdSupportLib, DfciGroupLib, and DfciUiSupportLib. Adding the DSC sections below. Adding the FDF sections below. [LibraryClasses.XXX] DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf DfciSettingsLib|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf DfciDeviceIdSupportLib|YOURPLATFORMPKG/Library/DfciDeviceIdSupportLib/DfciDeviceIdSupportLib.inf DfciUiSupportLib|YOURPLATFORMPKG/Library/DfciUiSupportLib/DfciUiSupportLib.inf DfciGroupLib|YOURPLATFORMPKG/Library/DfciGroupLib/DfciGroups.inf [Components.XXX] DfciPkg/SettingsManager/SettingsManagerDxe.inf { #Platform should add all it settings libs here <LibraryClasses> NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf NULL|YOUR_PLATFORM_PKG/Library/YOUR_FIRST_SETTING_PROVIDER.inf NULL|YOUR_PLATFORM_PKG/Library/YOUR_SECOND_SETTING_PROVIDER.inf NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf NULL|DfciPkg/Library/DfciVirtualizationSettings/DfciVirtualizationSettings.inf DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE } DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf DfciPkg/DfciManager/DfciManager.inf DfciPkg/Application/DfciMenu/DfciMenu.inf Platform FDF statements \u00b6 [FV.YOUR_DXE_FV] INF DfciPkg/SettingsManager/SettingsManagerDxe.inf INF DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf INF DfciPkg/Application/DfciMenu/DfciMenu.inf INF DfciPkg/DfciManager/DfciManager.inf Unsigned Settings packets \u00b6 Dfci has a feature where a platform can enable some settings to be changes with an unsigned packet. This is allowed only when the system is not enrolled in Dfci. This can allow setting parameters that don't affect the security of the system and there is a cost benefit to being able to deploy these setting changes easily, and not step up to full Dfci. To enable to platform to allow unsigned settings, the platform must produce an unsigned permission list in xml format and include this xml file in the platform build .fdf file: <!-- NOTE: None of the Permission Masks or the Delegated Masks are actually used. However, they must be present for the XML parser used by Dfci. This include Default, Delegated, Append, PMask, and DMask values. --> <PermissionsPacket xmlns= \"urn:UefiSettings-Schema\" > <Permissions Default= \"243\" Delegated= \"0\" Append= \"False\" > <Permission> <Id> Device.PlatformSetting1.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> <Permission> <Id> Device.PlatformSetting2.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> <Permission> <Id> Device.PlatformSetting3.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> </Permissions> </PermissionsPacket> To include this file in the platform .fdf file, do the following: FILE FREEFORM = PCD(gDfciPkgTokenSpaceGuid.PcdUnsignedPermissionsFile) { SECTION RAW = YourPlatformPkg/StaticFiles/UnsignedPermissions.xml } Certain platforms may choose to enable all settings to be set via unsigned packets by building with the Pcd PcdUnsignedListFormatAllow set to FALSE. This will enable all settings to be changed using unsigned packets. When PcdUnsignedListFormatAllow is FALSE, the unsigned settings list becomes a disallow list, providing a list of settings that do NOT have the permission to be set by an unsigned packet. An Unsigned Permissions file is required to be read before the Disallow operation is enabled. To generate an unsigned settings packet, refer to the DFCI_UnsignedSettings test case. The GenUsb.bat file will produce an unsigned packet (Unsigned_Settings_apply.bin) from a settings xml file (UnsignedSettings.xml). To deploy the Unsigned_Settings_apply.bin file, set the UEFI Variable gDfciSettingsManagerVarNamespace:DfciSettingsRequest to the contents of the Unsigned_Settings_apply.bin file, and restart the system. Testing DFCI operation \u00b6 Please refer to the DFCI TestCase documentation","title":"Platform Integration Overview"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#platform-integration-of-dfci","text":"This section of documentation is focused on UEFI firmware developers and helping them enable their platforms with the DFCI feature. DFCI consists mostly of a software feature that is written in the DXE phase of UEFI. It has numerous architecture and platform independent modules with only a few required platform libraries. It also requires the platform adhere to and use the DFCI components to ensure the DFCI features work as designed. Finally to enable an End-To-End management scenario there maybe custom requirements in adjacent UEFI firmware components.","title":"Platform Integration of DFCI"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-menu-application","text":"The DfciMenu application is optimized for mu_plus MsGraphicsPkg . It is VFR but since many platforms use custom layouts and graphical representation this area might need some adjustments. The DfciMenu application publishes a HII formset that should be located by your pre-boot UEFI menu application (e.g. \"FrontPage\") and displayed. Formset GUID: gDfciMenuFormsetGuid = {0x3b82283d, 0x7add, 0x4c6a, {0xad, 0x2b, 0x71, 0x9b, 0x8d, 0x7b, 0x77, 0xc9 }} Entry Form: #define DFCI_MENU_FORM_ID 0x2000 Source Location: DfciPkg\\Application\\DfciMenu","title":"Dfci Menu application"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-dxe-drivers","text":"Dxe Driver Location DfciManager.efi DfciPkg/DfciManager/DfciManager.inf IdentityAndAuthManager.efi DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf SettingsManager.efi DfciPkg/SettingsManager/SettingsManagerDxe.inf DfciMenu.inf DfciPkg/Application/DfciMenu/DfciMenu.inf","title":"DFCI DXE Drivers"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-core-libraries","text":"These DFCI Standard libraries are expected to be used as is for standard functionality. Library Location DfciRecoveryLib DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf DfciSettingsLib DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciV1SupportLib DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf DfciXmlDeviceIdSchemaSupportLib DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlSettingSchemaSupportLib DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf ZeroTouchSettingsLib ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf DfciSettingPermissionLib DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf","title":"DFCI Core Libraries"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-platform-provided-libraries","text":"The following libraries have to be provided by the platform: Library Documentation Function DfciDeviceIdSupportLib Documentation Provides SMBIOS information - Manufacturer, Product, and Serial number DfciGroupLib Documentation Provides lists of platform settings that are in the Dfci group settings. DfciUiSupportLib Documentation Provides UI for various user interactions","title":"DFCI Platform provided libraries"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-setting-providers","text":"Setting providers is how a platform provides a setting to DFCI Setting detailed overview","title":"DFCI Setting Providers"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#mu-changes","text":"DFCI Recovery service uses HTTPS certificates with Subject Alternative Names. This requires a source modification to NetworkPkg, removal of EFI_TLS_VERIFY_FLAG_NO_WILDCARDS from TlsConfigureSession() . Configure OpenSSL to support modern TLS ciphers","title":"Mu Changes"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#platform-dsc-statements","text":"Adding DFCI to your system consists of: Write your settings providers. Use DfciPkg/Library/DfciSampleProvider . Writing three library classes for the DfciDeviceIdSupportLib, DfciGroupLib, and DfciUiSupportLib. Adding the DSC sections below. Adding the FDF sections below. [LibraryClasses.XXX] DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf DfciSettingsLib|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf DfciDeviceIdSupportLib|YOURPLATFORMPKG/Library/DfciDeviceIdSupportLib/DfciDeviceIdSupportLib.inf DfciUiSupportLib|YOURPLATFORMPKG/Library/DfciUiSupportLib/DfciUiSupportLib.inf DfciGroupLib|YOURPLATFORMPKG/Library/DfciGroupLib/DfciGroups.inf [Components.XXX] DfciPkg/SettingsManager/SettingsManagerDxe.inf { #Platform should add all it settings libs here <LibraryClasses> NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf NULL|YOUR_PLATFORM_PKG/Library/YOUR_FIRST_SETTING_PROVIDER.inf NULL|YOUR_PLATFORM_PKG/Library/YOUR_SECOND_SETTING_PROVIDER.inf NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf NULL|DfciPkg/Library/DfciVirtualizationSettings/DfciVirtualizationSettings.inf DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf <PcdsFeatureFlag> gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE } DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf DfciPkg/DfciManager/DfciManager.inf DfciPkg/Application/DfciMenu/DfciMenu.inf","title":"Platform DSC statements"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#platform-fdf-statements","text":"[FV.YOUR_DXE_FV] INF DfciPkg/SettingsManager/SettingsManagerDxe.inf INF DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf INF DfciPkg/Application/DfciMenu/DfciMenu.inf INF DfciPkg/DfciManager/DfciManager.inf","title":"Platform FDF statements"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#unsigned-settings-packets","text":"Dfci has a feature where a platform can enable some settings to be changes with an unsigned packet. This is allowed only when the system is not enrolled in Dfci. This can allow setting parameters that don't affect the security of the system and there is a cost benefit to being able to deploy these setting changes easily, and not step up to full Dfci. To enable to platform to allow unsigned settings, the platform must produce an unsigned permission list in xml format and include this xml file in the platform build .fdf file: <!-- NOTE: None of the Permission Masks or the Delegated Masks are actually used. However, they must be present for the XML parser used by Dfci. This include Default, Delegated, Append, PMask, and DMask values. --> <PermissionsPacket xmlns= \"urn:UefiSettings-Schema\" > <Permissions Default= \"243\" Delegated= \"0\" Append= \"False\" > <Permission> <Id> Device.PlatformSetting1.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> <Permission> <Id> Device.PlatformSetting2.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> <Permission> <Id> Device.PlatformSetting3.Enable </Id> <PMask> 243 </PMask> <DMask> 0 </DMask> </Permission> </Permissions> </PermissionsPacket> To include this file in the platform .fdf file, do the following: FILE FREEFORM = PCD(gDfciPkgTokenSpaceGuid.PcdUnsignedPermissionsFile) { SECTION RAW = YourPlatformPkg/StaticFiles/UnsignedPermissions.xml } Certain platforms may choose to enable all settings to be set via unsigned packets by building with the Pcd PcdUnsignedListFormatAllow set to FALSE. This will enable all settings to be changed using unsigned packets. When PcdUnsignedListFormatAllow is FALSE, the unsigned settings list becomes a disallow list, providing a list of settings that do NOT have the permission to be set by an unsigned packet. An Unsigned Permissions file is required to be read before the Disallow operation is enabled. To generate an unsigned settings packet, refer to the DFCI_UnsignedSettings test case. The GenUsb.bat file will produce an unsigned packet (Unsigned_Settings_apply.bin) from a settings xml file (UnsignedSettings.xml). To deploy the Unsigned_Settings_apply.bin file, set the UEFI Variable gDfciSettingsManagerVarNamespace:DfciSettingsRequest to the contents of the Unsigned_Settings_apply.bin file, and restart the system.","title":"Unsigned Settings packets"},{"location":"dyn/mu_plus/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#testing-dfci-operation","text":"Please refer to the DFCI TestCase documentation","title":"Testing DFCI operation"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/","text":"Microsoft DFCI Scenarios \u00b6 Overview \u00b6 Microsoft leverages DFCI to provide automated UEFI settings management via Microsoft Intune . Intune provides the IT manager with abstracted, easy button settings that are generally applicable to all platforms, for example, disable booting USB devices or disable all cameras. IT managers depend on the UEFI implementation to protect and enforce DFCI configurations such that they cannot be bypassed by an operating system or casual physical attacker. Windows Autopilot provides the trusted device ownership database, mapping devices to Azure Active Directory Tenants. The \"Microsoft Device Management Trust\" certificate must be included in UEFI to act as the root of trust for automated UEFI management. The Autopilot Service (APS) exposes a cloud endpoint to enable recovery from a BIOS menu in case the device can no longer boot due to misconfiguration or disk corruption. Microsoft DFCI Scenario Requirements \u00b6 PCs must include the DFCI feature in their UEFI PCs must be registered to the Windows Autopilot service by an OEM or Microsoft Cloud Solution Provider PCs must be managed with Microsoft Intune OEMs that support DFCI \u00b6 More are in the works... Lifecycle \u00b6 The DFCI lifecycle can be viewed as UEFI integration, device registration, profile creation, enrollment, management, retirement, & recovery. Stage Description UEFI Integration PCs must first include a UEFI BIOS that integrates the DFCI code and includes the Microsoft Device Management Trust certificate. Device Registration Device ownership must be registered via the Windows Autopilot program by an OEM or Microsoft Cloud Solution Provider Profile Creation An IT administrator leverages Intune to create DFCI Profiles for their devices. Enrollment The DFCI enrollment process is kicked off when a PC is enrolled into Intune and has a matching DFCI Profile. Enrollment includes Intune requesting enrollment packets from APS, sending the packets to the Windows UEFI configuration service provider (CSP) endpoints , the CSP writes the packets to UEFI variables, and triggers an OS reboot to allow UEFI firmware to process the DFCI packets. Management For day-to-day management, Intune creates device-specific packets, digitally signs them, and sends them through the same UEFI configuration service provider , UEFI variable, and reboot process. Retirement When a device is removed from Windows Autopilot, they are marked as unenrolled in APS. Intune will attempt to restore permissions (un-grey all settings) and remove its management authority from the device. Recovery Recovery shall be provided via a pre-boot UEFI menu, always available to a physically-present user, that can refresh DFCI configuration via web, USB, or other. Enrollment Flow \u00b6 Prior to the time of Enrollment, Microsoft Device Management Trust delegates management to the APS by signing a wildcard enrollment packet (targeting all manufacturer, model, & serial number) that authorizes enrollment of the APS certificate. At the request of Intune, the APS authorizes enrollment of a device, creates and signs per-device-targeted enrollment packets that enroll the Intune DFCI management certificate. The APS provides a level of indirection as well as an extra level of recovery via a web recovery service endpoint. The APS additionally configures recovery settings as well as permissions that deny Intune access to modify them. DEFINED: A device is considered \"enrolled\" when IS_OWNER_IDENTITY_ENROLLED(IdMask) returns TRUE, unenrolled when FALSE. Intune creates device-specific packets to provision the Intune authority and configure DFCI settings and permissions as specified in the matching Intune DFCI Profile. Intune delivers these packets via the Windows UEFI configuration service provider which writes them to UEFI mailboxes, to be processed by DFCI on the following boot. Device-specific packets include the SMBIOS manufacturer, model, & serial number, along with an anti-rollback count, to be leveraged by the UEFI DFCI code to determine applicability. Retirement & Recovery Flows \u00b6 Retirement \u00b6 An IT administrator leverages the Intune console to remove devices from Autopilot. Intune creates and sends device- specific packets that both restore DFCI permissions (effectively un-managing settings, making them available in the BIOS menu) and remove the Intune authority from DFCI. Note that this does not restore the settings to default values, they remain as is. Intune also notifies APS that the device is in the unenrolled state. If the device owner wants to further remove the APS authority and/or opt-out of DFCI management, they must leverage the Recovery flow. Recovery \u00b6 Recovery is essential because UEFI misconfiguration may prevent booting to an operating system, for example if USB and network boot are disabled and the hard disk becomes corrupted. When a device is enrolled, UEFI must provide alternative mechanisms for the physically-present user to place packets in the DFCI request mailboxes - this MUST NOT be blocked by a BIOS password or similar. Note that when a device is not enrolled, a BIOS password should prevent access to DFCI enrollment by a physically-present user until they have entered the correct credential. The APS keeps track of the enrollment state of devices. When an administrator removes a device from Autopilot, APS creates signed, device-specific un-enrollment packets and makes them available via a REST endpoint at DFCI_PRIVATE_SETTING_ID__DFCI_RECOVERY_URL. These packets should delete the Intune and APS certificates and provide the local user with access to all settings (they should no longer be greyed out in BIOS menus). Note that retirement does not restore visible settings to their default values. Standard Settings \u00b6 The following standard settings are defined for DFCI v1.0, will be exposed by Intune, and Settings Providers for them must be implemented by the UEFI provider. Note that for device management, the settings apply only to built-in devices, not externally attached devices. All cameras All audio (microphones & speakers) All radios (Wi-Fi, broadband, NFC, BT, ...) CPU & IO virtualization (exposed, enabled for use by the OS so that Virtualization Based Security may be enabled) Boot to external media (e.g. USB, SD, ...) Boot via on-board network devices Refer to the \"Group Settings\" section of DfciSettings.h Device Ownership \u00b6 The Windows Autopilot database is used for authorizing DFCI management. It includes a map of device identifiers an owner's Azure Active Directory tenant. It is populated as part of the Windows Autopilot program by OEMs and Microsoft-authorized Cloud Solution Providers . The DFCI UEFI code leverages the SMBIOS manufacturer, model, and serial number for packet targeting. DFCI is a Windows Autopilot feature, available from Microsoft Intune. Management Authorities \u00b6 DFCI supports UEFI settings and permission management by multiple entities. In the recommended configuration, systems are shipped with 1 Microsoft public certificate included, \"CN=Microsoft Device Management Trust\", which provides the root of trust for management. This certificate authorizes Microsoft to automatically enroll management delegates with varying permissions. \"Microsoft Device Management Trust\" is only used to delegate management to APS and to provide second-chance recovery. APS in turn delegates management to Intune and provides a REST endpoint for online recovery. After enrollment, Intune performs the day-to-day UEFI management, whereas APS and Device Management Trust authorities provide various recovery paths. Authority DFCI ID Usage \"CN=Microsoft Device Management Trust\" DFCI_IDENTITY_SIGNER_ZTD Allowed to enroll a management delegates without a physical presence prompt. Enrolls the Autopilot Service authority. Can act as a backup recovery service. Autopilot Service (APS) DFCI_IDENTITY_SIGNER_OWNER Enrolls Microsoft Intune as a delegated management provider. Provides an online recovery service in case the OS is disconnected from Intune. Microsoft Intune DFCI_IDENTITY_SIGNER_USER Performs day-to-day UEFI settings and permissions management Security & Privacy Considerations \u00b6 When a DFCI owner is enrolled, DFCI must take precedence over any other UEFI management solution. Physically-present user, including authenticated, may not bypass DFCI permissions on DFCI_IDENTITY_LOCAL . Protection: The hardware/firmware implementation of DFCI must protect DFCI configuration code and data such that they cannot by bypassed by an operating system or casual physical attacker. For example, non-volatile storage that is locked prior to Boot Device Selection. Enforcement: The hardware/firmware implementation of DFCI must enforce DFCI configurations such that they cannot by bypassed by an operating system or casual physical attacker. For example, power to devices is disabled or busses disabled and the configuration is locked prior to Boot Device Selection. It is recommended to include an \"Opt Out\" button that enables a physically-present user on an unenrolled device to eject the DFCI_IDENTITY_SIGNER_ZTD from DFCI. The effectively disables automated management - any enrollment attempt will display a red prompt at boot. A user could then prevent enrollment by configuring a BIOS password or enroll their own User certificate (proceeding through the red prompt). Online Recovery via the Autopilot Service \u00b6 The Recovery REST interface includes machine identities. Before transferring machine identities, the server's authenticity should be verified against DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. After authenticating the server, the network traffic, including machine identities, are kept private by HTTPS encryption. But wait, there's more... the server certificate is updated regularly, so UEFI must first ensure it has the up-to-date DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. DFCI_PRIVATE_SETTING_ID__DFCI_BOOTSTRAP_URL provides a REST API to download a signed settings packet containing DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. For this workflow, the server is not authenticated, but the payload will be authenticated prior to consumption. Unknown Certificate Enrollment \u00b6 This is not a Microsoft-supported scenario but might be encountered during development and testing. On an unenrolled system, if enrollment packets are supplied to the DFCI mailboxes that are signed by an unknown certificate, a red authorization prompt is displayed during boot. The prompt requests the physically-present user to authorize the enrollment of the unknown certificate by typing the last 2 characters of the certificate's SHA-1 thumbprint. If a BIOS password is configured, the password must be entered prior to authorizing the enrollment. This is designed to avoid accidental or nefarious enrollment while allowing for valid custom identity management.","title":"Scenarios"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#microsoft-dfci-scenarios","text":"","title":"Microsoft DFCI Scenarios"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#overview","text":"Microsoft leverages DFCI to provide automated UEFI settings management via Microsoft Intune . Intune provides the IT manager with abstracted, easy button settings that are generally applicable to all platforms, for example, disable booting USB devices or disable all cameras. IT managers depend on the UEFI implementation to protect and enforce DFCI configurations such that they cannot be bypassed by an operating system or casual physical attacker. Windows Autopilot provides the trusted device ownership database, mapping devices to Azure Active Directory Tenants. The \"Microsoft Device Management Trust\" certificate must be included in UEFI to act as the root of trust for automated UEFI management. The Autopilot Service (APS) exposes a cloud endpoint to enable recovery from a BIOS menu in case the device can no longer boot due to misconfiguration or disk corruption.","title":"Overview"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#microsoft-dfci-scenario-requirements","text":"PCs must include the DFCI feature in their UEFI PCs must be registered to the Windows Autopilot service by an OEM or Microsoft Cloud Solution Provider PCs must be managed with Microsoft Intune","title":"Microsoft DFCI Scenario Requirements"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#oems-that-support-dfci","text":"More are in the works...","title":"OEMs that support DFCI"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#lifecycle","text":"The DFCI lifecycle can be viewed as UEFI integration, device registration, profile creation, enrollment, management, retirement, & recovery. Stage Description UEFI Integration PCs must first include a UEFI BIOS that integrates the DFCI code and includes the Microsoft Device Management Trust certificate. Device Registration Device ownership must be registered via the Windows Autopilot program by an OEM or Microsoft Cloud Solution Provider Profile Creation An IT administrator leverages Intune to create DFCI Profiles for their devices. Enrollment The DFCI enrollment process is kicked off when a PC is enrolled into Intune and has a matching DFCI Profile. Enrollment includes Intune requesting enrollment packets from APS, sending the packets to the Windows UEFI configuration service provider (CSP) endpoints , the CSP writes the packets to UEFI variables, and triggers an OS reboot to allow UEFI firmware to process the DFCI packets. Management For day-to-day management, Intune creates device-specific packets, digitally signs them, and sends them through the same UEFI configuration service provider , UEFI variable, and reboot process. Retirement When a device is removed from Windows Autopilot, they are marked as unenrolled in APS. Intune will attempt to restore permissions (un-grey all settings) and remove its management authority from the device. Recovery Recovery shall be provided via a pre-boot UEFI menu, always available to a physically-present user, that can refresh DFCI configuration via web, USB, or other.","title":"Lifecycle"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#enrollment-flow","text":"Prior to the time of Enrollment, Microsoft Device Management Trust delegates management to the APS by signing a wildcard enrollment packet (targeting all manufacturer, model, & serial number) that authorizes enrollment of the APS certificate. At the request of Intune, the APS authorizes enrollment of a device, creates and signs per-device-targeted enrollment packets that enroll the Intune DFCI management certificate. The APS provides a level of indirection as well as an extra level of recovery via a web recovery service endpoint. The APS additionally configures recovery settings as well as permissions that deny Intune access to modify them. DEFINED: A device is considered \"enrolled\" when IS_OWNER_IDENTITY_ENROLLED(IdMask) returns TRUE, unenrolled when FALSE. Intune creates device-specific packets to provision the Intune authority and configure DFCI settings and permissions as specified in the matching Intune DFCI Profile. Intune delivers these packets via the Windows UEFI configuration service provider which writes them to UEFI mailboxes, to be processed by DFCI on the following boot. Device-specific packets include the SMBIOS manufacturer, model, & serial number, along with an anti-rollback count, to be leveraged by the UEFI DFCI code to determine applicability.","title":"Enrollment Flow"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#retirement-recovery-flows","text":"","title":"Retirement &amp; Recovery Flows"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#retirement","text":"An IT administrator leverages the Intune console to remove devices from Autopilot. Intune creates and sends device- specific packets that both restore DFCI permissions (effectively un-managing settings, making them available in the BIOS menu) and remove the Intune authority from DFCI. Note that this does not restore the settings to default values, they remain as is. Intune also notifies APS that the device is in the unenrolled state. If the device owner wants to further remove the APS authority and/or opt-out of DFCI management, they must leverage the Recovery flow.","title":"Retirement"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#recovery","text":"Recovery is essential because UEFI misconfiguration may prevent booting to an operating system, for example if USB and network boot are disabled and the hard disk becomes corrupted. When a device is enrolled, UEFI must provide alternative mechanisms for the physically-present user to place packets in the DFCI request mailboxes - this MUST NOT be blocked by a BIOS password or similar. Note that when a device is not enrolled, a BIOS password should prevent access to DFCI enrollment by a physically-present user until they have entered the correct credential. The APS keeps track of the enrollment state of devices. When an administrator removes a device from Autopilot, APS creates signed, device-specific un-enrollment packets and makes them available via a REST endpoint at DFCI_PRIVATE_SETTING_ID__DFCI_RECOVERY_URL. These packets should delete the Intune and APS certificates and provide the local user with access to all settings (they should no longer be greyed out in BIOS menus). Note that retirement does not restore visible settings to their default values.","title":"Recovery"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#standard-settings","text":"The following standard settings are defined for DFCI v1.0, will be exposed by Intune, and Settings Providers for them must be implemented by the UEFI provider. Note that for device management, the settings apply only to built-in devices, not externally attached devices. All cameras All audio (microphones & speakers) All radios (Wi-Fi, broadband, NFC, BT, ...) CPU & IO virtualization (exposed, enabled for use by the OS so that Virtualization Based Security may be enabled) Boot to external media (e.g. USB, SD, ...) Boot via on-board network devices Refer to the \"Group Settings\" section of DfciSettings.h","title":"Standard Settings"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#device-ownership","text":"The Windows Autopilot database is used for authorizing DFCI management. It includes a map of device identifiers an owner's Azure Active Directory tenant. It is populated as part of the Windows Autopilot program by OEMs and Microsoft-authorized Cloud Solution Providers . The DFCI UEFI code leverages the SMBIOS manufacturer, model, and serial number for packet targeting. DFCI is a Windows Autopilot feature, available from Microsoft Intune.","title":"Device Ownership"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#management-authorities","text":"DFCI supports UEFI settings and permission management by multiple entities. In the recommended configuration, systems are shipped with 1 Microsoft public certificate included, \"CN=Microsoft Device Management Trust\", which provides the root of trust for management. This certificate authorizes Microsoft to automatically enroll management delegates with varying permissions. \"Microsoft Device Management Trust\" is only used to delegate management to APS and to provide second-chance recovery. APS in turn delegates management to Intune and provides a REST endpoint for online recovery. After enrollment, Intune performs the day-to-day UEFI management, whereas APS and Device Management Trust authorities provide various recovery paths. Authority DFCI ID Usage \"CN=Microsoft Device Management Trust\" DFCI_IDENTITY_SIGNER_ZTD Allowed to enroll a management delegates without a physical presence prompt. Enrolls the Autopilot Service authority. Can act as a backup recovery service. Autopilot Service (APS) DFCI_IDENTITY_SIGNER_OWNER Enrolls Microsoft Intune as a delegated management provider. Provides an online recovery service in case the OS is disconnected from Intune. Microsoft Intune DFCI_IDENTITY_SIGNER_USER Performs day-to-day UEFI settings and permissions management","title":"Management Authorities"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#security-privacy-considerations","text":"When a DFCI owner is enrolled, DFCI must take precedence over any other UEFI management solution. Physically-present user, including authenticated, may not bypass DFCI permissions on DFCI_IDENTITY_LOCAL . Protection: The hardware/firmware implementation of DFCI must protect DFCI configuration code and data such that they cannot by bypassed by an operating system or casual physical attacker. For example, non-volatile storage that is locked prior to Boot Device Selection. Enforcement: The hardware/firmware implementation of DFCI must enforce DFCI configurations such that they cannot by bypassed by an operating system or casual physical attacker. For example, power to devices is disabled or busses disabled and the configuration is locked prior to Boot Device Selection. It is recommended to include an \"Opt Out\" button that enables a physically-present user on an unenrolled device to eject the DFCI_IDENTITY_SIGNER_ZTD from DFCI. The effectively disables automated management - any enrollment attempt will display a red prompt at boot. A user could then prevent enrollment by configuring a BIOS password or enroll their own User certificate (proceeding through the red prompt).","title":"Security &amp; Privacy Considerations"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#online-recovery-via-the-autopilot-service","text":"The Recovery REST interface includes machine identities. Before transferring machine identities, the server's authenticity should be verified against DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. After authenticating the server, the network traffic, including machine identities, are kept private by HTTPS encryption. But wait, there's more... the server certificate is updated regularly, so UEFI must first ensure it has the up-to-date DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. DFCI_PRIVATE_SETTING_ID__DFCI_BOOTSTRAP_URL provides a REST API to download a signed settings packet containing DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. For this workflow, the server is not authenticated, but the payload will be authenticated prior to consumption.","title":"Online Recovery via the Autopilot Service"},{"location":"dyn/mu_plus/DfciPkg/Docs/Scenarios/DfciScenarios/#unknown-certificate-enrollment","text":"This is not a Microsoft-supported scenario but might be encountered during development and testing. On an unenrolled system, if enrollment packets are supplied to the DFCI mailboxes that are signed by an unknown certificate, a red authorization prompt is displayed during boot. The prompt requests the physically-present user to authorize the enrollment of the unknown certificate by typing the last 2 characters of the certificate's SHA-1 thumbprint. If a BIOS password is configured, the password must be entered prior to authorizing the enrollment. This is designed to avoid accidental or nefarious enrollment while allowing for valid custom identity management.","title":"Unknown Certificate Enrollment"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/","text":"Identity and Authentication Manager \u00b6 Basic overview of the IdentityAndAuthManager module. File Overview \u00b6 IdentityAndAuthManager.H \u00b6 Private header file defining private functions for use across module Define the internal structure that holds the auth handle to identity mapping IdentityAndAuthManagerDxe \u00b6 Implement the Dxe specific parts of this. Including: Event handling Protocol access Protocol installation AuthManager.C \u00b6 Provide the implementation for the auth protocol functions AuthManagerProvision.C \u00b6 Support using Variable to set, change, or remove the AuthManager Key based identities AuthManagerProvisionedData.C \u00b6 Support NV storage of Provisioned Data. This manages loading internal store and saving changes to internal store. This differs from the Provision.c file in that this has nothing to do with User input or applying user changes. Thi is internal to the module only. IdentityManager.C \u00b6 Support the get identity functionality Dispose Auth Handle Private Identity / auth token map management (Add, Free, Find) Add security TODO IdentityAndAuthManagerDxe.INF \u00b6 Dxe Module inf file DfciAuthentication.h PUBLIC HEADER FILE \u00b6 Defines the DXE protocol to access Identity and Auth management","title":"Identity And Auth Manager"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#identity-and-authentication-manager","text":"Basic overview of the IdentityAndAuthManager module.","title":"Identity and Authentication Manager"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#file-overview","text":"","title":"File Overview"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerh","text":"Private header file defining private functions for use across module Define the internal structure that holds the auth handle to identity mapping","title":"IdentityAndAuthManager.H"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerdxe","text":"Implement the Dxe specific parts of this. Including: Event handling Protocol access Protocol installation","title":"IdentityAndAuthManagerDxe"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerc","text":"Provide the implementation for the auth protocol functions","title":"AuthManager.C"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerprovisionc","text":"Support using Variable to set, change, or remove the AuthManager Key based identities","title":"AuthManagerProvision.C"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerprovisioneddatac","text":"Support NV storage of Provisioned Data. This manages loading internal store and saving changes to internal store. This differs from the Provision.c file in that this has nothing to do with User input or applying user changes. Thi is internal to the module only.","title":"AuthManagerProvisionedData.C"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#identitymanagerc","text":"Support the get identity functionality Dispose Auth Handle Private Identity / auth token map management (Add, Free, Find) Add security TODO","title":"IdentityManager.C"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerdxeinf","text":"Dxe Module inf file","title":"IdentityAndAuthManagerDxe.INF"},{"location":"dyn/mu_plus/DfciPkg/IdentityAndAuthManager/ReadMe/#dfciauthenticationh-public-header-file","text":"Defines the DXE protocol to access Identity and Auth management","title":"DfciAuthentication.h  PUBLIC HEADER FILE"},{"location":"dyn/mu_plus/DfciPkg/Library/DfciSampleProvider/readme/","text":"Dfci Sample Provider \u00b6 This is a DXE driver that publishes the gDfciSettingsProviderSupportProtocolGuid protocol, which is a settings provider for DFCI. This is not to be used in production but is provided as a sample for reference when creating your own provider. For more information, please refer to the DFCI documentation here Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dfci Sample Provider"},{"location":"dyn/mu_plus/DfciPkg/Library/DfciSampleProvider/readme/#dfci-sample-provider","text":"This is a DXE driver that publishes the gDfciSettingsProviderSupportProtocolGuid protocol, which is a settings provider for DFCI. This is not to be used in production but is provided as a sample for reference when creating your own provider. For more information, please refer to the DFCI documentation here","title":"Dfci Sample Provider"},{"location":"dyn/mu_plus/DfciPkg/Library/DfciSampleProvider/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DeviceIdTest/readme/","text":"Verify DfciDeviceIdLib library functionality \u00b6 The library DfciDeviceIdLib provided Dfci with platform information that Dfci needs. This include the manufacturer name, product name, and serial number. Dfci has limit on the characters supported, and the length of the strings returned. Device Id Library rules: The following five characters are not allowed: \" ' < > & The maximum string length is 64 characters plus a terminating '\\0' '\\0' is a required terminator. The interfaces return the string and the size of the string (including the '\\0'). The string is a valid UTF-8 string (ie, no 8-bit ASCII) About \u00b6 These tests verify that the DeviceIdLib Library functions properly. DeviceIdIdTestApp \u00b6 This application consumes the DfciDeviceIdLib executed test cases for the verification of the Device Id Strings. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Device Id Test"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DeviceIdTest/readme/#verify-dfcideviceidlib-library-functionality","text":"The library DfciDeviceIdLib provided Dfci with platform information that Dfci needs. This include the manufacturer name, product name, and serial number. Dfci has limit on the characters supported, and the length of the strings returned. Device Id Library rules: The following five characters are not allowed: \" ' < > & The maximum string length is 64 characters plus a terminating '\\0' '\\0' is a required terminator. The interfaces return the string and the size of the string (including the '\\0'). The string is a valid UTF-8 string (ie, no 8-bit ASCII)","title":"Verify DfciDeviceIdLib library functionality"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DeviceIdTest/readme/#about","text":"These tests verify that the DeviceIdLib Library functions properly.","title":"About"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DeviceIdTest/readme/#deviceididtestapp","text":"This application consumes the DfciDeviceIdLib executed test cases for the verification of the Device Id Strings.","title":"DeviceIdIdTestApp"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DeviceIdTest/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/","text":"Testing DFCI \u00b6 This describes the test structure for insuring DFCI operates properly. A Host System (HOST) to run the test cases. A Device Under Test (DUT) to be tested. with the new DFCI supported also running current Windows. Both systems on the same network. Overview \u00b6 The DFCI tests are a collection of Robot Framework test cases. Each Robot Framework test case collection is contained in a directory, and, as a minimum, contains a run.robot file. Each test case collection is run manually in a proscribed order, and its status is verified before running the next test case. The tests must be run in order, as they alter the system state, much like the real usage of DFCI. Equipment needed \u00b6 The following equipment is needed to run the DFCI tests: A system to run the test cases running a current version of Windows. A System Under Test also running current version of Windows. Both systems able to communicate with each other across the same network. Optional equipment is a mechanism to collect firmware logs from the system under test. Included is a serial port support function that looks for an FTDI serial connection. See the Platforms\\SimpleFTDI folder. Setting up the Device Under Test (DUT) \u00b6 Copy the files needed for the DUT. There is a script to help you do this. For example, with a removable device mounted at drive D:, issue the command: DeviceUnderTest\\CollectFilesForDut.cmd D:\\DfciSetup This will create a directory on the USB key named DfciSetup with the required files for setting up the remote server. Mount the removable device on the DUT and start an administrator CMD Window, then run (where x: is the drive letter where the USB key is mounted): x:\\DfciSetup\\SetupDUT.cmd This will download and install Python, robotframework, robotremoteserver, and pypiwin32. In addition, the SetupDUT command will update the firewall for the robot framework testing, and a make a couple of configuration changes to Windows for a better test experience. Setting up the HOST system \u00b6 The HOST system requires the following software (NOTE - There are dependencies on x86-64 versions of Windows): A current version of Windows x86-64. The current Windows SDK, available here Windows SDK . Python x86-64 (the version tested), available here Python 3.9.4 . Copy the DfciTests directory, including all of the contents of the subdirectories, onto the HOST system. Install the required python packages by running using the pip-requirements.txt file in the DfciTests directory: python -m pip install --upgrade -r pip-requirements.txt Test Cases Collections \u00b6 Table of DFCI Test case collections: Test Case Collection Description of Test Case DFCI_CertChainingTest Verifies that a ZeroTouch enroll actually prompts for authorization to Enroll when the enroll package is not signed by the proper key. DFCI_InitialState Verifies that the firmware indicates support for DFCI and that the system is Opted In for InTune, and is not already enrolled into DFCI. DFCI_InTuneBadUpdate Tries to apply a settings package signed with the wrong key DFCI_InTunePermissions Applies multiple sets of permissions to an InTune Enrolled system. DFCI_InTuneEnroll Applies a InTune Owner, an InTune Manager, and the appropriate permissions and settings. DFCI_InTuneRollCerts Updates the Owner and Manager certificates. This test can be run multiple times as it just swaps between two sets of certificates. DFCI_InTuneSettings Applies multiple sets of settings to a InTune Enrolled system. DFCI_InTuneUnenroll Applies an InTune Owner unenroll package, that removes both the InTune Owner and the InTune Manager, resets the Permission Database, and restores settings marked No UI to their default state. Note on the firmware for testing DFCI \u00b6 Most of DFCI functionality can be tested without regard of the Zero Touch certificate. To test functionality of the Zero Touch feature, the firmware needs to be built with the ZTD_Leaf.cer file instead of the ZtdRecovery.cer file. To do this, change your platform .fdf file from: FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) { SECTION RAW = ZeroTouchPkg/Certs/ZeroTouch/ZtdRecovery.cer } to: FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) { SECTION RAW = DfciPkg/UnitTests/DfciTests/ZTD_Leaf.cer } WARNING: Do not ship with the ZTD_Leaf.cer certificate in your firmware \u00b6 Be sure your production systems are using the ZtdRecovery.cer file. Running The First Test Case \u00b6 Run the first test as shown replacing 11.11.11.211 with the actual IP address of the DUT. You should expect to see similar output with all four tests passing. DfciTests>RunDfciTest.bat TestCases\\DFCI_InitialState 11.11.11.211 DfciTests>python.exe -m robot.run -L TRACE -x DFCI_InitialState.xml -A Platforms\\SimpleFTDI\\Args.txt -v IP_OF_DUT:11.11.11.211 -v TEST_OUTPUT_BASE:C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 -d C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 TestCases\\DFCI_InitialState\\run.robot ============================================================================== Run :: DFCI Initial State test - Verifies that there are no enrolled identi... ============================================================================== Ensure Mailboxes Are Clean .. .L:\\Common\\MU\\DfciPkg\\UnitTests\\DfciTests\\TestCases\\DFCI_InitialState\\run.robot Ensure Mailboxes Are Clean | PASS | ------------------------------------------------------------------------------ Get the starting DFCI Settings | PASS | ------------------------------------------------------------------------------ Obtain Target Parameters From Target | PASS | ------------------------------------------------------------------------------ Process Complete Testcase List ..Initializing testcases ..Running test Process Complete Testcase List | PASS | ------------------------------------------------------------------------------ Run :: DFCI Initial State test - Verifies that there are no enroll... | PASS | 4 critical tests, 4 passed, 0 failed 4 tests total, 4 passed, 0 failed ============================================================================== Output: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\output.xml XUnit: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\DFCI_InitialState.xml Log: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\log.html Report: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\report.html Standard Testing \u00b6 Starting with a DUT that is not enrolled in DFCI, run the tests in the following order: DFCI_InitialState DFCI_InTuneEnroll DFCI_InTuneRollCerts DFCI_InTunePermissions DFCI_InTuneSettings DFCI_InTuneBadUpdate DFCI_InTuneUnenroll Steps 3 through 6 can and should be repeated in any order. Extended Testing \u00b6 This tests also start with a DUT that is not enrolled in DFCI, and will leave the system not enrolled if it completes successfully. DFCI_CertChainingTest Recovering from errors \u00b6 Code issues can present issues with DFCI that may require deleting the Identity and Permission databases. Using privileged access of a DUT that unlocks the varstore, you can delete the two master variables of DFCI. These variables are: _SPP _IPCVN USB Refresh Test \u00b6 The test cases DFCI_InTuneEnroll and DFCI_InTuneUnenroll have a GenUsb.bat file. The GenUsb.bat file will generate a .dfi file that UEFI management menu can read. GenUsb MFG_NAME PRODUCT_NAME SERIAL_NUMBER If there is a space or other special characters, add double quotes as in: GenUsb Fabrikam \"Fabrikam Spelunker Kit\" \"SN-47599011345\" After producing your .dfi file, place it on a USB drive and take it to the system under test. Press the Install from USB button to apply the packets. Variable Lock Test \u00b6 DfciPkg/UnitTest/DfciVarLockAudit contains a UEFI shell command to audit the state of the DFCI variables. This test should be run at multiple points during the development cycle, with the DfciVarLockAudit test run after enrollment and again after the system has been unenrolled. This verifies that the variables that secure the state of DFCI are not compromised. The automation to run DfciVarLock test automatically is not available at this time.","title":"Dfci Tests"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#testing-dfci","text":"This describes the test structure for insuring DFCI operates properly. A Host System (HOST) to run the test cases. A Device Under Test (DUT) to be tested. with the new DFCI supported also running current Windows. Both systems on the same network.","title":"Testing DFCI"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#overview","text":"The DFCI tests are a collection of Robot Framework test cases. Each Robot Framework test case collection is contained in a directory, and, as a minimum, contains a run.robot file. Each test case collection is run manually in a proscribed order, and its status is verified before running the next test case. The tests must be run in order, as they alter the system state, much like the real usage of DFCI.","title":"Overview"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#equipment-needed","text":"The following equipment is needed to run the DFCI tests: A system to run the test cases running a current version of Windows. A System Under Test also running current version of Windows. Both systems able to communicate with each other across the same network. Optional equipment is a mechanism to collect firmware logs from the system under test. Included is a serial port support function that looks for an FTDI serial connection. See the Platforms\\SimpleFTDI folder.","title":"Equipment needed"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#setting-up-the-device-under-test-dut","text":"Copy the files needed for the DUT. There is a script to help you do this. For example, with a removable device mounted at drive D:, issue the command: DeviceUnderTest\\CollectFilesForDut.cmd D:\\DfciSetup This will create a directory on the USB key named DfciSetup with the required files for setting up the remote server. Mount the removable device on the DUT and start an administrator CMD Window, then run (where x: is the drive letter where the USB key is mounted): x:\\DfciSetup\\SetupDUT.cmd This will download and install Python, robotframework, robotremoteserver, and pypiwin32. In addition, the SetupDUT command will update the firewall for the robot framework testing, and a make a couple of configuration changes to Windows for a better test experience.","title":"Setting up the Device Under Test (DUT)"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#setting-up-the-host-system","text":"The HOST system requires the following software (NOTE - There are dependencies on x86-64 versions of Windows): A current version of Windows x86-64. The current Windows SDK, available here Windows SDK . Python x86-64 (the version tested), available here Python 3.9.4 . Copy the DfciTests directory, including all of the contents of the subdirectories, onto the HOST system. Install the required python packages by running using the pip-requirements.txt file in the DfciTests directory: python -m pip install --upgrade -r pip-requirements.txt","title":"Setting up the HOST system"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#test-cases-collections","text":"Table of DFCI Test case collections: Test Case Collection Description of Test Case DFCI_CertChainingTest Verifies that a ZeroTouch enroll actually prompts for authorization to Enroll when the enroll package is not signed by the proper key. DFCI_InitialState Verifies that the firmware indicates support for DFCI and that the system is Opted In for InTune, and is not already enrolled into DFCI. DFCI_InTuneBadUpdate Tries to apply a settings package signed with the wrong key DFCI_InTunePermissions Applies multiple sets of permissions to an InTune Enrolled system. DFCI_InTuneEnroll Applies a InTune Owner, an InTune Manager, and the appropriate permissions and settings. DFCI_InTuneRollCerts Updates the Owner and Manager certificates. This test can be run multiple times as it just swaps between two sets of certificates. DFCI_InTuneSettings Applies multiple sets of settings to a InTune Enrolled system. DFCI_InTuneUnenroll Applies an InTune Owner unenroll package, that removes both the InTune Owner and the InTune Manager, resets the Permission Database, and restores settings marked No UI to their default state.","title":"Test Cases Collections"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#note-on-the-firmware-for-testing-dfci","text":"Most of DFCI functionality can be tested without regard of the Zero Touch certificate. To test functionality of the Zero Touch feature, the firmware needs to be built with the ZTD_Leaf.cer file instead of the ZtdRecovery.cer file. To do this, change your platform .fdf file from: FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) { SECTION RAW = ZeroTouchPkg/Certs/ZeroTouch/ZtdRecovery.cer } to: FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) { SECTION RAW = DfciPkg/UnitTests/DfciTests/ZTD_Leaf.cer }","title":"Note on the firmware for testing DFCI"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#warning-do-not-ship-with-the-ztd_leafcer-certificate-in-your-firmware","text":"Be sure your production systems are using the ZtdRecovery.cer file.","title":"WARNING: Do not ship with the ZTD_Leaf.cer certificate in your firmware"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#running-the-first-test-case","text":"Run the first test as shown replacing 11.11.11.211 with the actual IP address of the DUT. You should expect to see similar output with all four tests passing. DfciTests>RunDfciTest.bat TestCases\\DFCI_InitialState 11.11.11.211 DfciTests>python.exe -m robot.run -L TRACE -x DFCI_InitialState.xml -A Platforms\\SimpleFTDI\\Args.txt -v IP_OF_DUT:11.11.11.211 -v TEST_OUTPUT_BASE:C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 -d C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 TestCases\\DFCI_InitialState\\run.robot ============================================================================== Run :: DFCI Initial State test - Verifies that there are no enrolled identi... ============================================================================== Ensure Mailboxes Are Clean .. .L:\\Common\\MU\\DfciPkg\\UnitTests\\DfciTests\\TestCases\\DFCI_InitialState\\run.robot Ensure Mailboxes Are Clean | PASS | ------------------------------------------------------------------------------ Get the starting DFCI Settings | PASS | ------------------------------------------------------------------------------ Obtain Target Parameters From Target | PASS | ------------------------------------------------------------------------------ Process Complete Testcase List ..Initializing testcases ..Running test Process Complete Testcase List | PASS | ------------------------------------------------------------------------------ Run :: DFCI Initial State test - Verifies that there are no enroll... | PASS | 4 critical tests, 4 passed, 0 failed 4 tests total, 4 passed, 0 failed ============================================================================== Output: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\output.xml XUnit: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\DFCI_InitialState.xml Log: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\log.html Report: C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\report.html","title":"Running The First Test Case"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#standard-testing","text":"Starting with a DUT that is not enrolled in DFCI, run the tests in the following order: DFCI_InitialState DFCI_InTuneEnroll DFCI_InTuneRollCerts DFCI_InTunePermissions DFCI_InTuneSettings DFCI_InTuneBadUpdate DFCI_InTuneUnenroll Steps 3 through 6 can and should be repeated in any order.","title":"Standard Testing"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#extended-testing","text":"This tests also start with a DUT that is not enrolled in DFCI, and will leave the system not enrolled if it completes successfully. DFCI_CertChainingTest","title":"Extended Testing"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#recovering-from-errors","text":"Code issues can present issues with DFCI that may require deleting the Identity and Permission databases. Using privileged access of a DUT that unlocks the varstore, you can delete the two master variables of DFCI. These variables are: _SPP _IPCVN","title":"Recovering from errors"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#usb-refresh-test","text":"The test cases DFCI_InTuneEnroll and DFCI_InTuneUnenroll have a GenUsb.bat file. The GenUsb.bat file will generate a .dfi file that UEFI management menu can read. GenUsb MFG_NAME PRODUCT_NAME SERIAL_NUMBER If there is a space or other special characters, add double quotes as in: GenUsb Fabrikam \"Fabrikam Spelunker Kit\" \"SN-47599011345\" After producing your .dfi file, place it on a USB drive and take it to the system under test. Press the Install from USB button to apply the packets.","title":"USB Refresh Test"},{"location":"dyn/mu_plus/DfciPkg/UnitTests/DfciTests/readme/#variable-lock-test","text":"DfciPkg/UnitTest/DfciVarLockAudit contains a UEFI shell command to audit the state of the DFCI variables. This test should be run at multiple points during the development cycle, with the DfciVarLockAudit test run after enrollment and again after the system has been unenrolled. This verifies that the variables that secure the state of DFCI are not compromised. The automation to run DfciVarLock test automatically is not available at this time.","title":"Variable Lock Test"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/","text":"HID support package \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About \u00b6 The purpose of this package is to provide a generic Boot HID layer that can be used so that devices that implement the Boot Mouse and Boot Keyboard HID interfaces defined in the USB 1.1 spec can share a common HID processing layer. This avoids duplication of the HID parsing/processing code and provides a natural interface layer where various HID-supporting hardware can plug into the UEFI input stack. Adding support for new hardware that wants to plug into HID Keyboard or Mouse simply requires implementing HidKeyboardProtocol or HidMouseProtocol and installing instances of those protocols on the controller handle for the hardware. This greatly simplifies the process of supporting hardware that is already designed to support Boot Mouse or Boot Keyboard HID spec, since such hardware is already producing reports in the same format that the HidKeyboardProtocol or HidMouseProtocol expects. Integration Guide \u00b6 To use the HidPkg, include the following drivers in your build: FDF: #HID Support INF HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf INF HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf DSC: #HID Support HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf Then, include low-level drivers that produce the HID protocols. This package includes two sample drivers for USB keyboard and Mouse that can be used in place of the standard USB keyboard and Mouse drivers. A platform may add additional drivers to support proprietary hardware such as keyboards/track pads/ touchscreens that support the HID protocol definitions in this package. To include the sample USB HID drivers, remove the MdeModulePkg versions and replace them with the sample drivers from this package. FDF: -INF MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf -INF MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf +INF HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf +INF HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf DSC: - MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf - MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf + HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf + HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf","title":"Package Overview"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#hid-support-package","text":"","title":"HID support package"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#about","text":"The purpose of this package is to provide a generic Boot HID layer that can be used so that devices that implement the Boot Mouse and Boot Keyboard HID interfaces defined in the USB 1.1 spec can share a common HID processing layer. This avoids duplication of the HID parsing/processing code and provides a natural interface layer where various HID-supporting hardware can plug into the UEFI input stack. Adding support for new hardware that wants to plug into HID Keyboard or Mouse simply requires implementing HidKeyboardProtocol or HidMouseProtocol and installing instances of those protocols on the controller handle for the hardware. This greatly simplifies the process of supporting hardware that is already designed to support Boot Mouse or Boot Keyboard HID spec, since such hardware is already producing reports in the same format that the HidKeyboardProtocol or HidMouseProtocol expects.","title":"About"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#integration-guide","text":"To use the HidPkg, include the following drivers in your build: FDF: #HID Support INF HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf INF HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf DSC: #HID Support HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf Then, include low-level drivers that produce the HID protocols. This package includes two sample drivers for USB keyboard and Mouse that can be used in place of the standard USB keyboard and Mouse drivers. A platform may add additional drivers to support proprietary hardware such as keyboards/track pads/ touchscreens that support the HID protocol definitions in this package. To include the sample USB HID drivers, remove the MdeModulePkg versions and replace them with the sample drivers from this package. FDF: -INF MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf -INF MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf +INF HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf +INF HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf DSC: - MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf - MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf + HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf + HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf","title":"Integration Guide"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/","text":"Description \u00b6 This driver produces an instances of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX for keyboard support in UEFI It registers a callback with devices exposing the HID_KEYBOARD_PROTOCOL to receive Keyboard HID reports, which are used to satisfy the contract of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX. Provides \u00b6 SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX instance for consumption by UEFI console. Dependencies \u00b6 HID_KEYBOARD_PROTOCOL to register for and receive HID Keyboard Reports. Application \u00b6 Used to enable PreBoot Keyboard Support.","title":"Hid Keyboard Dxe"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#description","text":"This driver produces an instances of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX for keyboard support in UEFI It registers a callback with devices exposing the HID_KEYBOARD_PROTOCOL to receive Keyboard HID reports, which are used to satisfy the contract of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX.","title":"Description"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#provides","text":"SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX instance for consumption by UEFI console.","title":"Provides"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#dependencies","text":"HID_KEYBOARD_PROTOCOL to register for and receive HID Keyboard Reports.","title":"Dependencies"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#application","text":"Used to enable PreBoot Keyboard Support.","title":"Application"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/","text":"HID Mouse Absolute Pointer DXE \u00b6 Description \u00b6 This driver produces an instance of EFI_ABSOLUTE_POINTER_PROTOCOL for mouse support in UEFI It registers a callback with the devices exposing HID_POINTER_PROTOCOL to receive Mouse HID reports, which are used to satisfy the contract of EFI_ABSOLUTE_POINTER_PROTOCOL. Provides \u00b6 EFI_ABSOLUTE_POINTER_PROTOCOL instance for consumption by UEFI console. Dependencies \u00b6 HID_POINTER_PROTOCOL to register for and receive HID Mouse Reports. Application \u00b6 Used to enable PreBoot Mouse Support.","title":"Hid Mouse Absolute Pointer Dxe"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#hid-mouse-absolute-pointer-dxe","text":"","title":"HID Mouse Absolute Pointer DXE"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#description","text":"This driver produces an instance of EFI_ABSOLUTE_POINTER_PROTOCOL for mouse support in UEFI It registers a callback with the devices exposing HID_POINTER_PROTOCOL to receive Mouse HID reports, which are used to satisfy the contract of EFI_ABSOLUTE_POINTER_PROTOCOL.","title":"Description"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#provides","text":"EFI_ABSOLUTE_POINTER_PROTOCOL instance for consumption by UEFI console.","title":"Provides"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#dependencies","text":"HID_POINTER_PROTOCOL to register for and receive HID Mouse Reports.","title":"Dependencies"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#application","text":"Used to enable PreBoot Mouse Support.","title":"Application"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/","text":"Manufacturer Firmware Configuration Interface (MFCI) \u00b6 Overview \u00b6 In a Sentence \u00b6 Manufacturer Firmware Configuration Interface (MFCI) is a UEFI BIOS feature that provides a secure mechanism for an authorized agent, such as an OEM or ODM, to modify firmware security properties of a specific device, typically for the purposes of remanufacturing or refurbishment. Background \u00b6 Manufacturing and remanufacturing (refurbishment) of devices requires configuration of settings related to safety (batteries, thermals), compliance (radio calibration, anti-theft), licensing (OA3, serial numbers), & security. These sensitive settings are typically secured by the OEM / ODM at end of manufacturing to ensure that they are not modified with malicious intent. During initial manufacturing, a device is typically not secured until the final provisioning station, after calibration and other secure data have been provisioned. After a device is secured, product demand may deviate from forecasts and a device may need to be reprovisioned for a different region, requiring modification of secured settings. Remanufacturing of devices requires executing tools and workflows that bypass this security, allowing modification of these sensitive settings, and performing potentially destructive diagnostics. The Windows 10X Compatibility Requirements prohibit unauthorized execution of these dangerous tools. The MFCI feature provides a secure path to enable remanufacturing while maintaining the Windows 10X security promise. Building an End-to-End MFCI Solution \u00b6 An MFCI-based solution requires: Devices with MFCI integrated into their UEFI BIOS An authority that produces signed MFCI policy blobs, for example, Microsoft's cloud MFCI service from Hardware Dev Center A manufacturer process that connects the MFCI-enabled device to an MFCI policy service The Project Mu MfciPkg provides the reference code to enable device-side UEFI BIOS, and includes examples of signing authorities & processes needed to implement a solution. A Remanufacturing Example \u00b6 Conceptual Workflow \u00b6 Determine the desired 64-bit MFCI policy to be applied to the device based upon the type of remanufacturing to be performed (see MFCI Structures for more information) Read targeting information stored in OS-visible UEFI variables from the device Combine the 64-bit MFCI policy and targeting information to construct an unsigned MFCI blob Digitally sign the MFCI blob using the specified digital signing format and trusted signing keys Write the signed MFCI Policy blob to the \"next\" policy blob mailbox (a UEFI variable) on the target device Reboot the target device to trigger an installation attempt Prior to OS launch, UEFI attempts to verify the digital signature and targeting information If verification fails, the policy is deleted from the \"next\" policy blob mailbox, and the device proceeds with boot to the OS If verification succeeds, MFCI policy is applied: Callbacks are notified to perform any 1-time actions Designated action bit ranges are cleared from the policy If the policy contains persistent states, it is moved to the \"current\" policy blob mailbox, otherwise it is deleted from the \"next\" policy blob mailbox The device reboots for the new policy to take effect The device's UEFI code should now modify its behavior based upon the persistent state bits or device changes resulting from the 1-time actions If a persistent MFCI Policy was installed, it is removed by deleting the \"current\" policy blob mailbox Example Workflow Using Microsoft Tools & Services \u00b6 Boot device to FFU mode Use Microsoft-supplied tool ImageUtility.exe to read the targeting variables from the device Use Microsoft Hardware Dev Center (web portal or REST APIs) to generate the signed policy Authenticate from an authorized account Supply the targeting and policy parameters Receive the signed MFCI Policy blob for your device Use the Microsoft-supplied tool ImageUtility.exe to set the signed policy blob to a mailbox Reboot, and the new policy should take effect OEM performs customer service or re-manufacturing as needed. Note that if the device make, model, serial number, or related UEFI variables change or are deleted, the policy may no longer be valid on subsequent boots. After re-manufacturing, remove the policy using MS-supplied tool ImageUtility.exe to delete the policy Deep Dives \u00b6 MFCI Structures UEFI Integration Guide End to End Testing Guide","title":"Mfci Feature"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#manufacturer-firmware-configuration-interface-mfci","text":"","title":"Manufacturer Firmware Configuration Interface (MFCI)"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#overview","text":"","title":"Overview"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#in-a-sentence","text":"Manufacturer Firmware Configuration Interface (MFCI) is a UEFI BIOS feature that provides a secure mechanism for an authorized agent, such as an OEM or ODM, to modify firmware security properties of a specific device, typically for the purposes of remanufacturing or refurbishment.","title":"In a Sentence"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#background","text":"Manufacturing and remanufacturing (refurbishment) of devices requires configuration of settings related to safety (batteries, thermals), compliance (radio calibration, anti-theft), licensing (OA3, serial numbers), & security. These sensitive settings are typically secured by the OEM / ODM at end of manufacturing to ensure that they are not modified with malicious intent. During initial manufacturing, a device is typically not secured until the final provisioning station, after calibration and other secure data have been provisioned. After a device is secured, product demand may deviate from forecasts and a device may need to be reprovisioned for a different region, requiring modification of secured settings. Remanufacturing of devices requires executing tools and workflows that bypass this security, allowing modification of these sensitive settings, and performing potentially destructive diagnostics. The Windows 10X Compatibility Requirements prohibit unauthorized execution of these dangerous tools. The MFCI feature provides a secure path to enable remanufacturing while maintaining the Windows 10X security promise.","title":"Background"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#building-an-end-to-end-mfci-solution","text":"An MFCI-based solution requires: Devices with MFCI integrated into their UEFI BIOS An authority that produces signed MFCI policy blobs, for example, Microsoft's cloud MFCI service from Hardware Dev Center A manufacturer process that connects the MFCI-enabled device to an MFCI policy service The Project Mu MfciPkg provides the reference code to enable device-side UEFI BIOS, and includes examples of signing authorities & processes needed to implement a solution.","title":"Building an End-to-End MFCI Solution"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#a-remanufacturing-example","text":"","title":"A Remanufacturing Example"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#conceptual-workflow","text":"Determine the desired 64-bit MFCI policy to be applied to the device based upon the type of remanufacturing to be performed (see MFCI Structures for more information) Read targeting information stored in OS-visible UEFI variables from the device Combine the 64-bit MFCI policy and targeting information to construct an unsigned MFCI blob Digitally sign the MFCI blob using the specified digital signing format and trusted signing keys Write the signed MFCI Policy blob to the \"next\" policy blob mailbox (a UEFI variable) on the target device Reboot the target device to trigger an installation attempt Prior to OS launch, UEFI attempts to verify the digital signature and targeting information If verification fails, the policy is deleted from the \"next\" policy blob mailbox, and the device proceeds with boot to the OS If verification succeeds, MFCI policy is applied: Callbacks are notified to perform any 1-time actions Designated action bit ranges are cleared from the policy If the policy contains persistent states, it is moved to the \"current\" policy blob mailbox, otherwise it is deleted from the \"next\" policy blob mailbox The device reboots for the new policy to take effect The device's UEFI code should now modify its behavior based upon the persistent state bits or device changes resulting from the 1-time actions If a persistent MFCI Policy was installed, it is removed by deleting the \"current\" policy blob mailbox","title":"Conceptual Workflow"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#example-workflow-using-microsoft-tools-services","text":"Boot device to FFU mode Use Microsoft-supplied tool ImageUtility.exe to read the targeting variables from the device Use Microsoft Hardware Dev Center (web portal or REST APIs) to generate the signed policy Authenticate from an authorized account Supply the targeting and policy parameters Receive the signed MFCI Policy blob for your device Use the Microsoft-supplied tool ImageUtility.exe to set the signed policy blob to a mailbox Reboot, and the new policy should take effect OEM performs customer service or re-manufacturing as needed. Note that if the device make, model, serial number, or related UEFI variables change or are deleted, the policy may no longer be valid on subsequent boots. After re-manufacturing, remove the policy using MS-supplied tool ImageUtility.exe to delete the policy","title":"Example Workflow Using Microsoft Tools &amp; Services"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#deep-dives","text":"MFCI Structures UEFI Integration Guide End to End Testing Guide","title":"Deep Dives"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/","text":"MFCI UEFI Integration Guide \u00b6 MfciPkg Provides \u00b6 a structure for encoding a manufacturer policy that is bound to a specific device and usage instance (they are 1-time use) a definition of the structure's digital signature format, authentication & authorization a test certificate and private key for development & testing a production Microsoft certificate and Enhanced Key Usage for authorizing Microsoft's cloud MFCI service a manufacturing-line-facing UEFI interface, based upon UEFI variables, that supports creation, installation, and removal of policies a UEFI-implementor-facing UEFI interface that reports the in-effect policy and notifications of policy changes a reference UEFI implementation that handles the authentication, target validation, and structure parsing, translating signed policy blobs into actionable 64-bit policies examples of policy change handlers for Secure Boot Clear and TPM Clear tests including data and scripts that simulate the manufacturer unlock process UEFI Integration Overview \u00b6 Include MfciPkg and its dependencies in your platform Author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values. These variables MUST be set prior the EndOfDxe event. Where applicable to your platform, leverage MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes Including MfciPkg and dependencies \u00b6 FDF \u00b6 Add the following to your EDK2 Flash Descriptor File (FDF) INF MfciPkg/MfciDxe/MfciDxe.inf INF MfciPkg/MfciPei/MfciPei.inf DSC \u00b6 Including Modules \u00b6 MfciPkg provides a .dsc.inc that can be !include in your platform DSC. An example follows: !include MfciPkg/MfciPkg.dsc.inc Additionally, an instance of MfciRetrievePolicyLib will need to be specified. The default instance of MfciRetrievePolicyLibNull must be overridden. Two other instances are available in the MfciPkg, or a custom version can be authored. MfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaHob/MfciRetrievePolicyLibViaHob.inf MfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaVariable/MfciRetrievePolicyLibViaVariable.inf Including Pkcs Certificates \u00b6 Mfci Policy Blobs need to be digitally signed for the system to consume their data. The public portion of the Public/Private key needs to be included into for the MfciPkg to be able to verify policy blobs. This is done through the PCDs PcdMfciPkcs7CertBufferXdr. To help convert the Mfci Pkcs certificate into a PCD, the BinToPcd.py in MU_BASECORE can be used. Additionally, PcdMfciPkcs7RequiredLeafEKU needs to be filled out with the Extended Key Usage information. The below examples are from the Unit Test portion of this package. The Unit Test implementation can be followed to see how to convert a certificate into a binary pcd, and how to add the Extended Key Usage string into the PCD. DEFINE MFCI_POLICY_EKU_TEST = \"1.3.6.1.4.1.311.45.255.255\" # the unit test uses the test certificate that will also be used for testing end-to-end scenarios !include MfciPkg/Private/Certs/CA-test.dsc.inc gMfciPkgTokenSpaceGuid.PcdMfciPkcs7RequiredLeafEKU |$(MFCI_POLICY_EKU_TEST) # use the test version MfciPkg Dependencies \u00b6 Variable Policy Variable policy is used to protect MFCI's security data (UEFI variables) from malicious tampering EDK2's SecureBootVariableLib, specifically: DeleteSecureBootVariables() EDK2's BaseCryptLib, specifically: Pkcs7GetAttachedContent() Pkcs7Verify() VerifyEKUsInPkcs7Signature() Populating Device Targeting Variables \u00b6 An integrator must author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values. These variables MUST be set prior the EndOfDxe event. See the header file for type information on these variables, they must exactly match the contents of policies for targeting to successfully match them. Take action based upon MFCI Policy & changes \u00b6 The final piece of code integration is to enumerate the list of behaviors and actions to be supported, and activate their code by calling either MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes. State Machine \u00b6 MfciPkg's public interface defines UEFI variable mailboxes for installing and removing policy blobs, see MFCI Per-Device Targeting Variable Names A machine with no policy blob installed is deemed to have have a configuration policy value of 0x0 and is said to be running in the default customer mode, typically the most secure state with all security enabled. There are 2 groups of mailboxes prefixed with Current... and Next... . The Current... mailboxes represent the policy in effect for the current boot. The Next... mailboxes are used for queuing installation of a new policy. Boot Timeline Example \u00b6 PEI PEI is considered too early in the boot root of trust to perform policy blob validation. A pre-validated, cached copy of configuration policy is available to PEI modules via the PEI interface. Policy will not change in the PEI phase, so a policy change notification is not part of the PEI interface. If a policy change occurs later in boot, the platform is guaranteed to reboot prior to the BDS phase. DXE prior to StartOfBds Drivers that need security policy augmentation should both get the current pre-verified policy and register for notification of policy changes OEM-supplied code populates UEFI variables that communicate the Make, Model, & SN targeting information to MFCI policy driver StartOfBds event The MFCI Policy Driver will... Check for the presence of a policy. If present... Verify its signature, delete the policy on failure Verify its structure, delete the policy on failure If the resulting policy is different from the current policy, notify registered handlers, make the new policy active, reboot If a next policy is not present, and a pre-verified policy was used for this boot, roll nonces, delete the pre-verified policy, & notify registered handlers","title":"Mfci Integration Guide"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#mfci-uefi-integration-guide","text":"","title":"MFCI UEFI Integration Guide"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#mfcipkg-provides","text":"a structure for encoding a manufacturer policy that is bound to a specific device and usage instance (they are 1-time use) a definition of the structure's digital signature format, authentication & authorization a test certificate and private key for development & testing a production Microsoft certificate and Enhanced Key Usage for authorizing Microsoft's cloud MFCI service a manufacturing-line-facing UEFI interface, based upon UEFI variables, that supports creation, installation, and removal of policies a UEFI-implementor-facing UEFI interface that reports the in-effect policy and notifications of policy changes a reference UEFI implementation that handles the authentication, target validation, and structure parsing, translating signed policy blobs into actionable 64-bit policies examples of policy change handlers for Secure Boot Clear and TPM Clear tests including data and scripts that simulate the manufacturer unlock process","title":"MfciPkg Provides"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#uefi-integration-overview","text":"Include MfciPkg and its dependencies in your platform Author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values. These variables MUST be set prior the EndOfDxe event. Where applicable to your platform, leverage MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes","title":"UEFI Integration Overview"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-mfcipkg-and-dependencies","text":"","title":"Including MfciPkg and dependencies"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#fdf","text":"Add the following to your EDK2 Flash Descriptor File (FDF) INF MfciPkg/MfciDxe/MfciDxe.inf INF MfciPkg/MfciPei/MfciPei.inf","title":"FDF"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#dsc","text":"","title":"DSC"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-modules","text":"MfciPkg provides a .dsc.inc that can be !include in your platform DSC. An example follows: !include MfciPkg/MfciPkg.dsc.inc Additionally, an instance of MfciRetrievePolicyLib will need to be specified. The default instance of MfciRetrievePolicyLibNull must be overridden. Two other instances are available in the MfciPkg, or a custom version can be authored. MfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaHob/MfciRetrievePolicyLibViaHob.inf MfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaVariable/MfciRetrievePolicyLibViaVariable.inf","title":"Including Modules"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-pkcs-certificates","text":"Mfci Policy Blobs need to be digitally signed for the system to consume their data. The public portion of the Public/Private key needs to be included into for the MfciPkg to be able to verify policy blobs. This is done through the PCDs PcdMfciPkcs7CertBufferXdr. To help convert the Mfci Pkcs certificate into a PCD, the BinToPcd.py in MU_BASECORE can be used. Additionally, PcdMfciPkcs7RequiredLeafEKU needs to be filled out with the Extended Key Usage information. The below examples are from the Unit Test portion of this package. The Unit Test implementation can be followed to see how to convert a certificate into a binary pcd, and how to add the Extended Key Usage string into the PCD. DEFINE MFCI_POLICY_EKU_TEST = \"1.3.6.1.4.1.311.45.255.255\" # the unit test uses the test certificate that will also be used for testing end-to-end scenarios !include MfciPkg/Private/Certs/CA-test.dsc.inc gMfciPkgTokenSpaceGuid.PcdMfciPkcs7RequiredLeafEKU |$(MFCI_POLICY_EKU_TEST) # use the test version","title":"Including Pkcs Certificates"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#mfcipkg-dependencies","text":"Variable Policy Variable policy is used to protect MFCI's security data (UEFI variables) from malicious tampering EDK2's SecureBootVariableLib, specifically: DeleteSecureBootVariables() EDK2's BaseCryptLib, specifically: Pkcs7GetAttachedContent() Pkcs7Verify() VerifyEKUsInPkcs7Signature()","title":"MfciPkg Dependencies"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#populating-device-targeting-variables","text":"An integrator must author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values. These variables MUST be set prior the EndOfDxe event. See the header file for type information on these variables, they must exactly match the contents of policies for targeting to successfully match them.","title":"Populating Device Targeting Variables"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#take-action-based-upon-mfci-policy-changes","text":"The final piece of code integration is to enumerate the list of behaviors and actions to be supported, and activate their code by calling either MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes.","title":"Take action based upon MFCI Policy &amp; changes"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#state-machine","text":"MfciPkg's public interface defines UEFI variable mailboxes for installing and removing policy blobs, see MFCI Per-Device Targeting Variable Names A machine with no policy blob installed is deemed to have have a configuration policy value of 0x0 and is said to be running in the default customer mode, typically the most secure state with all security enabled. There are 2 groups of mailboxes prefixed with Current... and Next... . The Current... mailboxes represent the policy in effect for the current boot. The Next... mailboxes are used for queuing installation of a new policy.","title":"State Machine"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#boot-timeline-example","text":"PEI PEI is considered too early in the boot root of trust to perform policy blob validation. A pre-validated, cached copy of configuration policy is available to PEI modules via the PEI interface. Policy will not change in the PEI phase, so a policy change notification is not part of the PEI interface. If a policy change occurs later in boot, the platform is guaranteed to reboot prior to the BDS phase. DXE prior to StartOfBds Drivers that need security policy augmentation should both get the current pre-verified policy and register for notification of policy changes OEM-supplied code populates UEFI variables that communicate the Make, Model, & SN targeting information to MFCI policy driver StartOfBds event The MFCI Policy Driver will... Check for the presence of a policy. If present... Verify its signature, delete the policy on failure Verify its structure, delete the policy on failure If the resulting policy is different from the current policy, notify registered handlers, make the new policy active, reboot If a next policy is not present, and a pre-verified policy was used for this boot, roll nonces, delete the pre-verified policy, & notify registered handlers","title":"Boot Timeline Example"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/","text":"MFCI Structures \u00b6 Policy \u00b6 MFCI provides 64 bits of configuration policy, 32 bits to be defined by Microsoft, 32 bits reserved for OEM definition. Each 32-bit range is split into two 16-bit ranges, one for state that persists across reboots for the duration a policy is installed, and one for 1-time actions that are triggered once at policy installation. Example actions include Microsoft-defined Secure Boot clear and TPM clear. An example state might be \"OEM Manufacturing Mode foo\", which enables modification of secure configuration. Structure Definition Policy Blob \u00b6 An MFCI policy blob is a structure that contains the aforementioned 64-bit configuration policy, along with device targeting information including OEM, model, serial number, 2 OEM-defined fields, & a security nonce. To prevent tampering and provide authentication & authorization, MFCI policy blobs are digitally signed using the attached, embedded PKCS7 format (not the detached format as is used elsewhere in UEFI). Authentication of MFCI blobs leverages both a trust anchor public certificate that must be present in the blob's signing chain, and an Enhanced Key Usage (EKU) that must be present on the leaf certificate signer. By default, MfciPkg trusts a provided test certificate chain when SHIP_MODE==FALSE , otherwise the certificate and EKU specified by the Microsoft MFCI cloud signing service. At runtime, a UEFI implementor may consider the policy blobs to be opaque, as MfciPkg's private parsing lib handles the task of authenticating, verifying targeting, and parsing the blobs down to the 64-bit policies. For the purpose of testing, a python library and commandline wrappers are provided to facilitate creation of signed MFCI policies. https://github.com/tianocore/edk2-pytool-library/blob/master/docs/features/windows_firmware_policy.md https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_firmware_policy_tool.md Targeting Information \u00b6 Policies are targeted at specific devices via Make (OEM), Model, Serial Number, Nonce, and 2 optional, OEM-defined fields. The Nonce is a randomly-generated 64-bit integer, and the remaining fields are unescaped, WIDE NULL-terminated UTF-16LE strings. Digital Signature \u00b6 The PKCS7 digital signature format familiar to the UEFI ecosystem is used with 2 key differences. First, a full PKCS7 is used, not the SignedData subset used by authenticated variables. Second, the P7 is embedded, not detatched. The policy targeting and flavor information are embedded in a PKCS 7 Data inside the full PKCS 7 Signed object. Signed Packet Example \u00b6 certutil.exe -asn output for an example MFCI Policy packet (signed) is as follows: 0000: 30 82 0e 6c ; SEQUENCE (e6c Bytes) 0004: 06 09 ; OBJECT_ID (9 Bytes) 0006: | 2a 86 48 86 f7 0d 01 07 02 | ; 1.2.840.113549.1.7.2 PKCS 7 Signed 000f: a0 82 0e 5d ; OPTIONAL[0] (e5d Bytes) 0013: 30 82 0e 59 ; SEQUENCE (e59 Bytes) 0017: 02 01 ; INTEGER (1 Bytes) 0019: | 01 001a: 31 0f ; SET (f Bytes) 001c: | 30 0d ; SEQUENCE (d Bytes) 001e: | 06 09 ; OBJECT_ID (9 Bytes) 0020: | | 60 86 48 01 65 03 04 02 01 | | ; 2.16.840.1.101.3.4.2.1 sha256 (sha256NoSign) 0029: | 05 00 ; NULL (0 Bytes) 002b: 30 82 02 17 ; SEQUENCE (217 Bytes) 002f: | 06 09 ; OBJECT_ID (9 Bytes) 0031: | | 2a 86 48 86 f7 0d 01 07 01 | | ; 1.2.840.113549.1.7.1 PKCS 7 Data 003a: | a0 82 02 08 ; OPTIONAL[0] (208 Bytes) 003e: | 04 82 02 04 ; OCTET_STRING (204 Bytes) [policy payload starts here] 0042: | 02 00 01 00 00 00 08 f8 e6 5a 84 83 b9 4e a2 3a ; .........Z...N.: 0052: | 0c cc 10 93 e3 dd 00 00 00 00 00 00 00 00 07 00 ; ................ 0062: | 00 00 10 ef 00 00 00 00 0e 00 00 00 28 00 00 00 ; ............(... 0072: | 00 00 10 ef 58 00 00 00 66 00 00 00 76 00 00 00 ; ....X...f...v... 0082: | 00 00 10 ef 8e 00 00 00 9c 00 00 00 b6 00 00 00 ; ................ 0092: | 00 00 10 ef e0 00 00 00 ee 00 00 00 fc 00 00 00 ; ................ 00a2: | 00 00 10 ef 0e 01 00 00 1c 01 00 00 2a 01 00 00 ; ............*... 00b2: | 00 00 10 ef 2e 01 00 00 3c 01 00 00 48 01 00 00 ; ........<...H... 00c2: | 00 00 10 ef 52 01 00 00 5c 01 00 00 6a 01 00 00 ; ....R...\\...j... 00d2: | 0c 00 54 00 61 00 72 00 67 00 65 00 74 00 18 00 ; ..T.a.r.g.e.t... 00e2: | 4d 00 61 00 6e 00 75 00 66 00 61 00 63 00 74 00 ; M.a.n.u.f.a.c.t. 00f2: | 75 00 72 00 65 00 72 00 00 00 2c 00 43 00 6f 00 ; u.r.e.r...,.C.o. 0102: | 6e 00 74 00 6f 00 73 00 6f 00 20 00 43 00 6f 00 ; n.t.o.s.o. .C.o. 0112: | 6d 00 70 00 75 00 74 00 65 00 72 00 73 00 2c 00 ; m.p.u.t.e.r.s.,. 0122: | 20 00 4c 00 4c 00 43 00 0c 00 54 00 61 00 72 00 ; .L.L.C...T.a.r. 0132: | 67 00 65 00 74 00 0e 00 50 00 72 00 6f 00 64 00 ; g.e.t...P.r.o.d. 0142: | 75 00 63 00 74 00 00 00 14 00 4c 00 61 00 70 00 ; u.c.t.....L.a.p. 0152: | 74 00 6f 00 70 00 20 00 46 00 6f 00 6f 00 0c 00 ; t.o.p. .F.o.o... 0162: | 54 00 61 00 72 00 67 00 65 00 74 00 18 00 53 00 ; T.a.r.g.e.t...S. 0172: | 65 00 72 00 69 00 61 00 6c 00 4e 00 75 00 6d 00 ; e.r.i.a.l.N.u.m. 0182: | 62 00 65 00 72 00 00 00 26 00 46 00 30 00 30 00 ; b.e.r...&.F.0.0. 0192: | 31 00 33 00 2d 00 30 00 30 00 30 00 32 00 34 00 ; 1.3.-.0.0.0.2.4. 01a2: | 33 00 35 00 34 00 36 00 2d 00 58 00 30 00 32 00 ; 3.5.4.6.-.X.0.2. 01b2: | 0c 00 54 00 61 00 72 00 67 00 65 00 74 00 0c 00 ; ..T.a.r.g.e.t... 01c2: | 4f 00 45 00 4d 00 5f 00 30 00 31 00 00 00 0e 00 ; O.E.M._.0.1..... 01d2: | 4f 00 44 00 4d 00 20 00 46 00 6f 00 6f 00 0c 00 ; O.D.M. .F.o.o... 01e2: | 54 00 61 00 72 00 67 00 65 00 74 00 0c 00 4f 00 ; T.a.r.g.e.t...O. 01f2: | 45 00 4d 00 5f 00 30 00 32 00 00 00 00 00 0c 00 ; E.M._.0.2....... 0202: | 54 00 61 00 72 00 67 00 65 00 74 00 0a 00 4e 00 ; T.a.r.g.e.t...N. 0212: | 6f 00 6e 00 63 00 65 00 05 00 ef cd ab 89 67 45 ; o.n.c.e.......gE 0222: | 23 01 08 00 55 00 45 00 46 00 49 00 0c 00 50 00 ; #...U.E.F.I...P. 0232: | 6f 00 6c 00 69 00 63 00 79 00 05 00 03 00 00 00 ; o.l.i.c.y....... 0242: | 00 00 00 00 ; .... [policy payload ends here] [digital signature continues but is not shown here]","title":"Mfci Structures"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#mfci-structures","text":"","title":"MFCI Structures"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#policy","text":"MFCI provides 64 bits of configuration policy, 32 bits to be defined by Microsoft, 32 bits reserved for OEM definition. Each 32-bit range is split into two 16-bit ranges, one for state that persists across reboots for the duration a policy is installed, and one for 1-time actions that are triggered once at policy installation. Example actions include Microsoft-defined Secure Boot clear and TPM clear. An example state might be \"OEM Manufacturing Mode foo\", which enables modification of secure configuration. Structure Definition","title":"Policy"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#policy-blob","text":"An MFCI policy blob is a structure that contains the aforementioned 64-bit configuration policy, along with device targeting information including OEM, model, serial number, 2 OEM-defined fields, & a security nonce. To prevent tampering and provide authentication & authorization, MFCI policy blobs are digitally signed using the attached, embedded PKCS7 format (not the detached format as is used elsewhere in UEFI). Authentication of MFCI blobs leverages both a trust anchor public certificate that must be present in the blob's signing chain, and an Enhanced Key Usage (EKU) that must be present on the leaf certificate signer. By default, MfciPkg trusts a provided test certificate chain when SHIP_MODE==FALSE , otherwise the certificate and EKU specified by the Microsoft MFCI cloud signing service. At runtime, a UEFI implementor may consider the policy blobs to be opaque, as MfciPkg's private parsing lib handles the task of authenticating, verifying targeting, and parsing the blobs down to the 64-bit policies. For the purpose of testing, a python library and commandline wrappers are provided to facilitate creation of signed MFCI policies. https://github.com/tianocore/edk2-pytool-library/blob/master/docs/features/windows_firmware_policy.md https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_firmware_policy_tool.md","title":"Policy Blob"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#targeting-information","text":"Policies are targeted at specific devices via Make (OEM), Model, Serial Number, Nonce, and 2 optional, OEM-defined fields. The Nonce is a randomly-generated 64-bit integer, and the remaining fields are unescaped, WIDE NULL-terminated UTF-16LE strings.","title":"Targeting Information"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#digital-signature","text":"The PKCS7 digital signature format familiar to the UEFI ecosystem is used with 2 key differences. First, a full PKCS7 is used, not the SignedData subset used by authenticated variables. Second, the P7 is embedded, not detatched. The policy targeting and flavor information are embedded in a PKCS 7 Data inside the full PKCS 7 Signed object.","title":"Digital Signature"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#signed-packet-example","text":"certutil.exe -asn output for an example MFCI Policy packet (signed) is as follows: 0000: 30 82 0e 6c ; SEQUENCE (e6c Bytes) 0004: 06 09 ; OBJECT_ID (9 Bytes) 0006: | 2a 86 48 86 f7 0d 01 07 02 | ; 1.2.840.113549.1.7.2 PKCS 7 Signed 000f: a0 82 0e 5d ; OPTIONAL[0] (e5d Bytes) 0013: 30 82 0e 59 ; SEQUENCE (e59 Bytes) 0017: 02 01 ; INTEGER (1 Bytes) 0019: | 01 001a: 31 0f ; SET (f Bytes) 001c: | 30 0d ; SEQUENCE (d Bytes) 001e: | 06 09 ; OBJECT_ID (9 Bytes) 0020: | | 60 86 48 01 65 03 04 02 01 | | ; 2.16.840.1.101.3.4.2.1 sha256 (sha256NoSign) 0029: | 05 00 ; NULL (0 Bytes) 002b: 30 82 02 17 ; SEQUENCE (217 Bytes) 002f: | 06 09 ; OBJECT_ID (9 Bytes) 0031: | | 2a 86 48 86 f7 0d 01 07 01 | | ; 1.2.840.113549.1.7.1 PKCS 7 Data 003a: | a0 82 02 08 ; OPTIONAL[0] (208 Bytes) 003e: | 04 82 02 04 ; OCTET_STRING (204 Bytes) [policy payload starts here] 0042: | 02 00 01 00 00 00 08 f8 e6 5a 84 83 b9 4e a2 3a ; .........Z...N.: 0052: | 0c cc 10 93 e3 dd 00 00 00 00 00 00 00 00 07 00 ; ................ 0062: | 00 00 10 ef 00 00 00 00 0e 00 00 00 28 00 00 00 ; ............(... 0072: | 00 00 10 ef 58 00 00 00 66 00 00 00 76 00 00 00 ; ....X...f...v... 0082: | 00 00 10 ef 8e 00 00 00 9c 00 00 00 b6 00 00 00 ; ................ 0092: | 00 00 10 ef e0 00 00 00 ee 00 00 00 fc 00 00 00 ; ................ 00a2: | 00 00 10 ef 0e 01 00 00 1c 01 00 00 2a 01 00 00 ; ............*... 00b2: | 00 00 10 ef 2e 01 00 00 3c 01 00 00 48 01 00 00 ; ........<...H... 00c2: | 00 00 10 ef 52 01 00 00 5c 01 00 00 6a 01 00 00 ; ....R...\\...j... 00d2: | 0c 00 54 00 61 00 72 00 67 00 65 00 74 00 18 00 ; ..T.a.r.g.e.t... 00e2: | 4d 00 61 00 6e 00 75 00 66 00 61 00 63 00 74 00 ; M.a.n.u.f.a.c.t. 00f2: | 75 00 72 00 65 00 72 00 00 00 2c 00 43 00 6f 00 ; u.r.e.r...,.C.o. 0102: | 6e 00 74 00 6f 00 73 00 6f 00 20 00 43 00 6f 00 ; n.t.o.s.o. .C.o. 0112: | 6d 00 70 00 75 00 74 00 65 00 72 00 73 00 2c 00 ; m.p.u.t.e.r.s.,. 0122: | 20 00 4c 00 4c 00 43 00 0c 00 54 00 61 00 72 00 ; .L.L.C...T.a.r. 0132: | 67 00 65 00 74 00 0e 00 50 00 72 00 6f 00 64 00 ; g.e.t...P.r.o.d. 0142: | 75 00 63 00 74 00 00 00 14 00 4c 00 61 00 70 00 ; u.c.t.....L.a.p. 0152: | 74 00 6f 00 70 00 20 00 46 00 6f 00 6f 00 0c 00 ; t.o.p. .F.o.o... 0162: | 54 00 61 00 72 00 67 00 65 00 74 00 18 00 53 00 ; T.a.r.g.e.t...S. 0172: | 65 00 72 00 69 00 61 00 6c 00 4e 00 75 00 6d 00 ; e.r.i.a.l.N.u.m. 0182: | 62 00 65 00 72 00 00 00 26 00 46 00 30 00 30 00 ; b.e.r...&.F.0.0. 0192: | 31 00 33 00 2d 00 30 00 30 00 30 00 32 00 34 00 ; 1.3.-.0.0.0.2.4. 01a2: | 33 00 35 00 34 00 36 00 2d 00 58 00 30 00 32 00 ; 3.5.4.6.-.X.0.2. 01b2: | 0c 00 54 00 61 00 72 00 67 00 65 00 74 00 0c 00 ; ..T.a.r.g.e.t... 01c2: | 4f 00 45 00 4d 00 5f 00 30 00 31 00 00 00 0e 00 ; O.E.M._.0.1..... 01d2: | 4f 00 44 00 4d 00 20 00 46 00 6f 00 6f 00 0c 00 ; O.D.M. .F.o.o... 01e2: | 54 00 61 00 72 00 67 00 65 00 74 00 0c 00 4f 00 ; T.a.r.g.e.t...O. 01f2: | 45 00 4d 00 5f 00 30 00 32 00 00 00 00 00 0c 00 ; E.M._.0.2....... 0202: | 54 00 61 00 72 00 67 00 65 00 74 00 0a 00 4e 00 ; T.a.r.g.e.t...N. 0212: | 6f 00 6e 00 63 00 65 00 05 00 ef cd ab 89 67 45 ; o.n.c.e.......gE 0222: | 23 01 08 00 55 00 45 00 46 00 49 00 0c 00 50 00 ; #...U.E.F.I...P. 0232: | 6f 00 6c 00 69 00 63 00 79 00 05 00 03 00 00 00 ; o.l.i.c.y....... 0242: | 00 00 00 00 ; .... [policy payload ends here] [digital signature continues but is not shown here]","title":"Signed Packet Example"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/","text":"MFCI Device ID Support Library: NULL interface \u00b6 About \u00b6 Platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in MfciVariables.h . Alternatively, then can implement this library. MfciDxe will invoke this library if it cannot find variables just before EndOfDxe. Refer to MfciPkg/Include/MfciVariables.h , \"Targeting Variable Names\" for additional details on the strings to return. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mfci Device Id Support Lib Null"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/#mfci-device-id-support-library-null-interface","text":"","title":"MFCI Device ID Support Library: NULL interface"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/#about","text":"Platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in MfciVariables.h . Alternatively, then can implement this library. MfciDxe will invoke this library if it cannot find variables just before EndOfDxe. Refer to MfciPkg/Include/MfciVariables.h , \"Targeting Variable Names\" for additional details on the strings to return.","title":"About"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/","text":"MFCI Device ID Support Library: SMBIOS instance example \u00b6 Background \u00b6 MFCI-compatible platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in MfciVariables.h . Alternatively, then can implement an instance of MFCI Device ID Support Library. Refer to MfciDeviceIdSupportLib.h for this library's interface. About \u00b6 This example instance of MfciDeviceIdSupportLib leverages EFI_SMBIOS_PROTOCOL to implement the library interface. This library is invoked by MfciDxe in an event that triggers immediately prior to EndOfDxe, and expects all SMBIOS values leveraged to be populated with correct MFCI targeting values at that time. A platform might accomplish this by populating SMBIOS values in another driver's entry point, constructor, or in an event upon arrival of EFI_SMBIOS_PROTOCOL . To leverage this library, add the following to your platform DSC: [LibraryClasses] MfciDeviceIdSupportLib|MfciPkg/Library/MfciDeviceIdSupportLibSmbios/MfciDeviceIdSupportLibSmbios.inf Copyright \u00b6 Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mfci Device Id Support Lib Smbios"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#mfci-device-id-support-library-smbios-instance-example","text":"","title":"MFCI Device ID Support Library: SMBIOS instance example"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#background","text":"MFCI-compatible platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in MfciVariables.h . Alternatively, then can implement an instance of MFCI Device ID Support Library. Refer to MfciDeviceIdSupportLib.h for this library's interface.","title":"Background"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#about","text":"This example instance of MfciDeviceIdSupportLib leverages EFI_SMBIOS_PROTOCOL to implement the library interface. This library is invoked by MfciDxe in an event that triggers immediately prior to EndOfDxe, and expects all SMBIOS values leveraged to be populated with correct MFCI targeting values at that time. A platform might accomplish this by populating SMBIOS values in another driver's entry point, constructor, or in an event upon arrival of EFI_SMBIOS_PROTOCOL . To leverage this library, add the following to your platform DSC: [LibraryClasses] MfciDeviceIdSupportLib|MfciPkg/Library/MfciDeviceIdSupportLibSmbios/MfciDeviceIdSupportLibSmbios.inf","title":"About"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/","text":"MfciRetrievePolicyLib: NULL edition \u00b6 About \u00b6 Platforms are not generally expected to implement this library, as MFCI carries known implementations, thus it's header is under MfciPkg/Private/... This library abstracts where MfciDxe retrieves the cached, current policy. On platforms with a PEI phase, it may retrieve the policy from a HOB. On platforms that lack a PEI phase, it may retrieve the policy from a UEFI variable. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mfci Retrieve Policy Lib Null"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/#mfciretrievepolicylib-null-edition","text":"","title":"MfciRetrievePolicyLib: NULL edition"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/#about","text":"Platforms are not generally expected to implement this library, as MFCI carries known implementations, thus it's header is under MfciPkg/Private/... This library abstracts where MfciDxe retrieves the cached, current policy. On platforms with a PEI phase, it may retrieve the policy from a HOB. On platforms that lack a PEI phase, it may retrieve the policy from a UEFI variable.","title":"About"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/","text":"MfciRetrievePolicyLib: HOB edition \u00b6 About \u00b6 This library implements retrieving the current, cached policy from a HOB. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mfci Retrieve Policy Lib Via Hob"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/#mfciretrievepolicylib-hob-edition","text":"","title":"MfciRetrievePolicyLib: HOB edition"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/#about","text":"This library implements retrieving the current, cached policy from a HOB.","title":"About"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/","text":"MfciRetrievePolicyLib: UEFI variable edition \u00b6 About \u00b6 This library implements retrieving the current, cached policy from a UEFI variable. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mfci Retrieve Policy Lib Via Variable"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/#mfciretrievepolicylib-uefi-variable-edition","text":"","title":"MfciRetrievePolicyLib: UEFI variable edition"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/#about","text":"This library implements retrieving the current, cached policy from a UEFI variable.","title":"About"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/","text":"ACPI RGRT \u00b6 About \u00b6 The Regulatory Graphics Resource Table is an entry into the ACPI table. It provides a way to publish a PNG with the regulatory information of a given product. This could include FCC id, UL, Model number, or CMIIT ID just to name a few. This driver publishes that entry in the ACPI table to be picked up by the OS later to display for regulatory reasons. The table definition \u00b6 The format of the table is defined by a pending addition to the ACPI spec here: and consists of a standard ACPI header along with an RGRT payload. At time of writing, the only image format supported by RGRT is PNG. Using in your project \u00b6 Using this is as simple as including the INF in both your DSC and FDF. You will also need to define the PCD you use in the FDF file in your DEC file. DSC: [Components] MsCorePkg/AcpiRGRT/AcpiRgrt.inf FDF: [FV.FVDXE] # Regulatory Graphic Driver INF MsCorePkg/AcpiRGRT/AcpiRgrt.inf FILE FREEFORM = PCD(gMsCorePkgTokenSpaceGuid.PcdRegulatoryGraphicFileGuid) { SECTION RAW = $(GRAPHICS_RESOURCES)/RGRT.png } Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Acpi RGRT"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#acpi-rgrt","text":"","title":"ACPI RGRT"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#about","text":"The Regulatory Graphics Resource Table is an entry into the ACPI table. It provides a way to publish a PNG with the regulatory information of a given product. This could include FCC id, UL, Model number, or CMIIT ID just to name a few. This driver publishes that entry in the ACPI table to be picked up by the OS later to display for regulatory reasons.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#the-table-definition","text":"The format of the table is defined by a pending addition to the ACPI spec here: and consists of a standard ACPI header along with an RGRT payload. At time of writing, the only image format supported by RGRT is PNG.","title":"The table definition"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#using-in-your-project","text":"Using this is as simple as including the INF in both your DSC and FDF. You will also need to define the PCD you use in the FDF file in your DEC file. DSC: [Components] MsCorePkg/AcpiRGRT/AcpiRgrt.inf FDF: [FV.FVDXE] # Regulatory Graphic Driver INF MsCorePkg/AcpiRGRT/AcpiRgrt.inf FILE FREEFORM = PCD(gMsCorePkgTokenSpaceGuid.PcdRegulatoryGraphicFileGuid) { SECTION RAW = $(GRAPHICS_RESOURCES)/RGRT.png }","title":"Using in your project"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/","text":"CapsuleRuntimeDxe \u00b6 Supports the UpdateCapsule and QueryCapsuleCapabilities runtime services. This driver does not apply capsules. This driver uses a DXE protocol (gCapsuleServiceProtocolGuid) to provide these services. Once ExitBootServices has been signaled, the driver will always return EFI_UNSUPPORTED for both calls. Why A Protocol \u00b6 This is done for binary size reduction and library simplification. Because this isn't a \"true\" runtime driver (it effectively becomes a NOP at runtime), libraries that would be leveraged by this runtime service would need to support runtime. This choice poses a challenge because this driver isn't a \"true\" runtime driver so many of the libraries need to support runtime dxe in name only. This nuance can cause problems if an attempt is made to use these libraries in a runtime driver. Protocol Producer \u00b6 Currently CapsuleServiceProtocolDxe is the primary producer of the gCapsuleServiceProtocolGuid protocol - there is additional documentation there, including a flow chart of the capsule update process.","title":"Capsule Runtime Dxe"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/#capsuleruntimedxe","text":"Supports the UpdateCapsule and QueryCapsuleCapabilities runtime services. This driver does not apply capsules. This driver uses a DXE protocol (gCapsuleServiceProtocolGuid) to provide these services. Once ExitBootServices has been signaled, the driver will always return EFI_UNSUPPORTED for both calls.","title":"CapsuleRuntimeDxe"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/#why-a-protocol","text":"This is done for binary size reduction and library simplification. Because this isn't a \"true\" runtime driver (it effectively becomes a NOP at runtime), libraries that would be leveraged by this runtime service would need to support runtime. This choice poses a challenge because this driver isn't a \"true\" runtime driver so many of the libraries need to support runtime dxe in name only. This nuance can cause problems if an attempt is made to use these libraries in a runtime driver.","title":"Why A Protocol"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/#protocol-producer","text":"Currently CapsuleServiceProtocolDxe is the primary producer of the gCapsuleServiceProtocolGuid protocol - there is additional documentation there, including a flow chart of the capsule update process.","title":"Protocol Producer"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServicePei/ReadMe/","text":"CapsuleServicePei \u00b6 Produces the capsule PPI which currently only fully implements the CheckCapsuleUpdate functionality. Everything else returns success or unsupported, as it is related to capsule coalescing. This is needed as there is often infrastructure which detects FlashUpdate as a boot mode and attempts to find this PPI to check to make sure we actually have a capsule. So, we produce a simple PPI to satisfy that requirement.","title":"Capsule Service Pei"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServicePei/ReadMe/#capsuleservicepei","text":"Produces the capsule PPI which currently only fully implements the CheckCapsuleUpdate functionality. Everything else returns success or unsupported, as it is related to capsule coalescing. This is needed as there is often infrastructure which detects FlashUpdate as a boot mode and attempts to find this PPI to check to make sure we actually have a capsule. So, we produce a simple PPI to satisfy that requirement.","title":"CapsuleServicePei"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/","text":"Capsule Service Protocol DXE \u00b6 This driver produces a protocol (gCapsuleServiceProtocolGuid) which can be used by the CapsuleRuntimeService. There is a readme which details why a protocol was used in that folder (see CapsuleRuntimeDxe ). This protocol does not apply capsules. It combines CapsuleLib, PersistLib, and CapsuleRuntimeDxe. It is significantly less configurable and is focused on reducing attack surface. Constraints Introduced in Comparison to the Traditional Capsule Runtime mechanism \u00b6 MRC does not preserve memory. We do a warm reset but make no guarantee that memory is preserved. Capsules will not be applied at runtime. All capsules will do a reset before applying. Option roms are not supported. Embedded Drivers inside of Capsules are not supported. Implementation \u00b6 Flow chart \u00b6 Here is a flow chart that should explain the overall flow of the capsule system. The new system stores capsules on the EFI partition of the main disk. While it shares many similarities to Capsule on Disk, it is significantly more opinionated and has few modes of operation/configuration. It has a few additional security features as well. Capsules are staged by the OS by calling the Runtime service UpdateCapsule . The capsule header is given a quick sanity check, hashed, given a unique ID, and saved to the EFI partition. Once saved, a variable is created to keep track of the capsules which have been saved and are processed in a first in, first out manner. Libraries \u00b6 Two other pieces of capsule infrastructure are leveraged by this driver: IsCapsuleSupportedLib and CapsulePersistenceLib. These libraries are used to validate a capsule as well as manage the storage of capsules. This driver also uses QueueLib to keep track of capsules that have been persisted. Each library has a readme containing further information located in their respective folders. Further Notes \u00b6 The first time a capsule is persisted, we clear the Capsules folder on the disk to remove stale files. The only way to stage a capsule is by calling the Runtime service. Currently there are no plans to support capsules that are placed manually in the Capsules folder. Next Boot Path \u00b6 Before the system is reset, the variable PreviousCapsuleCount is set to zero. This variable signals that capsules are present. It is zero as it is a marker of the number of capsules on the last boot. If we set it to the current number of capsules, we would detect it as no progress being made, and would abort.","title":"Capsule Service Protocol Dxe"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#capsule-service-protocol-dxe","text":"This driver produces a protocol (gCapsuleServiceProtocolGuid) which can be used by the CapsuleRuntimeService. There is a readme which details why a protocol was used in that folder (see CapsuleRuntimeDxe ). This protocol does not apply capsules. It combines CapsuleLib, PersistLib, and CapsuleRuntimeDxe. It is significantly less configurable and is focused on reducing attack surface.","title":"Capsule Service Protocol DXE"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#constraints-introduced-in-comparison-to-the-traditional-capsule-runtime-mechanism","text":"MRC does not preserve memory. We do a warm reset but make no guarantee that memory is preserved. Capsules will not be applied at runtime. All capsules will do a reset before applying. Option roms are not supported. Embedded Drivers inside of Capsules are not supported.","title":"Constraints Introduced in Comparison to the Traditional Capsule Runtime mechanism"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#implementation","text":"","title":"Implementation"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#flow-chart","text":"Here is a flow chart that should explain the overall flow of the capsule system. The new system stores capsules on the EFI partition of the main disk. While it shares many similarities to Capsule on Disk, it is significantly more opinionated and has few modes of operation/configuration. It has a few additional security features as well. Capsules are staged by the OS by calling the Runtime service UpdateCapsule . The capsule header is given a quick sanity check, hashed, given a unique ID, and saved to the EFI partition. Once saved, a variable is created to keep track of the capsules which have been saved and are processed in a first in, first out manner.","title":"Flow chart"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#libraries","text":"Two other pieces of capsule infrastructure are leveraged by this driver: IsCapsuleSupportedLib and CapsulePersistenceLib. These libraries are used to validate a capsule as well as manage the storage of capsules. This driver also uses QueueLib to keep track of capsules that have been persisted. Each library has a readme containing further information located in their respective folders.","title":"Libraries"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#further-notes","text":"The first time a capsule is persisted, we clear the Capsules folder on the disk to remove stale files. The only way to stage a capsule is by calling the Runtime service. Currently there are no plans to support capsules that are placed manually in the Capsules folder.","title":"Further Notes"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#next-boot-path","text":"Before the system is reset, the variable PreviousCapsuleCount is set to zero. This variable signals that capsules are present. It is zero as it is a marker of the number of capsules on the last boot. If we set it to the current number of capsules, we would detect it as no progress being made, and would abort.","title":"Next Boot Path"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/","text":"CheckHardwareConnected \u00b6 About \u00b6 This driver determines at boot if the specified pci devices found in the DeviceSpecificBusInfoLib library are properly connected Usage \u00b6 To employ this driver, simply build it and supply the DeviceSpecificBusInfoLib which implements the DeviceSpecificBusInfoLib.h interface. The info for each PCI device will be contained within the DEVICE_PCI_INFO struct which contains fields: DeviceName: A friendly name for the device. This Ascii name will be contained within the AdditionalInfo2 field of the MU_TELEMETRY_CPER_SECTION_DATA telemetry struct. IsFatal: A boolean which if true states that the pci device being absent crashes the device upon OS boot SegmentNumber , BusNumber , DeviceNumber , FunctionNumber : Info required to locate the PCI device MinimumLinkSpeed The minimum link speed expected for the PCI device The library interface consists of two functions: GetPciCheckDevices() : Populates an array of pointers to DEVICE_PCI_INFO structs. The pointer to the unallocated array is passed in as an argument and should be allocated within the function. The DEVICE_PCI_INFO structs should be global variables in the library and the array should contain their addresses. Function returns the number of DEVICE_PCI_INFO struct pointers within the allocated array. ProcessPciDeviceResults() : Accepts an array of PCI device check results in the form of a pointer to a type of DEVICE_PCI_CHECK_RESULT and performs custom actions based upon the results. If there are specific cases when you do not want to check for certain PCI devices (such as when a device has been purposefully disabled), simply exclude the DEVICE_PCI_INFO associated with that device when allocating and returning the array. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Check Hardware Connected"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#checkhardwareconnected","text":"","title":"CheckHardwareConnected"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#about","text":"This driver determines at boot if the specified pci devices found in the DeviceSpecificBusInfoLib library are properly connected","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#usage","text":"To employ this driver, simply build it and supply the DeviceSpecificBusInfoLib which implements the DeviceSpecificBusInfoLib.h interface. The info for each PCI device will be contained within the DEVICE_PCI_INFO struct which contains fields: DeviceName: A friendly name for the device. This Ascii name will be contained within the AdditionalInfo2 field of the MU_TELEMETRY_CPER_SECTION_DATA telemetry struct. IsFatal: A boolean which if true states that the pci device being absent crashes the device upon OS boot SegmentNumber , BusNumber , DeviceNumber , FunctionNumber : Info required to locate the PCI device MinimumLinkSpeed The minimum link speed expected for the PCI device The library interface consists of two functions: GetPciCheckDevices() : Populates an array of pointers to DEVICE_PCI_INFO structs. The pointer to the unallocated array is passed in as an argument and should be allocated within the function. The DEVICE_PCI_INFO structs should be global variables in the library and the array should contain their addresses. Function returns the number of DEVICE_PCI_INFO struct pointers within the allocated array. ProcessPciDeviceResults() : Accepts an array of PCI device check results in the form of a pointer to a type of DEVICE_PCI_CHECK_RESULT and performs custom actions based upon the results. If there are specific cases when you do not want to check for certain PCI devices (such as when a device has been purposefully disabled), simply exclude the DEVICE_PCI_INFO associated with that device when allocating and returning the array.","title":"Usage"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/","text":"GuidedSectionExtract \u00b6 About \u00b6 A version of GuidedSectionExtract without decompression. By moving decompression to DXE, a PEI FV that is tight on space, may have a little more room if decompression code is moved to DXE, and swapped for an uncompressed DxeIplPeim. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Guided Section Extract Peim"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/#guidedsectionextract","text":"","title":"GuidedSectionExtract"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/#about","text":"A version of GuidedSectionExtract without decompression. By moving decompression to DXE, a PEI FV that is tight on space, may have a little more room if decompression code is moved to DXE, and swapped for an uncompressed DxeIplPeim.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/","text":"Debug File Logger II \u00b6 NOTE: Superseded by the AdvLoggerPkg. This is Debug File Logger II. Debug File Logger was tried a few times with varying degrees of success. It was thought that the not quite right USB stack was the issue with the Debug File Logger. When the Debug File Logger was enabled to write logs in the ESP (EFI System Partition) on the NVMe drive, there would be systems that would no longer boot. Over time, we have found that there were issues in the Windows FAT file system driver across hibernate where the OS assumed no change to the file system metadata (The FAT and Directory Entries) causing irreparable damage to the ESP. Top design points \u00b6 The debug log files are pre-allocated the first time they are needed on a particular device. Every SimpleFileSystem device that is connected during POST is eligible to be a log device. A USB device must have a directory in the root named 'Logs' to be considered a log device. The NVMe device(s) will get a hidden directory named 'Logs' the first time is is mounted. The time to create the initial logs is about 2 seconds. The time to register the logs during subsequent time through POST is about 2ms. The logs can be obtained in the OS or by booting to the Shell. In the OS, mount the ESP using: mountvol P: /S The drive letter can be any available drive letter. Logs will be recorded at: When a registered device is connected When just prior to ExitBootServices to any previously registered devices When the system is reset (from TPL <= TPL_CALLBACK) to any previously registered devices If you want to collect logs on a USB device, you can insert the non-bootable USB drive with the Logs directory installed, then power on the system and hold VOL/- to attempt booting from USB. This will mount the USB filesystem, the Logs directory will be acknowledged, and the log written. The system will continue to boot and should append the rest of the log at ExitBootServices. Future items \u00b6 Should there be more suggestions for future items, post them at Microsoft Mu Issues Some features under considerations: Refactor DebugLib again to insure logs are collected during the whole boot. Add a new feature to DebugLib to capture the full UEFI log, but only send selected entries to the serial port (to handle devices with a slow serial port). Always connect the NVMe drive at console connect. For 99.9% of the cases, the system is going to boot the NVMe drive, so connecting it early would not significantly change the boot time, but would allow logs to be collected in more cases. When the log cannot be written (too high of TPL for the FileSystem to work), have a method to store the last 100 lines or so of the log somewhere (system dependent) that can be collected on the next boot. Timestamp the head of the log to assist in sorting logs. Installation Instructions \u00b6 Replace the current Pei/DebugFileLoggerPei.inf and /Dxe/DebugFileLogger.inf with the new versions. Delete the DebugFileLoggerLib as it is no longer necessary. Remove these lines of the old Debug File Logger: DebugFileLoggerLib|XxxxxPkg/Library/DebugFileLoggerLib/DebugFileLoggerLib.inf XxxxxPkg/DebugFileLogger/Pei/DebugFileLoggerPei.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } XxxxxPkg/DebugFileLogger/Dxe/DebugFileLogger.inf Replace the old Debug file logger files with these new Debug File Logger II entries: MsCorePkg/DebugFileLoggerII/Pei/DebugFileLoggerPei.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } MsCorePkg/DebugFileLoggerII/Dxe/DebugFileLogger.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } There is no check for Manufacturing mode. The idea is for the File Logger to be robust enough to be on in all builds. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Debug File Logger II"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#debug-file-logger-ii","text":"NOTE: Superseded by the AdvLoggerPkg. This is Debug File Logger II. Debug File Logger was tried a few times with varying degrees of success. It was thought that the not quite right USB stack was the issue with the Debug File Logger. When the Debug File Logger was enabled to write logs in the ESP (EFI System Partition) on the NVMe drive, there would be systems that would no longer boot. Over time, we have found that there were issues in the Windows FAT file system driver across hibernate where the OS assumed no change to the file system metadata (The FAT and Directory Entries) causing irreparable damage to the ESP.","title":"Debug File Logger II"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#top-design-points","text":"The debug log files are pre-allocated the first time they are needed on a particular device. Every SimpleFileSystem device that is connected during POST is eligible to be a log device. A USB device must have a directory in the root named 'Logs' to be considered a log device. The NVMe device(s) will get a hidden directory named 'Logs' the first time is is mounted. The time to create the initial logs is about 2 seconds. The time to register the logs during subsequent time through POST is about 2ms. The logs can be obtained in the OS or by booting to the Shell. In the OS, mount the ESP using: mountvol P: /S The drive letter can be any available drive letter. Logs will be recorded at: When a registered device is connected When just prior to ExitBootServices to any previously registered devices When the system is reset (from TPL <= TPL_CALLBACK) to any previously registered devices If you want to collect logs on a USB device, you can insert the non-bootable USB drive with the Logs directory installed, then power on the system and hold VOL/- to attempt booting from USB. This will mount the USB filesystem, the Logs directory will be acknowledged, and the log written. The system will continue to boot and should append the rest of the log at ExitBootServices.","title":"Top design points"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#future-items","text":"Should there be more suggestions for future items, post them at Microsoft Mu Issues Some features under considerations: Refactor DebugLib again to insure logs are collected during the whole boot. Add a new feature to DebugLib to capture the full UEFI log, but only send selected entries to the serial port (to handle devices with a slow serial port). Always connect the NVMe drive at console connect. For 99.9% of the cases, the system is going to boot the NVMe drive, so connecting it early would not significantly change the boot time, but would allow logs to be collected in more cases. When the log cannot be written (too high of TPL for the FileSystem to work), have a method to store the last 100 lines or so of the log somewhere (system dependent) that can be collected on the next boot. Timestamp the head of the log to assist in sorting logs.","title":"Future items"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#installation-instructions","text":"Replace the current Pei/DebugFileLoggerPei.inf and /Dxe/DebugFileLogger.inf with the new versions. Delete the DebugFileLoggerLib as it is no longer necessary. Remove these lines of the old Debug File Logger: DebugFileLoggerLib|XxxxxPkg/Library/DebugFileLoggerLib/DebugFileLoggerLib.inf XxxxxPkg/DebugFileLogger/Pei/DebugFileLoggerPei.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } XxxxxPkg/DebugFileLogger/Dxe/DebugFileLogger.inf Replace the old Debug file logger files with these new Debug File Logger II entries: MsCorePkg/DebugFileLoggerII/Pei/DebugFileLoggerPei.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } MsCorePkg/DebugFileLoggerII/Dxe/DebugFileLogger.inf { <LibraryClasses> DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf } There is no check for Manufacturing mode. The idea is for the File Logger to be robust enough to be on in all builds.","title":"Installation Instructions"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/","text":"MS Core Package \u00b6 About \u00b6 This package has shared drivers and libraries that are silicon and platform independent. Modules \u00b6 Modules Link to Documentation AcpiRGRT: Regulatory Graphics Resource Table CheckHardwareConnected: Require Devices Connected DebugFileLoggerII: Uefi Log to File GuidedSectionExtractPeim: Pei version without decompression IncompatiblePciDevices Incompatible Pci Devices No Option Roms Allowed NoOptionRomsAllowed MuCryptoDxe MuCryptoDxe MuVarPolicyFoundationDxe MuVarPolicyFoundationDxe Libraries \u00b6 Libraries Link to Documentation DebugPortPei DebugPortPei DebugPortProtocolInstallLib DebugPortProtocolInstallLib DeviceBootManagerLibNull DeviceBootManagerLibNull DeviceSpecificBusInfoLibNull DeviceSpecificBusInfoLibNull DxeDebugLibRouter DxeDebugLibRouter JsonLiteParser JsonLiteParser MathLib MathLib MemoryTypeInformationChangeLib MemoryTypeInformationChangeLib PasswordStoreLibNull PasswordStoreLibNull PeiDebugLib PeiDebugLib PlatformBootManagerLib PlatformBootManagerLib TpmSgNvIndexLib TpmSgNvIndexLib ExceptionPersistenceLib ExceptionPersistenceLib MemoryProtectionExceptionHandlerLib MemoryProtectionExceptionHandlerLib Testing \u00b6 There are UEFI shell application based unit tests for some libraries. These tests attempt to verify basic functionality of public interfaces. Check the UntTests folder at the root of the package. Library Tests Link to Documentation Json Test: Json Test MathLib UnitTests: MathLib UnitTests Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Package Overview"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#ms-core-package","text":"","title":"MS Core Package"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#about","text":"This package has shared drivers and libraries that are silicon and platform independent.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#modules","text":"Modules Link to Documentation AcpiRGRT: Regulatory Graphics Resource Table CheckHardwareConnected: Require Devices Connected DebugFileLoggerII: Uefi Log to File GuidedSectionExtractPeim: Pei version without decompression IncompatiblePciDevices Incompatible Pci Devices No Option Roms Allowed NoOptionRomsAllowed MuCryptoDxe MuCryptoDxe MuVarPolicyFoundationDxe MuVarPolicyFoundationDxe","title":"Modules"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#libraries","text":"Libraries Link to Documentation DebugPortPei DebugPortPei DebugPortProtocolInstallLib DebugPortProtocolInstallLib DeviceBootManagerLibNull DeviceBootManagerLibNull DeviceSpecificBusInfoLibNull DeviceSpecificBusInfoLibNull DxeDebugLibRouter DxeDebugLibRouter JsonLiteParser JsonLiteParser MathLib MathLib MemoryTypeInformationChangeLib MemoryTypeInformationChangeLib PasswordStoreLibNull PasswordStoreLibNull PeiDebugLib PeiDebugLib PlatformBootManagerLib PlatformBootManagerLib TpmSgNvIndexLib TpmSgNvIndexLib ExceptionPersistenceLib ExceptionPersistenceLib MemoryProtectionExceptionHandlerLib MemoryProtectionExceptionHandlerLib","title":"Libraries"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#testing","text":"There are UEFI shell application based unit tests for some libraries. These tests attempt to verify basic functionality of public interfaces. Check the UntTests folder at the root of the package. Library Tests Link to Documentation Json Test: Json Test MathLib UnitTests: MathLib UnitTests","title":"Testing"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/","text":"Incompatible Pci Devices \u00b6 About \u00b6 There are times when a PCI devices misbehaves. This library class allows you to specify what to do when you need to support a PCI device that doesn't follow the spec, or if the platform wants to disable a feature. The only Incompatible Pci device behavior currently supported is to disable processing of the Option Rom. It is expected for supported PCI devices to have their rom built into the system firmware. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Read Me"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/#incompatible-pci-devices","text":"","title":"Incompatible Pci Devices"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/#about","text":"There are times when a PCI devices misbehaves. This library class allows you to specify what to do when you need to support a PCI device that doesn't follow the spec, or if the platform wants to disable a feature. The only Incompatible Pci device behavior currently supported is to disable processing of the Option Rom. It is expected for supported PCI devices to have their rom built into the system firmware.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/NoOptionRomsAllowed/ReadMe/","text":"Incompatible Pci Devices - No Option Roms Allowed \u00b6 About \u00b6 Some system plaforms do not want PCI devices to run their option ROMS. In this case, the platform provides the PCI Option Rom in the system firmware image, and this driver prevents the PCI drivers from loading the option rom from the device.","title":"No Option Roms Allowed"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/NoOptionRomsAllowed/ReadMe/#incompatible-pci-devices-no-option-roms-allowed","text":"","title":"Incompatible Pci Devices - No Option Roms Allowed"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/NoOptionRomsAllowed/ReadMe/#about","text":"Some system plaforms do not want PCI devices to run their option ROMS. In this case, the platform provides the PCI Option Rom in the system firmware image, and this driver prevents the PCI drivers from loading the option rom from the device.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/","text":"Debug Port Pei \u00b6 About \u00b6 This library is meant to be linked against a module within a DSC already linked against a version of DebugLib. This PPI is meant to be used by the rest of the PEI modules as a source for DebugLib functions. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Debug Port Pei"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/#debug-port-pei","text":"","title":"Debug Port Pei"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/#about","text":"This library is meant to be linked against a module within a DSC already linked against a version of DebugLib. This PPI is meant to be used by the rest of the PEI modules as a source for DebugLib functions.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/","text":"DebugPortProtocolInstallLib \u00b6 About \u00b6 Provides the gEfiDebugPortProtocolGuid to support Generic Debug prints across platforms. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Debug Port Protocol Install Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/#debugportprotocolinstalllib","text":"","title":"DebugPortProtocolInstallLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/#about","text":"Provides the gEfiDebugPortProtocolGuid to support Generic Debug prints across platforms.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/","text":"DeviceBootManagerLibNull \u00b6 About \u00b6 DeviceBootManagerLib contains the device or family of devices actions which can be customized by IBV/OEM. Each of the BdsDxe callback actions are passed from PlatformBootManagerLib to DeviceBootManagerLib for device specific action. This is the NULL version of the library for CI builds. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Device Boot Manager Lib Null"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/#devicebootmanagerlibnull","text":"","title":"DeviceBootManagerLibNull"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/#about","text":"DeviceBootManagerLib contains the device or family of devices actions which can be customized by IBV/OEM. Each of the BdsDxe callback actions are passed from PlatformBootManagerLib to DeviceBootManagerLib for device specific action. This is the NULL version of the library for CI builds.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/","text":"DeviceSpecificBusInfoLibNull \u00b6 About \u00b6 Provides a NULL implementation of DeviceSpecificBusInfoLibNull for use by CI builds. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Device Specific Bus Info Lib Null"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/#devicespecificbusinfolibnull","text":"","title":"DeviceSpecificBusInfoLibNull"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/#about","text":"Provides a NULL implementation of DeviceSpecificBusInfoLibNull for use by CI builds.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeCapsulePersistenceLib/ReadMe/","text":"Capsule Persistence Lib for PEI and DXE \u00b6 This is an implementation of CapsulePersistenceLib which is used to persist capsules using the EFI partition. It provides methods for: Persisting a capsule across reset Retrieving all currently persisted capsules and deleting them Retrieving a specific persisted capsule Deleting a specific persisted capsule This library can be used without any sort of queue, by using a retrieve all method but, ideally, it should be paired with QueueLib .","title":"Dxe Capsule Persistence Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeCapsulePersistenceLib/ReadMe/#capsule-persistence-lib-for-pei-and-dxe","text":"This is an implementation of CapsulePersistenceLib which is used to persist capsules using the EFI partition. It provides methods for: Persisting a capsule across reset Retrieving all currently persisted capsules and deleting them Retrieving a specific persisted capsule Deleting a specific persisted capsule This library can be used without any sort of queue, by using a retrieve all method but, ideally, it should be paired with QueueLib .","title":"Capsule Persistence Lib for PEI and DXE"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/","text":"Debugging with DxeDebugLibRouter \u00b6 About \u00b6 DxeDebugLibRouter \u00b6 The DxeDebugLibRouter is an implementation of DebugLib that routes the DebugPrint and DebugAssert messages depending on what the platform is capable of and what has been set-up. In the example below we show how to use DxeDebugLibRouter to route debug messages through either the serial interface or the report status code interface, depending on what protocols and libraries are being used. StatusCodeHandler \u00b6 If you wish to make use of the Report Status Code debugging feature you will need to set up a status code handler and install the gMsSerialStatusCodeHandlerDxeProtocolGuid tag GUID. The MsCorePkg version of StatusCodeHandler is setup to do this. DebugPortProtocolInstallLib \u00b6 The DebugPortProtocolInstallLib is a shim library whose only purpose is to install a protocol that points to the currently linked DebugLib being used by the module. You can see how this is used in the DSC example shown below. ReportStatusCodeRouter \u00b6 This library handles the routing of ReportStatusCode if the DxeDebugLibRouter is set-up to use the ReportStatusCode debug path. We have only implemented the serial output for report status code, but there are many ways you can implement a RSC observer including Serial Port Listener Save Debug To File System Save Debug To Memory ... How To Use \u00b6 To make full use of the DxeDebugLibRouter each Dxe Driver will need to use the DebugPort implementation of DebugLib to route their messages through the DxeDebugLibRouter. The Flowchart below shows how this would work. To set up DxeCore to work as the router you will need to set up the DSC as below: [LibraryClasses.X64] DebugLib|MdePkg/Library/UefiDebugLibDebugPortProtocol/UefiDebugLibDebugPortProtocol.inf [Components.X64] MdeModulePkg/Core/Dxe/DxeMain.inf { <LibraryClasses> NULL|MsCorePkg/Library/DebugPortProtocolInstallLib/DebugPortProtocolInstallLib.inf DebugLib|MsCorePkg/Library/DxeDebugLibRouter/DxeDebugLibRouter.inf } Debug Flow \u00b6 The NULL library responsible for publishing the DebugPort protocol is linked against DxeMain. This allows the DebugLib used by Dxe drivers to locate the DebugLib used by Dxe Main Dxe Driver makes a DebugPrint which is routed to the DebugLib linked to DxeMain DebugLib routes the DebugPrint through either Serial or Report Status Code depending on what is installed at the time This step can happen at any time. When the StatusCodeHandler is dispatched it installs a tag GUID letting the DebugLib know that Report Status Code is now available Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Dxe Debug Lib Router"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#debugging-with-dxedebuglibrouter","text":"","title":"Debugging with DxeDebugLibRouter"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#about","text":"","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#dxedebuglibrouter","text":"The DxeDebugLibRouter is an implementation of DebugLib that routes the DebugPrint and DebugAssert messages depending on what the platform is capable of and what has been set-up. In the example below we show how to use DxeDebugLibRouter to route debug messages through either the serial interface or the report status code interface, depending on what protocols and libraries are being used.","title":"DxeDebugLibRouter"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#statuscodehandler","text":"If you wish to make use of the Report Status Code debugging feature you will need to set up a status code handler and install the gMsSerialStatusCodeHandlerDxeProtocolGuid tag GUID. The MsCorePkg version of StatusCodeHandler is setup to do this.","title":"StatusCodeHandler"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#debugportprotocolinstalllib","text":"The DebugPortProtocolInstallLib is a shim library whose only purpose is to install a protocol that points to the currently linked DebugLib being used by the module. You can see how this is used in the DSC example shown below.","title":"DebugPortProtocolInstallLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#reportstatuscoderouter","text":"This library handles the routing of ReportStatusCode if the DxeDebugLibRouter is set-up to use the ReportStatusCode debug path. We have only implemented the serial output for report status code, but there are many ways you can implement a RSC observer including Serial Port Listener Save Debug To File System Save Debug To Memory ...","title":"ReportStatusCodeRouter"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#how-to-use","text":"To make full use of the DxeDebugLibRouter each Dxe Driver will need to use the DebugPort implementation of DebugLib to route their messages through the DxeDebugLibRouter. The Flowchart below shows how this would work. To set up DxeCore to work as the router you will need to set up the DSC as below: [LibraryClasses.X64] DebugLib|MdePkg/Library/UefiDebugLibDebugPortProtocol/UefiDebugLibDebugPortProtocol.inf [Components.X64] MdeModulePkg/Core/Dxe/DxeMain.inf { <LibraryClasses> NULL|MsCorePkg/Library/DebugPortProtocolInstallLib/DebugPortProtocolInstallLib.inf DebugLib|MsCorePkg/Library/DxeDebugLibRouter/DxeDebugLibRouter.inf }","title":"How To Use"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#debug-flow","text":"The NULL library responsible for publishing the DebugPort protocol is linked against DxeMain. This allows the DebugLib used by Dxe drivers to locate the DebugLib used by Dxe Main Dxe Driver makes a DebugPrint which is routed to the DebugLib linked to DxeMain DebugLib routes the DebugPrint through either Serial or Report Status Code depending on what is installed at the time This step can happen at any time. When the StatusCodeHandler is dispatched it installs a tag GUID letting the DebugLib know that Report Status Code is now available","title":"Debug Flow"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeIsCapsuleSupportedLib/ReadMe/","text":"DXE Is Capsule Supported Lib \u00b6 This library performs a sanity check to determine if a capsule is supported by the UEFI firmware. It does not perform any sort of signature or hash. In the case of nested capsules, there is stubbed out functionality to check if the ESRT table contains an entry related to the nested capsule. Why DXE_DRIVER Only \u00b6 This is called from the DXE_RUNTIME_DRIVER indirectly via the CapsuleServiceProtocol . Because this is a DXE protocol and the Capsule Runtime service doesn't call the protocol after ExitBootServices, this is safe.","title":"Dxe Is Capsule Supported Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeIsCapsuleSupportedLib/ReadMe/#dxe-is-capsule-supported-lib","text":"This library performs a sanity check to determine if a capsule is supported by the UEFI firmware. It does not perform any sort of signature or hash. In the case of nested capsules, there is stubbed out functionality to check if the ESRT table contains an entry related to the nested capsule.","title":"DXE Is Capsule Supported Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeIsCapsuleSupportedLib/ReadMe/#why-dxe_driver-only","text":"This is called from the DXE_RUNTIME_DRIVER indirectly via the CapsuleServiceProtocol . Because this is a DXE protocol and the Capsule Runtime service doesn't call the protocol after ExitBootServices, this is safe.","title":"Why DXE_DRIVER Only"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeQueueUefiVariableLib/ReadMe/","text":"DXE Queue UEFI Variable Lib \u00b6 This is an implementation of QueueLib backed by the UEFI variable store. Because the queue has manipulation functions, this does not support PEI as the variable services in PEI are usually read only.","title":"Dxe Queue Uefi Variable Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeQueueUefiVariableLib/ReadMe/#dxe-queue-uefi-variable-lib","text":"This is an implementation of QueueLib backed by the UEFI variable store. Because the queue has manipulation functions, this does not support PEI as the variable services in PEI are usually read only.","title":"DXE Queue UEFI Variable Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/","text":"ExceptionPersistenceLib \u00b6 About \u00b6 ExceptionPersistenceLib implements functionality for getting, setting, and clearing exception info to/from platform-specific early store. All functions return an EFI_ERROR if the function was unsuccessful. The validity of the data stored in CMOS is verified through the use of a two-byte checksum. Sets/Gets/Clears will first evaluate the checksum and return an EFI_ERROR if it is invalid. Sets/Gets/Clears will also write and read a test value to CMOS to make sure the library is working as expected which also should catch instances where the library was linked improperly. Usage \u00b6 ExceptionPersistenceLib is a BASE library and can be included under [LibraryClasses]. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Exception Persistence Lib Cmos"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#exceptionpersistencelib","text":"","title":"ExceptionPersistenceLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#about","text":"ExceptionPersistenceLib implements functionality for getting, setting, and clearing exception info to/from platform-specific early store. All functions return an EFI_ERROR if the function was unsuccessful. The validity of the data stored in CMOS is verified through the use of a two-byte checksum. Sets/Gets/Clears will first evaluate the checksum and return an EFI_ERROR if it is invalid. Sets/Gets/Clears will also write and read a test value to CMOS to make sure the library is working as expected which also should catch instances where the library was linked improperly.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#usage","text":"ExceptionPersistenceLib is a BASE library and can be included under [LibraryClasses].","title":"Usage"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/","text":"JsonLiteParser \u00b6 About \u00b6 This is a limited function Json parser used by the DfciPkg InTune Http requests. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Json Lite Parser"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/#jsonliteparser","text":"","title":"JsonLiteParser"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/#about","text":"This is a limited function Json parser used by the DfciPkg InTune Http requests.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/","text":"MathLib \u00b6 About \u00b6 MathLib provide add, subtract, multiply and divide routines that return an error when there is an underflow or overflow. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Math Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/#mathlib","text":"","title":"MathLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/#about","text":"MathLib provide add, subtract, multiply and divide routines that return an error when there is an underflow or overflow.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/","text":"MemoryProtectionExceptionHandlerLib \u00b6 About \u00b6 If memory protections are on, MemoryProtectionExceptionHandlerLib registers an exception handler which uses platform early store to log the page fault. Usage \u00b6 To use this library, make MemoryProtectionExceptionHandlerLib a null library for a module such as CpuDxe: UefiCpuPkg \\ CpuDxe \\ CpuDxe . inf { < LibraryClasses > NULL | MsCorePkg / Library / MemoryProtectionExceptionHandlerLib / MemoryProtectionExceptionHandlerLib . inf } CpuDxe is preferable because the page fault exception handler is only registered after gEfiCpuArchProtocolGuid has been installed.","title":"Memory Protection Exception Handler Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/#memoryprotectionexceptionhandlerlib","text":"","title":"MemoryProtectionExceptionHandlerLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/#about","text":"If memory protections are on, MemoryProtectionExceptionHandlerLib registers an exception handler which uses platform early store to log the page fault.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/#usage","text":"To use this library, make MemoryProtectionExceptionHandlerLib a null library for a module such as CpuDxe: UefiCpuPkg \\ CpuDxe \\ CpuDxe . inf { < LibraryClasses > NULL | MsCorePkg / Library / MemoryProtectionExceptionHandlerLib / MemoryProtectionExceptionHandlerLib . inf } CpuDxe is preferable because the page fault exception handler is only registered after gEfiCpuArchProtocolGuid has been installed.","title":"Usage"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/","text":"MemoryTypeInformationChangeLib \u00b6 About \u00b6 Reports the memory type information change as a telemetry event. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Memory Type Information Change Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/#memorytypeinformationchangelib","text":"","title":"MemoryTypeInformationChangeLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/#about","text":"Reports the memory type information change as a telemetry event.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/","text":"Using MuSecureBootKeySelectorLib \u00b6 About \u00b6 This document describes the overview of Secure Boot related changes from SecurityPkg and how MuSecureBootKeySelectorLib and SecureBootKeyStoreLib are introduced to leverage the changes to support multiple key chains needed by OEMs. Involved Definitions \u00b6 Definitions Definition Paths Implementation Paths UefiSecureBoot.h SecurityPkg/Include/UefiSecureBoot.h N/A SecureBootVariableLib.h SecurityPkg/Include/Library/SecureBootVariableLib.h SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf PlatformPKProtectionLib.h SecurityPkg/Include/Library/PlatformPKProtectionLib.h SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf ( Required If Platforms Uses Variable Policy to Protect PK ) MuSecureBootKeySelectorLib.h MsCorePkg/Include/Library/MuSecureBootKeySelectorLib.h MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf SecureBootKeyStoreLib.h MsCorePkg/Include/Library/SecureBootKeyStoreLib.h Platform Supplied Update for Secure Boot Variable Operation in SecurityPkg \u00b6 With the improvement from SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf , this library begins to support the Secure Boot related variables (db, dbt, dbx, KEK, PK, etc.) deletion and enrollment without much external dependencies: gEfiVariableWriteArchProtocolGuid is required; if platform supports variable policy, gEdkiiVariablePolicyProtocolGuid is also required. The Delete** interfaces as well as the EnrollFromInput could be leveraged to delete or write individual secure boot variable with time based authenticated payload. IsSecureBootEnabled is also added to query the secure boot state quickly. Interface DeleteSecureBootVariables \u00b6 In addition, the newly introduced interface from SecureBootVariableLib , DeleteSecureBootVariables , streamline all secure boot variable deletion in one function to facilitate the usage for platforms. Interface SetSecureBootVariablesToDefault \u00b6 Another newly introduced interface from SecureBootVariableLib , SetSecureBootVariablesToDefault , streamline all secure boot variable enrollment in one function to facilitate the usage for platforms. This function takes the platform supplied SECURE_BOOT_PAYLOAD_INFO structure (defined in SecurityPkg/Include/UefiSecureBoot.h ) that contains pointers to target secure boot variables (db, dbt, dbx, KEK, PK, etc.), creates time based authenticated payload, disable PK variable protection if needed, and write the variables. Specifically, the content from SECURE_BOOT_PAYLOAD_INFO must be formatted to EFI_SIGNATURE_LIST structures. Interface SecureBootCreateDataFromInput \u00b6 This interface is a helper function to convert DER formatted certificates to EFI_SIGNATURE_LIST . Callers can collect all applicable DER formatted certificates' addresses and sizes in SECURE_BOOT_CERTIFICATE_INFO arrays. The collected array can be passed into this interface to create a single, concatenated EFI_SIGNATURE_LIST in one call. This function is especially useful for platforms that currently carry these certificates in DER format to populate SECURE_BOOT_PAYLOAD_INFO structure. Creation of MuSecureBootKeySelectorLib \u00b6 The introduction of this library instance is to support platforms that needs to install mutiple chains of secure boot keys under various circumstances. i.e. Platform would like to support only 1 st party signed applications vs. 1 st party and 3 rd party signed application. This library provides a set of SECURE_BOOT_PAYLOAD_INFO , each entry formatted to EFI_SIGNATURE_LIST structure. This set of keys will be used with MuSecureBootKeySelectorLib to select which key set to be applied to the system. Along with the signature list pointers, each key could provide a unicode string to denote its name, which might be used in other modules for informational purpose. The provided key sets should persist in the lifetime of its consuming module. The caller should not free the key store buffer after usage. Note: If the platforms currently deliver any associated certificates in DER format, one should use SecureBootCreateDataFromInput function to convert them into EFI_SIGNATURE_LIST format. Usage of MuSecureBootKeySelectorLib \u00b6 This library provides an interface to query or set the current status of secure boot variables in accordance to the key sets provided in MuSecureBootKeySelectorLib . Platform Integration \u00b6 Platform Code \u00b6 Platforms held the responsibility in authoring a library instance of SecureBootKeyStoreLib to provide certificates or signature lists for secure boot operation usage. Optional: if platforms do not use variable policy to protect PK , one should also author an instance of PlatformPKProtectionLib to disarm the protection when PK is about to be updated. Platform DSC Change \u00b6 Add the following items in the platform DSC file: SecureBootVariableLib | SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf # Optional PlatformPKProtectionLib | SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf MuSecureBootKeySelectorLib | MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf # Platform Code SecureBootKeyStoreLib | PlatformPkg/Library/SecureBootKeyStoreLibPlat/SecureBootKeyStoreLibPlat.inf","title":"Mu Secure Boot Key Selector Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#using-musecurebootkeyselectorlib","text":"","title":"Using MuSecureBootKeySelectorLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#about","text":"This document describes the overview of Secure Boot related changes from SecurityPkg and how MuSecureBootKeySelectorLib and SecureBootKeyStoreLib are introduced to leverage the changes to support multiple key chains needed by OEMs.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#involved-definitions","text":"Definitions Definition Paths Implementation Paths UefiSecureBoot.h SecurityPkg/Include/UefiSecureBoot.h N/A SecureBootVariableLib.h SecurityPkg/Include/Library/SecureBootVariableLib.h SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf PlatformPKProtectionLib.h SecurityPkg/Include/Library/PlatformPKProtectionLib.h SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf ( Required If Platforms Uses Variable Policy to Protect PK ) MuSecureBootKeySelectorLib.h MsCorePkg/Include/Library/MuSecureBootKeySelectorLib.h MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf SecureBootKeyStoreLib.h MsCorePkg/Include/Library/SecureBootKeyStoreLib.h Platform Supplied","title":"Involved Definitions"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#update-for-secure-boot-variable-operation-in-securitypkg","text":"With the improvement from SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf , this library begins to support the Secure Boot related variables (db, dbt, dbx, KEK, PK, etc.) deletion and enrollment without much external dependencies: gEfiVariableWriteArchProtocolGuid is required; if platform supports variable policy, gEdkiiVariablePolicyProtocolGuid is also required. The Delete** interfaces as well as the EnrollFromInput could be leveraged to delete or write individual secure boot variable with time based authenticated payload. IsSecureBootEnabled is also added to query the secure boot state quickly.","title":"Update for Secure Boot Variable Operation in SecurityPkg"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-deletesecurebootvariables","text":"In addition, the newly introduced interface from SecureBootVariableLib , DeleteSecureBootVariables , streamline all secure boot variable deletion in one function to facilitate the usage for platforms.","title":"Interface DeleteSecureBootVariables"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-setsecurebootvariablestodefault","text":"Another newly introduced interface from SecureBootVariableLib , SetSecureBootVariablesToDefault , streamline all secure boot variable enrollment in one function to facilitate the usage for platforms. This function takes the platform supplied SECURE_BOOT_PAYLOAD_INFO structure (defined in SecurityPkg/Include/UefiSecureBoot.h ) that contains pointers to target secure boot variables (db, dbt, dbx, KEK, PK, etc.), creates time based authenticated payload, disable PK variable protection if needed, and write the variables. Specifically, the content from SECURE_BOOT_PAYLOAD_INFO must be formatted to EFI_SIGNATURE_LIST structures.","title":"Interface SetSecureBootVariablesToDefault"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-securebootcreatedatafrominput","text":"This interface is a helper function to convert DER formatted certificates to EFI_SIGNATURE_LIST . Callers can collect all applicable DER formatted certificates' addresses and sizes in SECURE_BOOT_CERTIFICATE_INFO arrays. The collected array can be passed into this interface to create a single, concatenated EFI_SIGNATURE_LIST in one call. This function is especially useful for platforms that currently carry these certificates in DER format to populate SECURE_BOOT_PAYLOAD_INFO structure.","title":"Interface SecureBootCreateDataFromInput"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#creation-of-musecurebootkeyselectorlib","text":"The introduction of this library instance is to support platforms that needs to install mutiple chains of secure boot keys under various circumstances. i.e. Platform would like to support only 1 st party signed applications vs. 1 st party and 3 rd party signed application. This library provides a set of SECURE_BOOT_PAYLOAD_INFO , each entry formatted to EFI_SIGNATURE_LIST structure. This set of keys will be used with MuSecureBootKeySelectorLib to select which key set to be applied to the system. Along with the signature list pointers, each key could provide a unicode string to denote its name, which might be used in other modules for informational purpose. The provided key sets should persist in the lifetime of its consuming module. The caller should not free the key store buffer after usage. Note: If the platforms currently deliver any associated certificates in DER format, one should use SecureBootCreateDataFromInput function to convert them into EFI_SIGNATURE_LIST format.","title":"Creation of MuSecureBootKeySelectorLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#usage-of-musecurebootkeyselectorlib","text":"This library provides an interface to query or set the current status of secure boot variables in accordance to the key sets provided in MuSecureBootKeySelectorLib .","title":"Usage of MuSecureBootKeySelectorLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-integration","text":"","title":"Platform Integration"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-code","text":"Platforms held the responsibility in authoring a library instance of SecureBootKeyStoreLib to provide certificates or signature lists for secure boot operation usage. Optional: if platforms do not use variable policy to protect PK , one should also author an instance of PlatformPKProtectionLib to disarm the protection when PK is about to be updated.","title":"Platform Code"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-dsc-change","text":"Add the following items in the platform DSC file: SecureBootVariableLib | SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf # Optional PlatformPKProtectionLib | SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf MuSecureBootKeySelectorLib | MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf # Platform Code SecureBootKeyStoreLib | PlatformPkg/Library/SecureBootKeyStoreLibPlat/SecureBootKeyStoreLibPlat.inf","title":"Platform DSC Change"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/","text":"PasswordStoreLibNull \u00b6 About \u00b6 Provides a NULL implementation of PasswordStoreLibNull for use by CI builds. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Password Store Lib Null"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/#passwordstorelibnull","text":"","title":"PasswordStoreLibNull"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/#about","text":"Provides a NULL implementation of PasswordStoreLibNull for use by CI builds.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/","text":"PeiDebugLib \u00b6 About \u00b6 Debug Library to be used with DebugPortPEI library Routes all DebugPrint and DebugAssert calls through PPI. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Pei Debug Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/#peidebuglib","text":"","title":"PeiDebugLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/#about","text":"Debug Library to be used with DebugPortPEI library Routes all DebugPrint and DebugAssert calls through PPI.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/","text":"PlatformBootManagerLib \u00b6 About \u00b6 This file include all the common platform action which can be customized by IBV/OEM. Each of the BDS actions are passed to DeviceBootManagerLib for device specific action. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Platform Boot Manager Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/#platformbootmanagerlib","text":"","title":"PlatformBootManagerLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/#about","text":"This file include all the common platform action which can be customized by IBV/OEM. Each of the BDS actions are passed to DeviceBootManagerLib for device specific action.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/","text":"TpmSgNvIndexLib \u00b6 About \u00b6 Library to create SystemGuard NV Index consumed by OS Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Tpm Sg Nv Index Lib"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/#tpmsgnvindexlib","text":"","title":"TpmSgNvIndexLib"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/#about","text":"Library to create SystemGuard NV Index consumed by OS","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/","text":"MuCryptoDxe \u00b6 About \u00b6 MuCryptoDxe is a DXE_DRIVER you can include in your platform to have a protocol that can call Crypto functions without having to statically linked against the crypto library in many places Supported Architectures \u00b6 This package is not architecturally dependent. Methods supported \u00b6 There are two protocols exposed in this GUID MU_PKCS5_PASSWORD_HASH_PROTOCOL \u00b6 HashPassword \u00b6 Hashes a password by passing through to the BaseCryptLib. Returns EFI_STATUS NOTE : DigestSize will be used to determine the hash algorithm and must correspond to a known hash digest size . Use standards . @ retval EFI_SUCCESS Congratulations ! Your hash is in the output buffer . @ retval EFI_INVALID_PARAMETER One of the pointers was NULL or one of the sizes was too large . @ retval EFI_INVALID_PARAMETER The hash algorithm could not be determined from the digest size . @ retval EFI_ABORTED An error occurred in the OpenSSL subroutines . ** Inputs **: IN CONST MU_PKCS5_PASSWORD_HASH_PROTOCOL IN UINTN PasswordSize IN CONST CHAR8 * Password IN UINTN SaltSize IN CONST UINT8 * Salt IN UINTN IterationCount IN UINTN DigestSize IN UINTN OutputSize OUT UINT8 * Output MU_PKCS7_PROTOCOL \u00b6 Verify \u00b6 Verifies the validity of a PKCS#7 signed data as described in \"PKCS #7: Cryptographic Message Syntax Standard\". The input signed data could be wrapped in a ContentInfo structure. If P7Data, TrustedCert or InData is NULL, then return EFI_INVALID_PARAMETER. If P7Length, CertLength or DataLength overflow, then return EFI_INVALID_PARAMETER. If this interface is not supported, then return EFI_UNSUPPORTED. @ retval EFI_SUCCESS The specified PKCS # 7 signed data is valid . @ retval EFI_SECURITY_VIOLATION Invalid PKCS # 7 signed data . @ retval EFI_UNSUPPORTED This interface is not supported . ** Inputs :** IN CONST MU_PKCS7_PROTOCOL IN CONST UINT8 * P7Data , IN UINTN P7DataLength , IN CONST UINT8 * TrustedCert , IN UINTN TrustedCertLength , IN CONST UINT8 * Data , IN UINTN DataLength ( in bytes ) VerifyEKU \u00b6 This function receives a PKCS7 formatted signature, and then verifies that the specified Enhanced or Extended Key Usages (EKU's) are present in the end-entity leaf signing certificate. Note that this function does not validate the certificate chain. Applications for custom EKU's are quite flexible. For example, a policy EKU may be present in an Issuing Certificate Authority (CA), and any sub-ordinate certificate issued might also contain this EKU, thus constraining the sub-ordinate certificate. Other applications might allow a certificate embedded in a device to specify that other Object Identifiers (OIDs) are present which contains binary data specifying custom capabilities that the device is able to do. @ retval EFI_SUCCESS - The required EKUs were found in the signature . @ retval EFI_INVALID_PARAMETER - A parameter was invalid . @ retval EFI_NOT_FOUND - One or more EKU ' s were not found in the signature . ** Inputs :** IN CONST MU_PKCS7_PROTOCOL IN CONST UINT8 * Pkcs7Signature , IN CONST UINT32 SignatureSize , ( in bytes ) IN CONST CHAR8 * RequiredEKUs [], null - terminated strings listing OIDs of required EKUs IN CONST UINT32 RequiredEKUsSize , IN BOOLEAN RequireAllPresent Including in your platform \u00b6 Sample DSC change \u00b6 [Components.<arch>] ... ... MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf Sample FDF change \u00b6 [FV.<a DXE firmware volume>] ... ... INF MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mu Crypto Dxe"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#mucryptodxe","text":"","title":"MuCryptoDxe"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#about","text":"MuCryptoDxe is a DXE_DRIVER you can include in your platform to have a protocol that can call Crypto functions without having to statically linked against the crypto library in many places","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#supported-architectures","text":"This package is not architecturally dependent.","title":"Supported Architectures"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#methods-supported","text":"There are two protocols exposed in this GUID","title":"Methods supported"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#mu_pkcs5_password_hash_protocol","text":"","title":"MU_PKCS5_PASSWORD_HASH_PROTOCOL"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#hashpassword","text":"Hashes a password by passing through to the BaseCryptLib. Returns EFI_STATUS NOTE : DigestSize will be used to determine the hash algorithm and must correspond to a known hash digest size . Use standards . @ retval EFI_SUCCESS Congratulations ! Your hash is in the output buffer . @ retval EFI_INVALID_PARAMETER One of the pointers was NULL or one of the sizes was too large . @ retval EFI_INVALID_PARAMETER The hash algorithm could not be determined from the digest size . @ retval EFI_ABORTED An error occurred in the OpenSSL subroutines . ** Inputs **: IN CONST MU_PKCS5_PASSWORD_HASH_PROTOCOL IN UINTN PasswordSize IN CONST CHAR8 * Password IN UINTN SaltSize IN CONST UINT8 * Salt IN UINTN IterationCount IN UINTN DigestSize IN UINTN OutputSize OUT UINT8 * Output","title":"HashPassword"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#mu_pkcs7_protocol","text":"","title":"MU_PKCS7_PROTOCOL"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#verify","text":"Verifies the validity of a PKCS#7 signed data as described in \"PKCS #7: Cryptographic Message Syntax Standard\". The input signed data could be wrapped in a ContentInfo structure. If P7Data, TrustedCert or InData is NULL, then return EFI_INVALID_PARAMETER. If P7Length, CertLength or DataLength overflow, then return EFI_INVALID_PARAMETER. If this interface is not supported, then return EFI_UNSUPPORTED. @ retval EFI_SUCCESS The specified PKCS # 7 signed data is valid . @ retval EFI_SECURITY_VIOLATION Invalid PKCS # 7 signed data . @ retval EFI_UNSUPPORTED This interface is not supported . ** Inputs :** IN CONST MU_PKCS7_PROTOCOL IN CONST UINT8 * P7Data , IN UINTN P7DataLength , IN CONST UINT8 * TrustedCert , IN UINTN TrustedCertLength , IN CONST UINT8 * Data , IN UINTN DataLength ( in bytes )","title":"Verify"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#verifyeku","text":"This function receives a PKCS7 formatted signature, and then verifies that the specified Enhanced or Extended Key Usages (EKU's) are present in the end-entity leaf signing certificate. Note that this function does not validate the certificate chain. Applications for custom EKU's are quite flexible. For example, a policy EKU may be present in an Issuing Certificate Authority (CA), and any sub-ordinate certificate issued might also contain this EKU, thus constraining the sub-ordinate certificate. Other applications might allow a certificate embedded in a device to specify that other Object Identifiers (OIDs) are present which contains binary data specifying custom capabilities that the device is able to do. @ retval EFI_SUCCESS - The required EKUs were found in the signature . @ retval EFI_INVALID_PARAMETER - A parameter was invalid . @ retval EFI_NOT_FOUND - One or more EKU ' s were not found in the signature . ** Inputs :** IN CONST MU_PKCS7_PROTOCOL IN CONST UINT8 * Pkcs7Signature , IN CONST UINT32 SignatureSize , ( in bytes ) IN CONST CHAR8 * RequiredEKUs [], null - terminated strings listing OIDs of required EKUs IN CONST UINT32 RequiredEKUsSize , IN BOOLEAN RequireAllPresent","title":"VerifyEKU"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#including-in-your-platform","text":"","title":"Including in your platform"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#sample-dsc-change","text":"[Components.<arch>] ... ... MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf","title":"Sample DSC change"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#sample-fdf-change","text":"[FV.<a DXE firmware volume>] ... ... INF MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf","title":"Sample FDF change"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/","text":"MuVarPolicyFoundationDxe Driver and Policies \u00b6 Overview \u00b6 This driver works in conjunction with the Variable Policy engine to create two policy-based concepts that can be leveraged by other drivers in the system and to produce an EDK2 Variable Locking Protocol. The two concepts are: Dxe Phase Indicators and Write Once State Variables. DXE Phase Indicators \u00b6 To support the DXE Phase Indicators, a new policy is installed that creates the gMuVarPolicyDxePhaseGuid variable namespace. By policy, all variables in this namespace are required to be the size of a PHASE_INDICATOR (which is a UINT8 ) and must be volatile and readable in both BootServices and Runtime. All variables in this namespace will also be made read-only immediately upon creation (as such, they are also Write-Once, but have a special purpose). Because these variables are required to be volatile, it will not be possible to create more after ExitBootServices. This driver will also register callbacks for EndOfDxe, ReadyToBoot, and ExitBootServices. At the time of the corresponding event, a new PHASE_INDICATOR variable will be created for the callback that has just been triggered. The purpose of these variables is two-fold: They can be queried by any driver or library that needs to know what phases of boot have already occurred. This is especially convenient for libraries that might be linked against any type of driver or application, but may not have been able to register callbacks for all the events because they don't know their execution order or time. They can be used as the delegated \"Variable State\" variables in other Variable Policy lock policies. As such, you could describe a variable that locks \"at ReadyToBoot\" or \"EndOfDxe\". Note that the PHASE_INDICATOR variables are intentionally named as short abbreviations, such as \"EOD\" and \"RTB\". This is to minimize the size of the policy entries for lock-on-state policies. Important Note on Timing \u00b6 The EndOfDxe and ReadyToBoot state variables will be created at the end of the Notify list for the respective event. As such, any variable that locks on those events will still be writeable in Notify callbacks for the event. However, the ExitBootServices state variable (due to architectural requirements) will be created at a non-deterministic time in the Notify list. Therefore, it is unpredictable whether any variable which locks \"on ExitBootServices\" would still be writeable in any given callback. Write-Once State Variables \u00b6 The Write-Once State Variables are actually quite similar to the DXE Phase Variables in terms of policy, but are kept distinct because of the different intentions for their use. This driver will also register a policy that creates the gMuVarPolicyWriteOnceStateVarGuid namespace. This policy will also limit these variables to being: volatile, BootServices and Runtime, read-only on create, and a fixed size -- sizeof(POLICY_LOCK_VAR) , which is also a UINT8 , given that that is the size of the Value field of the current VARIABLE_LOCK_ON_VAR_STATE_POLICY structure. The primary difference is that the DXE Phase Variables have a very clear purpose and meaning. While the gMuVarPolicyWriteOnceStateVarGuid namespace is designed to be general-purpose and used to easily describe delegated variables for VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE -type policies without requiring every driver to define two policies in order to employ this common pattern. Example \u00b6 Driver XYZ wants to define a policy to allow a boot application (that executes after the policy creation interface may be closed) to modify a collection of variables until the boot application chooses to lock them. One way to accomplish this is the create a policy that delegates the lock control of the target variables to the state of variable A. However, now the variable A is the linchpin for the protections of the target variables and should have some protections of its own. This might require another policy. Instead, the driver could create a policy that delegates lock control of the target variables to a variable in the gMuVarPolicyWriteOnceStateVarGuid . This would not require a second policy, as a general-purpose policy is already in place. Now the boot application only needs to create variable A in the gMuVarPolicyWriteOnceStateVarGuid namespace (with the value designated in the policy created by driver XYZ) in order to lock the target variables. Important Note on Naming \u00b6 Since the gMuVarPolicyWriteOnceStateVarGuid namespace is a single variable namespace, naming collisions are possible. Because of the write-once nature of the policy, it is not a concern that an existing lock may be overwritten, but there still may be policy confusion if there are two policies that delegate to the exact same name. It is up to the platform architect to ensure that naming collisions like this do not occur. EDK2 Variable Locking Protocol \u00b6 Finally, this driver installs an EDK2 Variable Locking Protocol instance. This implementation locks a variable by creating a policy entry and registering it via the Variable Policy Protocol. The policy entry is of type VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE and locks the variable based on state of the Phase Indicator variable \"EOD\" (meaning End Of Dxe) in gMuVarPolicyDxePhaseGuid namespace. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Mu Var Policy Foundation Dxe"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#muvarpolicyfoundationdxe-driver-and-policies","text":"","title":"MuVarPolicyFoundationDxe Driver and Policies"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#overview","text":"This driver works in conjunction with the Variable Policy engine to create two policy-based concepts that can be leveraged by other drivers in the system and to produce an EDK2 Variable Locking Protocol. The two concepts are: Dxe Phase Indicators and Write Once State Variables.","title":"Overview"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#dxe-phase-indicators","text":"To support the DXE Phase Indicators, a new policy is installed that creates the gMuVarPolicyDxePhaseGuid variable namespace. By policy, all variables in this namespace are required to be the size of a PHASE_INDICATOR (which is a UINT8 ) and must be volatile and readable in both BootServices and Runtime. All variables in this namespace will also be made read-only immediately upon creation (as such, they are also Write-Once, but have a special purpose). Because these variables are required to be volatile, it will not be possible to create more after ExitBootServices. This driver will also register callbacks for EndOfDxe, ReadyToBoot, and ExitBootServices. At the time of the corresponding event, a new PHASE_INDICATOR variable will be created for the callback that has just been triggered. The purpose of these variables is two-fold: They can be queried by any driver or library that needs to know what phases of boot have already occurred. This is especially convenient for libraries that might be linked against any type of driver or application, but may not have been able to register callbacks for all the events because they don't know their execution order or time. They can be used as the delegated \"Variable State\" variables in other Variable Policy lock policies. As such, you could describe a variable that locks \"at ReadyToBoot\" or \"EndOfDxe\". Note that the PHASE_INDICATOR variables are intentionally named as short abbreviations, such as \"EOD\" and \"RTB\". This is to minimize the size of the policy entries for lock-on-state policies.","title":"DXE Phase Indicators"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#important-note-on-timing","text":"The EndOfDxe and ReadyToBoot state variables will be created at the end of the Notify list for the respective event. As such, any variable that locks on those events will still be writeable in Notify callbacks for the event. However, the ExitBootServices state variable (due to architectural requirements) will be created at a non-deterministic time in the Notify list. Therefore, it is unpredictable whether any variable which locks \"on ExitBootServices\" would still be writeable in any given callback.","title":"Important Note on Timing"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#write-once-state-variables","text":"The Write-Once State Variables are actually quite similar to the DXE Phase Variables in terms of policy, but are kept distinct because of the different intentions for their use. This driver will also register a policy that creates the gMuVarPolicyWriteOnceStateVarGuid namespace. This policy will also limit these variables to being: volatile, BootServices and Runtime, read-only on create, and a fixed size -- sizeof(POLICY_LOCK_VAR) , which is also a UINT8 , given that that is the size of the Value field of the current VARIABLE_LOCK_ON_VAR_STATE_POLICY structure. The primary difference is that the DXE Phase Variables have a very clear purpose and meaning. While the gMuVarPolicyWriteOnceStateVarGuid namespace is designed to be general-purpose and used to easily describe delegated variables for VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE -type policies without requiring every driver to define two policies in order to employ this common pattern.","title":"Write-Once State Variables"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#example","text":"Driver XYZ wants to define a policy to allow a boot application (that executes after the policy creation interface may be closed) to modify a collection of variables until the boot application chooses to lock them. One way to accomplish this is the create a policy that delegates the lock control of the target variables to the state of variable A. However, now the variable A is the linchpin for the protections of the target variables and should have some protections of its own. This might require another policy. Instead, the driver could create a policy that delegates lock control of the target variables to a variable in the gMuVarPolicyWriteOnceStateVarGuid . This would not require a second policy, as a general-purpose policy is already in place. Now the boot application only needs to create variable A in the gMuVarPolicyWriteOnceStateVarGuid namespace (with the value designated in the policy created by driver XYZ) in order to lock the target variables.","title":"Example"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#important-note-on-naming","text":"Since the gMuVarPolicyWriteOnceStateVarGuid namespace is a single variable namespace, naming collisions are possible. Because of the write-once nature of the policy, it is not a concern that an existing lock may be overwritten, but there still may be policy confusion if there are two policies that delegate to the exact same name. It is up to the platform architect to ensure that naming collisions like this do not occur.","title":"Important Note on Naming"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#edk2-variable-locking-protocol","text":"Finally, this driver installs an EDK2 Variable Locking Protocol instance. This implementation locks a variable by creating a policy entry and registering it via the Variable Policy Protocol. The policy entry is of type VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE and locks the variable based on state of the Phase Indicator variable \"EOD\" (meaning End Of Dxe) in gMuVarPolicyDxePhaseGuid namespace.","title":"EDK2 Variable Locking Protocol"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/","text":"Verify Json Lite library functionality \u00b6 The Json Lite Library parses json strings in to tuples and encodes tuples into a json string. About \u00b6 These tests verify that the Json Lite Library functions properly. JsonTestApp \u00b6 This application consumes the UnitTestLib and implements various test cases for the verification of the Json Lite Library. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Json Test"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#verify-json-lite-library-functionality","text":"The Json Lite Library parses json strings in to tuples and encodes tuples into a json string.","title":"Verify Json Lite library functionality"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#about","text":"These tests verify that the Json Lite Library functions properly.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#jsontestapp","text":"This application consumes the UnitTestLib and implements various test cases for the verification of the Json Lite Library.","title":"JsonTestApp"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/","text":"Math Lib Unit Tests \u00b6 About \u00b6 The Math Lib Unit Tests test the boundary conditions to insure proper results of catching underflows and overflows during calculations. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Math Lib Unit Test"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/#math-lib-unit-tests","text":"","title":"Math Lib Unit Tests"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/#about","text":"The Math Lib Unit Tests test the boundary conditions to insure proper results of catching underflows and overflows during calculations.","title":"About"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsCorePkg/Universal/StatusCodeHandler/ReadMe/","text":"Status Code Handler \u00b6 About \u00b6 Provides output of the Report Status Codes to a debugging device.","title":"Status Code Handler"},{"location":"dyn/mu_plus/MsCorePkg/Universal/StatusCodeHandler/ReadMe/#status-code-handler","text":"","title":"Status Code Handler"},{"location":"dyn/mu_plus/MsCorePkg/Universal/StatusCodeHandler/ReadMe/#about","text":"Provides output of the Report Status Codes to a debugging device.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/","text":"BmpDisplay test application \u00b6 About \u00b6 While UEFI uses and displays BMP format files, there are some BMP specification that UEFI follows that not all drawing programs honor. Running this tool to display a BMP in the Uefi Shell will check to make sure your BMP file are displayable in UEFI. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Bmp Display"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/#bmpdisplay-test-application","text":"","title":"BmpDisplay test application"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/#about","text":"While UEFI uses and displays BMP format files, there are some BMP specification that UEFI follows that not all drawing programs honor. Running this tool to display a BMP in the Uefi Shell will check to make sure your BMP file are displayable in UEFI.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/","text":"DisplayEngineDxe Driver \u00b6 About \u00b6 This DisplayEngine driver supports the SetupBrowser display engine interface, and this version uses the Simple Window Manager to implement the backend of the IFR operations. Currently, not all IFR's are implemented. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Display Engine Dxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/#displayenginedxe-driver","text":"","title":"DisplayEngineDxe Driver"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/#about","text":"This DisplayEngine driver supports the SetupBrowser display engine interface, and this version uses the Simple Window Manager to implement the backend of the IFR operations. Currently, not all IFR's are implemented.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/","text":"MS Graphics Package \u00b6 About \u00b6 This package has shared drivers and libraries that extend the UEFI graphics with a simple windowing system. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Package Overview"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/#ms-graphics-package","text":"","title":"MS Graphics Package"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/#about","text":"This package has shared drivers and libraries that extend the UEFI graphics with a simple windowing system.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/","text":"Gop Override Dxe Driver \u00b6 About \u00b6 This driver provides a less optimal method of providing the MsGopOverrideProtocol for the Rendering Engine. See What Does the GopOverrideDxe Do Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Gop Override Dxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/#gop-override-dxe-driver","text":"","title":"Gop Override Dxe Driver"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/#about","text":"This driver provides a less optimal method of providing the MsGopOverrideProtocol for the Rendering Engine. See What Does the GopOverrideDxe Do","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/","text":"Base Ui Progress Circle Library \u00b6 About \u00b6 Implements Ui Progress Circle or Donut. You can specify 100% or drawing whatever segments you specify. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Base Ui Progress Circle Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/#base-ui-progress-circle-library","text":"","title":"Base Ui Progress Circle Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/#about","text":"Implements Ui Progress Circle or Donut. You can specify 100% or drawing whatever segments you specify.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/","text":"Base UI Rectanble Library \u00b6 About \u00b6 This library provides the ability to draw rectangles on the display. They can be solid, checkered, or striped. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Base Ui Rectangle Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/#base-ui-rectanble-library","text":"","title":"Base UI Rectanble Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/#about","text":"This library provides the ability to draw rectangles on the display. They can be solid, checkered, or striped.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/","text":"Boot Graphics Library \u00b6 About \u00b6 This BootGraphicsLib is only intended to be used by BDS to draw the main boot graphics to the screen. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Boot Graphics Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/#boot-graphics-library","text":"","title":"Boot Graphics Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/#about","text":"This BootGraphicsLib is only intended to be used by BDS to draw the main boot graphics to the screen.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/","text":"Boot Graphics Null Library \u00b6 About \u00b6 This library is used in the CI build configuration. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Boot Graphics Lib Null"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/#boot-graphics-null-library","text":"","title":"Boot Graphics Null Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/#about","text":"This library is used in the CI build configuration.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/","text":"Boot Graphics Provider NULL Library \u00b6 About \u00b6 This library is used by CI builds to test compile users of the BootGraphicsLib. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Boot Graphics Provider Lib Null"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/#boot-graphics-provider-null-library","text":"","title":"Boot Graphics Provider NULL Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/#about","text":"This library is used by CI builds to test compile users of the BootGraphicsLib.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/","text":"Color Bar Display Device State Library \u00b6 About \u00b6 There are a number of states that are critical when manufacturing a system. Some of these are the fuses that must be set that protect the device. These fuses are not set on some machines for test purposes, etc. To quickly notice that these customer critical settings are correct, this library display color bars on the display if there state is not in the secure state. This allows an end user to quickly notice that secure boot is off. This allows an end of line tester to verify that the fuses are in the correct state for customer delivery. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Color Bar Display Device State Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/#color-bar-display-device-state-library","text":"","title":"Color Bar Display Device State Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/#about","text":"There are a number of states that are critical when manufacturing a system. Some of these are the fuses that must be set that protect the device. These fuses are not set on some machines for test purposes, etc. To quickly notice that these customer critical settings are correct, this library display color bars on the display if there state is not in the secure state. This allows an end user to quickly notice that secure boot is off. This allows an end of line tester to verify that the fuses are in the correct state for customer delivery.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/","text":"Display Device State Null Library \u00b6 About \u00b6 The Display Device State NULL library is in the CI build when a real DisplayDeviceState library is not accessible. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Display Device State Lib Null"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/#display-device-state-null-library","text":"","title":"Display Device State Null Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/#about","text":"The Display Device State NULL library is in the CI build when a real DisplayDeviceState library is not accessible.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/","text":"FrameBufferMemDrawLib \u00b6 FrameBufferMemDrawLib is a wrapper around FrameBufferBltLib. This offers some nice benefits as the FrameBufferBltLib offers a nice abstractions of manipulating the frame buffer while it's in memory. This is most useful in situations where the full display protocol might not be up yet. FrameBufferMemDrawLib tries to simplify using the FrameBufferBltLib by gathering the information about the display, the pixel format, and getting the handles needed to manipulate the frame buffer. This is done through a constructor and a destructor. Methods offered \u00b6 MemDrawOnFrameBuffer \u00b6 This is meant to take a buffer that is formatted with 32bit pixels in the standard RGB+reserved format. It takes in the top left corner of the position on the screen where the buffer should be drawn. It also takes in the number of rows and columns of the buffer. MemFillOnFrameBuffer \u00b6 This fills in a region with a solid color. This color is the standard 32 bit format referenced in the previous method. This functions takes in the top left corner of the position on the screen where the color should be filled. It also takes in the number of rows and columns that the color should fill out to.","title":"Frame Buffer Mem Draw Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#framebuffermemdrawlib","text":"FrameBufferMemDrawLib is a wrapper around FrameBufferBltLib. This offers some nice benefits as the FrameBufferBltLib offers a nice abstractions of manipulating the frame buffer while it's in memory. This is most useful in situations where the full display protocol might not be up yet. FrameBufferMemDrawLib tries to simplify using the FrameBufferBltLib by gathering the information about the display, the pixel format, and getting the handles needed to manipulate the frame buffer. This is done through a constructor and a destructor.","title":"FrameBufferMemDrawLib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#methods-offered","text":"","title":"Methods offered"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#memdrawonframebuffer","text":"This is meant to take a buffer that is formatted with 32bit pixels in the standard RGB+reserved format. It takes in the top left corner of the position on the screen where the buffer should be drawn. It also takes in the number of rows and columns of the buffer.","title":"MemDrawOnFrameBuffer"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#memfillonframebuffer","text":"This fills in a region with a solid color. This color is the standard 32 bit format referenced in the previous method. This functions takes in the top left corner of the position on the screen where the color should be filled. It also takes in the number of rows and columns that the color should fill out to.","title":"MemFillOnFrameBuffer"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/","text":"MS Color Table Library \u00b6 About \u00b6 This package defines the absolute RGB values for each color that is used by users of the Simple Window Manager. Each UI element is assigned a color. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Color Table Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/#ms-color-table-library","text":"","title":"MS Color Table Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/#about","text":"This package defines the absolute RGB values for each color that is used by users of the Simple Window Manager. Each UI element is assigned a color.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/","text":"Ms Early Graphics NULL Library \u00b6 About \u00b6 This library is used in the CI build configuration. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Early Graphics Lib Null"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/#ms-early-graphics-null-library","text":"","title":"Ms Early Graphics NULL Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/#about","text":"This library is used in the CI build configuration.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/","text":"Ms Ui Theme Copy Library \u00b6 About \u00b6 MsUiThemeCopyLib is used to unpack the fonts from the packed FV into execution time structures. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Ui Theme Copy Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/#ms-ui-theme-copy-library","text":"","title":"Ms Ui Theme Copy Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/#about","text":"MsUiThemeCopyLib is used to unpack the fonts from the packed FV into execution time structures.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/","text":"Ms Ui Theme Library \u00b6 About \u00b6 The MsUiThemeLib publishes the MuUiTheme (Ppi/Protocol). Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Ui Theme Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/#ms-ui-theme-library","text":"","title":"Ms Ui Theme Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/#about","text":"The MsUiThemeLib publishes the MuUiTheme (Ppi/Protocol).","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/","text":"Qr Encoder Library \u00b6 About \u00b6 This package builds a QR code bit map object from binary data. The encoder supports all 40 versions, all 4 error correction levels (L, Q, M, H), but only three character encoding modes (Numeric, AlphNumeric, and Byte). Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Qr Encoder Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/#qr-encoder-library","text":"","title":"Qr Encoder Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/#about","text":"This package builds a QR code bit map object from binary data. The encoder supports all 40 versions, all 4 error correction levels (L, Q, M, H), but only three character encoding modes (Numeric, AlphNumeric, and Byte).","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/","text":"Sample Platform Theme Library \u00b6 About \u00b6 The Sample Platform Theme Library is used to specify the fonts and display size information to the Simple Window Manager. How to choose scale and font sizes \u00b6 The starting point is a 3000 W x 2000 H display as a 100% size. Start with your display size. Scale = (The width in pixels of the your display) / 3000. Change the #define SCALE value to your whole number scale value. Using Scale, multiply each font size in the sample by your Scale value and select a font point close to your Scale value.. Keep in mind that each font must be a unique fonts. The same font file cannot be used for multiple fonts. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Sample Platform Theme Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#sample-platform-theme-library","text":"","title":"Sample Platform Theme Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#about","text":"The Sample Platform Theme Library is used to specify the fonts and display size information to the Simple Window Manager.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#how-to-choose-scale-and-font-sizes","text":"The starting point is a 3000 W x 2000 H display as a 100% size. Start with your display size. Scale = (The width in pixels of the your display) / 3000. Change the #define SCALE value to your whole number scale value. Using Scale, multiply each font size in the sample by your Scale value and select a font point close to your Scale value.. Keep in mind that each font must be a unique fonts. The same font file cannot be used for multiple fonts.","title":"How to choose scale and font sizes"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/","text":"Simple UI ToolKit Library \u00b6 About \u00b6 The Simple UI Toolkit library allows code to create interfaces dynamically. The two sample users of the Simple UI Toolkit is the Display Engine and SwmDialogs Library. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Simple UITool Kit"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/#simple-ui-toolkit-library","text":"","title":"Simple UI ToolKit Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/#about","text":"The Simple UI Toolkit library allows code to create interfaces dynamically. The two sample users of the Simple UI Toolkit is the Display Engine and SwmDialogs Library.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/","text":"Swm Dialogs Library \u00b6 About \u00b6 The Simple Window Manager Dialog Library has a couple of dialogs that can be use by UEFI application. These dialogs use the Simple Window Manager. Dialog types \u00b6 Simple Message Box Password Prompt Selection Prompt SwmDialogsVerifyThumbprintPrompt special for DFCI Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Swm Dialogs Lib"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#swm-dialogs-library","text":"","title":"Swm Dialogs Library"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#about","text":"The Simple Window Manager Dialog Library has a couple of dialogs that can be use by UEFI application. These dialogs use the Simple Window Manager.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#dialog-types","text":"Simple Message Box Password Prompt Selection Prompt SwmDialogsVerifyThumbprintPrompt special for DFCI","title":"Dialog types"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/","text":"MS Early Graphics Drivers \u00b6 About \u00b6 The MsEarlyGraphics drivers load the fonts used for the Simple Window Manager, and is used to display Preboot information on the graphics console, when the display if first initialized (for example, in PEI) by drawing directly to the frame buffer. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Early Graphics"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/#ms-early-graphics-drivers","text":"","title":"MS Early Graphics Drivers"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/#about","text":"The MsEarlyGraphics drivers load the fonts used for the Simple Window Manager, and is used to display Preboot information on the graphics console, when the display if first initialized (for example, in PEI) by drawing directly to the frame buffer.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/","text":"MS UI Theme Drivers \u00b6 About \u00b6 The MsUiTheme drivers load the fonts used by the platform. Each platform must supply the font information required based on the display information. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Ui Theme"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/#ms-ui-theme-drivers","text":"","title":"MS UI Theme Drivers"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/#about","text":"The MsUiTheme drivers load the fonts used by the platform. Each platform must supply the font information required based on the display information.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/","text":"OnScreenKeyboardDxe \u00b6 About \u00b6 This driver implements an OnScreen keyboard driver. This driver relies heavily on the SimpleWindowManager, The SimpleUI Toolkit, and the RenderingEngine to implement a floating on screen keyboard that can be rotated on the display. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"On Screen Keyboard Dxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/#onscreenkeyboarddxe","text":"","title":"OnScreenKeyboardDxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/#about","text":"This driver implements an OnScreen keyboard driver. This driver relies heavily on the SimpleWindowManager, The SimpleUI Toolkit, and the RenderingEngine to implement a floating on screen keyboard that can be rotated on the display.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/","text":"PrintScreenLogger \u00b6 About \u00b6 PrintScreenLogger is a DXE_DRIVER you can include in your platform to obtain Screen Captures during the preboot environment by pressing the Ctrl-PrtScn key combination. This action will creates a 24bbp (Bits Per Pixel) .BMP file of the screen's contents and write it to a enabled USB drive. Supported Architectures \u00b6 This package is not architecturally dependent. This package is dependent upon the Gop pixel format, and only supports these two pixel formats: PixelRedGreenBlueReserved8BitPerColor PixelBlueGreenRedReserved8BitPerColor PrintScreenLogger operation \u00b6 During initialization, the Print Screen Logger registers for notification of the Ctrl-PrtScn key combination is pressed. When a Print Screen callback occurs: Looks for a mounted USB drive that contains a file in the root directory called PrintScreenEnable.txt . This limits PrintScreenLogger to only write to enabled USB devices. Looks for the next available filename in the form PrtScreen####.bmp , starting with 0000. Creates the new PrtScreen####.bmp file. Call GraphicsOutput->Blt to obtain the complete screen. Converts the BLT buffer to a 24bbp BMP structure. Writes the BMP structure to the new PrtScreen####.bmp file. Including in your platform \u00b6 Sample DSC change \u00b6 [Components.<arch>] ... ... MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf Sample FDF change \u00b6 [FV.<a DXE firmware volume>] ... ... INF MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Print Screen Logger"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#printscreenlogger","text":"","title":"PrintScreenLogger"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#about","text":"PrintScreenLogger is a DXE_DRIVER you can include in your platform to obtain Screen Captures during the preboot environment by pressing the Ctrl-PrtScn key combination. This action will creates a 24bbp (Bits Per Pixel) .BMP file of the screen's contents and write it to a enabled USB drive.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#supported-architectures","text":"This package is not architecturally dependent. This package is dependent upon the Gop pixel format, and only supports these two pixel formats: PixelRedGreenBlueReserved8BitPerColor PixelBlueGreenRedReserved8BitPerColor","title":"Supported Architectures"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#printscreenlogger-operation","text":"During initialization, the Print Screen Logger registers for notification of the Ctrl-PrtScn key combination is pressed. When a Print Screen callback occurs: Looks for a mounted USB drive that contains a file in the root directory called PrintScreenEnable.txt . This limits PrintScreenLogger to only write to enabled USB devices. Looks for the next available filename in the form PrtScreen####.bmp , starting with 0000. Creates the new PrtScreen####.bmp file. Call GraphicsOutput->Blt to obtain the complete screen. Converts the BLT buffer to a 24bbp BMP structure. Writes the BMP structure to the new PrtScreen####.bmp file.","title":"PrintScreenLogger operation"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#including-in-your-platform","text":"","title":"Including in your platform"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#sample-dsc-change","text":"[Components.<arch>] ... ... MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf","title":"Sample DSC change"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#sample-fdf-change","text":"[FV.<a DXE firmware volume>] ... ... INF MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf","title":"Sample FDF change"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/","text":"Rendering Engine Driver \u00b6 About \u00b6 The Rendering Engine is responsible for maintaining the supported windows, displaying popups, and restopring windows when popups are dismissed. The Rendering Engins is the only consumer of the MsGopOverrideProtocol and is the publisher of the \"real\" Efi Graphics Output protocol. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Rendering Engine Dxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/#rendering-engine-driver","text":"","title":"Rendering Engine Driver"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/#about","text":"The Rendering Engine is responsible for maintaining the supported windows, displaying popups, and restopring windows when popups are dismissed. The Rendering Engins is the only consumer of the MsGopOverrideProtocol and is the publisher of the \"real\" Efi Graphics Output protocol.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/","text":"Simple Window Manager \u00b6 About \u00b6 The Simple Window Manager manages window placement and pop up dialogs. The Simple Window Manager uses the Rendering Engine to display objects in their display region. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Simple Window Manager Dxe"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/#simple-window-manager","text":"","title":"Simple Window Manager"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/#about","text":"The Simple Window Manager manages window placement and pop up dialogs. The Simple Window Manager uses the Rendering Engine to display objects in their display region.","title":"About"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsWheaPkg/readme/","text":"MS WHEA Package \u00b6 About \u00b6 This package contains drivers and infrastructure for reporting errors and telemetry through the CPER (Common Platform Error Record) HwErrRecord interface, specifically targeting systems that also leverage WHEA (Windows Hardware Error Architecture). The MsWhea drivers provide the same functionality at different stages of UEFI by binding to the REPORT_STATUS_CODE interface. Together, they store hardware errors and corrected faults into non-volatile memory that is later picked up by Windows. In Windows, this can be emitted as telemetry which is then used to identify errors and patterns for devices (as of time of writing any event besides EFI_GENERIC_ERROR_INFO will be sent). Project MU has updated design which defines a specific section type under gMuTelemetrySectionTypeGuid to be used in CPER header for WHEA telemetry. All reported data will be formatted to this section. Please refer to MuTelemetryCperSection.h for field definitions. This package also contains optional solutions for persisting error records in the pre-memory space. In early boot stages, drivers need to emit events as critical in order for them to be logged. Detailed information about CPER can be found in Appendix N of the UEFI spec. How to include this driver \u00b6 This driver must be included via DSC by including the EarlyStorageLib: MsWheaEarlyStorageLib|MsWheaPkg/Library/MsWheaEarlyStorageLib/MsWheaEarlyStorageLib.inf Then the PEI stage driver will be included in the DSC Components.IA32 or PEI section: MsWheaPkg/MsWheaReport/Pei/MsWheaReportPei.inf Then the DXE stage driver will be included in the Components.X64 or DXE section: MsWheaPkg/MsWheaReport/Dxe/MsWheaReportDxe.inf Finally the SMM stage driver will be included in the Components.X64 or DXE_SMM_DRIVER section: MsWheaPkg/MsWheaReport/Smm/MsWheaReportSmm.inf Important Notes \u00b6 The PCD value of gMsWheaPkgTokenSpaceGuid.PcdDeviceIdentifierGuid must be overriden by each platform as this is later used in the CPER as the Platform ID (byte offset 32 in the record). In the DXE phase, errors will be picked up by MsWhea for you. In early phases of boot, the errors must be explicitly logged. To do so, first add the library into your INF: MsWheaPkg/MsWheaPkg.dec These headers must be included: MsWheaErrorStatus.h MuTelemetryCperSection.h Library/BaseLib.h Once you're ready to log your error, you can fill the MU_TELEMETRY_CPER_SECTION_DATA and report the StatusCode. The failure type is of type EFI_STATUS_CODE_VALUE. Note that MsWhea drivers will only listen to report status code calls with (EFI_ERROR_MINOR | EFI_ERROR_CODE) or (EFI_ERROR_MAJOR | EFI_ERROR_CODE) at EFI_STATUS_CODE_TYPE. ReportStatusCode ( MS_WHEA_ERROR_STATUS_TYPE_FATAL , {{ FAILURE_TYPE }}); for error under EFI_GENERIC_ERROR_FATAL severity. Or: ReportStatusCode ( MS_WHEA_ERROR_STATUS_TYPE_INFO , {{ FAILURE_TYPE }}); will report errors under EFI_GENERIC_ERROR_INFO severity. Testing \u00b6 There is a UEFI shell application based unit test for WHEA reports. This test attempts to verify basic functionality of public interfaces. Check the UnitTests folder at the root of the package. There is also a feature flag that can inject reports on each boot during various uefi stages. This flag should be off in production. Helper Lib \u00b6 A helper lib to help integrate the MsWhea package has been provided. It is entirely optional and can be easily dropped in. It provides a few macros that are detailed here. LOG_INFO_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_INFO_EVENT ( ClassId ) LOG_CRITICAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_CRITICAL_EVENT ( ClassId ) LOG_FATAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_FATAL_EVENT ( ClassId ) Currently FATAL and CRITICAL map to the same level in the WHEA log but has been implemented to provide future functionality. The parameters are as follows. ClassId - An EFI_STATUS_CODE_VALUE representing the event that has occurred. This should be unique enough to identify a module or region of code. LibraryId - An optional EFI_GUID that should identify the library emitting this event IhvId - An optional EFI_GUID that should identify the Ihv that is most applicable to this. This will often be NULL ExtraData1 - A UINT64 that can be used to provide contextual or runtime data. It will be persisted and can be useful for debugging purposes. ExtraData2 - Another UINT64 that is also used for contextual and runtime data similar to ExtraData1. By default, gEfiCallerIdGuid is used as the module ID when using the macros. If you need complete control over the WHEA entry, you can use the LogTelemetry function to log a telemetry event. This is the function that the Macros use. More information on this function is in the public header for MuTelemetryHelperLib. Including the Helper Lib \u00b6 The helper lib can easily be included by including it in your DSC. [LibraryClasses] MuTelemetryHelperLib|MsWheaPkg/Library/MuTelemetryHelperLib/MuTelemetryHelperLib.inf Since it is a BASE library, it is available for all architectures. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"readme"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#ms-whea-package","text":"","title":"MS WHEA Package"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#about","text":"This package contains drivers and infrastructure for reporting errors and telemetry through the CPER (Common Platform Error Record) HwErrRecord interface, specifically targeting systems that also leverage WHEA (Windows Hardware Error Architecture). The MsWhea drivers provide the same functionality at different stages of UEFI by binding to the REPORT_STATUS_CODE interface. Together, they store hardware errors and corrected faults into non-volatile memory that is later picked up by Windows. In Windows, this can be emitted as telemetry which is then used to identify errors and patterns for devices (as of time of writing any event besides EFI_GENERIC_ERROR_INFO will be sent). Project MU has updated design which defines a specific section type under gMuTelemetrySectionTypeGuid to be used in CPER header for WHEA telemetry. All reported data will be formatted to this section. Please refer to MuTelemetryCperSection.h for field definitions. This package also contains optional solutions for persisting error records in the pre-memory space. In early boot stages, drivers need to emit events as critical in order for them to be logged. Detailed information about CPER can be found in Appendix N of the UEFI spec.","title":"About"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#how-to-include-this-driver","text":"This driver must be included via DSC by including the EarlyStorageLib: MsWheaEarlyStorageLib|MsWheaPkg/Library/MsWheaEarlyStorageLib/MsWheaEarlyStorageLib.inf Then the PEI stage driver will be included in the DSC Components.IA32 or PEI section: MsWheaPkg/MsWheaReport/Pei/MsWheaReportPei.inf Then the DXE stage driver will be included in the Components.X64 or DXE section: MsWheaPkg/MsWheaReport/Dxe/MsWheaReportDxe.inf Finally the SMM stage driver will be included in the Components.X64 or DXE_SMM_DRIVER section: MsWheaPkg/MsWheaReport/Smm/MsWheaReportSmm.inf","title":"How to include this driver"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#important-notes","text":"The PCD value of gMsWheaPkgTokenSpaceGuid.PcdDeviceIdentifierGuid must be overriden by each platform as this is later used in the CPER as the Platform ID (byte offset 32 in the record). In the DXE phase, errors will be picked up by MsWhea for you. In early phases of boot, the errors must be explicitly logged. To do so, first add the library into your INF: MsWheaPkg/MsWheaPkg.dec These headers must be included: MsWheaErrorStatus.h MuTelemetryCperSection.h Library/BaseLib.h Once you're ready to log your error, you can fill the MU_TELEMETRY_CPER_SECTION_DATA and report the StatusCode. The failure type is of type EFI_STATUS_CODE_VALUE. Note that MsWhea drivers will only listen to report status code calls with (EFI_ERROR_MINOR | EFI_ERROR_CODE) or (EFI_ERROR_MAJOR | EFI_ERROR_CODE) at EFI_STATUS_CODE_TYPE. ReportStatusCode ( MS_WHEA_ERROR_STATUS_TYPE_FATAL , {{ FAILURE_TYPE }}); for error under EFI_GENERIC_ERROR_FATAL severity. Or: ReportStatusCode ( MS_WHEA_ERROR_STATUS_TYPE_INFO , {{ FAILURE_TYPE }}); will report errors under EFI_GENERIC_ERROR_INFO severity.","title":"Important Notes"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#testing","text":"There is a UEFI shell application based unit test for WHEA reports. This test attempts to verify basic functionality of public interfaces. Check the UnitTests folder at the root of the package. There is also a feature flag that can inject reports on each boot during various uefi stages. This flag should be off in production.","title":"Testing"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#helper-lib","text":"A helper lib to help integrate the MsWhea package has been provided. It is entirely optional and can be easily dropped in. It provides a few macros that are detailed here. LOG_INFO_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_INFO_EVENT ( ClassId ) LOG_CRITICAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_CRITICAL_EVENT ( ClassId ) LOG_FATAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData ) LOG_FATAL_EVENT ( ClassId ) Currently FATAL and CRITICAL map to the same level in the WHEA log but has been implemented to provide future functionality. The parameters are as follows. ClassId - An EFI_STATUS_CODE_VALUE representing the event that has occurred. This should be unique enough to identify a module or region of code. LibraryId - An optional EFI_GUID that should identify the library emitting this event IhvId - An optional EFI_GUID that should identify the Ihv that is most applicable to this. This will often be NULL ExtraData1 - A UINT64 that can be used to provide contextual or runtime data. It will be persisted and can be useful for debugging purposes. ExtraData2 - Another UINT64 that is also used for contextual and runtime data similar to ExtraData1. By default, gEfiCallerIdGuid is used as the module ID when using the macros. If you need complete control over the WHEA entry, you can use the LogTelemetry function to log a telemetry event. This is the function that the Macros use. More information on this function is in the public header for MuTelemetryHelperLib.","title":"Helper Lib"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#including-the-helper-lib","text":"The helper lib can easily be included by including it in your DSC. [LibraryClasses] MuTelemetryHelperLib|MsWheaPkg/Library/MuTelemetryHelperLib/MuTelemetryHelperLib.inf Since it is a BASE library, it is available for all architectures.","title":"Including the Helper Lib"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/","text":"HwhMenu \u00b6 About \u00b6 A UEFI front page application which displays various fields of hardware error records to the user. The application attempts to parse fields to provide more useful information and prints the raw data if it cannot. Main File \u00b6 HwhMenu.c \u00b6 The main application file. Loading Logs \u00b6 The HwErrRecs are loaded when the Hardware Health tab is first opened using GetVariable(). The records are verified using CheckHwErrRecHeaderLib within MsWheaPkg before being added to a linked list structure. The linked list is not being deleted because it will simply be reclaimed when the OS boots or another allocation call is made which needs that memory. The config struct used by the vfr holds a single UINT8 which if equal to LOGS_TRUE means there are errors to display. If it is equal to LOGS_FALSE, the page will be suppressed and a string saying that there are no logs present will be displayed at the top. Paging between logs and updating the form \u00b6 There is a simple paging interface between records. Whenever Next or Previous is pressed by the user, the page attempts to perform the desired action. If it is successful, UpdateForm() is called which simply inserts nothing into the label section of the VFR. What this does is make the form think it has been updated and tricks it into refreshing, thus allowing all error specific strings which have been edited to be displayed to the user. Parsing the logs \u00b6 Each field which we display is parsed using the structs defined in Cper.h. Parsing most fields is straightforward, but parsing section data requires a bit more work. When preparing section data for the user, a call is made to ParserRegistryLib using the Section Type guid within the section header of the hardware error record. The parser registry holds a table which associates guids with function pointers, and any entity which employs its own section guid should register a section data parser with the library. During parsing, if the section type matches one in the register, the function pointer is called with the parameters specified in ParserRegistryLib.h (SECTIONFUNCTIONPTR). The parser parses the data and populates an array of strings with their desired display. HwhMenu.c holds a 2D array of EFI_STRING_IDs which are the lines/columns where section data can be placed. The populated string array is written to these strings until there is no more data to display or there are no more strings to put the data. The user can place '\\n' within their strings to separate a line into columns. See the GenericSectionParserLib for a parsing example. Adding to the Section Parser \u00b6 If you, the platform developer, recognize a section guid and know how to parse the bytes, you can provide a function to do so by calling ParserLibRegisterSectionParser() with the guid you're able to parse and a function pointer to parse it. This can be done within a new driver or by simply extending an existing driver. The HWH menu will pass to your function (if the guid matches) a pointer to the section data and a pointer to an array of strings to fill out with your completed parse. Secondary files \u00b6 CreatorIDParser.c and PlatformIDParser.c \u00b6 Called from within the HwhMenu.c file to parse the Creator and Platform IDs. HwhMenuVfr.h \u00b6 Holds configuration information and guid opcodes used in the VFR file Including the HWH Menu \u00b6 To include, paste the following in the platform DSC flie: [LibraryClasses] ParserRegistryLib |MsWheaPkg/Library/ParserRegistryLib/ParserRegistryLib.inf CheckHwErrRecHeaderLib|MsWheaPkg/Library/CheckHwErrRecHeaderLib/CheckHwErrRecHeaderLib.inf [Components.X64] MsWheaPkg/HwhMenu/HwhMenu.inf and the following in the platform FDF file [FV.FVDXE] INF MsWheaPkg/HwhMenu/HwhMenu.inf Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Hwh Menu"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#hwhmenu","text":"","title":"HwhMenu"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#about","text":"A UEFI front page application which displays various fields of hardware error records to the user. The application attempts to parse fields to provide more useful information and prints the raw data if it cannot.","title":"About"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#main-file","text":"","title":"Main File"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#hwhmenuc","text":"The main application file.","title":"HwhMenu.c"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#loading-logs","text":"The HwErrRecs are loaded when the Hardware Health tab is first opened using GetVariable(). The records are verified using CheckHwErrRecHeaderLib within MsWheaPkg before being added to a linked list structure. The linked list is not being deleted because it will simply be reclaimed when the OS boots or another allocation call is made which needs that memory. The config struct used by the vfr holds a single UINT8 which if equal to LOGS_TRUE means there are errors to display. If it is equal to LOGS_FALSE, the page will be suppressed and a string saying that there are no logs present will be displayed at the top.","title":"Loading Logs"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#paging-between-logs-and-updating-the-form","text":"There is a simple paging interface between records. Whenever Next or Previous is pressed by the user, the page attempts to perform the desired action. If it is successful, UpdateForm() is called which simply inserts nothing into the label section of the VFR. What this does is make the form think it has been updated and tricks it into refreshing, thus allowing all error specific strings which have been edited to be displayed to the user.","title":"Paging between logs and updating the form"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#parsing-the-logs","text":"Each field which we display is parsed using the structs defined in Cper.h. Parsing most fields is straightforward, but parsing section data requires a bit more work. When preparing section data for the user, a call is made to ParserRegistryLib using the Section Type guid within the section header of the hardware error record. The parser registry holds a table which associates guids with function pointers, and any entity which employs its own section guid should register a section data parser with the library. During parsing, if the section type matches one in the register, the function pointer is called with the parameters specified in ParserRegistryLib.h (SECTIONFUNCTIONPTR). The parser parses the data and populates an array of strings with their desired display. HwhMenu.c holds a 2D array of EFI_STRING_IDs which are the lines/columns where section data can be placed. The populated string array is written to these strings until there is no more data to display or there are no more strings to put the data. The user can place '\\n' within their strings to separate a line into columns. See the GenericSectionParserLib for a parsing example.","title":"Parsing the logs"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#adding-to-the-section-parser","text":"If you, the platform developer, recognize a section guid and know how to parse the bytes, you can provide a function to do so by calling ParserLibRegisterSectionParser() with the guid you're able to parse and a function pointer to parse it. This can be done within a new driver or by simply extending an existing driver. The HWH menu will pass to your function (if the guid matches) a pointer to the section data and a pointer to an array of strings to fill out with your completed parse.","title":"Adding to the Section Parser"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#secondary-files","text":"","title":"Secondary files"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#creatoridparserc-and-platformidparserc","text":"Called from within the HwhMenu.c file to parse the Creator and Platform IDs.","title":"CreatorIDParser.c and PlatformIDParser.c"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#hwhmenuvfrh","text":"Holds configuration information and guid opcodes used in the VFR file","title":"HwhMenuVfr.h"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#including-the-hwh-menu","text":"To include, paste the following in the platform DSC flie: [LibraryClasses] ParserRegistryLib |MsWheaPkg/Library/ParserRegistryLib/ParserRegistryLib.inf CheckHwErrRecHeaderLib|MsWheaPkg/Library/CheckHwErrRecHeaderLib/CheckHwErrRecHeaderLib.inf [Components.X64] MsWheaPkg/HwhMenu/HwhMenu.inf and the following in the platform FDF file [FV.FVDXE] INF MsWheaPkg/HwhMenu/HwhMenu.inf","title":"Including the HWH Menu"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/","text":"ParserRegistryLib \u00b6 About \u00b6 Holds a table which associates guids with function pointers used for parsing section data. If an entity wishes to parse a section type in a specific way, they simply need to call the register function using a the section type guid and function pointer. When HwhMenu.c tries to parse section data, it will look through all guids and return a function pointer if one matches. The functions being registered must adhere to the SECTIONFUNCTIONPTR type located in ParserRegistryLib.h. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Parser Registry Lib"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/#parserregistrylib","text":"","title":"ParserRegistryLib"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/#about","text":"Holds a table which associates guids with function pointers used for parsing section data. If an entity wishes to parse a section type in a specific way, they simply need to call the register function using a the section type guid and function pointer. When HwhMenu.c tries to parse section data, it will look through all guids and return a function pointer if one matches. The functions being registered must adhere to the SECTIONFUNCTIONPTR type located in ParserRegistryLib.h.","title":"About"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/","text":"MS Network DependencyLib and NetworkDelayLib \u00b6 About \u00b6 These libraries implement a method to disable the network stack unless there is a reason to use the network. Not starting the network improves boot performance and causes fewer issues during manufacturing. How to use these libraries \u00b6 Add the NetworkDelayLib as a NULL library reference. All this library does is introduce a [Depex] on a NetworkDelay protocol. MdeModulePkg/Universal/Network/SnpDxe/SnpDxe.inf { <LibraryClasses> NULL|PcBdsPkg/Library/MsNetworkDelayLib/MsNetworkDelayLib.inf } The NetworkDependencyLib implements a StartNetwork() interface that will publish the NetworkDelay protocol. The future goal of this functionality is to have the EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() function be overridden and insert a call to DeviceDependencyLib.StartNetwork() when a request is made to start the network class. You nay see other references to NetworkDependencyLib as the conversion to using EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() is not complete. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Network Dependency Lib"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#ms-network-dependencylib-and-networkdelaylib","text":"","title":"MS Network DependencyLib and NetworkDelayLib"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#about","text":"These libraries implement a method to disable the network stack unless there is a reason to use the network. Not starting the network improves boot performance and causes fewer issues during manufacturing.","title":"About"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#how-to-use-these-libraries","text":"Add the NetworkDelayLib as a NULL library reference. All this library does is introduce a [Depex] on a NetworkDelay protocol. MdeModulePkg/Universal/Network/SnpDxe/SnpDxe.inf { <LibraryClasses> NULL|PcBdsPkg/Library/MsNetworkDelayLib/MsNetworkDelayLib.inf } The NetworkDependencyLib implements a StartNetwork() interface that will publish the NetworkDelay protocol. The future goal of this functionality is to have the EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() function be overridden and insert a call to DeviceDependencyLib.StartNetwork() when a request is made to start the network class. You nay see other references to NetworkDependencyLib as the conversion to using EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() is not complete.","title":"How to use these libraries"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/","text":"UEFI Testing Package \u00b6 About \u00b6 This package adds tests. System Functional tests \u00b6 Tests that invoke system functions and query system state for verification. MemmapAndMatTestApp \u00b6 This test compares the UEFI memory map and Memory Attributes Table against known requirements. The MAT has strict requirements to allow OS usage and page protections. MorLockTestApp \u00b6 This test verifies the UEFI variable store handling of MorLock v1 and v2 behavior. SmmPagingProtections \u00b6 This test verifies the SMM paging attributes by invoking operations that should cause cpu exceptions if the memory protections are in place. The SMM cpu exception handler needs to be configured to force reset on trap to allow automated testing. See UefiCpuPkg/Include/Protocol/SmmExceptionTestProtocol.h , gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionRebootInsteadOfHaltDefault , and gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionTestModeSupport . System Audit tests \u00b6 UEFI applications that collect data from the system and then that data can be used to compare against known good values. UefiVarLockAudit \u00b6 Audit collection tool that gathers information about UEFI variables. This allows auditing the variables within a system, checking attributes, and confirming read/write status. This information is put into an XML file that allows for easy comparison and programmatic auditing. UEFI \u00b6 UEFI shell application that gets the current variable information from the UEFI shell and creates an XML file. Windows (UEFI) \u00b6 Python script that can be run from the Windows OS. It takes the UEFI created XML file as input and then queries all listed variables and updates the XML with access and status codes. This gives additional verification for variables that may employ late locking or other protections from OS access. TpmEventLogAudit \u00b6 Audit tool to collect the TPM Event Log from the system in standard format. It can then be programmatically compared against a known event log for the given system. Easy this that can be tested are the number of events in some PCRs, confirm that all PCRs should be capped, etc. SMMPagingAudit \u00b6 Audit tool creates a human readable description of the SMM page tables and memory environment. App \u00b6 UEFI shell application collects information from SMM and writes it to files. SMM \u00b6 SMM Library linked into SMM driver used to collect information about SMM environment. Activated by the shell app collects IDT, GDT, page tables, and loaded images. Windows (SMM) \u00b6 Python scripts that process the files generated by the UEFI app and output a report for verification and analysis. Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Readme"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#uefi-testing-package","text":"","title":"UEFI Testing Package"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#about","text":"This package adds tests.","title":"About"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#system-functional-tests","text":"Tests that invoke system functions and query system state for verification.","title":"System Functional tests"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#memmapandmattestapp","text":"This test compares the UEFI memory map and Memory Attributes Table against known requirements. The MAT has strict requirements to allow OS usage and page protections.","title":"MemmapAndMatTestApp"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#morlocktestapp","text":"This test verifies the UEFI variable store handling of MorLock v1 and v2 behavior.","title":"MorLockTestApp"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smmpagingprotections","text":"This test verifies the SMM paging attributes by invoking operations that should cause cpu exceptions if the memory protections are in place. The SMM cpu exception handler needs to be configured to force reset on trap to allow automated testing. See UefiCpuPkg/Include/Protocol/SmmExceptionTestProtocol.h , gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionRebootInsteadOfHaltDefault , and gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionTestModeSupport .","title":"SmmPagingProtections"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#system-audit-tests","text":"UEFI applications that collect data from the system and then that data can be used to compare against known good values.","title":"System Audit tests"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#uefivarlockaudit","text":"Audit collection tool that gathers information about UEFI variables. This allows auditing the variables within a system, checking attributes, and confirming read/write status. This information is put into an XML file that allows for easy comparison and programmatic auditing.","title":"UefiVarLockAudit"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#uefi","text":"UEFI shell application that gets the current variable information from the UEFI shell and creates an XML file.","title":"UEFI"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#windows-uefi","text":"Python script that can be run from the Windows OS. It takes the UEFI created XML file as input and then queries all listed variables and updates the XML with access and status codes. This gives additional verification for variables that may employ late locking or other protections from OS access.","title":"Windows (UEFI)"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#tpmeventlogaudit","text":"Audit tool to collect the TPM Event Log from the system in standard format. It can then be programmatically compared against a known event log for the given system. Easy this that can be tested are the number of events in some PCRs, confirm that all PCRs should be capped, etc.","title":"TpmEventLogAudit"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smmpagingaudit","text":"Audit tool creates a human readable description of the SMM page tables and memory environment.","title":"SMMPagingAudit"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#app","text":"UEFI shell application collects information from SMM and writes it to files.","title":"App"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smm","text":"SMM Library linked into SMM driver used to collect information about SMM environment. Activated by the shell app collects IDT, GDT, page tables, and loaded images.","title":"SMM"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#windows-smm","text":"Python scripts that process the files generated by the UEFI app and output a report for verification and analysis.","title":"Windows (SMM)"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/","text":"DMAR Table Audit \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About \u00b6 DMAProtectionUnitTestApp.c Shell based UEFI unit test based off of the UnitTestFrameworkPkg that test for: IOMMU status register shows IOMMU enabled All excluded regions are set as EfiReservedMemoryType(VTd)/EfiACPIMemoryNVS(IVRS) Bus mastering enabled (BME) is disabled on ExitBootServices. Because we can no longer write to file after ExitBootServices a variable is used to store the test state and the machine. Note: this unit test requires a restart to finish its testing. If you plan to use this unit test in automation make sure to set up your startup.nsh script properly.","title":"UEFI"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/#dmar-table-audit","text":"","title":"DMAR Table Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/#about","text":"DMAProtectionUnitTestApp.c Shell based UEFI unit test based off of the UnitTestFrameworkPkg that test for: IOMMU status register shows IOMMU enabled All excluded regions are set as EfiReservedMemoryType(VTd)/EfiACPIMemoryNVS(IVRS) Bus mastering enabled (BME) is disabled on ExitBootServices. Because we can no longer write to file after ExitBootServices a variable is used to store the test state and the machine. Note: this unit test requires a restart to finish its testing. If you plan to use this unit test in automation make sure to set up your startup.nsh script properly.","title":"About"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/","text":"DMAR Table Audit \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About \u00b6 DMARTableAudit.py Unit test that checks: DMA remapping bit is enabled No ANDD structures are included in DMAR table RMRRs are limited to only the RMRRs specified in provided XML file (if no XML provided then verify no RMRRs exist) Software Requirements Python3 Pywin32 pip install Pywin32 Project Mu python library pip install mu-python-library","title":"Windows"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/#dmar-table-audit","text":"","title":"DMAR Table Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/#about","text":"DMARTableAudit.py Unit test that checks: DMA remapping bit is enabled No ANDD structures are included in DMAR table RMRRs are limited to only the RMRRs specified in provided XML file (if no XML provided then verify no RMRRs exist) Software Requirements Python3 Pywin32 pip install Pywin32 Project Mu python library pip install mu-python-library","title":"About"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/","text":"Paging Audit \u00b6 SmmPagingAudit \u00b6 SMM is a privileged mode of the ia32/x64 cpu architecture. In this environment nearly all system state can be inspected including that of the operating system, kernel, and hypervisor. Due to it's capabilities SMM has become an area of interest for those searching to exploit the system. To help minimize the interest and impact of an exploit in SMM the SMI handlers should operate in a least privileged model. To do this standard paging can be leveraged to limit the SMI handlers access. Tianocore has a feature to enable paging within SMM and this tool helps confirm the configuration being used. This tool requires three parts to get a complete view. SMM \u00b6 The SMM driver must be included in your build and dispatched to SMM before the End Of Dxe. It is recommended that this driver should only be used on debug builds as it reports the entire SMM memory environment to the caller. The shell app will communicate to the SMM driver and request critical memory information including IDT, GDT, page tables, and loaded images. SMM Version App \u00b6 The UEFI shell application collects system information from the DXE environment and then communicates to the SMM driver/handler to collect necessary info from SMM. It then writes this data to files and then that content is used by the windows scripts. DxePagingAudit \u00b6 The Dxe version of paging audit driver/shell app intends to inspect all 4 levels of page tables and their corresponding Read/Write/Execute/Present attributes. The driver/shell app will collect necessary memory information from platform environment, then iterate through each page entries and log them on to available SimpleFileSystem. The collected *.dat files can be parsed using Windows\\PagingReportGenerator.py. DXE Driver \u00b6 The DXE Driver registers an event to be notified on Mu Pre Exit Boot Services (to change this, replace gMuEventPreExitBootServicesGuid with a different event GUID), which will then trigger the paging information collection. DXE Version App \u00b6 The DXE version of UEFI shell application collects necessary system and memory information from DXE when invoked from Shell environment. Windows \u00b6 The Windows script will look at the *.DAT files, parse their content, check for errors and then insert the formatted data into the Html report file. This report file is then double-clickable by the end user/developer to review the posture of the SMM environment. The Results tab applies our suggested rules for SMM to show if the environment passes or fails. If it fails the filters on the data tab can be configured to show where the problem exists. Usage / Enabling on EDK2 based system \u00b6 First, for the SMM driver and app you need to add them to your DSC file for your project so they get compiled. SMM Paging Audit \u00b6 [PcdsFixedAtBuild.X64] # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditTestApp.inf Next, you must add the SMM driver to a firmware volume in your FDF that can dispatch SMM modules. INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf Third, after compiling your new firmware you must: Flash that image on the system. Copy the SmmPagingAuditTestApp.efi to a USB key Then, boot your system running the new firmware to the shell and run the app. The tool will create a set of *.dat files on the same USB key. On a Windows PC, run the Python script on the data found on your USB key. Finally, double-click the HTML output file and check your results. DXE Paging Audit \u00b6 DxePagingAuditDxe \u00b6 Add the following entry to platform dsc file; [PcdsFixedAtBuild.X64] # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf Add the driver to a firmware volume in your FDF that can dispatch it; INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf After compiling your new firmware you must flash that image on the system. Boot your system running the new firmware to the OS then reboot to UEFI shell with a USB plugged in. If the USB disk is FS0:\\\\ , the files should be in FS1:\\\\ . Copy them to the flash drive: copy FS1:\\*.dat FS0:\\ On a Windows PC, run Windows\\PagingReportGenerator.py script with the data found on your USB key. Please use the following command for detailed script instruction: PagingReportGenerator.py -h Double-click the HTML output file and check your results. DxePagingAuditTestApp \u00b6 Add the following entry to platform dsc file: [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditTestApp.inf Compile the newly added application and copy DxePagingAuditTestApp.efi to a USB key. Boot your system to the shell with the USB plugged in. If the USB disk is FS0:\\ , the files should be in FS1:\\\\ . Copy them to the flash drive: FS0:\\ DxePagingAuditTestApp.efi copy FS1:\\*.dat FS0:\\ Follow step 5 - 6 from DxePagingAuditDxe section. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Paging Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#paging-audit","text":"","title":"Paging Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smmpagingaudit","text":"SMM is a privileged mode of the ia32/x64 cpu architecture. In this environment nearly all system state can be inspected including that of the operating system, kernel, and hypervisor. Due to it's capabilities SMM has become an area of interest for those searching to exploit the system. To help minimize the interest and impact of an exploit in SMM the SMI handlers should operate in a least privileged model. To do this standard paging can be leveraged to limit the SMI handlers access. Tianocore has a feature to enable paging within SMM and this tool helps confirm the configuration being used. This tool requires three parts to get a complete view.","title":"SmmPagingAudit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm","text":"The SMM driver must be included in your build and dispatched to SMM before the End Of Dxe. It is recommended that this driver should only be used on debug builds as it reports the entire SMM memory environment to the caller. The shell app will communicate to the SMM driver and request critical memory information including IDT, GDT, page tables, and loaded images.","title":"SMM"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm-version-app","text":"The UEFI shell application collects system information from the DXE environment and then communicates to the SMM driver/handler to collect necessary info from SMM. It then writes this data to files and then that content is used by the windows scripts.","title":"SMM Version App"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingaudit","text":"The Dxe version of paging audit driver/shell app intends to inspect all 4 levels of page tables and their corresponding Read/Write/Execute/Present attributes. The driver/shell app will collect necessary memory information from platform environment, then iterate through each page entries and log them on to available SimpleFileSystem. The collected *.dat files can be parsed using Windows\\PagingReportGenerator.py.","title":"DxePagingAudit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-driver","text":"The DXE Driver registers an event to be notified on Mu Pre Exit Boot Services (to change this, replace gMuEventPreExitBootServicesGuid with a different event GUID), which will then trigger the paging information collection.","title":"DXE Driver"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-version-app","text":"The DXE version of UEFI shell application collects necessary system and memory information from DXE when invoked from Shell environment.","title":"DXE Version App"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#windows","text":"The Windows script will look at the *.DAT files, parse their content, check for errors and then insert the formatted data into the Html report file. This report file is then double-clickable by the end user/developer to review the posture of the SMM environment. The Results tab applies our suggested rules for SMM to show if the environment passes or fails. If it fails the filters on the data tab can be configured to show where the problem exists.","title":"Windows"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#usage-enabling-on-edk2-based-system","text":"First, for the SMM driver and app you need to add them to your DSC file for your project so they get compiled.","title":"Usage / Enabling on EDK2 based system"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm-paging-audit","text":"[PcdsFixedAtBuild.X64] # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditTestApp.inf Next, you must add the SMM driver to a firmware volume in your FDF that can dispatch SMM modules. INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf Third, after compiling your new firmware you must: Flash that image on the system. Copy the SmmPagingAuditTestApp.efi to a USB key Then, boot your system running the new firmware to the shell and run the app. The tool will create a set of *.dat files on the same USB key. On a Windows PC, run the Python script on the data found on your USB key. Finally, double-click the HTML output file and check your results.","title":"SMM Paging Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-paging-audit","text":"","title":"DXE Paging Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingauditdxe","text":"Add the following entry to platform dsc file; [PcdsFixedAtBuild.X64] # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf Add the driver to a firmware volume in your FDF that can dispatch it; INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf After compiling your new firmware you must flash that image on the system. Boot your system running the new firmware to the OS then reboot to UEFI shell with a USB plugged in. If the USB disk is FS0:\\\\ , the files should be in FS1:\\\\ . Copy them to the flash drive: copy FS1:\\*.dat FS0:\\ On a Windows PC, run Windows\\PagingReportGenerator.py script with the data found on your USB key. Please use the following command for detailed script instruction: PagingReportGenerator.py -h Double-click the HTML output file and check your results.","title":"DxePagingAuditDxe"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingaudittestapp","text":"Add the following entry to platform dsc file: [Components.X64] UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditTestApp.inf Compile the newly added application and copy DxePagingAuditTestApp.efi to a USB key. Boot your system to the shell with the USB plugged in. If the USB disk is FS0:\\ , the files should be in FS1:\\\\ . Copy them to the flash drive: FS0:\\ DxePagingAuditTestApp.efi copy FS1:\\*.dat FS0:\\ Follow step 5 - 6 from DxePagingAuditDxe section.","title":"DxePagingAuditTestApp"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/","text":"Variable Lock Audit Test \u00b6 The Variable Lock Audit tests is a tool to ensure that variables have the correct policy. The test is only a helper. That is, running the Audit test generates a report. Developers need to understand the report, and ensure that all the variable have the correct policy. The reviewed report is saved as a master known good report. Later, after ingesting new code and update the firmware, you can run the audit test and compare the new report with the previously stored master known good report. Two versions of the Variable Audit Test \u00b6 There are two versions of the Variable Audit Test. One is a shell application to check all the variables visible during Boot Services. The second version of the Variable Audit Test checks all the variables visible in the OS using the list of variables generated bu the UEFI version of the test. Building the UEFI version of the tool \u00b6 Just add the following to your platform package .dsc file: UefiTestingPkg/AuditTests/UefiVarLockAudit/UEFI/UefiVarLockAuditTestApp.inf Running the VarLockAudit Test \u00b6 Copy UefiVarLockAuditTestApp.efi, UefiVarAudit.py, and UefiVariablesSupportLib.py to a USB device. First, you need to run the UEFI Version of the test by booting to the UEFI Shell. Log into the USB device (ie FS0:). Run UefiVarLockAuditTestApp.efi to generate the UefiVarLockAudit_manifest.xml file: FS0:> UefiVarLockAuditTestApp Boot the system into Windows. Open an Administrator Cmd window. Change the drive to the USB device, and to the directory to where UefiVarLockAudit_manifest.xml, UefiVarAudit.py, and UefiVariablesSupportLib.py are stored. Run: D:\\python UefiVarAudit.py -InputXml UefiVarLockAudit_manifest.xml -OutputXml VarLockAuditResults.xml Analyzing the VarLockAuditResults.xml \u00b6 Here is an example of a Boot Services variable: <Variable Guid= \"4C19049F-4137-4DD3-9C10-8B97A83FFDFA\" Name= \"MemoryTypeInformation\" > <Attributes> 0x3 NV BS </Attributes> <Size> 48 </Size> <Data> 09000000580000000A000000200000000000000029000000060000004601000005000000B70000000F00000000000000 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0xCB [WinError 203] The system could not find the environment option that was entered. </ReadStatus> <WriteStatus> 0x13 [WinError 19] The media is write protected. </WriteStatus> </FromOs> </Variable> It shows the results of reading and writing to the variable at two places. One is after ReadyToBoot, and is provided by the UEFI version of the VarLockAudit test. The other is in the OS. In this example, the variable does not have the RT (Runtime) attributes, and Windows cannot read this variable. It also cannot write to the variable since is is present. Here is an example of a variable with the Runtime attribute: <Variable Guid= \"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name= \"BootOrder\" > <Attributes> 0x7 NV BS RT </Attributes> <Size> 10 </Size> <Data> 05000000010002000300 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0x0 </ReadStatus> <WriteStatus> 0x0 </WriteStatus> </FromOs> </Variable> ```` The BootOrder variable is readable and writable in the OS. Here is an example of a write protected RT variable: ```xml <Variable Guid= \"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name= \"ConOutDev\" > <Attributes> 0x6 BS RT </Attributes> <Size> 30 </Size> <Data> 02010C00D041030A0000000001010600000202030800001401807FFF0400 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0x0 </ReadStatus> <WriteStatus> 0x13 [WinError 19] The media is write protected. </WriteStatus> </FromOs> </Variable> Subsequent runs of the Variable Audit test \u00b6 Once you have validated the results file, you can save it as a Good Master. You could simply run the tests on every firmware and compare the newly generated VarLockAuditResults.xml with the Good Master you saved. You only need to analyze the differences.","title":"Uefi Var Lock Audit"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#variable-lock-audit-test","text":"The Variable Lock Audit tests is a tool to ensure that variables have the correct policy. The test is only a helper. That is, running the Audit test generates a report. Developers need to understand the report, and ensure that all the variable have the correct policy. The reviewed report is saved as a master known good report. Later, after ingesting new code and update the firmware, you can run the audit test and compare the new report with the previously stored master known good report.","title":"Variable Lock Audit Test"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#two-versions-of-the-variable-audit-test","text":"There are two versions of the Variable Audit Test. One is a shell application to check all the variables visible during Boot Services. The second version of the Variable Audit Test checks all the variables visible in the OS using the list of variables generated bu the UEFI version of the test.","title":"Two versions of the Variable Audit Test"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#building-the-uefi-version-of-the-tool","text":"Just add the following to your platform package .dsc file: UefiTestingPkg/AuditTests/UefiVarLockAudit/UEFI/UefiVarLockAuditTestApp.inf","title":"Building the UEFI version of the tool"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#running-the-varlockaudit-test","text":"Copy UefiVarLockAuditTestApp.efi, UefiVarAudit.py, and UefiVariablesSupportLib.py to a USB device. First, you need to run the UEFI Version of the test by booting to the UEFI Shell. Log into the USB device (ie FS0:). Run UefiVarLockAuditTestApp.efi to generate the UefiVarLockAudit_manifest.xml file: FS0:> UefiVarLockAuditTestApp Boot the system into Windows. Open an Administrator Cmd window. Change the drive to the USB device, and to the directory to where UefiVarLockAudit_manifest.xml, UefiVarAudit.py, and UefiVariablesSupportLib.py are stored. Run: D:\\python UefiVarAudit.py -InputXml UefiVarLockAudit_manifest.xml -OutputXml VarLockAuditResults.xml","title":"Running the VarLockAudit Test"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#analyzing-the-varlockauditresultsxml","text":"Here is an example of a Boot Services variable: <Variable Guid= \"4C19049F-4137-4DD3-9C10-8B97A83FFDFA\" Name= \"MemoryTypeInformation\" > <Attributes> 0x3 NV BS </Attributes> <Size> 48 </Size> <Data> 09000000580000000A000000200000000000000029000000060000004601000005000000B70000000F00000000000000 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0xCB [WinError 203] The system could not find the environment option that was entered. </ReadStatus> <WriteStatus> 0x13 [WinError 19] The media is write protected. </WriteStatus> </FromOs> </Variable> It shows the results of reading and writing to the variable at two places. One is after ReadyToBoot, and is provided by the UEFI version of the VarLockAudit test. The other is in the OS. In this example, the variable does not have the RT (Runtime) attributes, and Windows cannot read this variable. It also cannot write to the variable since is is present. Here is an example of a variable with the Runtime attribute: <Variable Guid= \"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name= \"BootOrder\" > <Attributes> 0x7 NV BS RT </Attributes> <Size> 10 </Size> <Data> 05000000010002000300 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0x0 </ReadStatus> <WriteStatus> 0x0 </WriteStatus> </FromOs> </Variable> ```` The BootOrder variable is readable and writable in the OS. Here is an example of a write protected RT variable: ```xml <Variable Guid= \"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name= \"ConOutDev\" > <Attributes> 0x6 BS RT </Attributes> <Size> 30 </Size> <Data> 02010C00D041030A0000000001010600000202030800001401807FFF0400 </Data> <ReadyToBoot> <ReadStatus> 0x0 Success </ReadStatus> <WriteStatus> 0x0 Success </WriteStatus> </ReadyToBoot> <FromOs> <ReadStatus> 0x0 </ReadStatus> <WriteStatus> 0x13 [WinError 19] The media is write protected. </WriteStatus> </FromOs> </Variable>","title":"Analyzing the VarLockAuditResults.xml"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#subsequent-runs-of-the-variable-audit-test","text":"Once you have validated the results file, you can save it as a Good Master. You could simply run the tests on every firmware and compare the newly generated VarLockAuditResults.xml with the Good Master you saved. You only need to analyze the differences.","title":"Subsequent runs of the Variable Audit test"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/","text":"Memory Protection Tests \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About This Test \u00b6 This is set of tests to ensure that heap guard, stack guard, null pointer detection, and nx protections are working properly. It consists of: An SMM driver A Shell-based test app The Shell-based app may be built at any time and run from Shell. The app can use the SMM driver to preform SMM tests if the SMM driver is installed. It is not the intention of this test to include the driver in production systems. They should only be used for purpose-built test images.","title":"Memory Protection Test"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/#memory-protection-tests","text":"","title":"Memory Protection Tests"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/#about-this-test","text":"This is set of tests to ensure that heap guard, stack guard, null pointer detection, and nx protections are working properly. It consists of: An SMM driver A Shell-based test app The Shell-based app may be built at any time and run from Shell. The app can use the SMM driver to preform SMM tests if the SMM driver is installed. It is not the intention of this test to include the driver in production systems. They should only be used for purpose-built test images.","title":"About This Test"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/","text":"SMM Paging Protections Test \u00b6 Copyright \u00b6 Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent About This Test \u00b6 This is a [currently] small test to prove that certain SMM paging protections have been applied. It consists of: An SMM driver A DXE driver A Shell-based test app In order to use this test, the SMM and DXE drivers must be built and included in your FW image to be dispatched at boot time. The Shell-based app may be built at any time and run from Shell. The app will ask the DXE driver to pass a message to the SMM driver to invoke a particular test. It is not the intention of this test to include the two drivers in production systems. They should only be used for purpose-built test images.","title":"Smm Paging Protections Test"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/#smm-paging-protections-test","text":"","title":"SMM Paging Protections Test"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/#copyright","text":"Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/#about-this-test","text":"This is a [currently] small test to prove that certain SMM paging protections have been applied. It consists of: An SMM driver A DXE driver A Shell-based test app In order to use this test, the SMM and DXE drivers must be built and included in your FW image to be dispatched at boot time. The Shell-based app may be built at any time and run from Shell. The app will ask the DXE driver to pass a message to the SMM driver to invoke a particular test. It is not the intention of this test to include the two drivers in production systems. They should only be used for purpose-built test images.","title":"About This Test"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/","text":"Xml Support Package \u00b6 About \u00b6 This package adds some limited XML support to the UEFI environment. Xml brings value in that there are numerous, robust, readily available parsing solutions in nearly every environment, language, and operating system. The UEFI support is limited in that it only supports ASCII strings and does not support XSD, schema, namespaces, or other extensions to XML. XmlTreeLib \u00b6 The XmlTreeLib is the cornerstone of this package. It provides functions for: Reading and parsing XML strings into an XML node/tree structure Creating or altering xml nodes within a tree Writing xml nodes/trees to ASCII string Escaping and Un-Escaping strings XmlTreeQueryLib \u00b6 The XmlTreeQueryLib provides very basic and simple query functions allowing code to interact with the XmlTree to do things like: Find the first child element node with a name equal to the parameter Find the first attribute node of a given element with a name equal to the parameter UnitTestResultReportLib \u00b6 A UnitTestResultReportLib that formats the results in XML using the JUnit defined schema. This instance allows the UEFI Unit Test Framework to integrate results with existing tools and other frameworks. Testing \u00b6 There are UEFI shell and host based unit tests for each library. These tests attempt to verify basic functionality of publicly defined functions. Check the Test/UnitTest folder at the root of the package for more details. Developer Notes \u00b6 These libraries have known limitations and have not been fully vetted for un-trusted input. If used in such a situation it is suggested to validate the input before leveraging the XML libraries. With that said the ability to use xml in UEFI has been invaluable for building features and tests that interact with code running in other environments. The parser has been tuned to fail fast and when invalid XML encountered just return NULL. Copyright \u00b6 Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Modules"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#xml-support-package","text":"","title":"Xml Support Package"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#about","text":"This package adds some limited XML support to the UEFI environment. Xml brings value in that there are numerous, robust, readily available parsing solutions in nearly every environment, language, and operating system. The UEFI support is limited in that it only supports ASCII strings and does not support XSD, schema, namespaces, or other extensions to XML.","title":"About"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#xmltreelib","text":"The XmlTreeLib is the cornerstone of this package. It provides functions for: Reading and parsing XML strings into an XML node/tree structure Creating or altering xml nodes within a tree Writing xml nodes/trees to ASCII string Escaping and Un-Escaping strings","title":"XmlTreeLib"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#xmltreequerylib","text":"The XmlTreeQueryLib provides very basic and simple query functions allowing code to interact with the XmlTree to do things like: Find the first child element node with a name equal to the parameter Find the first attribute node of a given element with a name equal to the parameter","title":"XmlTreeQueryLib"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#unittestresultreportlib","text":"A UnitTestResultReportLib that formats the results in XML using the JUnit defined schema. This instance allows the UEFI Unit Test Framework to integrate results with existing tools and other frameworks.","title":"UnitTestResultReportLib"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#testing","text":"There are UEFI shell and host based unit tests for each library. These tests attempt to verify basic functionality of publicly defined functions. Check the Test/UnitTest folder at the root of the package for more details.","title":"Testing"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#developer-notes","text":"These libraries have known limitations and have not been fully vetted for un-trusted input. If used in such a situation it is suggested to validate the input before leveraging the XML libraries. With that said the ability to use xml in UEFI has been invaluable for building features and tests that interact with code running in other environments. The parser has been tuned to fail fast and when invalid XML encountered just return NULL.","title":"Developer Notes"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/","text":"Contributing to EDK2 \u00b6 Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"CONTRIBUTING"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#contributing-to-edk2","text":"Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"Contributing to EDK2"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/","text":"Project Mu Silicon Arm Tiano Repository \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_silicon_arm_tiano.git Branch: release/202202 Commit: f8219c08ed6a5c8ce16945efadb1d95d05dc1991 Commit Date: 2022-10-24 16:56:41 -0400 This repository contains Project Mu code based on TianoCore edk2 code for ARM silicon features and ARM based platforms. More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Repo Details"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#project-mu-silicon-arm-tiano-repository","text":"Git Details Repository Url: https://github.com/Microsoft/mu_silicon_arm_tiano.git Branch: release/202202 Commit: f8219c08ed6a5c8ce16945efadb1d95d05dc1991 Commit Date: 2022-10-24 16:56:41 -0400 This repository contains Project Mu code based on TianoCore edk2 code for ARM silicon features and ARM based platforms.","title":"Project Mu Silicon Arm Tiano Repository"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_silicon_arm_tiano/ArmPlatformPkg/Drivers/HestMmErrorSources/Readme/","text":"HEST & SDEI \u00b6 Hardware Error Source Table HEST [1] and Software Delegated Exception Interface SDEI [2] ACPI tables are used to accomplish firmware first error handling.This patch series introduces a framework to build and install the HEST ACPI table dynamically. The following figure illustrates the possible usage of the dynamic generation of HEST ACPI table. ascii art NS | S +--------------------------------------+--------------------------------------+ | | | |+-------------------------------------+---------------------+ | || +---------------------+--------------------+| | || | | || | || +-----------+ |+------------------+ | +-----------------+|| +-------------+| || |HestTable | || HestErrorSource | | | HestErrorSource ||| | DMC-620 || || | DXE | || DXE | | | StandaloneMM ||| |Standalone MM|| || +-----------+ |+------------------+ | +-----------------+|| +-------------+| || |GHESv2 | || | || +---------------------+--------------------+| | || +--------------------+ | | | || |PlatformErrorHandler| | | | || | DXE | | | | || +--------------------+ | | | ||FF FWK | | | |+-------------------------------------+---------------------+ | | | | +--------------------------------------+--------------------------------------+ | Figure: Dynamic Hest Table Generation. All the hardware error sources are added to HEST table as GHESv2[3] error source descriptors. The framework comprises of following DXE and MM drivers: HestTableDxe: Builds HEST table header and allows appending error source descriptors to the HEST table. Also provides protocol interface to install the built HEST table. HestErrorSourceDxe & HestErrorSourceStandaloneMM: These two drivers together retrieve all possible error source descriptors of type GHESv2 from the MM drivers implementing HEST Error Source Descriptor protocol. Once all the descriptors are collected HestErrorSourceDxe appends it to HEST table using HestTableDxe driver. PlatformErrorHandlerDxe: Builds and installs SDEI ACPI table. This driver does not initialize(load) until HestErrorSourceDxe driver has finished appending all possible GHESv2 error source descriptors to the HEST table. Once that is complete using the HestTableDxe driver it installs the HEST table. This patch series provides reference implementation for DMC-620 Dynamic Memory Controller[4] that has RAS feature enabled. This is platform code implemented as Standalone MM driver in edk2-platforms. References \u00b6 [1]: ACPI 6.3, Table 18-382, Hardware Error Source Table [2] : SDEI Platform Design Document, revision b, 10 Appendix C, ACPI table definitions for SDEI [3] : ACPI Reference Specification 6.3, Table 18-393 GHESv2 Structure [4] : DMC620 Dynamic Memory Controller, revision r1p0 [5] : UEFI Reference Specification 2.8, Appendix N - Common Platform Error Record [6] : UEFI Reference Specification 2.8, Section N.2.5 Memory Error Section Link to github branch with the patches in this series - https://github.com/omkkul01/edk2/tree/ras_firmware_first_edk2","title":"Hest Mm Error Sources"},{"location":"dyn/mu_silicon_arm_tiano/ArmPlatformPkg/Drivers/HestMmErrorSources/Readme/#hest-sdei","text":"Hardware Error Source Table HEST [1] and Software Delegated Exception Interface SDEI [2] ACPI tables are used to accomplish firmware first error handling.This patch series introduces a framework to build and install the HEST ACPI table dynamically. The following figure illustrates the possible usage of the dynamic generation of HEST ACPI table. ascii art NS | S +--------------------------------------+--------------------------------------+ | | | |+-------------------------------------+---------------------+ | || +---------------------+--------------------+| | || | | || | || +-----------+ |+------------------+ | +-----------------+|| +-------------+| || |HestTable | || HestErrorSource | | | HestErrorSource ||| | DMC-620 || || | DXE | || DXE | | | StandaloneMM ||| |Standalone MM|| || +-----------+ |+------------------+ | +-----------------+|| +-------------+| || |GHESv2 | || | || +---------------------+--------------------+| | || +--------------------+ | | | || |PlatformErrorHandler| | | | || | DXE | | | | || +--------------------+ | | | ||FF FWK | | | |+-------------------------------------+---------------------+ | | | | +--------------------------------------+--------------------------------------+ | Figure: Dynamic Hest Table Generation. All the hardware error sources are added to HEST table as GHESv2[3] error source descriptors. The framework comprises of following DXE and MM drivers: HestTableDxe: Builds HEST table header and allows appending error source descriptors to the HEST table. Also provides protocol interface to install the built HEST table. HestErrorSourceDxe & HestErrorSourceStandaloneMM: These two drivers together retrieve all possible error source descriptors of type GHESv2 from the MM drivers implementing HEST Error Source Descriptor protocol. Once all the descriptors are collected HestErrorSourceDxe appends it to HEST table using HestTableDxe driver. PlatformErrorHandlerDxe: Builds and installs SDEI ACPI table. This driver does not initialize(load) until HestErrorSourceDxe driver has finished appending all possible GHESv2 error source descriptors to the HEST table. Once that is complete using the HestTableDxe driver it installs the HEST table. This patch series provides reference implementation for DMC-620 Dynamic Memory Controller[4] that has RAS feature enabled. This is platform code implemented as Standalone MM driver in edk2-platforms.","title":"HEST &amp; SDEI"},{"location":"dyn/mu_silicon_arm_tiano/ArmPlatformPkg/Drivers/HestMmErrorSources/Readme/#references","text":"[1]: ACPI 6.3, Table 18-382, Hardware Error Source Table [2] : SDEI Platform Design Document, revision b, 10 Appendix C, ACPI table definitions for SDEI [3] : ACPI Reference Specification 6.3, Table 18-393 GHESv2 Structure [4] : DMC620 Dynamic Memory Controller, revision r1p0 [5] : UEFI Reference Specification 2.8, Appendix N - Common Platform Error Record [6] : UEFI Reference Specification 2.8, Section N.2.5 Memory Error Section Link to github branch with the patches in this series - https://github.com/omkkul01/edk2/tree/ras_firmware_first_edk2","title":"References"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/","text":"ArmVirtPkg - Platform CI \u00b6 This Readme.md describes the Azure DevOps based Platform CI for ArmVirtPkg and how to use the same Pytools based build infrastructure locally. Supported Configuration Details \u00b6 This solution for building and running ArmVirtPkg has only been validated with Ubuntu 18.04 and the GCC5 toolchain. Two different firmware builds are supported and are described below. Configuration name Architecture DSC File Additional Flags AARCH64 AARCH64 ArmVirtQemu.dsc None ARM ARM ArmVirtQemu.dsc None EDK2 Developer environment \u00b6 Python 3.8.x - Download & Install GIT - Download & Install QEMU - Download, Install, and add to your path Edk2 Source Additional packages found necessary for Ubuntu 18.04 apt-get install gcc g++ make uuid-dev Note: edksetup, Submodule initialization and manual installation of NASM, iASL, or the required cross-compiler toolchains are not required, this is handled by the Pytools build system. Building with Pytools for ArmVirtPkg \u00b6 [Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Windows <name of virtual environment>/Scripts/activate.bat Linux source <name of virtual environment>/bin/activate Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Compile the basetools if necessary - only when basetools C source files change python BaseTools/Edk2ToolsBuild.py -t <ToolChainTag> Compile Firmware stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> use stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> --FlashOnly Notes \u00b6 Including the expected build architecture and toolchain to the stuart_update command is critical. This is because there are extra scopes and tools that will be resolved during the update step that need to match your build step. Configuring ACTIVE_PLATFORM and TARGET_ARCH in Conf/target.txt is not required. This environment is set by PlatformBuild.py based upon the [-a <TARGET_ARCH>] parameter. QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. NOTE: Logging the execution output will be in the normal stuart log as well as to your console. Custom Build Options \u00b6 MAKE_STARTUP_NSH=TRUE will output a startup.nsh file to the location mapped as fs0. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this. Passing Build Defines \u00b6 To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add an =1 suffix for bare defines. For example, to enable the TPM2 support, instead of the traditional \"-D TPM2_ENABLE=TRUE\", the stuart_build command-line would be: stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py BLD_*_TPM2_ENABLE=TRUE References \u00b6 Installing and using Pytools More on python virtual environments","title":"Platform CI"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#armvirtpkg-platform-ci","text":"This Readme.md describes the Azure DevOps based Platform CI for ArmVirtPkg and how to use the same Pytools based build infrastructure locally.","title":"ArmVirtPkg - Platform CI"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#supported-configuration-details","text":"This solution for building and running ArmVirtPkg has only been validated with Ubuntu 18.04 and the GCC5 toolchain. Two different firmware builds are supported and are described below. Configuration name Architecture DSC File Additional Flags AARCH64 AARCH64 ArmVirtQemu.dsc None ARM ARM ArmVirtQemu.dsc None","title":"Supported Configuration Details"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#edk2-developer-environment","text":"Python 3.8.x - Download & Install GIT - Download & Install QEMU - Download, Install, and add to your path Edk2 Source Additional packages found necessary for Ubuntu 18.04 apt-get install gcc g++ make uuid-dev Note: edksetup, Submodule initialization and manual installation of NASM, iASL, or the required cross-compiler toolchains are not required, this is handled by the Pytools build system.","title":"EDK2 Developer environment"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#building-with-pytools-for-armvirtpkg","text":"[Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Windows <name of virtual environment>/Scripts/activate.bat Linux source <name of virtual environment>/bin/activate Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Compile the basetools if necessary - only when basetools C source files change python BaseTools/Edk2ToolsBuild.py -t <ToolChainTag> Compile Firmware stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> use stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> --FlashOnly","title":"Building with Pytools for ArmVirtPkg"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#notes","text":"Including the expected build architecture and toolchain to the stuart_update command is critical. This is because there are extra scopes and tools that will be resolved during the update step that need to match your build step. Configuring ACTIVE_PLATFORM and TARGET_ARCH in Conf/target.txt is not required. This environment is set by PlatformBuild.py based upon the [-a <TARGET_ARCH>] parameter. QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. NOTE: Logging the execution output will be in the normal stuart log as well as to your console.","title":"Notes"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#custom-build-options","text":"MAKE_STARTUP_NSH=TRUE will output a startup.nsh file to the location mapped as fs0. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this.","title":"Custom Build Options"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#passing-build-defines","text":"To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add an =1 suffix for bare defines. For example, to enable the TPM2 support, instead of the traditional \"-D TPM2_ENABLE=TRUE\", the stuart_build command-line would be: stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py BLD_*_TPM2_ENABLE=TRUE","title":"Passing Build Defines"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#references","text":"Installing and using Pytools More on python virtual environments","title":"References"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/","text":"Contributing to EDK2 \u00b6 Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"CONTRIBUTING"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#contributing-to-edk2","text":"Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"Contributing to EDK2"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/","text":"Project Mu Silicon Intel Tiano Repository \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_silicon_intel_tiano.git Branch: release/202202 Commit: cc73cddc9ca78b0b4e44c7745cf550edcc5e9c1b Commit Date: 2022-10-25 10:08:52 -0700 This repository contains Project Mu code based on TianoCore edk2 code for Intel silicon features and Intel based platforms. More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Repo Details"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#project-mu-silicon-intel-tiano-repository","text":"Git Details Repository Url: https://github.com/Microsoft/mu_silicon_intel_tiano.git Branch: release/202202 Commit: cc73cddc9ca78b0b4e44c7745cf550edcc5e9c1b Commit Date: 2022-10-25 10:08:52 -0700 This repository contains Project Mu code based on TianoCore edk2 code for Intel silicon features and Intel based platforms.","title":"Project Mu Silicon Intel Tiano Repository"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Readme/","text":"IntelFsp2Pkg \u00b6 This package provides the component to create an FSP binary. Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2Pkg A whitepaper to describe the IntelFsp2Pkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Creating_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf","title":"Readme"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Readme/#intelfsp2pkg","text":"This package provides the component to create an FSP binary. Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2Pkg A whitepaper to describe the IntelFsp2Pkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Creating_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf","title":"IntelFsp2Pkg"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/","text":"Name \u00b6 ConfigEditor.py is a python script with a GUI interface that can support changing configuration settings directly from the interface without having to modify the source. Description \u00b6 This is a GUI interface that can be used by users who would like to change configuration settings directly from the interface without having to modify the SBL source. This tool depends on Python GUI tool kit Tkinter. It runs on both Windows and Linux. The user needs to load the YAML file along with DLT file for a specific board into the ConfigEditor, change the desired configuration values. Finally, generate a new configuration delta file or a config binary blob for the newly changed values to take effect. These will be the inputs to the merge tool or the stitch tool so that new config changes can be merged and stitched into the final configuration blob. It supports the following options: 1. Open Config YAML file \u00b6 This option loads the YAML file for a FSP UPD into the ConfigEditor to change the desired configuration values. Example: \u00b6 ![Example ConfigEditor 1](https://slimbootloader.github.io/_images/CfgEditOpen.png) ![Example ConfigEditor 2](https://slimbootloader.github.io/_images/CfgEditDefYaml.png) 2. Open Config BSF file \u00b6 This option loads the BSF file for a FSP UPD into the ConfigEditor to change the desired configuration values. It works as a similar fashion with Binary Configuration Tool (BCT) 3. Show Binary Information \u00b6 This option loads configuration data from FD file and displays it in the ConfigEditor. 4. Save Config Data to Binary \u00b6 This option generates a config binary blob for the newly changed values to take effect. 5. Load Config Data from Binary \u00b6 This option reloads changed configuration from BIN file into the ConfigEditor. 6. Load Config Changes from Delta File \u00b6 This option loads the changed configuration values from Delta file into the ConfigEditor. 7. Save Config Changes to Delta File \u00b6 This option generates a new configuration delta file for the newly changed values to take effect. 8. Save Full Config Data to Delta File \u00b6 This option saves all the changed configuration values into a Delta file. 9. Search feature \u00b6 This feature helps the user to easily find any configuration item they are looking for in ConfigEditor. A text search box is available on the Top Right Corner of ConfigEditor. To use this feature the user should type the name or a key word of the item they want to search in the text box and then click on the \"Search\" button. This will display all the items which contains that particular word searched by the user. Running Configuration Editor: \u00b6 python ConfigEditor.py","title":"Config Editor User Manual"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#name","text":"ConfigEditor.py is a python script with a GUI interface that can support changing configuration settings directly from the interface without having to modify the source.","title":"Name"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#description","text":"This is a GUI interface that can be used by users who would like to change configuration settings directly from the interface without having to modify the SBL source. This tool depends on Python GUI tool kit Tkinter. It runs on both Windows and Linux. The user needs to load the YAML file along with DLT file for a specific board into the ConfigEditor, change the desired configuration values. Finally, generate a new configuration delta file or a config binary blob for the newly changed values to take effect. These will be the inputs to the merge tool or the stitch tool so that new config changes can be merged and stitched into the final configuration blob. It supports the following options:","title":"Description"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#1-open-config-yaml-file","text":"This option loads the YAML file for a FSP UPD into the ConfigEditor to change the desired configuration values.","title":"1. Open Config YAML file"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#example","text":"![Example ConfigEditor 1](https://slimbootloader.github.io/_images/CfgEditOpen.png) ![Example ConfigEditor 2](https://slimbootloader.github.io/_images/CfgEditDefYaml.png)","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#2-open-config-bsf-file","text":"This option loads the BSF file for a FSP UPD into the ConfigEditor to change the desired configuration values. It works as a similar fashion with Binary Configuration Tool (BCT)","title":"2. Open Config BSF file"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#3-show-binary-information","text":"This option loads configuration data from FD file and displays it in the ConfigEditor.","title":"3. Show Binary Information"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#4-save-config-data-to-binary","text":"This option generates a config binary blob for the newly changed values to take effect.","title":"4. Save Config Data to Binary"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#5-load-config-data-from-binary","text":"This option reloads changed configuration from BIN file into the ConfigEditor.","title":"5. Load Config Data from Binary"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#6-load-config-changes-from-delta-file","text":"This option loads the changed configuration values from Delta file into the ConfigEditor.","title":"6. Load Config Changes from Delta File"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#7-save-config-changes-to-delta-file","text":"This option generates a new configuration delta file for the newly changed values to take effect.","title":"7. Save Config Changes to Delta File"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#8-save-full-config-data-to-delta-file","text":"This option saves all the changed configuration values into a Delta file.","title":"8. Save Full Config Data to Delta File"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#9-search-feature","text":"This feature helps the user to easily find any configuration item they are looking for in ConfigEditor. A text search box is available on the Top Right Corner of ConfigEditor. To use this feature the user should type the name or a key word of the item they want to search in the text box and then click on the \"Search\" button. This will display all the items which contains that particular word searched by the user.","title":"9. Search feature"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#running-configuration-editor","text":"python ConfigEditor.py","title":"Running Configuration Editor:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/","text":"Name \u00b6 FspDscBsf2Yaml.py The python script that generates YAML file for the Boot Settings from an EDK II Platform Description ( DSC ) file or from a Boot Settings File ( BSF ). It is created to help transitioning FSP Updateable Product Data ( UPD ) file format to new standardized YAML format so that it can be configured through open source tools. Synopsis \u00b6 FspDscBsf2Yaml DscFile|BsfFile YamlFile Description \u00b6 FspDscBsf2Yaml.py is a script that generates configuration options from an EDK II Platform Description (DSC) file or a Boot Settings File (BSF) file. It generates a YAML file that can be used by the Config Editor to provide a graphical user interface for manipulating settings in the UPD regions. The following sections explain the usage of this script. 1. FspDscBsf2Yaml.py DscFile YamlFile \u00b6 The DscFile option is an input DSC file. The YamlFile option is an output YAML file. The script takes the FSP DSC file consisting BSF syntax and generates a YAML output file describing the boot settings. 2. FspDscBsf2Yaml.py BsfFile YamlFile \u00b6 The BsfFile option is an input BSF file. The YamlFile option is an output YAML file. The script generates a YAML output file from a BSF file. The BSF file can be generated using GenCfgOpt tool.","title":"Fsp Dsc Bsf2Yaml User Manual"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#name","text":"FspDscBsf2Yaml.py The python script that generates YAML file for the Boot Settings from an EDK II Platform Description ( DSC ) file or from a Boot Settings File ( BSF ). It is created to help transitioning FSP Updateable Product Data ( UPD ) file format to new standardized YAML format so that it can be configured through open source tools.","title":"Name"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#synopsis","text":"FspDscBsf2Yaml DscFile|BsfFile YamlFile","title":"Synopsis"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#description","text":"FspDscBsf2Yaml.py is a script that generates configuration options from an EDK II Platform Description (DSC) file or a Boot Settings File (BSF) file. It generates a YAML file that can be used by the Config Editor to provide a graphical user interface for manipulating settings in the UPD regions. The following sections explain the usage of this script.","title":"Description"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#1-fspdscbsf2yamlpy-dscfile-yamlfile","text":"The DscFile option is an input DSC file. The YamlFile option is an output YAML file. The script takes the FSP DSC file consisting BSF syntax and generates a YAML output file describing the boot settings.","title":"1. FspDscBsf2Yaml.py DscFile YamlFile"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#2-fspdscbsf2yamlpy-bsffile-yamlfile","text":"The BsfFile option is an input BSF file. The YamlFile option is an output YAML file. The script generates a YAML output file from a BSF file. The BSF file can be generated using GenCfgOpt tool.","title":"2. FspDscBsf2Yaml.py BsfFile YamlFile"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/","text":"Name \u00b6 GenCfgOpt.py The python script that generates UPD text ( .txt ) files for the compiler, header files for the UPD regions, and generates a Boot Settings File ( BSF ), all from an EDK II Platform Description ( DSC ) file. Synopsis \u00b6 GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros] GenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros] GenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros] Description \u00b6 GenCfgOpt.py is a script that generates configuration options from an EDK II Platform Description (DSC) file. It has three functions. It produces a .txt file that is used by the compiler that summarizes the UPD section in the DSC file. It generates header files for the UPD regions. It generates a Boot Settings File (BSF) that can be used by the Binary Configuration Tool (BCT) to provide a graphical user interface for manipulating settings in the UPD regions. The GenCfgOpt.py script generates important files that are vital parts of your build process. The UPDTXT and HEADER use cases must be done before the 'build' command; the GENBSF use case may be done at any time. The following sections explain the three use cases. 1. GenCfgOpt.py UPDTXT \u00b6 The UPDTXT option creates a text file with all the UPD entries, offsets, size in bytes, and values. GenCfgOpt reads this information from the [PcdsDynamicVpd.Upd] section of the project's DSC file. The DSC file allows you to specify offsets and sizes for each entry, opening up the possibility of introducing gaps between entries. GenCfgOpt fills in these gaps with UPD entries that have the generic names UnusedUpdSpaceN where N begins with 0 and increments. The command signature for UPDTXT is: GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros] PlatformDscFile must be the location of the DSC file for the platform you're building. BuildFvDir is the location where the binary will be stored. The optional TxtOutFile is a name and location for the output of GenCfgOpt . The default name and location is the <UPD_TOOL_GUID>.txt in the directory specified by BuildFvDir . The macro UPD_TOOL_GUID must be defined in the DSC file or in the optional Macros arguments. Each optional macro argument must follow the form ?D <MACRO_NAME>=<VALUE> . GenCfgOpt checks to see if the UPD txt file has already been created and will only re-create it if the DSC was modified after it was created. 2. GenCfgOpt.py HEADER \u00b6 The HEADER option creates header files in the build folder. Both header files define the _UPD_DATA_REGION data structures in FspUpd.h, FsptUpd.h, FspmUpd.h and FspsUpd.h. In these header files any undefined elements of structures will be added as ReservedUpdSpaceN beginning with N=0. The command signature for HEADER is GenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros] PlatformDscFile and BuildFvDir are described in the previous section. The optional InputHFile is a header file that may contain data definitions that are used by variables in the UPD regions. This header file must contain the special keywords !EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN and !EXPORT EXTERNAL_BOOTLOADER_STRUCT_END in comments. Everything between these two keywords will be included in the generated header file. The mechanism to specify whether a variable appears as ReservedUpdSpaceN in the FspUpd.h header file is in special commands that appear in the comments of the DSC file. The special commands begin with !HDR , for header. The following table summarizes the two command options. HEADER \u00b6 Use the HEADER command to hide specific variables in the public header file. In your project DSC file, use !HDR HEADER:{OFF} at the beginning of the section you wish to hide and !HDR HEADER:{ON} at the end. STRUCT \u00b6 The STRUCT command allows you to specify a specific data type for a variable. You can specify a pointer to a data struct, for example. You define the data structure in the InputHFile between !EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN and !EXPORT EXTERNAL_BOOTLOADER_STRUCT_END . Example: \u00b6 !HDR STRUCT:{MY_DATA_STRUCT*} You then define MY_DATA_STRUCT in InputHFile . EMBED \u00b6 The EMBED command allows you to put one or more UPD data into a specify data structure. You can utilize it as a group of UPD for example. You must specify a start and an end for the specify data structure. Example: \u00b6 !HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:START} gTokenSpaceGuid.Upd1 | 0x0020 | 0x01 | 0x00 gTokenSpaceGuid.Upd2 | 0x0021 | 0x01 | 0x00 !HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:END} gTokenSpaceGuid.UpdN | 0x0022 | 0x01 | 0x00 Result: \u00b6 typedef struct { /** Offset 0x0020 **/ UINT8 Upd1; /** Offset 0x0021 **/ UINT8 Upd2; /** Offset 0x0022 **/ UINT8 UpdN; } MY_DATA_STRUCT; typedef struct _UPD_DATA_REGION { ... /** Offset 0x0020 **/ MY_DATA_STRUCT MyDataStruct; ... } UPD_DATA_REGION; 3. GenCfgOpt .py GENBSF \u00b6 The GENBSF option generates a BSF from the UPD entries in a package's DSC file. It does this by parsing special commands found in the comments of the DSC file. They roughly match the keywords that define the different sections of the BSF. The command signature for GENBSF is GenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros] In this case, the BsfOutFile parameter is required; it should be the relative path to where the BSF should be stored. Every BSF command in the DSC file begins with !BSF or @Bsf . The following table summarizes the options that come after !BSF or @Bsf : BSF Commands Description \u00b6 PAGES \u00b6 PAGES maps abbreviations to friendly-text descriptions of the pages in a BSF. Example: \u00b6 !BSF PAGES:{PG1:?Page 1?, PG2:?Page 2?} or @Bsf PAGES:{PG1:?Page 1?, PG2:?Page 2?} PAGE \u00b6 This marks the beginning of a page. Use the abbreviation specified in PAGES command. Example: \u00b6 !BSF PAGE:{PG1} or @Bsf PAGE:{PG1} All the entries that come after this command are assumed to be on that page, until the next PAGE command FIND \u00b6 FIND maps to the BSF Find command. It will be placed in the StructDef region of the BSF and should come at the beginning of the UPD sections of the DSC, immediately before the signatures that mark the beginning of these sections. The content should be the plain-text equivalent of the signature. The signature is usually 8 characters. Example: \u00b6 !BSF FIND:{PROJSIG1} or @Bsf FIND:{PROJSIG1} BLOCK \u00b6 The BLOCK command maps to the BeginInfoBlock section of the BSF. There are two elements: a version number and a plain-text description. Example: \u00b6 !BSF BLOCK:{NAME:\"My platform name\", VER:\"0.1\"} or @Bsf BLOCK:{NAME:\"My platform name\", VER:\"0.1\"} NAME \u00b6 NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT . Example: \u00b6 !BSF NAME:{Variable 0} or @Bsf NAME:{Variable 0} If the !BSF NAME or @Bsf NAME command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF. TYPE \u00b6 The TYPE command is used either by itself or with the NAME command. It is usually used by itself when defining an EditNum field for the BSF. You specify the type of data in the second parameter and the range of valid values in the third. Example: \u00b6 !BSF TYPE:{EditNum, HEX, (0x00,0xFF)} or @Bsf TYPE:{EditNum, HEX, (0x00,0xFF)} TYPE appears on the same line as the NAME command when using a combo-box. Example: \u00b6 !BSF NAME:{Variable 1} TYPE:{Combo} or @Bsf NAME:{Variable 1} TYPE:{Combo} There is a special None type that puts the variable in the StructDef region of the BSF, but doesn't put it in any Page section. This makes the variable visible to BCT, but not to the end user. HELP \u00b6 The HELP command defines what will appear in the help text for each control in BCT. Example: \u00b6 !BSF HELP:{Enable/disable LAN controller.} or @Bsf HELP:{Enable/disable LAN controller.} OPTION \u00b6 The OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options. Example: \u00b6 !BSF OPTION:{0:IDE, 1:AHCI, 2:RAID} !BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} or @Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID} @Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} FIELD \u00b6 The FIELD command can be used to define a section of a consolidated PCD such that the PCD will be displayed in several fields via BCT interface instead of one long entry. Example: \u00b6 !BSF FIELD:{PcdDRAMSpeed:1} or @Bsf FIELD:{PcdDRAMSpeed:1} ORDER \u00b6 The ORDER command can be used to adjust the display order for the BSF items. By default the order value for a BSF item is assigned to be the UPD item (Offset * 256) . It can be overridden by declaring ORDER command using format ORDER: {HexMajor.HexMinor} . In this case the order value will be (HexMajor*256+HexMinor) . The item order value will be used as the sort key during the BSF item display. Example: \u00b6 !BSF ORDER:{0x0040.01} or @Bsf ORDER:{0x0040.01} For OPTION and HELP commands, it allows to split the contents into multiple lines by adding multiple OPTION and HELP command lines. The lines except for the very first line need to start with + in the content to tell the tool to append this string to the previous one. For example, the statement !BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} is equivalent to: !BSF OPTION:{0x00:0 MB, 0x01:32 MB,} !BSF OPTION:{+ 0x02:64 MB} or @Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} is equivalent to: @Bsf OPTION:{0x00:0 MB, 0x01:32 MB,} @Bsf OPTION:{+ 0x02:64 MB} The NAME , OPTION , TYPE , and HELP commands can all appear on the same line following the !BSF or @Bsf keyword or they may appear on separate lines to improve readability. There are four alternative ways to replace current BSF commands. 1. # @Prompt \u00b6 An alternative way replacing NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT. Example: \u00b6 # @Prompt Variable 0 The above example can replace the two methods as below. !BSF NAME:{Variable 0} or @Bsf NAME:{Variable 0} If the # @Prompt command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF. 2. ## \u00b6 An alternative way replacing HELP command defines what will appear in the help text for each control in BCT. Example: \u00b6 ## Enable/disable LAN controller. The above example can replace the two methods as below. !BSF HELP:{Enable/disable LAN controller.} or @Bsf HELP:{Enable/disable LAN controller.} 3. # @ValidList \u00b6 An alternative way replacing OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options. Example: \u00b6 ``` # @ValidList 0x80000003 | 0, 1, 2 | IDE, AHCI, RAID Error Code | Options | Descriptions The above example can replace the two methods as below. ```!BSF OPTION:{0:IDE, 1:AHCI, 2:RAID}``` or ```@Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID}``` ### 4. ```# @ValidRange``` An alternative way replace **EditNum** field for the BSF. #####Example: ```# @ValidRange 0x80000001 | 0x0 ? 0xFF Error Code | Range The above example can replace the two methods as below. !BSF TYPE:{EditNum, HEX, (0x00,0xFF)} or @Bsf TYPE:{EditNum, HEX, (0x00,0xFF)}","title":"Gen Cfg Opt User Manual"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#name","text":"GenCfgOpt.py The python script that generates UPD text ( .txt ) files for the compiler, header files for the UPD regions, and generates a Boot Settings File ( BSF ), all from an EDK II Platform Description ( DSC ) file.","title":"Name"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#synopsis","text":"GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros] GenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros] GenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros]","title":"Synopsis"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#description","text":"GenCfgOpt.py is a script that generates configuration options from an EDK II Platform Description (DSC) file. It has three functions. It produces a .txt file that is used by the compiler that summarizes the UPD section in the DSC file. It generates header files for the UPD regions. It generates a Boot Settings File (BSF) that can be used by the Binary Configuration Tool (BCT) to provide a graphical user interface for manipulating settings in the UPD regions. The GenCfgOpt.py script generates important files that are vital parts of your build process. The UPDTXT and HEADER use cases must be done before the 'build' command; the GENBSF use case may be done at any time. The following sections explain the three use cases.","title":"Description"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#1-gencfgoptpy-updtxt","text":"The UPDTXT option creates a text file with all the UPD entries, offsets, size in bytes, and values. GenCfgOpt reads this information from the [PcdsDynamicVpd.Upd] section of the project's DSC file. The DSC file allows you to specify offsets and sizes for each entry, opening up the possibility of introducing gaps between entries. GenCfgOpt fills in these gaps with UPD entries that have the generic names UnusedUpdSpaceN where N begins with 0 and increments. The command signature for UPDTXT is: GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros] PlatformDscFile must be the location of the DSC file for the platform you're building. BuildFvDir is the location where the binary will be stored. The optional TxtOutFile is a name and location for the output of GenCfgOpt . The default name and location is the <UPD_TOOL_GUID>.txt in the directory specified by BuildFvDir . The macro UPD_TOOL_GUID must be defined in the DSC file or in the optional Macros arguments. Each optional macro argument must follow the form ?D <MACRO_NAME>=<VALUE> . GenCfgOpt checks to see if the UPD txt file has already been created and will only re-create it if the DSC was modified after it was created.","title":"1. GenCfgOpt.py UPDTXT"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#2-gencfgoptpy-header","text":"The HEADER option creates header files in the build folder. Both header files define the _UPD_DATA_REGION data structures in FspUpd.h, FsptUpd.h, FspmUpd.h and FspsUpd.h. In these header files any undefined elements of structures will be added as ReservedUpdSpaceN beginning with N=0. The command signature for HEADER is GenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros] PlatformDscFile and BuildFvDir are described in the previous section. The optional InputHFile is a header file that may contain data definitions that are used by variables in the UPD regions. This header file must contain the special keywords !EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN and !EXPORT EXTERNAL_BOOTLOADER_STRUCT_END in comments. Everything between these two keywords will be included in the generated header file. The mechanism to specify whether a variable appears as ReservedUpdSpaceN in the FspUpd.h header file is in special commands that appear in the comments of the DSC file. The special commands begin with !HDR , for header. The following table summarizes the two command options.","title":"2. GenCfgOpt.py HEADER"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#header","text":"Use the HEADER command to hide specific variables in the public header file. In your project DSC file, use !HDR HEADER:{OFF} at the beginning of the section you wish to hide and !HDR HEADER:{ON} at the end.","title":"HEADER"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#struct","text":"The STRUCT command allows you to specify a specific data type for a variable. You can specify a pointer to a data struct, for example. You define the data structure in the InputHFile between !EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN and !EXPORT EXTERNAL_BOOTLOADER_STRUCT_END .","title":"STRUCT"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example","text":"!HDR STRUCT:{MY_DATA_STRUCT*} You then define MY_DATA_STRUCT in InputHFile .","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#embed","text":"The EMBED command allows you to put one or more UPD data into a specify data structure. You can utilize it as a group of UPD for example. You must specify a start and an end for the specify data structure.","title":"EMBED"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_1","text":"!HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:START} gTokenSpaceGuid.Upd1 | 0x0020 | 0x01 | 0x00 gTokenSpaceGuid.Upd2 | 0x0021 | 0x01 | 0x00 !HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:END} gTokenSpaceGuid.UpdN | 0x0022 | 0x01 | 0x00","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#result","text":"typedef struct { /** Offset 0x0020 **/ UINT8 Upd1; /** Offset 0x0021 **/ UINT8 Upd2; /** Offset 0x0022 **/ UINT8 UpdN; } MY_DATA_STRUCT; typedef struct _UPD_DATA_REGION { ... /** Offset 0x0020 **/ MY_DATA_STRUCT MyDataStruct; ... } UPD_DATA_REGION;","title":"Result:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#3-gencfgopt-py-genbsf","text":"The GENBSF option generates a BSF from the UPD entries in a package's DSC file. It does this by parsing special commands found in the comments of the DSC file. They roughly match the keywords that define the different sections of the BSF. The command signature for GENBSF is GenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros] In this case, the BsfOutFile parameter is required; it should be the relative path to where the BSF should be stored. Every BSF command in the DSC file begins with !BSF or @Bsf . The following table summarizes the options that come after !BSF or @Bsf :","title":"3. GenCfgOpt .py GENBSF"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#bsf-commands-description","text":"","title":"BSF Commands Description"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#pages","text":"PAGES maps abbreviations to friendly-text descriptions of the pages in a BSF.","title":"PAGES"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_2","text":"!BSF PAGES:{PG1:?Page 1?, PG2:?Page 2?} or @Bsf PAGES:{PG1:?Page 1?, PG2:?Page 2?}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#page","text":"This marks the beginning of a page. Use the abbreviation specified in PAGES command.","title":"PAGE"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_3","text":"!BSF PAGE:{PG1} or @Bsf PAGE:{PG1} All the entries that come after this command are assumed to be on that page, until the next PAGE command","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#find","text":"FIND maps to the BSF Find command. It will be placed in the StructDef region of the BSF and should come at the beginning of the UPD sections of the DSC, immediately before the signatures that mark the beginning of these sections. The content should be the plain-text equivalent of the signature. The signature is usually 8 characters.","title":"FIND"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_4","text":"!BSF FIND:{PROJSIG1} or @Bsf FIND:{PROJSIG1}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#block","text":"The BLOCK command maps to the BeginInfoBlock section of the BSF. There are two elements: a version number and a plain-text description.","title":"BLOCK"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_5","text":"!BSF BLOCK:{NAME:\"My platform name\", VER:\"0.1\"} or @Bsf BLOCK:{NAME:\"My platform name\", VER:\"0.1\"}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#name_1","text":"NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT .","title":"NAME"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_6","text":"!BSF NAME:{Variable 0} or @Bsf NAME:{Variable 0} If the !BSF NAME or @Bsf NAME command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF.","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#type","text":"The TYPE command is used either by itself or with the NAME command. It is usually used by itself when defining an EditNum field for the BSF. You specify the type of data in the second parameter and the range of valid values in the third.","title":"TYPE"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_7","text":"!BSF TYPE:{EditNum, HEX, (0x00,0xFF)} or @Bsf TYPE:{EditNum, HEX, (0x00,0xFF)} TYPE appears on the same line as the NAME command when using a combo-box.","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_8","text":"!BSF NAME:{Variable 1} TYPE:{Combo} or @Bsf NAME:{Variable 1} TYPE:{Combo} There is a special None type that puts the variable in the StructDef region of the BSF, but doesn't put it in any Page section. This makes the variable visible to BCT, but not to the end user.","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#help","text":"The HELP command defines what will appear in the help text for each control in BCT.","title":"HELP"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_9","text":"!BSF HELP:{Enable/disable LAN controller.} or @Bsf HELP:{Enable/disable LAN controller.}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#option","text":"The OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options.","title":"OPTION"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_10","text":"!BSF OPTION:{0:IDE, 1:AHCI, 2:RAID} !BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} or @Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID} @Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#field","text":"The FIELD command can be used to define a section of a consolidated PCD such that the PCD will be displayed in several fields via BCT interface instead of one long entry.","title":"FIELD"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_11","text":"!BSF FIELD:{PcdDRAMSpeed:1} or @Bsf FIELD:{PcdDRAMSpeed:1}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#order","text":"The ORDER command can be used to adjust the display order for the BSF items. By default the order value for a BSF item is assigned to be the UPD item (Offset * 256) . It can be overridden by declaring ORDER command using format ORDER: {HexMajor.HexMinor} . In this case the order value will be (HexMajor*256+HexMinor) . The item order value will be used as the sort key during the BSF item display.","title":"ORDER"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_12","text":"!BSF ORDER:{0x0040.01} or @Bsf ORDER:{0x0040.01} For OPTION and HELP commands, it allows to split the contents into multiple lines by adding multiple OPTION and HELP command lines. The lines except for the very first line need to start with + in the content to tell the tool to append this string to the previous one. For example, the statement !BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} is equivalent to: !BSF OPTION:{0x00:0 MB, 0x01:32 MB,} !BSF OPTION:{+ 0x02:64 MB} or @Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB} is equivalent to: @Bsf OPTION:{0x00:0 MB, 0x01:32 MB,} @Bsf OPTION:{+ 0x02:64 MB} The NAME , OPTION , TYPE , and HELP commands can all appear on the same line following the !BSF or @Bsf keyword or they may appear on separate lines to improve readability. There are four alternative ways to replace current BSF commands.","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#1-prompt","text":"An alternative way replacing NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT.","title":"1. # @Prompt"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_13","text":"# @Prompt Variable 0 The above example can replace the two methods as below. !BSF NAME:{Variable 0} or @Bsf NAME:{Variable 0} If the # @Prompt command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF.","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#2","text":"An alternative way replacing HELP command defines what will appear in the help text for each control in BCT.","title":"2. ##"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_14","text":"## Enable/disable LAN controller. The above example can replace the two methods as below. !BSF HELP:{Enable/disable LAN controller.} or @Bsf HELP:{Enable/disable LAN controller.}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#3-validlist","text":"An alternative way replacing OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options.","title":"3. # @ValidList"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_15","text":"``` # @ValidList 0x80000003 | 0, 1, 2 | IDE, AHCI, RAID Error Code | Options | Descriptions The above example can replace the two methods as below. ```!BSF OPTION:{0:IDE, 1:AHCI, 2:RAID}``` or ```@Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID}``` ### 4. ```# @ValidRange``` An alternative way replace **EditNum** field for the BSF. #####Example: ```# @ValidRange 0x80000001 | 0x0 ? 0xFF Error Code | Range The above example can replace the two methods as below. !BSF TYPE:{EditNum, HEX, (0x00,0xFF)} or @Bsf TYPE:{EditNum, HEX, (0x00,0xFF)}","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/","text":"Name \u00b6 PatchFv.py - The python script that patches the firmware volumes ( FV ) with in the flash device ( FD ) file post FSP build. Synopsis \u00b6 PatchFv FvBuildDir [FvFileBaseNames:]FdFileBaseNameToPatch [\"Offset, Value\"]+ | [\"Offset, Value, @Comment\"]+ | [\"Offset, Value, $Command\"]+ | [\"Offset, Value, $Command, @Comment\"]+ Description \u00b6 The PatchFv.py tool allows the developer to fix up FD images to follow the Intel FSP Architecture specification. It also makes the FD image relocatable. The tool is written in Python and uses Python 2.7 or later to run. Consider using the tool in a build script. FvBuildDir (Argument 1) \u00b6 This is the first argument that PatchFv.py requires. It is the build directory for all firmware volumes created during the FSP build. The path must be either an absolute path or a relevant path, relevant to the top level of the FSP tree. Example usage: \u00b6 Build\\YouPlatformFspPkg\\%BD_TARGET%_%VS_VERSION%%VS_X86%\\FV The example used contains Windows batch script %VARIABLES%. FvFileBaseNames (Argument 2: Optional Part 1) \u00b6 The firmware volume file base names ( FvFileBaseNames ) are the independent Fv?s that are to be patched within the FD. (0 or more in the form FVFILEBASENAME: ) The colon : is used for delimiting the single argument and must be appended to the end of each ( FvFileBaseNames ). Example usage: \u00b6 STAGE1:STAGE2:MANIFEST:YOURPLATFORM In the example STAGE1 is STAGE1.Fv in YOURPLATFORM.fd . FdFileNameToPatch (Argument 2: Mandatory Part 2) \u00b6 Firmware device file name to patch ( FdFileNameToPatch ) is the base name of the FD file that is to be patched. (1 only, in the form YOURPLATFORM ) Example usage: \u00b6 STAGE1:STAGE2:MANIFEST:YOURPLATFORM In the example YOURPLATFORM is from YOURPLATFORM.fd \"Offset, Value[, Command][, Comment]\" (Argument 3) \u00b6 The Offset can be a positive or negative number and represents where the Value to be patched is located within the FD. The Value is what will be written at the given Offset in the FD. Constants may be used for both offsets and values. Also, this argument handles expressions for both offsets and values using these operators: = - * & | ~ ( ) [ ] { } < > The entire argument includes the quote marks like in the example argument below: 0xFFFFFFC0, SomeCore:__EntryPoint - [0x000000F0],@SomeCore Entry Constants: \u00b6 Hexadecimal (use 0x as prefix) | Decimal Examples: \u00b6 Positive Hex Negative Hex Positive Decimal Negative Decimal 0x000000BC 0xFFFFFFA2 188 -94 ModuleName:FunctionName | ModuleName:GlobalVariableName ModuleGuid:Offset Operators: \u00b6 + Addition - Subtraction * Multiplication & Logical and | Logical or ~ Complement ( ) Evaluation control [ ] Get a DWord value at the specified offset expression from [expr] { } Convert an offset {expr} into an absolute address (FSP_BASE + expr) < > Convert absolute address <expr> into an image offset (expr & FSP_SIZE) Special Commands: \u00b6 Special commands must use the $ symbol as a prefix to the command itself. There is only one command available at this time. $COPY ? Copy a binary block from source to destination. Example: \u00b6 0x94, [PlatformInit:__gPcd_BinPatch_FvRecOffset] + 0x94, [0x98], $COPY, @Sync up 2nd FSP Header Comments: \u00b6 Comments are allowed in the Offset, Value [, Comment] argument. Comments must use the @ symbol as a prefix. The comment will output to the build window upon successful completion of patching along with the offset and value data.","title":"Patch Fv User Manual"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#name","text":"PatchFv.py - The python script that patches the firmware volumes ( FV ) with in the flash device ( FD ) file post FSP build.","title":"Name"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#synopsis","text":"PatchFv FvBuildDir [FvFileBaseNames:]FdFileBaseNameToPatch [\"Offset, Value\"]+ | [\"Offset, Value, @Comment\"]+ | [\"Offset, Value, $Command\"]+ | [\"Offset, Value, $Command, @Comment\"]+","title":"Synopsis"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#description","text":"The PatchFv.py tool allows the developer to fix up FD images to follow the Intel FSP Architecture specification. It also makes the FD image relocatable. The tool is written in Python and uses Python 2.7 or later to run. Consider using the tool in a build script.","title":"Description"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fvbuilddir-argument-1","text":"This is the first argument that PatchFv.py requires. It is the build directory for all firmware volumes created during the FSP build. The path must be either an absolute path or a relevant path, relevant to the top level of the FSP tree.","title":"FvBuildDir (Argument 1)"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage","text":"Build\\YouPlatformFspPkg\\%BD_TARGET%_%VS_VERSION%%VS_X86%\\FV The example used contains Windows batch script %VARIABLES%.","title":"Example usage:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fvfilebasenames-argument-2-optional-part-1","text":"The firmware volume file base names ( FvFileBaseNames ) are the independent Fv?s that are to be patched within the FD. (0 or more in the form FVFILEBASENAME: ) The colon : is used for delimiting the single argument and must be appended to the end of each ( FvFileBaseNames ).","title":"FvFileBaseNames (Argument 2: Optional Part 1)"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage_1","text":"STAGE1:STAGE2:MANIFEST:YOURPLATFORM In the example STAGE1 is STAGE1.Fv in YOURPLATFORM.fd .","title":"Example usage:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fdfilenametopatch-argument-2-mandatory-part-2","text":"Firmware device file name to patch ( FdFileNameToPatch ) is the base name of the FD file that is to be patched. (1 only, in the form YOURPLATFORM )","title":"FdFileNameToPatch (Argument 2: Mandatory Part 2)"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage_2","text":"STAGE1:STAGE2:MANIFEST:YOURPLATFORM In the example YOURPLATFORM is from YOURPLATFORM.fd","title":"Example usage:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#offset-value-command-comment-argument-3","text":"The Offset can be a positive or negative number and represents where the Value to be patched is located within the FD. The Value is what will be written at the given Offset in the FD. Constants may be used for both offsets and values. Also, this argument handles expressions for both offsets and values using these operators: = - * & | ~ ( ) [ ] { } < > The entire argument includes the quote marks like in the example argument below: 0xFFFFFFC0, SomeCore:__EntryPoint - [0x000000F0],@SomeCore Entry","title":"\"Offset, Value[, Command][, Comment]\" (Argument 3)"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#constants","text":"Hexadecimal (use 0x as prefix) | Decimal","title":"Constants:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#examples","text":"Positive Hex Negative Hex Positive Decimal Negative Decimal 0x000000BC 0xFFFFFFA2 188 -94 ModuleName:FunctionName | ModuleName:GlobalVariableName ModuleGuid:Offset","title":"Examples:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#operators","text":"+ Addition - Subtraction * Multiplication & Logical and | Logical or ~ Complement ( ) Evaluation control [ ] Get a DWord value at the specified offset expression from [expr] { } Convert an offset {expr} into an absolute address (FSP_BASE + expr) < > Convert absolute address <expr> into an image offset (expr & FSP_SIZE)","title":"Operators:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#special-commands","text":"Special commands must use the $ symbol as a prefix to the command itself. There is only one command available at this time. $COPY ? Copy a binary block from source to destination.","title":"Special Commands:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example","text":"0x94, [PlatformInit:__gPcd_BinPatch_FvRecOffset] + 0x94, [0x98], $COPY, @Sync up 2nd FSP Header","title":"Example:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#comments","text":"Comments are allowed in the Offset, Value [, Comment] argument. Comments must use the @ symbol as a prefix. The comment will output to the build window upon successful completion of patching along with the offset and value data.","title":"Comments:"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/","text":"SplitFspBin.py is a python script to support some operations on Intel FSP 1.x/2.x image. \u00b6 It supports: Split Intel FSP 2.x image into individual FSP-T/M/S/O component Rebase Intel FSP 1.x/2.x components to different base addresses Generate Intel FSP 1.x/2.x C header file Display Intel FSP 1.x/2.x information header for each FSP component Split Intel FSP 2.x image \u00b6 FSP 1.x image is not supported by split command. To split individual FSP component in Intel FSP 2.x image, the following command can be used: python SplitFspBin.py split [-h] -f FSPBINARY [-o OUTPUTDIR] [-n NAMETEMPLATE] For example: python SplitFspBin.py split -f FSP.bin It will create FSP_T.bin, FSP_M.bin and FSP_S.bin in current directory. Rebase Intel FSP 1.x/2.x components \u00b6 To rebase one or multiple FSP components in Intel FSP 1.x/2.x image, the following command can be used: python SplitFspBin.py rebase [-h] -f FSPBINARY -c {t,m,s,o} [{t,m,s,o} ...] -b FSPBASE [FSPBASE ...] [-o OUTPUTDIR] [-n OUTPUTFILE] For example: python SplitFspBin.py rebase -f FSP.bin -c t -b 0xFFF00000 -n FSP_new.bin It will rebase FSP-T component inside FSP.bin to new base 0xFFF00000 and save the rebased Intel FSP 2.x image into file FSP_new.bin. For FSP 1.x image there is only one component in binary so above command also works for FSP 1.x image. python SplitFspBin.py rebase -f FSP.bin -c t m -b 0xFFF00000 0xFEF80000 -n FSP_new.bin It will rebase FSP-T and FSP-M components inside FSP.bin to new base 0xFFF00000 and 0xFEF80000 respectively, and save the rebased Intel FSP 2.x image into file FSP_new.bin file. Generate Intel FSP 1.x/2.x C header file \u00b6 To generate Intel FSP 1.x/2.x C header file, the following command can be used: Python SplitFspBin.py genhdr [-h] -f FSPBINARY [-o OUTPUTDIR] [-n HFILENAME] For example: python SplitFspBin.py genhdr -f FSP.bin -n FSP.h It will create the C header file FSP.h containing the image ID, revision, offset and size for each individual FSP component. Display Intel FSP 1.x/2.x information header \u00b6 To display Intel FSP 1.x/2.x information headers, the following command can be used: Python SplitFspBin.py info [-h] -f FSPBINARY For example: python SplitFspBin.py info -f FSP.bin It will print out the FSP information header for each FSP component.","title":"Split Fsp Bin User Manual"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#splitfspbinpy-is-a-python-script-to-support-some-operations-on-intel-fsp-1x2x-image","text":"It supports: Split Intel FSP 2.x image into individual FSP-T/M/S/O component Rebase Intel FSP 1.x/2.x components to different base addresses Generate Intel FSP 1.x/2.x C header file Display Intel FSP 1.x/2.x information header for each FSP component","title":"SplitFspBin.py is a python script to support some operations on Intel FSP 1.x/2.x image."},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#split-intel-fsp-2x-image","text":"FSP 1.x image is not supported by split command. To split individual FSP component in Intel FSP 2.x image, the following command can be used: python SplitFspBin.py split [-h] -f FSPBINARY [-o OUTPUTDIR] [-n NAMETEMPLATE] For example: python SplitFspBin.py split -f FSP.bin It will create FSP_T.bin, FSP_M.bin and FSP_S.bin in current directory.","title":"Split Intel FSP 2.x image"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#rebase-intel-fsp-1x2x-components","text":"To rebase one or multiple FSP components in Intel FSP 1.x/2.x image, the following command can be used: python SplitFspBin.py rebase [-h] -f FSPBINARY -c {t,m,s,o} [{t,m,s,o} ...] -b FSPBASE [FSPBASE ...] [-o OUTPUTDIR] [-n OUTPUTFILE] For example: python SplitFspBin.py rebase -f FSP.bin -c t -b 0xFFF00000 -n FSP_new.bin It will rebase FSP-T component inside FSP.bin to new base 0xFFF00000 and save the rebased Intel FSP 2.x image into file FSP_new.bin. For FSP 1.x image there is only one component in binary so above command also works for FSP 1.x image. python SplitFspBin.py rebase -f FSP.bin -c t m -b 0xFFF00000 0xFEF80000 -n FSP_new.bin It will rebase FSP-T and FSP-M components inside FSP.bin to new base 0xFFF00000 and 0xFEF80000 respectively, and save the rebased Intel FSP 2.x image into file FSP_new.bin file.","title":"Rebase Intel FSP 1.x/2.x components"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#generate-intel-fsp-1x2x-c-header-file","text":"To generate Intel FSP 1.x/2.x C header file, the following command can be used: Python SplitFspBin.py genhdr [-h] -f FSPBINARY [-o OUTPUTDIR] [-n HFILENAME] For example: python SplitFspBin.py genhdr -f FSP.bin -n FSP.h It will create the C header file FSP.h containing the image ID, revision, offset and size for each individual FSP component.","title":"Generate Intel FSP 1.x/2.x C header file"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#display-intel-fsp-1x2x-information-header","text":"To display Intel FSP 1.x/2.x information headers, the following command can be used: Python SplitFspBin.py info [-h] -f FSPBINARY For example: python SplitFspBin.py info -f FSP.bin It will print out the FSP information header for each FSP component.","title":"Display Intel FSP 1.x/2.x information header"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2WrapperPkg/Readme/","text":"IntelFsp2WrapperPkg \u00b6 This package provides the component to use an FSP binary. Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg A whitepaper to describe the IntelFsp2WrapperPkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Using_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf","title":"Modules"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2WrapperPkg/Readme/#intelfsp2wrapperpkg","text":"This package provides the component to use an FSP binary. Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg A whitepaper to describe the IntelFsp2WrapperPkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Using_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf","title":"IntelFsp2WrapperPkg"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsulePdb/Readme/","text":"How to generate Microcode FMP from Microcode PDB file \u00b6 1) Copy directory UefiCpuPkg/Feature/Capsule/MicrocodeUpdatePdb to <Your Platform Package>/MicrocodeUpdatePdb . 2) Uncomment and update FILE DATA statement in <Your Platform Package>/MicrocodeUpdatePdb/MicrocodeCapsulePdb.fdf with path to a Microcode PDB file. The PDB file can placed in <Your Platform Package>/MicrocodeUpdatePdb or any other path. FILE DATA = <your Microcode PDB file path> Uncomment and update PLATFORM_NAME , FLASH_DEFINITION , OUTPUT_DIRECTORY section in <Your Platform Package>/MicrocodeUpdatePdb/MicrocodeCapsulePdb.dsc with . PLATFORM_NAME = <Your Platform Package> FLASH_DEFINITION = <Your Platform Package>/MicrocodeCapsulePdb/MicrocodeCapsulePdb.fdf OUTPUT_DIRECTORY = Build/<Your Platform Package> 3) Use EDK II build tools to generate the Microcode FMP Capsule build -p <Your Platform Package>/MicrocodeCapsulePdb/MicrocodeCapsulePdb.dsc 4) The Microcode FMP Capsule is generated at $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap","title":"Microcode Capsule Pdb"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsulePdb/Readme/#how-to-generate-microcode-fmp-from-microcode-pdb-file","text":"1) Copy directory UefiCpuPkg/Feature/Capsule/MicrocodeUpdatePdb to <Your Platform Package>/MicrocodeUpdatePdb . 2) Uncomment and update FILE DATA statement in <Your Platform Package>/MicrocodeUpdatePdb/MicrocodeCapsulePdb.fdf with path to a Microcode PDB file. The PDB file can placed in <Your Platform Package>/MicrocodeUpdatePdb or any other path. FILE DATA = <your Microcode PDB file path> Uncomment and update PLATFORM_NAME , FLASH_DEFINITION , OUTPUT_DIRECTORY section in <Your Platform Package>/MicrocodeUpdatePdb/MicrocodeCapsulePdb.dsc with . PLATFORM_NAME = <Your Platform Package> FLASH_DEFINITION = <Your Platform Package>/MicrocodeCapsulePdb/MicrocodeCapsulePdb.fdf OUTPUT_DIRECTORY = Build/<Your Platform Package> 3) Use EDK II build tools to generate the Microcode FMP Capsule build -p <Your Platform Package>/MicrocodeCapsulePdb/MicrocodeCapsulePdb.dsc 4) The Microcode FMP Capsule is generated at $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap","title":"How to generate Microcode FMP from Microcode PDB file"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsuleTxt/Readme/","text":"How to generate Microcode FMP from Microcode TXT file \u00b6 1) Copy directory UefiCpuPkg/Feature/Capsule/MicrocodeUpdateTxt to <Your Platform Package>/MicrocodeUpdateTxt 2) Copy microcode TXT file to <Your Platform Package>/MicrocodeUpdateTxt/Microcode 3) Uncomment and update statement in [Sources] section of <Your Platform Package>/MicrocodeUpdateTxt/Microcode/Microcode.inf with name of Microcode TXT file copied in previous step. [Sources] <Your Microcode TXT file> Uncomment and update FILE DATA statement in <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.fdf with path to a Microcode MCB file. The MCB file is placed in $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/IA32/<Your Platform Package>/MicrocodeUpdateTxt/Microcode/Microcode/OUTPUT/ . FILE DATA = <your Microcode MCB file path> Uncomment and update PLATFORM_NAME , FLASH_DEFINITION , OUTPUT_DIRECTORY section in <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc with . PLATFORM_NAME = <Your Platform Package> FLASH_DEFINITION = <Your Platform Package>/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.fdf OUTPUT_DIRECTORY = Build/<Your Platform Package> Uncomment and update statement in Components section of <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc with path to a Microcode INF file. [Components] <Your Microcode INF file> 4) Use EDK II build tools to generate the Microcode FMP Capsule build -p <Your Platform Package>/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.dsc 5) The generated Microcode FMP Capsule is found at $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap","title":"Microcode Capsule Txt"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsuleTxt/Readme/#how-to-generate-microcode-fmp-from-microcode-txt-file","text":"1) Copy directory UefiCpuPkg/Feature/Capsule/MicrocodeUpdateTxt to <Your Platform Package>/MicrocodeUpdateTxt 2) Copy microcode TXT file to <Your Platform Package>/MicrocodeUpdateTxt/Microcode 3) Uncomment and update statement in [Sources] section of <Your Platform Package>/MicrocodeUpdateTxt/Microcode/Microcode.inf with name of Microcode TXT file copied in previous step. [Sources] <Your Microcode TXT file> Uncomment and update FILE DATA statement in <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.fdf with path to a Microcode MCB file. The MCB file is placed in $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/IA32/<Your Platform Package>/MicrocodeUpdateTxt/Microcode/Microcode/OUTPUT/ . FILE DATA = <your Microcode MCB file path> Uncomment and update PLATFORM_NAME , FLASH_DEFINITION , OUTPUT_DIRECTORY section in <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc with . PLATFORM_NAME = <Your Platform Package> FLASH_DEFINITION = <Your Platform Package>/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.fdf OUTPUT_DIRECTORY = Build/<Your Platform Package> Uncomment and update statement in Components section of <Your Platform Package>/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc with path to a Microcode INF file. [Components] <Your Microcode INF file> 4) Use EDK II build tools to generate the Microcode FMP Capsule build -p <Your Platform Package>/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.dsc 5) The generated Microcode FMP Capsule is found at $(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap","title":"How to generate Microcode FMP from Microcode TXT file"},{"location":"dyn/mu_tiano_platforms/CODE_OF_CONDUCT/","text":"Microsoft Open Source Code of Conduct \u00b6 This project has adopted the Microsoft Open Source Code of Conduct . Resources: Microsoft Open Source Code of Conduct Microsoft Code of Conduct FAQ Contact opencode@microsoft.com with questions or concerns","title":"CODE OF CONDUCT"},{"location":"dyn/mu_tiano_platforms/CODE_OF_CONDUCT/#microsoft-open-source-code-of-conduct","text":"This project has adopted the Microsoft Open Source Code of Conduct . Resources: Microsoft Open Source Code of Conduct Microsoft Code of Conduct FAQ Contact opencode@microsoft.com with questions or concerns","title":"Microsoft Open Source Code of Conduct"},{"location":"dyn/mu_tiano_platforms/RepoDetails/","text":"Mu Tiano Platforms Repository \u00b6 Git Details Repository Url: https://github.com/microsoft/mu_tiano_platforms.git Branch: release/202202 Commit: 63b24c70d9c289bc6c92a58a9f8c8df852219d27 Commit Date: 2022-10-12 18:53:42 -0400 Mu Tiano Platform is a public repository of Project Mu based firmware for the QEMU processor emulator. It contains a QemuQ35Pkg that is customized to enable many of the features of Project Mu. It also contains the original upstream OvmfPkg from edk2 which supports IA32/X64 virtual firmware for QEMU. This repository is to provide a readily available, free, and feature rich platform to use as an example for feature enablement and validation, demonstrating how a single firmware codebase can be shared across multiple products and architectures, promoting serviceable, maintainable, up-to-date and secure firmware. Eventually there may be numerous feature branches that demonstrate how to enable advanced capabilities. By providing an end-to-end example, these features can be easily tested and evaluated before being integrated into other platforms. Upstream Alignment \u00b6 This repo has a filtered version of edk2 as an upstream, which can be found in the upstream/main branch. The Azure Pipeline definition, which performs the upstream syncing process, can be found in upstream/sync . When edk2 is tagged, a new branch with the corresponding tag will be created (example: upstream/202005 ). Since it is a filtered branch, the exact commit that edk2 is tagged at won't be represented but it will be the closest applicable commit before edk2 was tagged. In addition, the current release branch of this repo will be rebased on those upstream release commits and a new release branch will be created and set as default. For example upstream/202005 will have a development branch of release/202005 . The expectation is that only the latest release branch is in active development. Long Term Support/Security Patches This repository and all code within it is not part of an officially supported customer facing product and therefore long term servicing will not be supported. Security issues will also not be backported. Platform Firmware Support \u00b6 Buildable platforms can be found under the Platforms folder inside the root of this repo. Details about the platform and how to build/use each platform can be found in their respective directories. Q35 Platform Ovmf upstream Platform For general details about Project Mu please see the Project Mu docs ( https://github.com/Microsoft/mu ). This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Copyright & License \u00b6 Project Mu contributions will be licensed as BSD-2-Clause-Patent and will contain the SPDX-License-Identifier. Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ================================================================================ Some files are subject to the following license, the MIT license. Those files are located in: Platform/OvmfPkg/Include/IndustryStandard/Xen/ Platform/OvmfPkg/XenBusDxe/ SPDX-License-Identifier: MIT Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Repo Details"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#mu-tiano-platforms-repository","text":"Git Details Repository Url: https://github.com/microsoft/mu_tiano_platforms.git Branch: release/202202 Commit: 63b24c70d9c289bc6c92a58a9f8c8df852219d27 Commit Date: 2022-10-12 18:53:42 -0400 Mu Tiano Platform is a public repository of Project Mu based firmware for the QEMU processor emulator. It contains a QemuQ35Pkg that is customized to enable many of the features of Project Mu. It also contains the original upstream OvmfPkg from edk2 which supports IA32/X64 virtual firmware for QEMU. This repository is to provide a readily available, free, and feature rich platform to use as an example for feature enablement and validation, demonstrating how a single firmware codebase can be shared across multiple products and architectures, promoting serviceable, maintainable, up-to-date and secure firmware. Eventually there may be numerous feature branches that demonstrate how to enable advanced capabilities. By providing an end-to-end example, these features can be easily tested and evaluated before being integrated into other platforms.","title":"Mu Tiano Platforms Repository"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#upstream-alignment","text":"This repo has a filtered version of edk2 as an upstream, which can be found in the upstream/main branch. The Azure Pipeline definition, which performs the upstream syncing process, can be found in upstream/sync . When edk2 is tagged, a new branch with the corresponding tag will be created (example: upstream/202005 ). Since it is a filtered branch, the exact commit that edk2 is tagged at won't be represented but it will be the closest applicable commit before edk2 was tagged. In addition, the current release branch of this repo will be rebased on those upstream release commits and a new release branch will be created and set as default. For example upstream/202005 will have a development branch of release/202005 . The expectation is that only the latest release branch is in active development. Long Term Support/Security Patches This repository and all code within it is not part of an officially supported customer facing product and therefore long term servicing will not be supported. Security issues will also not be backported.","title":"Upstream Alignment"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#platform-firmware-support","text":"Buildable platforms can be found under the Platforms folder inside the root of this repo. Details about the platform and how to build/use each platform can be found in their respective directories. Q35 Platform Ovmf upstream Platform For general details about Project Mu please see the Project Mu docs ( https://github.com/Microsoft/mu ). This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"Platform Firmware Support"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#copyright-license","text":"Project Mu contributions will be licensed as BSD-2-Clause-Patent and will contain the SPDX-License-Identifier. Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ================================================================================ Some files are subject to the following license, the MIT license. Those files are located in: Platform/OvmfPkg/Include/IndustryStandard/Xen/ Platform/OvmfPkg/XenBusDxe/ SPDX-License-Identifier: MIT Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_tiano_platforms/SECURITY/","text":"Security \u00b6 Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below. Reporting Security Issues \u00b6 Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, use after free, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs. Preferred Languages \u00b6 We prefer all communications to be in English. Policy \u00b6 Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"SECURITY"},{"location":"dyn/mu_tiano_platforms/SECURITY/#security","text":"Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft , Azure , DotNet , AspNet , Xamarin , and our GitHub organizations . If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability , please report it to us as described below.","title":"Security"},{"location":"dyn/mu_tiano_platforms/SECURITY/#reporting-security-issues","text":"Please do not report security vulnerabilities through public GitHub issues. Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report . If you prefer to submit without logging in, send email to secure@microsoft.com . If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page . You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc . Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue: Type of issue (e.g. buffer overflow, use after free, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue This information will help us triage your report more quickly. If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.","title":"Reporting Security Issues"},{"location":"dyn/mu_tiano_platforms/SECURITY/#preferred-languages","text":"We prefer all communications to be in English.","title":"Preferred Languages"},{"location":"dyn/mu_tiano_platforms/SECURITY/#policy","text":"Microsoft follows the principle of Coordinated Vulnerability Disclosure .","title":"Policy"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/ReadMe/","text":"OvmfPkg \u00b6 This package supports building the Tianocore edk2 OvmfPkg with Project Mu . The only changes in this package from the upstream should be related to build and repository layout differences. This particular package/platform does not showcase or enable the Project Mu feature set but it does serve as a convenient dependency and, in some cases, code delta for the other platform packages in this repository that do. More Details \u00b6 Building with Stuart - See OvmfPkg/PlatformCI/ReadMe.md For other details about OVMF and QEMU see the Edk2 maintained readme at OvmfPkg/README.","title":"Read Me"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/ReadMe/#ovmfpkg","text":"This package supports building the Tianocore edk2 OvmfPkg with Project Mu . The only changes in this package from the upstream should be related to build and repository layout differences. This particular package/platform does not showcase or enable the Project Mu feature set but it does serve as a convenient dependency and, in some cases, code delta for the other platform packages in this repository that do.","title":"OvmfPkg"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/ReadMe/#more-details","text":"Building with Stuart - See OvmfPkg/PlatformCI/ReadMe.md For other details about OVMF and QEMU see the Edk2 maintained readme at OvmfPkg/README.","title":"More Details"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/","text":"OvmfPkg - Platform CI \u00b6 This ReadMe.md describes the Azure DevOps based Platform CI for OvmfPkg and how to use the same Pytools based build infrastructure locally. Supported Configuration Details \u00b6 This solution for building and running OvmfPkg has only been validated with Windows 10 with VS2022 and Ubuntu 18.04 with GCC5 toolchain. Four different firmware builds are supported and are described below. Configuration name Architectures DSC File Additional Flags IA32 IA32 OvmfPkgIa32.dsc None X64 X64 OvmfPkgIa64.dsc None IA32 X64 PEI-IA32 DXE-X64 OvmfPkgIa32X64.dsc None IA32 X64 Full PEI-IA32 DXE-X64 OvmfPkgIa32X64.dsc SECURE_BOOT_ENABLE=1 SMM_REQUIRE=1 TPM1_ENABLE=1 TPM2_ENABLE=1 NETWORK_TLS_ENABLE=1 NETWORK_IP6_ENABLE=1 NETWORK_HTTP_BOOT_ENABLE=1 EDK2 Developer environment \u00b6 Python 3.8.x - Download & Install GIT - Download & Install QEMU - Download, Install, and add to your path Edk2 Source Additional packages found necessary for Ubuntu 18.04 apt-get install gcc g++ make uuid-dev Note: edksetup, Submodule initialization and manual installation of NASM, iASL, or the required cross-compiler toolchains are not required, this is handled by the Pytools build system. Building with Pytools for OvmfPkg \u00b6 [Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Linux source <name of virtual environment>/bin/activate Windows <name of virtual environment>/Scripts/activate.bat Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Compile the basetools if necessary - only when basetools C source files change python BaseTools/Edk2ToolsBuild.py -t <ToolChainTag> Compile Firmware To build IA32 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a IA32 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> To build X64 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a X64 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> To build IA32 X64 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a IA32,X64 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> use stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> --FlashOnly Notes \u00b6 Configuring ACTIVE_PLATFORM and TARGET_ARCH in Conf/target.txt is not required. This environment is set by PlatformBuild.py based upon the [-a <TARGET_ARCH>] parameter. QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. NOTE: Logging the execution output will be in the normal stuart log as well as to your console. Custom Build Options \u00b6 MAKE_STARTUP_NSH=TRUE will output a startup.nsh file to the location mapped as fs0. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this. Passing Build Defines \u00b6 To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add an =1 suffix for bare defines. For example, to enable the TPM2 support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be: stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py BLD_*_E1000_ENABLE=1 References \u00b6 Installing and using Pytools More on python virtual environments","title":"Platform CI"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#ovmfpkg-platform-ci","text":"This ReadMe.md describes the Azure DevOps based Platform CI for OvmfPkg and how to use the same Pytools based build infrastructure locally.","title":"OvmfPkg - Platform CI"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#supported-configuration-details","text":"This solution for building and running OvmfPkg has only been validated with Windows 10 with VS2022 and Ubuntu 18.04 with GCC5 toolchain. Four different firmware builds are supported and are described below. Configuration name Architectures DSC File Additional Flags IA32 IA32 OvmfPkgIa32.dsc None X64 X64 OvmfPkgIa64.dsc None IA32 X64 PEI-IA32 DXE-X64 OvmfPkgIa32X64.dsc None IA32 X64 Full PEI-IA32 DXE-X64 OvmfPkgIa32X64.dsc SECURE_BOOT_ENABLE=1 SMM_REQUIRE=1 TPM1_ENABLE=1 TPM2_ENABLE=1 NETWORK_TLS_ENABLE=1 NETWORK_IP6_ENABLE=1 NETWORK_HTTP_BOOT_ENABLE=1","title":"Supported Configuration Details"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#edk2-developer-environment","text":"Python 3.8.x - Download & Install GIT - Download & Install QEMU - Download, Install, and add to your path Edk2 Source Additional packages found necessary for Ubuntu 18.04 apt-get install gcc g++ make uuid-dev Note: edksetup, Submodule initialization and manual installation of NASM, iASL, or the required cross-compiler toolchains are not required, this is handled by the Pytools build system.","title":"EDK2 Developer environment"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#building-with-pytools-for-ovmfpkg","text":"[Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Linux source <name of virtual environment>/bin/activate Windows <name of virtual environment>/Scripts/activate.bat Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> Compile the basetools if necessary - only when basetools C source files change python BaseTools/Edk2ToolsBuild.py -t <ToolChainTag> Compile Firmware To build IA32 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a IA32 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> To build X64 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a X64 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> To build IA32 X64 stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -a IA32,X64 TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> use stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> -a <TARGET_ARCH> --FlashOnly","title":"Building with Pytools for OvmfPkg"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#notes","text":"Configuring ACTIVE_PLATFORM and TARGET_ARCH in Conf/target.txt is not required. This environment is set by PlatformBuild.py based upon the [-a <TARGET_ARCH>] parameter. QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. NOTE: Logging the execution output will be in the normal stuart log as well as to your console.","title":"Notes"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#custom-build-options","text":"MAKE_STARTUP_NSH=TRUE will output a startup.nsh file to the location mapped as fs0. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this.","title":"Custom Build Options"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#passing-build-defines","text":"To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add an =1 suffix for bare defines. For example, to enable the TPM2 support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be: stuart_build -c OvmfPkg/PlatformCI/PlatformBuild.py BLD_*_E1000_ENABLE=1","title":"Passing Build Defines"},{"location":"dyn/mu_tiano_platforms/Platforms/OvmfPkg/PlatformCI/ReadMe/#references","text":"Installing and using Pytools More on python virtual environments","title":"References"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/","text":"QemuQ35Pkg \u00b6 QemuQ35Pkg... Is a derivative of OvmfPkg. Will not support Legacy BIOS or CSM. WIll not support S3 sleep functionality. Has a 32-bit PEI phase and a 64-bit DXE phase. Seeks to enable a tightly constrained virtual platform based on the QEMU Q35 machine type. By solely focusing on the Q35 chipset, this package can be optimized such that it is allowed to break compatibility with other QEMU supported chipsets. The Q35 chipset can be paired with an IA32 or X64 processor to enable a machine that can emulate PC class hardware with industry standard features like SMM and PCI-E. Q35 Platform \u00b6 Q35 is a machine type that QEMU emulates. Below is a diagram from Qemu.org about the Q35 chipset which emulates a ICH9 (I/O controller hub). The advantages of the ICH9 over the I440FX (which is what QEMU often emulates) is that it has PCI-E instead of just PCI as well as having an integrated AHCI controller and no ISA bus. Visit the feature wiki detailing QEMU Q35 for more information: https://wiki.qemu.org/Features/Q35 Compiling and Running QEMU \u00b6 QemuQ35Pkg uses the Project Mu repositories and Edk2 PyTools for its build operations. Specific details can be found here Development/building.md Firmware Features \u00b6 QemuQ35Pkg is a great environment to demonstrate Project Mu features without any restricted or costly physical hardware. Current QEMU Q35 platform supports the following features provided by Project Mu: Mu Front Page \u00b6 Enable the Project Mu OEM sample \"front page\". This is a touch friendly, graphical, UEFI HII based UI application that allows basic platform and boot device configuration. Details Device Firmware Configuration Interface \u00b6 The DFCI feature enables cloud management services (MDM services like Microsoft Intune) to manage some PC bios settings securely . DFCI is a foundational feature that provides a shared identity and ownership model between the device firmware and the cloud. Once a device is enrolled this shared identity can be used to securely communicate across untrusted mediums (network or usb). Details Mu Telemetry / WHEA / HwErrorRecord \u00b6 The Mu Telemetry feature is an extension of the PI spec defined report status code. The feature is designed to collect critical (platform defined) status codes, record them into a HwErrRecord, and then transfer them through the Microsoft WHEA pipeline. From there an OEM can use Microsoft provided reports to check on in market device health. *Some work still pending completion. Details Platform Runtime Mechanism (PRM) \u00b6 Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. This feature adds the PRM infrastructure to the firmware that enables loading PRM modules which in turn are exposed to the OS for invocation. To accomplish this, a set of open source sample PRM modules are used to demonstrate the feature and show how additional modules can be added. Details Mu Customized Components \u00b6 Modules \u00b6 Modules Link to Documentation QemuVideoDxe QEMU Cirrus Video Controller Libraries \u00b6 Libraries Link to Documentation MsPlatformDevicesLib MsPlatformDevicesLib PlatformDebugLibIoPort PlatformDebugLibIoPort PlatformThemeLib PlatformThemeLib","title":"Qemu Q35 Read Me"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#qemuq35pkg","text":"QemuQ35Pkg... Is a derivative of OvmfPkg. Will not support Legacy BIOS or CSM. WIll not support S3 sleep functionality. Has a 32-bit PEI phase and a 64-bit DXE phase. Seeks to enable a tightly constrained virtual platform based on the QEMU Q35 machine type. By solely focusing on the Q35 chipset, this package can be optimized such that it is allowed to break compatibility with other QEMU supported chipsets. The Q35 chipset can be paired with an IA32 or X64 processor to enable a machine that can emulate PC class hardware with industry standard features like SMM and PCI-E.","title":"QemuQ35Pkg"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#q35-platform","text":"Q35 is a machine type that QEMU emulates. Below is a diagram from Qemu.org about the Q35 chipset which emulates a ICH9 (I/O controller hub). The advantages of the ICH9 over the I440FX (which is what QEMU often emulates) is that it has PCI-E instead of just PCI as well as having an integrated AHCI controller and no ISA bus. Visit the feature wiki detailing QEMU Q35 for more information: https://wiki.qemu.org/Features/Q35","title":"Q35 Platform"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#compiling-and-running-qemu","text":"QemuQ35Pkg uses the Project Mu repositories and Edk2 PyTools for its build operations. Specific details can be found here Development/building.md","title":"Compiling and Running QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#firmware-features","text":"QemuQ35Pkg is a great environment to demonstrate Project Mu features without any restricted or costly physical hardware. Current QEMU Q35 platform supports the following features provided by Project Mu:","title":"Firmware Features"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-front-page","text":"Enable the Project Mu OEM sample \"front page\". This is a touch friendly, graphical, UEFI HII based UI application that allows basic platform and boot device configuration. Details","title":"Mu Front Page"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#device-firmware-configuration-interface","text":"The DFCI feature enables cloud management services (MDM services like Microsoft Intune) to manage some PC bios settings securely . DFCI is a foundational feature that provides a shared identity and ownership model between the device firmware and the cloud. Once a device is enrolled this shared identity can be used to securely communicate across untrusted mediums (network or usb). Details","title":"Device Firmware Configuration Interface"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-telemetry-whea-hwerrorrecord","text":"The Mu Telemetry feature is an extension of the PI spec defined report status code. The feature is designed to collect critical (platform defined) status codes, record them into a HwErrRecord, and then transfer them through the Microsoft WHEA pipeline. From there an OEM can use Microsoft provided reports to check on in market device health. *Some work still pending completion. Details","title":"Mu Telemetry / WHEA / HwErrorRecord"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#platform-runtime-mechanism-prm","text":"Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. This feature adds the PRM infrastructure to the firmware that enables loading PRM modules which in turn are exposed to the OS for invocation. To accomplish this, a set of open source sample PRM modules are used to demonstrate the feature and show how additional modules can be added. Details","title":"Platform Runtime Mechanism (PRM)"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-customized-components","text":"","title":"Mu Customized Components"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#modules","text":"Modules Link to Documentation QemuVideoDxe QEMU Cirrus Video Controller","title":"Modules"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#libraries","text":"Libraries Link to Documentation MsPlatformDevicesLib MsPlatformDevicesLib PlatformDebugLibIoPort PlatformDebugLibIoPort PlatformThemeLib PlatformThemeLib","title":"Libraries"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/","text":"Building \u00b6 Steps to setup your environment, compile, and run the QemuQ35Pkg. This solution for building and running QemuQ35Pkg has only been validated with Windows 10 with VS2022 and Ubuntu 18.04 with GCC5 toolchain. Developer environment \u00b6 This is a Project Mu platform and thus the default environment requirements can be found here at the Project Mu Prerequisites page. In addition if you want to run your locally compiled firmware you need QEMU - Download, Install, and add to your path This build uses edk2-pytools for functionality. Documentation can be found here . On most Linux distros this requires an extra step for mono and nuget support. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_extdep.md#a-note-on-nuget-on-linux Building with Pytools \u00b6 [Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Linux source <name of virtual environment>/bin/activate Windows <name of virtual environment>/Scripts/activate.bat Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> TOOL_CHAIN_TAG being the toolchain you want to build with, currently VS2019 , VS2022 , and GCC5 are supported values Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> Compile Firmware stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> use stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --FlashOnly Alternative Options All the commands specified here can use a shortcut, which is to invoke the Build file directly. For example: py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --FlashOnly Setup and update can be done by passing it in py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --setup py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --update Under the hood, it just does the invocation of Stuart for you. Notes \u00b6 QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. QEMU output will be in Build/BUILDLOG_QemuQ35Pkg.txt as well as Build/QemuQ35Pkg/QEMULOG_QemuQ35Pkg.txt NOTE: Logging the execution output will be in the normal stuart log as well as to your console (if you have the correct logging level set, by default it doesn't output to console). Custom Build Options \u00b6 SHUTDOWN_AFTER_RUN=TRUE will output a startup.nsh file to the location mapped as fs0 with reset -s as the final line. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this. GDB_SERVER=\\<TCP Port> Enables the GDB port in the QEMU instance at the provided TCP port. SERIAL_PORT=\\<Serial Port> Enables the specified serial port to be used as console. Passing Build Defines \u00b6 To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add a =1 suffix for bare defines. For example, to enable the E1000 network support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be: stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py BLD_*_E1000_ENABLE=1 References \u00b6 Installing and using Pytools More on python virtual environments","title":"building"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#building","text":"Steps to setup your environment, compile, and run the QemuQ35Pkg. This solution for building and running QemuQ35Pkg has only been validated with Windows 10 with VS2022 and Ubuntu 18.04 with GCC5 toolchain.","title":"Building"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#developer-environment","text":"This is a Project Mu platform and thus the default environment requirements can be found here at the Project Mu Prerequisites page. In addition if you want to run your locally compiled firmware you need QEMU - Download, Install, and add to your path This build uses edk2-pytools for functionality. Documentation can be found here . On most Linux distros this requires an extra step for mono and nuget support. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_extdep.md#a-note-on-nuget-on-linux","title":"Developer environment"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#building-with-pytools","text":"[Optional] Create a Python Virtual Environment - generally once per workspace python -m venv <name of virtual environment> [Optional] Activate Virtual Environment - each time new shell opened Linux source <name of virtual environment>/bin/activate Windows <name of virtual environment>/Scripts/activate.bat Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes pip install --upgrade -r pip-requirements.txt Initialize & Update Submodules - only when submodules updated stuart_setup -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> TOOL_CHAIN_TAG being the toolchain you want to build with, currently VS2019 , VS2022 , and GCC5 are supported values Initialize & Update Dependencies - only as needed when ext_deps change stuart_update -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> Compile Firmware stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> use stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py -h option to see additional options like --clean Running Emulator You can add --FlashRom to the end of your build command and the emulator will run after the build is complete. or use the --FlashOnly feature to just run the emulator. stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --FlashOnly Alternative Options All the commands specified here can use a shortcut, which is to invoke the Build file directly. For example: py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --FlashOnly Setup and update can be done by passing it in py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --setup py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG = <TOOL_CHAIN_TAG> --update Under the hood, it just does the invocation of Stuart for you.","title":"Building with Pytools"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#notes","text":"QEMU must be on your path. On Windows this is a manual process and not part of the QEMU installer. QEMU output will be in Build/BUILDLOG_QemuQ35Pkg.txt as well as Build/QemuQ35Pkg/QEMULOG_QemuQ35Pkg.txt NOTE: Logging the execution output will be in the normal stuart log as well as to your console (if you have the correct logging level set, by default it doesn't output to console).","title":"Notes"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#custom-build-options","text":"SHUTDOWN_AFTER_RUN=TRUE will output a startup.nsh file to the location mapped as fs0 with reset -s as the final line. This is used in CI in combination with the --FlashOnly feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh . QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this. GDB_SERVER=\\<TCP Port> Enables the GDB port in the QEMU instance at the provided TCP port. SERIAL_PORT=\\<Serial Port> Enables the specified serial port to be used as console.","title":"Custom Build Options"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#passing-build-defines","text":"To pass build defines through stuart_build , prepend BLD_*_ to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add a =1 suffix for bare defines. For example, to enable the E1000 network support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be: stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py BLD_*_E1000_ENABLE=1","title":"Passing Build Defines"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#references","text":"Installing and using Pytools More on python virtual environments","title":"References"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/","text":"Debugging QEMU \u00b6 QEMU has the ability to expose a GDB port for debugging. This can be leveraged several ways. To start enable the GDB server, add the following parameter when launched QEMU through the QEMU runner. GDB_SERVER=<port number> Example ports can be: 1234, 5000, 5001, etc. Windbg Integration \u00b6 Windbg supports source debugging QEMU through an EXDI interface with the GDB port. Details can be found on the github readme . This supplies a EXDI server binary, a configuration file, and a script to start Windbg bound to the EXDI interface. Once Windbg is connected, following the instruction in the readme, the symbols and source can be loaded by scanning memory for images using the image scan command. For example: kd> r rip rip=000000007d1fc64b kd> .imgscan /l /r 0x07d000000 0x07e000000 This will scan for image headers between the specified addresses and load their symbols. More information on this command can be found in the Windbg help window. Debugging Windows on QEMU \u00b6 Boot to OS \u00b6 In order to kernel debug the OS, once need to boot to OS first. Download original OS image in the format of VHDX or QCOW2. If the image has never been booted before, one can boot this image using Hyper-V once to get through the OOBE process, if any. Related reads: Enable Hyper-V on Windows 10 Create a Virtual Machine with Hyper-V Although QEMU supports both VHDX and QCOW2 images. For the sake of fail proof, it is recommended to use QCOW2 format image, which can be converted from VHDX image with: qemu-img convert -f vhdx -p -c -O qcow2 foo.vhdx foo.qcow2 With the above QCOW2 image, set up the PATH_TO_OS parameter when launching QemuRunner.py: PATH_TO_OS=<absolute path to your OS image> SERIAL_PORT=<port number> More details on the <port number> in the corresponding section Debug Windows with WinDbg on QEMU \u00b6 Unlike EXDI debugger introduced above, this method will enlighten the target OS and debug the Windows more \"traditionally\", where Windows can communicate to the attached debugger with proper transports. Configurations on Target QEMU \u00b6 After booting to the desktop or command prompt of target Windows by following above steps , issue below commands: bcdedit /dbgsettings serial debugport:1 baudrate:115200 bcdedit /set {default} debug on # One can potentially enable boot debugger as well bcdedit /set {default} bootdebug on Configurations on Host that runs QEMU \u00b6 Once the QEMU boots to the point where the target is accepting debugger commands, launch the WinDbg using: windbg.exe -k com:ipport=<port number>,port=127.0.0.1 -v where the <port number> is the number you set when launching QEMU Serial Console for UEFI \u00b6 Launch terminal application such as Putty or Tera Term to connect to <port number> you set when launching QEMU at 127.0.0.1 through raw TCP/IP protocol. Note: One needs to release this console in order for the KD to attach. Some terminal software would enable \"local line editing\" for raw connection, this needs to be turned off to prevent garbage keystrokes.","title":"debugging"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#debugging-qemu","text":"QEMU has the ability to expose a GDB port for debugging. This can be leveraged several ways. To start enable the GDB server, add the following parameter when launched QEMU through the QEMU runner. GDB_SERVER=<port number> Example ports can be: 1234, 5000, 5001, etc.","title":"Debugging QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#windbg-integration","text":"Windbg supports source debugging QEMU through an EXDI interface with the GDB port. Details can be found on the github readme . This supplies a EXDI server binary, a configuration file, and a script to start Windbg bound to the EXDI interface. Once Windbg is connected, following the instruction in the readme, the symbols and source can be loaded by scanning memory for images using the image scan command. For example: kd> r rip rip=000000007d1fc64b kd> .imgscan /l /r 0x07d000000 0x07e000000 This will scan for image headers between the specified addresses and load their symbols. More information on this command can be found in the Windbg help window.","title":"Windbg Integration"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#debugging-windows-on-qemu","text":"","title":"Debugging Windows on QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#boot-to-os","text":"In order to kernel debug the OS, once need to boot to OS first. Download original OS image in the format of VHDX or QCOW2. If the image has never been booted before, one can boot this image using Hyper-V once to get through the OOBE process, if any. Related reads: Enable Hyper-V on Windows 10 Create a Virtual Machine with Hyper-V Although QEMU supports both VHDX and QCOW2 images. For the sake of fail proof, it is recommended to use QCOW2 format image, which can be converted from VHDX image with: qemu-img convert -f vhdx -p -c -O qcow2 foo.vhdx foo.qcow2 With the above QCOW2 image, set up the PATH_TO_OS parameter when launching QemuRunner.py: PATH_TO_OS=<absolute path to your OS image> SERIAL_PORT=<port number> More details on the <port number> in the corresponding section","title":"Boot to OS"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#debug-windows-with-windbg-on-qemu","text":"Unlike EXDI debugger introduced above, this method will enlighten the target OS and debug the Windows more \"traditionally\", where Windows can communicate to the attached debugger with proper transports.","title":"Debug Windows with WinDbg on QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#configurations-on-target-qemu","text":"After booting to the desktop or command prompt of target Windows by following above steps , issue below commands: bcdedit /dbgsettings serial debugport:1 baudrate:115200 bcdedit /set {default} debug on # One can potentially enable boot debugger as well bcdedit /set {default} bootdebug on","title":"Configurations on Target QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#configurations-on-host-that-runs-qemu","text":"Once the QEMU boots to the point where the target is accepting debugger commands, launch the WinDbg using: windbg.exe -k com:ipport=<port number>,port=127.0.0.1 -v where the <port number> is the number you set when launching QEMU","title":"Configurations on Host that runs QEMU"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#serial-console-for-uefi","text":"Launch terminal application such as Putty or Tera Term to connect to <port number> you set when launching QEMU at 127.0.0.1 through raw TCP/IP protocol. Note: One needs to release this console in order for the KD to attach. Some terminal software would enable \"local line editing\" for raw connection, this needs to be turned off to prevent garbage keystrokes.","title":"Serial Console for UEFI"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_dfci/","text":"Device Firmware Configuration Interface (DFCI) \u00b6 Todo","title":"feature dfci"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_dfci/#device-firmware-configuration-interface-dfci","text":"Todo","title":"Device Firmware Configuration Interface (DFCI)"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_frontpage/","text":"Front Page \u00b6 Todo","title":"feature frontpage"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_frontpage/#front-page","text":"Todo","title":"Front Page"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/","text":"Platform Runtime Mechanism (PRM) \u00b6 Overview \u00b6 Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. Generally, SMM code that does not depend upon SMM execution privileges is a candidate for conversion to PRM. The PRM conversion process involves porting code from SMM modules into code modules that execute at CPL0 and are directly invoked by host OS kernel components. These code modules are called PRM Modules . Functions within a PRM Module exposed to the OS for runtime execution are called PRM Handlers . End-to-end PRM support on a system requires firmware and OS support. The firmware must provide an initial set of PRM modules for the OS to use along with an ACPI tabled called PRMT that describes those modules. The OS uses this information to invoke PRM functionality when requested by a kernel component. PRM has two high-level invocation paths either directly from an OS driver (direct call) or by interacting with an ACPI OpRegion (ACPI call). PRM Goal in QemuQ35Pkg \u00b6 The goals of the PRM feature within QemuQ35Pkg are: To serve as an open source example of how to integrate PRM into a platform firmware. To serve as a test vehicle for generic PRM infrastructure and new PRM handlers testable in a virtual system. To provide an easily accessible virtual environment in open source that lends to PRM feature experimentation. For more information about the PRM feature and to access the platform agnostic PRM code/documentation visit edk2-staging/PlatformRuntimeMechanism . PRM Platform Agnostic Feature Code \u00b6 The official edk2 support for PRM is being developed in edk2-staging/PlatformRuntimeMechanism . All of the content in that branch is agnostic to any particular platform and should be considered the single source for PRM firmware infrastructure in an edk2 based firmware. PRM Modules Overview \u00b6 PRM is adopted in a particular platform by including platform-agnostic components from PrmPkg and then supplementing that with the PRM Modules that perform some platform-specific work. The following are key platform agnostic modules. PrmLoaderDxe - Discovers PRM Modules loaded into memory by the platform (e.g. an FV with PRM Modules is installed) and places those modules and the PRM Handlers within those modules into the PRMT ACPI table so the PRM configuration for the platform is described to the operating system. PrmConfigDxe - Configures PRM Module settings during the boot services environment. Some modules need special configuration and others do not. For example, if a module needs MMIO ranges to be converted it would describe those MMIO ranges during boot services so they are converted in the virtual memory address change event. Another example would be a module that allocates a static data buffer and then populates it with some data like that from a Setup menu item or a RAW section in a FV so it's accessible to a PRM Handler later. Often each PRM Module links a configuration library against this module to perform the configuration work needed for the module. The PRM Module could also choose to create a dedicated DXE configuration driver if that's preferred. For example, here's the configuration libraries currently linked against PrmConfigDxe in QemuQ35Pkg : PrmPkg/PrmConfigDxe/PrmConfigDxe.inf { <LibraryClasses> NULL|PrmPkg/Samples/PrmSampleAcpiParameterBufferModule/Library/DxeAcpiParameterBufferModuleConfigLib/DxeAcpiParameterBufferModuleConfigLib.inf NULL|PrmPkg/Samples/PrmSampleContextBufferModule/Library/DxeContextBufferModuleConfigLib/DxeContextBufferModuleConfigLib.inf NULL|PrmPkg/Samples/PrmSampleHardwareAccessModule/Library/DxeHardwareAccessModuleConfigLib/DxeHardwareAccessModuleConfigLib.inf } PrmSsdtInstallDxe - Installs the PRM SSDT. The SSDT in PrmPkg is a reference SSDT and a platform owner should inspect the SSDT to determine whether any changes are required. If the platform will not trigger PRM Handlers from ACPI code at all (only use direct call), this driver can be excluded from the platform firmware. PrmInfo - An optional UEFI application that reports information about the PRM configuration currently loaded in the system. The application can be used to confirm PRM Modules are discovered correctly and to exercise PRM Handlers in a lightweight manner (some activities like updating parameter buffers cannot be performed). In order to incorporate some PRM Modules into the boot flow, the sample PRM Modules provided by PrmPkg are loaded by QemuQ35Pkg . PRM Libraries Overview \u00b6 Some aspects of the generic PRM Modules in PrmPkg are customizable with libraries. It is not expected a platform needs to provide custom libraries but it is possible if needed. Those libraries are briefly noted below. PrmContextBufferLib - Provides a general abstraction for PRM context buffer management. PrmModuleDiscoveryLib - Provides functionality to discover PRM modules loaded in the system boot. PrmPeCoffLib - Provides functionality to support additional PE/COFF functionality needed to use Platform Runtime Mechanism (PRM) modules.","title":"feature prm"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#platform-runtime-mechanism-prm","text":"","title":"Platform Runtime Mechanism (PRM)"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#overview","text":"Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. Generally, SMM code that does not depend upon SMM execution privileges is a candidate for conversion to PRM. The PRM conversion process involves porting code from SMM modules into code modules that execute at CPL0 and are directly invoked by host OS kernel components. These code modules are called PRM Modules . Functions within a PRM Module exposed to the OS for runtime execution are called PRM Handlers . End-to-end PRM support on a system requires firmware and OS support. The firmware must provide an initial set of PRM modules for the OS to use along with an ACPI tabled called PRMT that describes those modules. The OS uses this information to invoke PRM functionality when requested by a kernel component. PRM has two high-level invocation paths either directly from an OS driver (direct call) or by interacting with an ACPI OpRegion (ACPI call).","title":"Overview"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-goal-in-qemuq35pkg","text":"The goals of the PRM feature within QemuQ35Pkg are: To serve as an open source example of how to integrate PRM into a platform firmware. To serve as a test vehicle for generic PRM infrastructure and new PRM handlers testable in a virtual system. To provide an easily accessible virtual environment in open source that lends to PRM feature experimentation. For more information about the PRM feature and to access the platform agnostic PRM code/documentation visit edk2-staging/PlatformRuntimeMechanism .","title":"PRM Goal in QemuQ35Pkg"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-platform-agnostic-feature-code","text":"The official edk2 support for PRM is being developed in edk2-staging/PlatformRuntimeMechanism . All of the content in that branch is agnostic to any particular platform and should be considered the single source for PRM firmware infrastructure in an edk2 based firmware.","title":"PRM Platform Agnostic Feature Code"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-modules-overview","text":"PRM is adopted in a particular platform by including platform-agnostic components from PrmPkg and then supplementing that with the PRM Modules that perform some platform-specific work. The following are key platform agnostic modules. PrmLoaderDxe - Discovers PRM Modules loaded into memory by the platform (e.g. an FV with PRM Modules is installed) and places those modules and the PRM Handlers within those modules into the PRMT ACPI table so the PRM configuration for the platform is described to the operating system. PrmConfigDxe - Configures PRM Module settings during the boot services environment. Some modules need special configuration and others do not. For example, if a module needs MMIO ranges to be converted it would describe those MMIO ranges during boot services so they are converted in the virtual memory address change event. Another example would be a module that allocates a static data buffer and then populates it with some data like that from a Setup menu item or a RAW section in a FV so it's accessible to a PRM Handler later. Often each PRM Module links a configuration library against this module to perform the configuration work needed for the module. The PRM Module could also choose to create a dedicated DXE configuration driver if that's preferred. For example, here's the configuration libraries currently linked against PrmConfigDxe in QemuQ35Pkg : PrmPkg/PrmConfigDxe/PrmConfigDxe.inf { <LibraryClasses> NULL|PrmPkg/Samples/PrmSampleAcpiParameterBufferModule/Library/DxeAcpiParameterBufferModuleConfigLib/DxeAcpiParameterBufferModuleConfigLib.inf NULL|PrmPkg/Samples/PrmSampleContextBufferModule/Library/DxeContextBufferModuleConfigLib/DxeContextBufferModuleConfigLib.inf NULL|PrmPkg/Samples/PrmSampleHardwareAccessModule/Library/DxeHardwareAccessModuleConfigLib/DxeHardwareAccessModuleConfigLib.inf } PrmSsdtInstallDxe - Installs the PRM SSDT. The SSDT in PrmPkg is a reference SSDT and a platform owner should inspect the SSDT to determine whether any changes are required. If the platform will not trigger PRM Handlers from ACPI code at all (only use direct call), this driver can be excluded from the platform firmware. PrmInfo - An optional UEFI application that reports information about the PRM configuration currently loaded in the system. The application can be used to confirm PRM Modules are discovered correctly and to exercise PRM Handlers in a lightweight manner (some activities like updating parameter buffers cannot be performed). In order to incorporate some PRM Modules into the boot flow, the sample PRM Modules provided by PrmPkg are loaded by QemuQ35Pkg .","title":"PRM Modules Overview"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-libraries-overview","text":"Some aspects of the generic PRM Modules in PrmPkg are customizable with libraries. It is not expected a platform needs to provide custom libraries but it is possible if needed. Those libraries are briefly noted below. PrmContextBufferLib - Provides a general abstraction for PRM context buffer management. PrmModuleDiscoveryLib - Provides functionality to discover PRM modules loaded in the system boot. PrmPeCoffLib - Provides functionality to support additional PE/COFF functionality needed to use Platform Runtime Mechanism (PRM) modules.","title":"PRM Libraries Overview"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/","text":"QemuRunner_plug_in \u00b6 The QEMU runner plugin supports easy execution of the QEMU emulator running the locally compiled QemuQ35Pkg firmware. This runner also supports easy local and server execution of UEFI shell based tests. It can automatically collect compiled UEFI shell based unit tests, mount a VHD or map a folder as a drive, and then parse the results once QEMU has finished. Configuration \u00b6 The plugin has numerous configuration options to support the Q35 Platform. These can be set when calling stuart_build or platform_build by adding <name>=<value> to the command line. Example setting up unit test to run automatically stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py SHUTDOWN_AFTER_RUN = TRUE RUN_TESTS = TRUE QEMU_HEADLESS \u00b6 Boolean string value to indicate if QEMU should be configured to run headless/no graphics. By default graphics will be used but in some server/remote scenarios headless is required. TRUE : configure QEMU to run headless or with no graphics FALSE : configure QEMU for local graphics (default) TEST_REGEX \u00b6 Comma separated regular expressions to configure the plugin on how to identify a UEFI shell based unit test. If one is provided and the user is on a Windows OS, all tests found with the regular expressions will be added to the virtual drive Example: TEST_REGEX=MyTestOne.efi,*UefiShellApp.efi RUN_TESTS \u00b6 Boolean string value to indicate the plugin should write all shell-based unit tests located with TEST_REGEX to startup.nsh .This startup.nsh is a special file that executes when the UEFI shell loads. See UEFI shell specification for more details. Unless SHUTDOWN_AFTER_RUN=FALSE is also passed, QEMU will shutdown after executing to parse and display the XML based results. TRUE : find, execute, and evaluate UEFI shell unit tests FALSE : do not (default) SHUTDOWN_AFTER_RUN \u00b6 Boolean string value to indicate that QEMU should be shutdown once it has finished running. The system is finished running when it has booted to shell or all unit tests specified by TEST_REGEX and added to the startup.nsh script with RUN_TESTS=TRUE have finished execution. TRUE : The system will automaticaly shutdown after booting to shell or running all unit tests FALSE : The system will not automatically shutdown (default) EMPTY_DRIVE \u00b6 Boolean string value to control plugin creation of virtual drive folder and emptying the folder before copying contents. When running automated tests multiple times they may write some state to the virtual drive which may change their execution. Sometimes that is desired and this option allows the plugin to copy new files to the virtual drive but not delete files. TRUE : delete all drive contents before copying new content FALSE : don't delete all drive content before copying new content (default)","title":"feature qemurunner"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#qemurunner_plug_in","text":"The QEMU runner plugin supports easy execution of the QEMU emulator running the locally compiled QemuQ35Pkg firmware. This runner also supports easy local and server execution of UEFI shell based tests. It can automatically collect compiled UEFI shell based unit tests, mount a VHD or map a folder as a drive, and then parse the results once QEMU has finished.","title":"QemuRunner_plug_in"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#configuration","text":"The plugin has numerous configuration options to support the Q35 Platform. These can be set when calling stuart_build or platform_build by adding <name>=<value> to the command line. Example setting up unit test to run automatically stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py SHUTDOWN_AFTER_RUN = TRUE RUN_TESTS = TRUE","title":"Configuration"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#qemu_headless","text":"Boolean string value to indicate if QEMU should be configured to run headless/no graphics. By default graphics will be used but in some server/remote scenarios headless is required. TRUE : configure QEMU to run headless or with no graphics FALSE : configure QEMU for local graphics (default)","title":"QEMU_HEADLESS"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#test_regex","text":"Comma separated regular expressions to configure the plugin on how to identify a UEFI shell based unit test. If one is provided and the user is on a Windows OS, all tests found with the regular expressions will be added to the virtual drive Example: TEST_REGEX=MyTestOne.efi,*UefiShellApp.efi","title":"TEST_REGEX"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#run_tests","text":"Boolean string value to indicate the plugin should write all shell-based unit tests located with TEST_REGEX to startup.nsh .This startup.nsh is a special file that executes when the UEFI shell loads. See UEFI shell specification for more details. Unless SHUTDOWN_AFTER_RUN=FALSE is also passed, QEMU will shutdown after executing to parse and display the XML based results. TRUE : find, execute, and evaluate UEFI shell unit tests FALSE : do not (default)","title":"RUN_TESTS"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#shutdown_after_run","text":"Boolean string value to indicate that QEMU should be shutdown once it has finished running. The system is finished running when it has booted to shell or all unit tests specified by TEST_REGEX and added to the startup.nsh script with RUN_TESTS=TRUE have finished execution. TRUE : The system will automaticaly shutdown after booting to shell or running all unit tests FALSE : The system will not automatically shutdown (default)","title":"SHUTDOWN_AFTER_RUN"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#empty_drive","text":"Boolean string value to control plugin creation of virtual drive folder and emptying the folder before copying contents. When running automated tests multiple times they may write some state to the virtual drive which may change their execution. Sometimes that is desired and this option allows the plugin to copy new files to the virtual drive but not delete files. TRUE : delete all drive contents before copying new content FALSE : don't delete all drive content before copying new content (default)","title":"EMPTY_DRIVE"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_whea/","text":"Mu Telemetry / WHEA \u00b6 Todo","title":"feature whea"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_whea/#mu-telemetry-whea","text":"Todo","title":"Mu Telemetry / WHEA"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/","text":"MS QEMU Devices Library \u00b6 About \u00b6 This abstraction layer sets up devices paths for QEMU Q35 platform console input/output that can be used by Project Mu based BDS. QEMU (Cirrus Logic 5446) video controller is configured to preferred graphics output for current implementation. Copyright \u00b6 Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Ms Platform Devices Lib Qemu Q35"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/#ms-qemu-devices-library","text":"","title":"MS QEMU Devices Library"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/#about","text":"This abstraction layer sets up devices paths for QEMU Q35 platform console input/output that can be used by Project Mu based BDS. QEMU (Cirrus Logic 5446) video controller is configured to preferred graphics output for current implementation.","title":"About"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/","text":"QEMU Debug Library \u00b6 About \u00b6 This library is derived from DebugLib in OvmfPkg. It corrected several typos from the original library and added support for DEBUG_BUFFER function. Copyright \u00b6 Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Platform Debug Lib Io Port"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/#qemu-debug-library","text":"","title":"QEMU Debug Library"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/#about","text":"This library is derived from DebugLib in OvmfPkg. It corrected several typos from the original library and added support for DEBUG_BUFFER function.","title":"About"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/","text":"Platform Theme Library \u00b6 About \u00b6 This platform specific abstraction layer allows the platforms to set the font type and font size for various rendering components as appropriate. Copyright \u00b6 Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Platform Theme Lib"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/#platform-theme-library","text":"","title":"Platform Theme Library"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/#about","text":"This platform specific abstraction layer allows the platforms to set the font type and font size for various rendering components as appropriate.","title":"About"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/","text":"Qemu Video Dxe \u00b6 About \u00b6 This driver is derived from sample GOP driver QemuVideoDxe in OvmfPkg. It replaces the standard GOP interfaces GUID with MsGopOverrideProtocolGuid from Project Mu to allow further graphics control through Mu interfaces. It also removes support for BOCHS due to out of project scope. Copyright \u00b6 Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Qemu Video Dxe"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/#qemu-video-dxe","text":"","title":"Qemu Video Dxe"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/#about","text":"This driver is derived from sample GOP driver QemuVideoDxe in OvmfPkg. It replaces the standard GOP interfaces GUID with MsGopOverrideProtocolGuid from Project Mu to allow further graphics control through Mu interfaces. It also removes support for BOCHS due to out of project scope.","title":"About"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/#copyright","text":"Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/","text":"BranchReadme [Name of Branch] \u00b6 Describe the goal of your project. What are you trying to showcase? Branched from: {Release you forked from - ie 202005} Branched on: {Date you branched} Author: {Email} What's unique about this branch \u00b6 Fill in with more detail about the technical differences between this branch and the release branch you forked from. Roadmap \u00b6 Fill in your expected roadmap, what do you hope to accomplish? What still needs to be done? Expected lifetime of your branch \u00b6 The goal of feature branches in mu_tiano_platforms is to showcase a feature and allow for development of that feature. Branches shouldn't linger on unnecessarily. They exist as proofs of concept and should try to become ready to be merged into a release branch or be archived as a useful learning exercise.","title":"docs"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#branchreadme-name-of-branch","text":"Describe the goal of your project. What are you trying to showcase? Branched from: {Release you forked from - ie 202005} Branched on: {Date you branched} Author: {Email}","title":"BranchReadme [Name of Branch]"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#whats-unique-about-this-branch","text":"Fill in with more detail about the technical differences between this branch and the release branch you forked from.","title":"What's unique about this branch"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#roadmap","text":"Fill in your expected roadmap, what do you hope to accomplish? What still needs to be done?","title":"Roadmap"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#expected-lifetime-of-your-branch","text":"The goal of feature branches in mu_tiano_platforms is to showcase a feature and allow for development of that feature. Branches shouldn't linger on unnecessarily. They exist as proofs of concept and should try to become ready to be merged into a release branch or be archived as a useful learning exercise.","title":"Expected lifetime of your branch"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/","text":"Contributing to EDK2 \u00b6 Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"CONTRIBUTING"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#contributing-to-edk2","text":"Contributor documentation is maintained on the wiki: https://github.com/tianocore/tianocore.github.io/wiki/EDK-II-Development-Process","title":"Contributing to EDK2"},{"location":"dyn/mu_tiano_plus/RepoDetails/","text":"Project Mu Tiano Plus \u00b6 Git Details Repository Url: https://github.com/Microsoft/mu_tiano_plus.git Branch: release/202202 Commit: 02bffd7c314f49a9ffdcb7fac0f1571745b45f3d Commit Date: 2022-11-14 14:29:50 -0500 This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. The modules in this repo were taken with minimal modification from TianoCore. For full documentation, please see the Project Mu Docs site . More Info \u00b6 Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Issues \u00b6 Please open any issues in the Project Mu GitHub tracker. More Details Contributing Code or Docs \u00b6 Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements Builds \u00b6 Please follow the steps in the Project Mu docs to build for CI and local testing. More Details Copyright & License \u00b6 Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent Upstream License (TianoCore) \u00b6 Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Repo Details"},{"location":"dyn/mu_tiano_plus/RepoDetails/#project-mu-tiano-plus","text":"Git Details Repository Url: https://github.com/Microsoft/mu_tiano_plus.git Branch: release/202202 Commit: 02bffd7c314f49a9ffdcb7fac0f1571745b45f3d Commit Date: 2022-11-14 14:29:50 -0500 This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. The modules in this repo were taken with minimal modification from TianoCore. For full documentation, please see the Project Mu Docs site .","title":"Project Mu Tiano Plus"},{"location":"dyn/mu_tiano_plus/RepoDetails/#more-info","text":"Please see the Project Mu docs ( https://github.com/Microsoft/mu ) for more information. This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.","title":"More Info"},{"location":"dyn/mu_tiano_plus/RepoDetails/#issues","text":"Please open any issues in the Project Mu GitHub tracker. More Details","title":"Issues"},{"location":"dyn/mu_tiano_plus/RepoDetails/#contributing-code-or-docs","text":"Please follow the general Project Mu Pull Request process. More Details Code Requirements Doc Requirements","title":"Contributing Code or Docs"},{"location":"dyn/mu_tiano_plus/RepoDetails/#builds","text":"Please follow the steps in the Project Mu docs to build for CI and local testing. More Details","title":"Builds"},{"location":"dyn/mu_tiano_plus/RepoDetails/#copyright-license","text":"Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright &amp; License"},{"location":"dyn/mu_tiano_plus/RepoDetails/#upstream-license-tianocore","text":"Copyright \u00a9 2019, TianoCore and contributors. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by: (a) their Contribution(s) (the licensed copyrights of copyright holders and non-copyrightable additions of contributors, in source or binary form) alone; or (b) combination of their Contribution(s) with the work of authorship to which such Contribution(s) was added by such copyright holder or contributor, if, at the time the Contribution is added, such addition causes such combination to be necessarily infringed. The patent license shall not apply to any other combinations which include the Contribution. Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise. DISCLAIMER THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Upstream License (TianoCore)"},{"location":"dyn/mu_tiano_plus/pull_request_template/","text":"Description \u00b6 < Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken? How This Was Tested \u00b6 < Please describe the test(s) that were run to verify the changes. > Integration Instructions \u00b6 < Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"pull request template"},{"location":"dyn/mu_tiano_plus/pull_request_template/#description","text":"< Please include a description of the change and why this change was made. > Breaking change? Will this change break pre-existing builds or functionality without action being taken?","title":"Description"},{"location":"dyn/mu_tiano_plus/pull_request_template/#how-this-was-tested","text":"< Please describe the test(s) that were run to verify the changes. >","title":"How This Was Tested"},{"location":"dyn/mu_tiano_plus/pull_request_template/#integration-instructions","text":"< Describe how these changes should be integrated. Use N/A if nothing is required. >","title":"Integration Instructions"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/","text":"Lauterbach T32 Scripts \u00b6 DXE Phase Debug \u00b6 Update the memsize variable in EfiLoadDxe.cmm for the actual amount of memory available in your system. Allow your system to boot to the point that the DXE core is initialized (so that the System Table and Debug Information table is present in memory) and execute this script (using the toolbar button or 'do EfiLoadDxe' from the command area). It will scan memory for the debug info table and load modules in it. SEC/PEI Phase Debug \u00b6 There is no way to autodetect where these images reside so you must pass an address for the memory-mapped Firmware Volume containing these images. To do this, enter 'do EfiLoadFv \\<addr>' where \\<addr> is the base address for the firmware volume containing the SEC or PEI code. To be more efficient you may want to create a script that calls this, like MyBoardLoadSec.cmm which contains the call to EfiLoadFv. You can them map this script to a T32 menu or toolbar button for quick access.","title":"Lauterbach T32"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/#lauterbach-t32-scripts","text":"","title":"Lauterbach T32 Scripts"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/#dxe-phase-debug","text":"Update the memsize variable in EfiLoadDxe.cmm for the actual amount of memory available in your system. Allow your system to boot to the point that the DXE core is initialized (so that the System Table and Debug Information table is present in memory) and execute this script (using the toolbar button or 'do EfiLoadDxe' from the command area). It will scan memory for the debug info table and load modules in it.","title":"DXE Phase Debug"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/#secpei-phase-debug","text":"There is no way to autodetect where these images reside so you must pass an address for the memory-mapped Firmware Volume containing these images. To do this, enter 'do EfiLoadFv \\<addr>' where \\<addr> is the base address for the firmware volume containing the SEC or PEI code. To be more efficient you may want to create a script that calls this, like MyBoardLoadSec.cmm which contains the call to EfiLoadFv. You can them map this script to a T32 menu or toolbar button for quick access.","title":"SEC/PEI Phase Debug"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/","text":"Capsule Update Policy DXE \u00b6 About \u00b6 This DXE driver produces the Capsule Update Policy Protocol ( EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL ). The policy functions wrap around the corresponding functions provided in the CapsuleUpdatePolicyLib linked against the driver. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Capsule Update Policy Dxe"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/#capsule-update-policy-dxe","text":"","title":"Capsule Update Policy DXE"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/#about","text":"This DXE driver produces the Capsule Update Policy Protocol ( EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL ). The policy functions wrap around the corresponding functions provided in the CapsuleUpdatePolicyLib linked against the driver.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/","text":"Firmware Management Protocol (FMP) Device Package \u00b6 FmpDevicePkg provides the common resources necessary to manage the firmware on a given device. The UEFI Specification defines several elements used in the firmware management process that are implemented or depended upon in FmpDevicePkg such as: EFI_FIRMWARE_MANAGEMENT_PROTOCOL Firmware Management Protocol dependency expression support FMP capsule format EFI System Resource Table (ESRT) Package Organization \u00b6 This section briefly describes the package modules and libraries. Modules \u00b6 CapsuleUpdatePolicyDxe readme Purpose: \\ Produces the Capsule Update Policy Protocol using the services of the Capsule Update Policy Library. FmpDxe readme Purpose: \\ Produces an instance of the Firmware Management Protocol ( EFI_FIRMWARE_MANAGEMENT_PROTOCOL ) that is used to support updates to a firmware image stored on a firmware device Libraries \u00b6 CapsuleUpdatePolicyLib Purpose: \\ Provides platform policy services used during a capsule update. CapsuleUpdatePolicyLibNull readme CapsuleUpdatePolicyLibOnProtocol readme FmpDependencyCheckLib Purpose: \\ Provides services to check that capsule dependencies are met during firmware update. FmpDependencyCheckLib readme FmpDependencyCheckLibNull readme FmpDependencyDeviceLib Purpose: \\ Provides firmware device specific services to support saving dependency expressions to a firmware device and getting dependency expressions from a firmware device. FmpDependencyDeviceLibNull readme FmpDependencyLib Purpose: \\ Provides functions used to manage dependencies between firmware components during the update of device firmware images. FmpDependencyLib readme FmpDeviceLib Purpose: \\ Provides firmware device specific services to support firmware updates on a given device. FmpDeviceLibNull readme FmpPayloadHeaderLib Purpose: \\ Provides services to retrieve values from a capsule FMP Payload Header. FmpPayloadHeaderLibV1 readme Further Reading \u00b6 Several documents describe important elements involved in understanding FmpDevicePkg . Consult the following resource for more information on a particular topic. FmpDevicePkg Overview The ReadMe documents referenced above that reside in the package. Tianocore wiki: FmpDevicePkg UEFI Specification Definitions for Firmware Updating and Reporting Section 23 of the UEFI Specification 2.8B Technical Overview of the EDK II Capsule Update and Recovery Flow A Tour Beyond BIOS - Capsule Update and Recovery in EDK II Windows UEFI Firmware Update Resources Windows UEFI Firmware Update Platform Validating Windows UEFI Firmware Update Platform Functionality NIST Guidelines for Authenticated Firmware Update SP800-147 SP800-147B SP800-193","title":"Package Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#firmware-management-protocol-fmp-device-package","text":"FmpDevicePkg provides the common resources necessary to manage the firmware on a given device. The UEFI Specification defines several elements used in the firmware management process that are implemented or depended upon in FmpDevicePkg such as: EFI_FIRMWARE_MANAGEMENT_PROTOCOL Firmware Management Protocol dependency expression support FMP capsule format EFI System Resource Table (ESRT)","title":"Firmware Management Protocol (FMP) Device Package"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#package-organization","text":"This section briefly describes the package modules and libraries.","title":"Package Organization"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#modules","text":"CapsuleUpdatePolicyDxe readme Purpose: \\ Produces the Capsule Update Policy Protocol using the services of the Capsule Update Policy Library. FmpDxe readme Purpose: \\ Produces an instance of the Firmware Management Protocol ( EFI_FIRMWARE_MANAGEMENT_PROTOCOL ) that is used to support updates to a firmware image stored on a firmware device","title":"Modules"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#libraries","text":"CapsuleUpdatePolicyLib Purpose: \\ Provides platform policy services used during a capsule update. CapsuleUpdatePolicyLibNull readme CapsuleUpdatePolicyLibOnProtocol readme FmpDependencyCheckLib Purpose: \\ Provides services to check that capsule dependencies are met during firmware update. FmpDependencyCheckLib readme FmpDependencyCheckLibNull readme FmpDependencyDeviceLib Purpose: \\ Provides firmware device specific services to support saving dependency expressions to a firmware device and getting dependency expressions from a firmware device. FmpDependencyDeviceLibNull readme FmpDependencyLib Purpose: \\ Provides functions used to manage dependencies between firmware components during the update of device firmware images. FmpDependencyLib readme FmpDeviceLib Purpose: \\ Provides firmware device specific services to support firmware updates on a given device. FmpDeviceLibNull readme FmpPayloadHeaderLib Purpose: \\ Provides services to retrieve values from a capsule FMP Payload Header. FmpPayloadHeaderLibV1 readme","title":"Libraries"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#further-reading","text":"Several documents describe important elements involved in understanding FmpDevicePkg . Consult the following resource for more information on a particular topic. FmpDevicePkg Overview The ReadMe documents referenced above that reside in the package. Tianocore wiki: FmpDevicePkg UEFI Specification Definitions for Firmware Updating and Reporting Section 23 of the UEFI Specification 2.8B Technical Overview of the EDK II Capsule Update and Recovery Flow A Tour Beyond BIOS - Capsule Update and Recovery in EDK II Windows UEFI Firmware Update Resources Windows UEFI Firmware Update Platform Validating Windows UEFI Firmware Update Platform Functionality NIST Guidelines for Authenticated Firmware Update SP800-147 SP800-147B SP800-193","title":"Further Reading"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/","text":"Firmware Management Protocol (FMP) DXE \u00b6 About \u00b6 This driver produces an instance of the Firmware Management Protocol ( EFI_FIRMWARE_MANAGEMENT_PROTOCOL ) that is used to support updates to a firmware image stored on a firmware device. Platform-specific information and customization is configured through libraries and PCDs. Getting Started \u00b6 This driver integrates several customization points that need to be considered during firmware update. This section provides brief background on key elements to consider when adapting this driver for a platform firmware. Capsule Authentication \u00b6 The firmware update capsule must be signed and this driver will verify the integrity of the capsule contents. The actual capsule data is preceded by an EFI_FIRMWARE_IMAGE_AUTHENTICATION structure. This structure contains a monotonic count and a WIN_CERTIFICATE_UEFI_GUID member that contains a signature that covers both the monotonic count and the capsule payload data. These two elements ensure replay protection across update operations and authentication. The certificate type used must be EFI_CERT_TYPE_PKCS7_GUID . An EDK II implementation of signature verification is available in the following FmpAuthenticationLib instance: SecurityPkg/Library/FmpAuthenticationLibPkcs7 . Capsule Versioning \u00b6 The capsule version should only be allowed to increment in value across updates to prevent rollback attacks. The EFI_FIRMWARE_IMAGE_DESCRIPTOR structure contains Version and LowestSupportedImageVersion fields that are used to check for compliance during firmware update. Version must be greater than or equal to LowestSupportedImageVersion in the current firmware and the greater than Version of the current firmware. An EDK II library implementation ( EdkiiSystemCapsuleLib ) that performs version checking is available at: SignedCapsulePkg/Library/EdkiiSystemCapsuleLib . Device-Specific Functionality During Update \u00b6 A capsule can target firmware update to a diverse set of devices on a system. Each device might bring unique logic and requirements to the firmware update process. Therefore, a library class called FmpDeviceLib exists that allows for instances written specific to a particular device. For more information about FmpDeviceLib , review: FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe.md Dependency Considerations \u00b6 The UEFI Specification 2.8 version introduced support for expressing dependencies between components involved in a capsule update. For instance, FWx requires FWy to be at least version 2.0 to install. This information is primarily conveyed to FmpDxe through the FmpDependencyCheckLib and FmpDependencyLib library classes. More information about the overall infrastructure is available in: Section 23.2 of the UEFI Specification 2.8B Tianocore wiki: Fmp Capsule Dependency Introduction More details regarding the libraries in FmpDevicePkg are available in the respective ReadMe files: [FmpDevicePkg/Library/FmpDependencyCheckLib] FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe.md [FmpDevicePkg/Library/FmpDependencyLib] FmpDevicePkg/Library/FmpDependencyLib/ReadMe.md Update Policy \u00b6 A library class ( CapsuleUpdatePolicyLib ) is used to make platform-specific policy decisions available to the firmware update process. This includes information such as whether the system power/thermal state permits firmware to be updated. A few functions also exist to modify expected behavior such as ignoring the LowestSupportedImageVersion check or not locking the firmware device for update when the FMP lock event is signaled. It is important to note that the latter functions should only be used in very rare special cases such as during manufacturing flows. Design Changes \u00b6 Date: 06/15/2020 Description/Rationale: Extending on the more granular LastAttemptStatus support added in FmpDeviceSetImage (), FmpDeviceCheckImage () also has a LastAttemptStatus parameter added. An image check is always performed by a set image operation. A more granular status code from the check image path greatly improves overall error isolation when applying an image. Changes: This change allows the FmpDeviceLib implementation to return a last attempt status code in the range LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MIN_ERROR_CODE to LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MAX_ERROR_CODE. Furthermore, an internal wrapper for CheckTheImage () in FmpDxe was added called CheckTheImageInternal (). This function can return a last attempt status code for an error in the driver prior to invoking FmpDeviceCheckImage (). These driver error codes will be in the range of LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE_MIN to LAST_ATTEMPT_STATUS_DRIVER_ERROR_MAX_ERROR_CODE. Impact/Mitigation: The change break the build for all FmpDeviceLib instances due to the API change. Each FmpDeviceLib should change to the new API definition and implement support to return unique values for LastAttemptStatus when appropriate. Date: 10/07/2019 Description/Rationale: Capsule update is the process where each OEM has a lot of interest. Especially when there is capsule update failure, it is helpful to gather more information of the failure. With existing implementations, the SetImage routine from FmpDxe driver, which performs most heavy lifting during capsule update, will only populate LastAttemptStatus with limited pre-defined error codes which could be consumed/inspected by the OS when it recovers and boots. Thus our proposal is to update the SetImage routine and leverage the LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range newly defined in UEFI Spec 2.8 Section 23.4, so that the error code will provide better granularity when viewing capsule update failure from OS device manager. Changes: A few error codes (128 total) are reserved from LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range for FmpDxe driver usage, which ranges from thermal and power API failure to capsule payload header check failure. Furthermore, an output pointer of the LastAttemptStatus is added as an input argument for FmpDeviceSetImage function in FmpDeviceLib to allow platform to provide their own platform specific error codes . (SPI write failure, SVN checking failure, and more). Impact/Mitigation: The italic text above will cause a breaking change for all the FmpDeviceLib instances due to API being modified. This is to provide better visibility to OEMs to decode capsule update failures more efficiently. Each FmpDeviceLib should change to the new API definition and populate proper LastAttemptStatus values when applicable. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Dxe"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#firmware-management-protocol-fmp-dxe","text":"","title":"Firmware Management Protocol (FMP) DXE"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#about","text":"This driver produces an instance of the Firmware Management Protocol ( EFI_FIRMWARE_MANAGEMENT_PROTOCOL ) that is used to support updates to a firmware image stored on a firmware device. Platform-specific information and customization is configured through libraries and PCDs.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#getting-started","text":"This driver integrates several customization points that need to be considered during firmware update. This section provides brief background on key elements to consider when adapting this driver for a platform firmware.","title":"Getting Started"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#capsule-authentication","text":"The firmware update capsule must be signed and this driver will verify the integrity of the capsule contents. The actual capsule data is preceded by an EFI_FIRMWARE_IMAGE_AUTHENTICATION structure. This structure contains a monotonic count and a WIN_CERTIFICATE_UEFI_GUID member that contains a signature that covers both the monotonic count and the capsule payload data. These two elements ensure replay protection across update operations and authentication. The certificate type used must be EFI_CERT_TYPE_PKCS7_GUID . An EDK II implementation of signature verification is available in the following FmpAuthenticationLib instance: SecurityPkg/Library/FmpAuthenticationLibPkcs7 .","title":"Capsule Authentication"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#capsule-versioning","text":"The capsule version should only be allowed to increment in value across updates to prevent rollback attacks. The EFI_FIRMWARE_IMAGE_DESCRIPTOR structure contains Version and LowestSupportedImageVersion fields that are used to check for compliance during firmware update. Version must be greater than or equal to LowestSupportedImageVersion in the current firmware and the greater than Version of the current firmware. An EDK II library implementation ( EdkiiSystemCapsuleLib ) that performs version checking is available at: SignedCapsulePkg/Library/EdkiiSystemCapsuleLib .","title":"Capsule Versioning"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#device-specific-functionality-during-update","text":"A capsule can target firmware update to a diverse set of devices on a system. Each device might bring unique logic and requirements to the firmware update process. Therefore, a library class called FmpDeviceLib exists that allows for instances written specific to a particular device. For more information about FmpDeviceLib , review: FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe.md","title":"Device-Specific Functionality During Update"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#dependency-considerations","text":"The UEFI Specification 2.8 version introduced support for expressing dependencies between components involved in a capsule update. For instance, FWx requires FWy to be at least version 2.0 to install. This information is primarily conveyed to FmpDxe through the FmpDependencyCheckLib and FmpDependencyLib library classes. More information about the overall infrastructure is available in: Section 23.2 of the UEFI Specification 2.8B Tianocore wiki: Fmp Capsule Dependency Introduction More details regarding the libraries in FmpDevicePkg are available in the respective ReadMe files: [FmpDevicePkg/Library/FmpDependencyCheckLib] FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe.md [FmpDevicePkg/Library/FmpDependencyLib] FmpDevicePkg/Library/FmpDependencyLib/ReadMe.md","title":"Dependency Considerations"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#update-policy","text":"A library class ( CapsuleUpdatePolicyLib ) is used to make platform-specific policy decisions available to the firmware update process. This includes information such as whether the system power/thermal state permits firmware to be updated. A few functions also exist to modify expected behavior such as ignoring the LowestSupportedImageVersion check or not locking the firmware device for update when the FMP lock event is signaled. It is important to note that the latter functions should only be used in very rare special cases such as during manufacturing flows.","title":"Update Policy"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#design-changes","text":"Date: 06/15/2020 Description/Rationale: Extending on the more granular LastAttemptStatus support added in FmpDeviceSetImage (), FmpDeviceCheckImage () also has a LastAttemptStatus parameter added. An image check is always performed by a set image operation. A more granular status code from the check image path greatly improves overall error isolation when applying an image. Changes: This change allows the FmpDeviceLib implementation to return a last attempt status code in the range LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MIN_ERROR_CODE to LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MAX_ERROR_CODE. Furthermore, an internal wrapper for CheckTheImage () in FmpDxe was added called CheckTheImageInternal (). This function can return a last attempt status code for an error in the driver prior to invoking FmpDeviceCheckImage (). These driver error codes will be in the range of LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE_MIN to LAST_ATTEMPT_STATUS_DRIVER_ERROR_MAX_ERROR_CODE. Impact/Mitigation: The change break the build for all FmpDeviceLib instances due to the API change. Each FmpDeviceLib should change to the new API definition and implement support to return unique values for LastAttemptStatus when appropriate. Date: 10/07/2019 Description/Rationale: Capsule update is the process where each OEM has a lot of interest. Especially when there is capsule update failure, it is helpful to gather more information of the failure. With existing implementations, the SetImage routine from FmpDxe driver, which performs most heavy lifting during capsule update, will only populate LastAttemptStatus with limited pre-defined error codes which could be consumed/inspected by the OS when it recovers and boots. Thus our proposal is to update the SetImage routine and leverage the LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range newly defined in UEFI Spec 2.8 Section 23.4, so that the error code will provide better granularity when viewing capsule update failure from OS device manager. Changes: A few error codes (128 total) are reserved from LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range for FmpDxe driver usage, which ranges from thermal and power API failure to capsule payload header check failure. Furthermore, an output pointer of the LastAttemptStatus is added as an input argument for FmpDeviceSetImage function in FmpDeviceLib to allow platform to provide their own platform specific error codes . (SPI write failure, SVN checking failure, and more). Impact/Mitigation: The italic text above will cause a breaking change for all the FmpDeviceLib instances due to API being modified. This is to provide better visibility to OEMs to decode capsule update failures more efficiently. Each FmpDeviceLib should change to the new API definition and populate proper LastAttemptStatus values when applicable.","title":"Design Changes"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/","text":"Capsule Update Policy NULL Library Instance \u00b6 About \u00b6 This is a NULL instance of the CapsuleUpdatePolicy library class. This instance is provided for building when an actual library instance is not needed or the values returned by this instance are sufficient for a platform. API Overview \u00b6 CheckSystemEnvironment () - Determines if the system environment state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . CheckSystemPower () - Determine if the system power state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . CheckSystemThermal () - Determines if the system thermal state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . IsLockFmpDeviceAtLockEventGuidRequired () - Determines if the Lowest Supported Version checks should be performed. The NULL implementation will always return TRUE . IsLowestSupportedVersionCheckRequired () - Determines if the FMP device should be locked when the event specified by PcdFmpDeviceLockEventGuid is signaled. The NULL implementation will always return TRUE . Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Capsule Update Policy Lib Null"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#capsule-update-policy-null-library-instance","text":"","title":"Capsule Update Policy NULL Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#about","text":"This is a NULL instance of the CapsuleUpdatePolicy library class. This instance is provided for building when an actual library instance is not needed or the values returned by this instance are sufficient for a platform.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#api-overview","text":"CheckSystemEnvironment () - Determines if the system environment state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . CheckSystemPower () - Determine if the system power state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . CheckSystemThermal () - Determines if the system thermal state supports a capsule update. The NULL implementation will always return EFI_SUCCESS . IsLockFmpDeviceAtLockEventGuidRequired () - Determines if the Lowest Supported Version checks should be performed. The NULL implementation will always return TRUE . IsLowestSupportedVersionCheckRequired () - Determines if the FMP device should be locked when the event specified by PcdFmpDeviceLockEventGuid is signaled. The NULL implementation will always return TRUE .","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/","text":"Capsule Update Policy On Protocol Library Instance \u00b6 About \u00b6 This library class instance of CapsuleUpdatePolicyLib implements the library API using the values returned from an installed instance of EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL . If the protocol is not found, the library will default to conservative responses. API Overview \u00b6 CheckSystemEnvironment () - Determines if the system environment state supports a capsule update. CheckSystemPower () - Determine if the system power state supports a capsule update. CheckSystemThermal () - Determines if the system thermal state supports a capsule update. IsLockFmpDeviceAtLockEventGuidRequired () - Determines if the Lowest Supported Version checks should be performed. IsLowestSupportedVersionCheckRequired () - Determines if the FMP device should be locked when the event specified by PcdFmpDeviceLockEventGuid is signaled. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Capsule Update Policy Lib On Protocol"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#capsule-update-policy-on-protocol-library-instance","text":"","title":"Capsule Update Policy On Protocol Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#about","text":"This library class instance of CapsuleUpdatePolicyLib implements the library API using the values returned from an installed instance of EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL . If the protocol is not found, the library will default to conservative responses.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#api-overview","text":"CheckSystemEnvironment () - Determines if the system environment state supports a capsule update. CheckSystemPower () - Determine if the system power state supports a capsule update. CheckSystemThermal () - Determines if the system thermal state supports a capsule update. IsLockFmpDeviceAtLockEventGuidRequired () - Determines if the Lowest Supported Version checks should be performed. IsLowestSupportedVersionCheckRequired () - Determines if the FMP device should be locked when the event specified by PcdFmpDeviceLockEventGuid is signaled.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/","text":"FMP Dependency Check Library Instance \u00b6 About \u00b6 This library provides services to check that capsule dependencies are met during firmware update. API Overview \u00b6 CheckFmpDependency () - Checks a given set of firmware image information such as the image type ID and version against a given dependency expression and returns whether the dependency expression is satisfied. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Dependency Check Lib"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#fmp-dependency-check-library-instance","text":"","title":"FMP Dependency Check Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#about","text":"This library provides services to check that capsule dependencies are met during firmware update.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#api-overview","text":"CheckFmpDependency () - Checks a given set of firmware image information such as the image type ID and version against a given dependency expression and returns whether the dependency expression is satisfied.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/","text":"FMP Dependency Check NULL Library Instance \u00b6 About \u00b6 This is a NULL instance of the FmpDependencyCheckLib library class. This instance is provided for building when an actual library instance is not needed. A version of the library that contains actual dependency checking implementation is also available in this package, see FmpDependencyCheckLib . API Overview \u00b6 CheckFmpDependency () - Checks a given set of firmware image information such as the image type ID and version against a given dependency expression and returns whether the dependency expression is satisfied. The NULL implementation will always return TRUE indicating the all dependencies are satisfied. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Dependency Check Lib Null"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#fmp-dependency-check-null-library-instance","text":"","title":"FMP Dependency Check NULL Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#about","text":"This is a NULL instance of the FmpDependencyCheckLib library class. This instance is provided for building when an actual library instance is not needed. A version of the library that contains actual dependency checking implementation is also available in this package, see FmpDependencyCheckLib .","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#api-overview","text":"CheckFmpDependency () - Checks a given set of firmware image information such as the image type ID and version against a given dependency expression and returns whether the dependency expression is satisfied. The NULL implementation will always return TRUE indicating the all dependencies are satisfied.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/","text":"FMP Dependency Device NULL Library Instance \u00b6 About \u00b6 This is a NULL instance of the FmpDependencyDeviceLib library class. This instance is provided for building when an actual library instance is not needed. API Overview \u00b6 GetFmpDependency () - Gets the dependency expression for the device represented by the library class instance. The NULL implementation always returns NULL a dependency expression was not retrieved. SaveFmpDependency () - Saves the dependency expression to the device represented by the library class instance. The NULL implementation always returns EFI_UNSUPPORTED indicating a dependency expression cannot be saved. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Dependency Device Lib Null"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#fmp-dependency-device-null-library-instance","text":"","title":"FMP Dependency Device NULL Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#about","text":"This is a NULL instance of the FmpDependencyDeviceLib library class. This instance is provided for building when an actual library instance is not needed.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#api-overview","text":"GetFmpDependency () - Gets the dependency expression for the device represented by the library class instance. The NULL implementation always returns NULL a dependency expression was not retrieved. SaveFmpDependency () - Saves the dependency expression to the device represented by the library class instance. The NULL implementation always returns EFI_UNSUPPORTED indicating a dependency expression cannot be saved.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/","text":"FMP Dependency Library Instance \u00b6 About \u00b6 This library provides functions used to manage dependencies between firmware components during the update of device firmware images. API Overview \u00b6 EvaluateDependency () - Evaluates a given dependency expression against a given set of FMP versions. GetImageDependency () - Gets the dependency expression from a given firmware image. ValidateDependency () - Validates a given dependency expression. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Dependency Lib"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#fmp-dependency-library-instance","text":"","title":"FMP Dependency Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#about","text":"This library provides functions used to manage dependencies between firmware components during the update of device firmware images.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#api-overview","text":"EvaluateDependency () - Evaluates a given dependency expression against a given set of FMP versions. GetImageDependency () - Gets the dependency expression from a given firmware image. ValidateDependency () - Validates a given dependency expression.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/","text":"FMP Device NULL Library Instance \u00b6 About \u00b6 This is a NULL instance of the FmpDeviceLib library class. This instance is provided for building when an actual library instance is not needed. Any device firmware that is actually updated using FmpDevicePkg should always implement a device-specific instance of FmpDeviceLib . API Overview \u00b6 This library provides an interface for component involved in controlling the firmware update process (such as FmpDxe ) to retrieve information specific to the device whose firmware is being updated. The current library API along with brief descriptions follow below. For more detailed information, check the individual function description comment that precedes each function in the library header file. FmpDeviceCheckImageWithStatus () - Checks if a given firmware image is valid for the device. The NULL implementation always returns EFI_SUCCESS . FmpDeviceGetAttributes () - Returns values used to indicate what firmware image attributes are supported and valid such as whether the image is updatable, a reset is required after update, authentication is required, and whether the image is a UEFI image. The NULL implementation always returns EFI_SUCCESS . FmpDeviceGetHardwareInstance () - Returns an instance of the firmware image currently stored on the device. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetImageTypeIdGuidPtr () - Returns a GUID that indicates the image type. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetLowestSupportedVersion () - Returns the lowest supported version from the currently stored firmware image for the device. The new firmware image version must be greater than or equal to this value. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetSize () - Returns the size, in bytes, of the firmware image currently stored on the device. The NULL implementation always returns EFI_SUCCESS unless Size is NULL in which case EFI_INVALID_PARAMETER is returned. FmpDeviceGetVersion () - Returns the Version of the firmware image currently stored on the device. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetVersionString () - Returns the Null-terminated Unicode string of the current firmware image version. The NULL implementation always returns EFI_UNSUPPORTED unless VersionString is NULL in which case EFI_INVALID_PARAMETER is returned. FmpDeviceLock () - Locks the firmware device, thereby preventing any future firmware updates (before a reset). The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceSetContext () - Sets the device context when the device is managed by a UEFI Driver Model driver. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceSetImageWithStatus () - Updates a firmware image with a new firmware image. The NULL implementation always returns EFI_UNSUPPORTED . Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Device Lib Null"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#fmp-device-null-library-instance","text":"","title":"FMP Device NULL Library Instance"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#about","text":"This is a NULL instance of the FmpDeviceLib library class. This instance is provided for building when an actual library instance is not needed. Any device firmware that is actually updated using FmpDevicePkg should always implement a device-specific instance of FmpDeviceLib .","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#api-overview","text":"This library provides an interface for component involved in controlling the firmware update process (such as FmpDxe ) to retrieve information specific to the device whose firmware is being updated. The current library API along with brief descriptions follow below. For more detailed information, check the individual function description comment that precedes each function in the library header file. FmpDeviceCheckImageWithStatus () - Checks if a given firmware image is valid for the device. The NULL implementation always returns EFI_SUCCESS . FmpDeviceGetAttributes () - Returns values used to indicate what firmware image attributes are supported and valid such as whether the image is updatable, a reset is required after update, authentication is required, and whether the image is a UEFI image. The NULL implementation always returns EFI_SUCCESS . FmpDeviceGetHardwareInstance () - Returns an instance of the firmware image currently stored on the device. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetImageTypeIdGuidPtr () - Returns a GUID that indicates the image type. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetLowestSupportedVersion () - Returns the lowest supported version from the currently stored firmware image for the device. The new firmware image version must be greater than or equal to this value. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetSize () - Returns the size, in bytes, of the firmware image currently stored on the device. The NULL implementation always returns EFI_SUCCESS unless Size is NULL in which case EFI_INVALID_PARAMETER is returned. FmpDeviceGetVersion () - Returns the Version of the firmware image currently stored on the device. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceGetVersionString () - Returns the Null-terminated Unicode string of the current firmware image version. The NULL implementation always returns EFI_UNSUPPORTED unless VersionString is NULL in which case EFI_INVALID_PARAMETER is returned. FmpDeviceLock () - Locks the firmware device, thereby preventing any future firmware updates (before a reset). The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceSetContext () - Sets the device context when the device is managed by a UEFI Driver Model driver. The NULL implementation always returns EFI_UNSUPPORTED . FmpDeviceSetImageWithStatus () - Updates a firmware image with a new firmware image. The NULL implementation always returns EFI_UNSUPPORTED .","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/","text":"FMP Payload Header Library \u00b6 About \u00b6 This library provides services to retrieve values from Version 1 of a capsule's FMP Payload Header. The FMP Payload Header structure is not defined in the library class. Instead, services are provided to retrieve information from the FMP Payload Header. If information is added to the FMP Payload Header, then new services may be added to this library class to retrieve the new information. API Overview \u00b6 GetFmpPayloadHeaderSize () - Returns the FMP Payload Header size in bytes. GetFmpPayloadHeaderVersion () - Returns the version described in the FMP Payload Header. GetFmpPayloadHeaderLowestSupportedVersion () - Returns the lowest supported version described in the FMP Payload Header. Copyright \u00b6 Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Fmp Payload Header Lib V1"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#fmp-payload-header-library","text":"","title":"FMP Payload Header Library"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#about","text":"This library provides services to retrieve values from Version 1 of a capsule's FMP Payload Header. The FMP Payload Header structure is not defined in the library class. Instead, services are provided to retrieve information from the FMP Payload Header. If information is added to the FMP Payload Header, then new services may be added to this library class to retrieve the new information.","title":"About"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#api-overview","text":"GetFmpPayloadHeaderSize () - Returns the FMP Payload Header size in bytes. GetFmpPayloadHeaderVersion () - Returns the version described in the FMP Payload Header. GetFmpPayloadHeaderLowestSupportedVersion () - Returns the lowest supported version described in the FMP Payload Header.","title":"API Overview"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#copyright","text":"Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent","title":"Copyright"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/","text":"Platform Runtime Mechanism \u00b6 Platform Runtime Mechanism (PRM) introduces the capability of moving platform-specific code out of SMM and into a code module that executes within the OS context. Moving this firmware to the OS context provides better transparency and mitigates the negative system impact currently accompanied with SMM solutions. Futhermore, the PRM code is packaged into modules with well-defined entry points, each representing a specific PRM functionality. For more details on PRM, refer to the Platform Runtime Mechanism Specification on uefi.org . The PrmPkg maintained in this branch provides a single cohesive set of generic PRM functionality that is intended to be leveraged by platform firmware with minimal overhead to integrate PRM functionality in the firmware. By default, the build makes use of a new ACPI OperationRegion type specifically introduced for PRM called PlatformRtMechanism . Support for this OperationRegion is planned for the next release of the ACPI specification. However, support for PlatformRtMechanism is already included in the iASL Compiler/Disassembler for early prototyping (i.e. this package). If you would like the default build to work and/or to use PRM handlers that are invoked through ACPI, iASL compiler 20200528 or greater must be used. If you are only interested in compiling the code and/or using direct call style PRM handlers, you can simply remove PrmSsdtInstallDxe from PrmPkg.dsc . The changes in the ACPI Specification include two elements: BIT20 in Platform-Wide _OSC Capabilities DWORD2 will be used by an OS to indicate support for PRM A new Operation Region Address Space Identifier Value is defined as 0xB for PlatformRtMechanism How to Build PrmPkg \u00b6 As noted earlier, resources in PrmPkg are intended to be referenced by a platform firmware so it can adopt support for PRM. In that case, the platform firmware should add the PrmConfigDxe and PrmLoaderDxe drivers to its DSC and FDF files so they are built in the platform firmware build and dispatched during its runtime. All that is left is to add individual PRM modules to the DSC and FDF. These can be built from source or included as binaries into the platform firmware flash map. PrmPkg Standalone Build \u00b6 To build PrmPkg as a standalone package: If new to EDK II, follow the directions in Getting Started with EDK II Clone the master branch on the edk2 repository locally \\ git clone https://github.com/tianocore/edk2.git Change to the edk2 workspace directory \\ cd edk2 Run edksetup to set local environment variables needed for build Windows: edksetup.bat Linux: If you have not already built BaseTools: make -C BaseTools . edksetup.sh Build PrmPkg \\ build -p PrmPkg/PrmPkg.dsc -a IA32 -a X64 Note : Due to the way PRM modules are compiled with exports, only building on Visual Studio compiler tool chains has been tested . Note : \\ This package has been used without modification in several environments including client, server, and virtual systems. You can add your own PRM modules into the build and check them with the PrmInfo UEFI application described later in this document and dump the PRMT table in the OS to check if your PRM module is represented as expected. PRM Platform GUID \u00b6 IMPORTANT PRM has a concept of a \"Platform GUID\" which associates a specific platform with a set of PRM modules built for that platform. This GUID is used to ensure system compatibility for a given collection of PRM modules. Therefore, each PRM module must only target a single platform and each platform must have a unique GUID. Even if a PRM module is unchanged between two different platforms now, there is no guarantee that will remain the case so always assign a unique Platform GUID for each platform. The PRM Platform GUID is primarily used during PRM module runtime updates in the OS to ensure that the Platform GUID in the system's ACPI table (PRMT) matches the Platform GUID of the module requested for update. Even if runtime updates are not a planned feature for a given platform, still assign a unique Platform GUID for binary module identification (the Platform GUID is in the module's export descriptor) and to ensure such updates can be seamlessly supported in the future if needed. In the PrmPkg implementation, the Platform GUID is automatically derived from the PLATFORM_GUID in the DSC file of the package being built. Build Output \u00b6 Like a typical EDK II package, the PrmPkg binary build output can be found in the Build directory in the edk2 workspace. The organization in that directory follows the same layout as other EDK II packages. For example, that path to PRM module sample binaries for a DEBUG VS2017 X64 build is: \\ edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples Overview \u00b6 At a high-level, PRM can be viewed from three levels of granularity: PRM interface - Encompassing the entirety of firmware functionalities and data provided to OS runtime. Most information is provided through ACPI tables to be agnostic to a UEFI implementation. PRM module - An independently updatable package of PRM handlers. The PRM interface will be composed of multiple PRM modules. This requirement allows for the separation of OEM and IHV PRM code, each of which can be serviced independently. PRM handler - The implementation/callback of a single PRM functionality as identified by a GUID. Firmware Design \u00b6 The firmware has three key generic drivers to support PRM: A PRM Loader driver - Functionality is split across three phases: Discover - Find all PRM modules in the firmware image made available by the platform firmware author. This phase includes verifying authenticity/integrity of the image, the image executable type, the export table is present and the PRM Export Module Descriptor is present and valid. Process - Convert PRM handler GUID to name mappings in the PRM Module Export Descriptor to PRM handler Name to physical address mappings required to construct the PRM ACPI table. Publish - Publish the PRM ACPI table using the information from the Process phase. A PRM Configuration driver - A generic driver responsible for processing PRM module configuration information consumed through a PRM_CONFIG_PROTOCOL per PRM module instance. Therefore, the PRM_CONFIG_PROTOCOL serves as the dynamic interface for this driver to process PRM module resources and prepare the module's data to be configured properly for OS runtime. A PRM Module - Not a single driver but a user written PE/COFF image that follows the PRM module authoring process. A PRM module groups together cohesive sets of PRM functionality into functions referred to as \"PRM handlers\". PrmPkg Code Organization \u00b6 The package follows a standard EDK II style package format. The list below contains some notable areas to explore in the package: ACPI Table Definitions Common Interface Definitions PRM Config Driver PRM Loader Driver Sample PRM Modules While the package does provide sample PRM modules to be used as a reference, actual PRM modules should not be maintained in PrmPkg. It is intended to only contain PRM infrastructure code and a few samples of how to use that infrastructure. The PrmPkg is meant to be used as-is by firmware that supports PRM. Any shortcomings that prevent the package from being used as-is should be addressed directly in PrmPkg. PRM Information UEFI Application \u00b6 A UEFI application is provided in this package called PrmInfo that allows a user to display and test PRM modules on their system. Link to application source code . This application is intended to be helpful during PRM enabling by allowing the user to: Confirm that their firmware port of the PRM infrastructure implemented in this package is functioning correctly. Quickly get information about what PRM modules and handlers that are present on a given system. Quickly test PRM handlers without booting into a full operating system. Develop and exercise PRM handlers prior to the availability of an operating system that is PRM aware. Execute the application help command for detailed usage instructions and examples of how to use the application: \\ PrmInfo -? Example Usage: PRM Module \u00b6 Note : You can find simple examples of PRM modules in the Samples directory of this package. Samples/Readme.md has more information. By default, the EDK II implementation of UEFI does not allow images with the subsystem type IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER to be built with exports. ERROR - Linker #1294 from LINK : fatal exports and import libraries are not supported with /SUBSYSTEM:EFI_RUNTIME_DRIVER This can adjusted in the MSVC linker options. The subsystem type is changed in the firmware build to allow the export table to be added but the subsystem type in the final image is still 0xC ( EFI Runtime Driver ). This is important to allow the DXE dispatcher to use its standard image verification and loading algorithms to load the image into permanent memory during the DXE execution phase. All firmware-loaded PRM modules are loaded into a memory buffer of type EfiRuntimeServicesCode . This means the operating system must preserve all PRM handler code and the buffer will be reflected in the UEFI memory map. The execution for invoking PRM handlers is the same as that required for UEFI Runtime Services, notably 4KiB or more of available stack space must be provided and the stack must be 16-byte aligned. Note: Long term it is possible to similarly load the modules into a EfiRuntimeServicesCode buffer and perform relocation fixups with a new EFI module type for PRM if desired. It was simply not done since it is not essential for this POC. Where possible, PRM module information is stored and generated using industry compiler tool chains. This is a key motivation behind using PE/COFF export tables to expose PRM module information and using a single PRM module binary definition consistent between firmware and OS load. PRM Module Exports \u00b6 A PRM module must contain at least two exports: A PRM Module Export Descriptor and at least one PRM handler. Here's an example of an export table from a PRM module that has a single PRM handler: 0000000000005000: 00 00 00 00 FF FF FF FF 00 00 00 00 3C 50 00 00 ............<P.. 0000000000005010: 01 00 00 00 02 00 00 00 02 00 00 00 28 50 00 00 ............(P.. 0000000000005020: 30 50 00 00 38 50 00 00 78 13 00 00 20 40 00 00 0P..8P..x... @.. 0000000000005030: 5D 50 00 00 7C 50 00 00 00 00 01 00 50 72 6D 53 ]P..|P......PrmS 0000000000005040: 61 6D 70 6C 65 43 6F 6E 74 65 78 74 42 75 66 66 ampleContextBuff 0000000000005050: 65 72 4D 6F 64 75 6C 65 2E 64 6C 6C 00 44 75 6D erModule.dll.Dum 0000000000005060: 70 53 74 61 74 69 63 44 61 74 61 42 75 66 66 65 pStaticDataBuffe 0000000000005070: 72 50 72 6D 48 61 6E 64 6C 65 72 00 50 72 6D 4D rPrmHandler.PrmM 0000000000005080: 6F 64 75 6C 65 45 78 70 6F 72 74 44 65 73 63 72 oduleExportDescr 0000000000005090: 69 70 74 6F 72 00 iptor. 00000000 characteristics FFFFFFFF time date stamp 0.00 version 1 ordinal base 2 number of functions 2 number of names ordinal hint RVA name 1 0 00001378 DumpStaticDataBufferPrmHandler 2 1 00004020 PrmModuleExportDescriptor PRM Image Format \u00b6 PRM modules are ultimately PE/COFF images. However, when packaged in firmware the PE/COFF image is placed into a Firmware File System (FFS) file. This is transparent to the operating system but done to better align with the typical packaging of PE32(+) images managed in the firmware binary image. In the dump of the PRM FV binary image shown earlier, the FFS sections placed by EDK II build tools (\"DXE dependency\", \"User interface\", \"Version\") that reside alongside the PE/COFF binary are shown. A PRM module can be placed into a firmware image as a pre-built PE/COFF binary or built during the firmware build process. In either case, the PE/COFF section is contained in a FFS file as shown in that image. PRM Module Implementation \u00b6 To simplify building the PRM Module Export Descriptor, a PRM module implementation can use the following macros to mark functions as PRM handlers. In this example, a PRM module registers three functions by name as PRM handlers with the associated GUIDs. // // Register the PRM export information for this PRM Module // PRM_MODULE_EXPORT ( PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_1_GUID , PrmHandler1 ), PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_2_GUID , PrmHandler2 ), PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_N_GUID , PrmHandlerN ) ); PRM_MODULE_EXPORT take a variable-length argument list of PRM_HANDLER_EXPORT_ENTRY entries that each describe an individual PRM handler being exported for the module. Ultimately, this information is used to define the structure necessary to statically allocate the PRM Module Export Descriptor Structure (and its PRM Handler Export Descriptor substructures) in the image. Another required export for PRM modules is automatically provided in PrmModule.h , a header file that pulls together all the includes needed to author a PRM module. This export is PRM_MODULE_UPDATE_LOCK_EXPORT . By including, PrmModule.h , a PRM module has the PRM_MODULE_UPDATE_LOCK_DESCRIPTOR automatically exported. PRM Handler Constraints \u00b6 At this time, PRM handlers are restricted to a maximum identifier length of 128 characters. This is checked when using the PRM_HANDLER_EXPORT macro by using a static assert that reports a violation at build-time. PRM handlers are not allowed to use UEFI Runtime Services and should not rely upon any UEFI constructs. For the purposes of this POC, this is currently not explicitly enforced but should be in the final changes.","title":"Readme"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#platform-runtime-mechanism","text":"Platform Runtime Mechanism (PRM) introduces the capability of moving platform-specific code out of SMM and into a code module that executes within the OS context. Moving this firmware to the OS context provides better transparency and mitigates the negative system impact currently accompanied with SMM solutions. Futhermore, the PRM code is packaged into modules with well-defined entry points, each representing a specific PRM functionality. For more details on PRM, refer to the Platform Runtime Mechanism Specification on uefi.org . The PrmPkg maintained in this branch provides a single cohesive set of generic PRM functionality that is intended to be leveraged by platform firmware with minimal overhead to integrate PRM functionality in the firmware. By default, the build makes use of a new ACPI OperationRegion type specifically introduced for PRM called PlatformRtMechanism . Support for this OperationRegion is planned for the next release of the ACPI specification. However, support for PlatformRtMechanism is already included in the iASL Compiler/Disassembler for early prototyping (i.e. this package). If you would like the default build to work and/or to use PRM handlers that are invoked through ACPI, iASL compiler 20200528 or greater must be used. If you are only interested in compiling the code and/or using direct call style PRM handlers, you can simply remove PrmSsdtInstallDxe from PrmPkg.dsc . The changes in the ACPI Specification include two elements: BIT20 in Platform-Wide _OSC Capabilities DWORD2 will be used by an OS to indicate support for PRM A new Operation Region Address Space Identifier Value is defined as 0xB for PlatformRtMechanism","title":"Platform Runtime Mechanism"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#how-to-build-prmpkg","text":"As noted earlier, resources in PrmPkg are intended to be referenced by a platform firmware so it can adopt support for PRM. In that case, the platform firmware should add the PrmConfigDxe and PrmLoaderDxe drivers to its DSC and FDF files so they are built in the platform firmware build and dispatched during its runtime. All that is left is to add individual PRM modules to the DSC and FDF. These can be built from source or included as binaries into the platform firmware flash map.","title":"How to Build PrmPkg"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prmpkg-standalone-build","text":"To build PrmPkg as a standalone package: If new to EDK II, follow the directions in Getting Started with EDK II Clone the master branch on the edk2 repository locally \\ git clone https://github.com/tianocore/edk2.git Change to the edk2 workspace directory \\ cd edk2 Run edksetup to set local environment variables needed for build Windows: edksetup.bat Linux: If you have not already built BaseTools: make -C BaseTools . edksetup.sh Build PrmPkg \\ build -p PrmPkg/PrmPkg.dsc -a IA32 -a X64 Note : Due to the way PRM modules are compiled with exports, only building on Visual Studio compiler tool chains has been tested . Note : \\ This package has been used without modification in several environments including client, server, and virtual systems. You can add your own PRM modules into the build and check them with the PrmInfo UEFI application described later in this document and dump the PRMT table in the OS to check if your PRM module is represented as expected.","title":"PrmPkg Standalone Build"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-platform-guid","text":"IMPORTANT PRM has a concept of a \"Platform GUID\" which associates a specific platform with a set of PRM modules built for that platform. This GUID is used to ensure system compatibility for a given collection of PRM modules. Therefore, each PRM module must only target a single platform and each platform must have a unique GUID. Even if a PRM module is unchanged between two different platforms now, there is no guarantee that will remain the case so always assign a unique Platform GUID for each platform. The PRM Platform GUID is primarily used during PRM module runtime updates in the OS to ensure that the Platform GUID in the system's ACPI table (PRMT) matches the Platform GUID of the module requested for update. Even if runtime updates are not a planned feature for a given platform, still assign a unique Platform GUID for binary module identification (the Platform GUID is in the module's export descriptor) and to ensure such updates can be seamlessly supported in the future if needed. In the PrmPkg implementation, the Platform GUID is automatically derived from the PLATFORM_GUID in the DSC file of the package being built.","title":"PRM Platform GUID"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#build-output","text":"Like a typical EDK II package, the PrmPkg binary build output can be found in the Build directory in the edk2 workspace. The organization in that directory follows the same layout as other EDK II packages. For example, that path to PRM module sample binaries for a DEBUG VS2017 X64 build is: \\ edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples","title":"Build Output"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#overview","text":"At a high-level, PRM can be viewed from three levels of granularity: PRM interface - Encompassing the entirety of firmware functionalities and data provided to OS runtime. Most information is provided through ACPI tables to be agnostic to a UEFI implementation. PRM module - An independently updatable package of PRM handlers. The PRM interface will be composed of multiple PRM modules. This requirement allows for the separation of OEM and IHV PRM code, each of which can be serviced independently. PRM handler - The implementation/callback of a single PRM functionality as identified by a GUID.","title":"Overview"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#firmware-design","text":"The firmware has three key generic drivers to support PRM: A PRM Loader driver - Functionality is split across three phases: Discover - Find all PRM modules in the firmware image made available by the platform firmware author. This phase includes verifying authenticity/integrity of the image, the image executable type, the export table is present and the PRM Export Module Descriptor is present and valid. Process - Convert PRM handler GUID to name mappings in the PRM Module Export Descriptor to PRM handler Name to physical address mappings required to construct the PRM ACPI table. Publish - Publish the PRM ACPI table using the information from the Process phase. A PRM Configuration driver - A generic driver responsible for processing PRM module configuration information consumed through a PRM_CONFIG_PROTOCOL per PRM module instance. Therefore, the PRM_CONFIG_PROTOCOL serves as the dynamic interface for this driver to process PRM module resources and prepare the module's data to be configured properly for OS runtime. A PRM Module - Not a single driver but a user written PE/COFF image that follows the PRM module authoring process. A PRM module groups together cohesive sets of PRM functionality into functions referred to as \"PRM handlers\".","title":"Firmware Design"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prmpkg-code-organization","text":"The package follows a standard EDK II style package format. The list below contains some notable areas to explore in the package: ACPI Table Definitions Common Interface Definitions PRM Config Driver PRM Loader Driver Sample PRM Modules While the package does provide sample PRM modules to be used as a reference, actual PRM modules should not be maintained in PrmPkg. It is intended to only contain PRM infrastructure code and a few samples of how to use that infrastructure. The PrmPkg is meant to be used as-is by firmware that supports PRM. Any shortcomings that prevent the package from being used as-is should be addressed directly in PrmPkg.","title":"PrmPkg Code Organization"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-information-uefi-application","text":"A UEFI application is provided in this package called PrmInfo that allows a user to display and test PRM modules on their system. Link to application source code . This application is intended to be helpful during PRM enabling by allowing the user to: Confirm that their firmware port of the PRM infrastructure implemented in this package is functioning correctly. Quickly get information about what PRM modules and handlers that are present on a given system. Quickly test PRM handlers without booting into a full operating system. Develop and exercise PRM handlers prior to the availability of an operating system that is PRM aware. Execute the application help command for detailed usage instructions and examples of how to use the application: \\ PrmInfo -? Example Usage:","title":"PRM Information UEFI Application"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module","text":"Note : You can find simple examples of PRM modules in the Samples directory of this package. Samples/Readme.md has more information. By default, the EDK II implementation of UEFI does not allow images with the subsystem type IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER to be built with exports. ERROR - Linker #1294 from LINK : fatal exports and import libraries are not supported with /SUBSYSTEM:EFI_RUNTIME_DRIVER This can adjusted in the MSVC linker options. The subsystem type is changed in the firmware build to allow the export table to be added but the subsystem type in the final image is still 0xC ( EFI Runtime Driver ). This is important to allow the DXE dispatcher to use its standard image verification and loading algorithms to load the image into permanent memory during the DXE execution phase. All firmware-loaded PRM modules are loaded into a memory buffer of type EfiRuntimeServicesCode . This means the operating system must preserve all PRM handler code and the buffer will be reflected in the UEFI memory map. The execution for invoking PRM handlers is the same as that required for UEFI Runtime Services, notably 4KiB or more of available stack space must be provided and the stack must be 16-byte aligned. Note: Long term it is possible to similarly load the modules into a EfiRuntimeServicesCode buffer and perform relocation fixups with a new EFI module type for PRM if desired. It was simply not done since it is not essential for this POC. Where possible, PRM module information is stored and generated using industry compiler tool chains. This is a key motivation behind using PE/COFF export tables to expose PRM module information and using a single PRM module binary definition consistent between firmware and OS load.","title":"PRM Module"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module-exports","text":"A PRM module must contain at least two exports: A PRM Module Export Descriptor and at least one PRM handler. Here's an example of an export table from a PRM module that has a single PRM handler: 0000000000005000: 00 00 00 00 FF FF FF FF 00 00 00 00 3C 50 00 00 ............<P.. 0000000000005010: 01 00 00 00 02 00 00 00 02 00 00 00 28 50 00 00 ............(P.. 0000000000005020: 30 50 00 00 38 50 00 00 78 13 00 00 20 40 00 00 0P..8P..x... @.. 0000000000005030: 5D 50 00 00 7C 50 00 00 00 00 01 00 50 72 6D 53 ]P..|P......PrmS 0000000000005040: 61 6D 70 6C 65 43 6F 6E 74 65 78 74 42 75 66 66 ampleContextBuff 0000000000005050: 65 72 4D 6F 64 75 6C 65 2E 64 6C 6C 00 44 75 6D erModule.dll.Dum 0000000000005060: 70 53 74 61 74 69 63 44 61 74 61 42 75 66 66 65 pStaticDataBuffe 0000000000005070: 72 50 72 6D 48 61 6E 64 6C 65 72 00 50 72 6D 4D rPrmHandler.PrmM 0000000000005080: 6F 64 75 6C 65 45 78 70 6F 72 74 44 65 73 63 72 oduleExportDescr 0000000000005090: 69 70 74 6F 72 00 iptor. 00000000 characteristics FFFFFFFF time date stamp 0.00 version 1 ordinal base 2 number of functions 2 number of names ordinal hint RVA name 1 0 00001378 DumpStaticDataBufferPrmHandler 2 1 00004020 PrmModuleExportDescriptor","title":"PRM Module Exports"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-image-format","text":"PRM modules are ultimately PE/COFF images. However, when packaged in firmware the PE/COFF image is placed into a Firmware File System (FFS) file. This is transparent to the operating system but done to better align with the typical packaging of PE32(+) images managed in the firmware binary image. In the dump of the PRM FV binary image shown earlier, the FFS sections placed by EDK II build tools (\"DXE dependency\", \"User interface\", \"Version\") that reside alongside the PE/COFF binary are shown. A PRM module can be placed into a firmware image as a pre-built PE/COFF binary or built during the firmware build process. In either case, the PE/COFF section is contained in a FFS file as shown in that image.","title":"PRM Image Format"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module-implementation","text":"To simplify building the PRM Module Export Descriptor, a PRM module implementation can use the following macros to mark functions as PRM handlers. In this example, a PRM module registers three functions by name as PRM handlers with the associated GUIDs. // // Register the PRM export information for this PRM Module // PRM_MODULE_EXPORT ( PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_1_GUID , PrmHandler1 ), PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_2_GUID , PrmHandler2 ), PRM_HANDLER_EXPORT_ENTRY ( PRM_HANDLER_N_GUID , PrmHandlerN ) ); PRM_MODULE_EXPORT take a variable-length argument list of PRM_HANDLER_EXPORT_ENTRY entries that each describe an individual PRM handler being exported for the module. Ultimately, this information is used to define the structure necessary to statically allocate the PRM Module Export Descriptor Structure (and its PRM Handler Export Descriptor substructures) in the image. Another required export for PRM modules is automatically provided in PrmModule.h , a header file that pulls together all the includes needed to author a PRM module. This export is PRM_MODULE_UPDATE_LOCK_EXPORT . By including, PrmModule.h , a PRM module has the PRM_MODULE_UPDATE_LOCK_DESCRIPTOR automatically exported.","title":"PRM Module Implementation"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-handler-constraints","text":"At this time, PRM handlers are restricted to a maximum identifier length of 128 characters. This is checked when using the PRM_HANDLER_EXPORT macro by using a static assert that reports a violation at build-time. PRM handlers are not allowed to use UEFI Runtime Services and should not rely upon any UEFI constructs. For the purposes of this POC, this is currently not explicitly enforced but should be in the final changes.","title":"PRM Handler Constraints"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/","text":"Platform Runtime Mechanism Sample Modules \u00b6 The PRM module samples provided here serve as focused examples of how to perform various tasks in a PRM module. The samples can also be used to verify the basic infrastructure needed in your firmware implementation is working as expected by checking that the sample modules are found properly and the handlers perform their tasks as noted. IMPORTANT NOTE \u00b6 The sample modules have currently only been tested on the Visual Studio compiler tool chain. Sample module build may fail on other tool chains. A future work item is to enable broader build support. How to Build PRM Sample Modules \u00b6 The sample modules are built as part of the normal PrmPkg build so you can follow the package build instructions and then find the PRM sample binaries in your workspace build output directory. For example, if your build workspace is called \"edk2\" and you build 64-bit binaries on the Visual Studio 2017 tool chain, your sample module binaries will be in the following location: \\ edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples Build an Individual PRM Sample Module \u00b6 Note that the build command does provide the option to build a specific module in a package which can result in faster build time. If you would like to just build a single PRM module that can be done by specifying the path to the module INF file with the \"-m\" argument to build . For example, this command builds 32-bit and 64-bit binaries with Visual Studio 2019: \\ build -p PrmPkg/PrmPkg.dsc -m PrmPkg/Samples/PrmSampleContextBufferModule/PrmSampleContextBufferModule.inf -a IA32 -a X64 -t VS2019 PRM Sample Module User's Guide \u00b6 The following table provides an overview of each sample module provided. By nature, different PRM handlers have different requirements. The information here is summarized for a user to understand how to use a given sample PRM handler along with GUID/name information to identify the sample PRM modules and their PRM handlers. It is recommended that all PRM authors write a similar set of documentation for their users to better understand and interact with their PRM modules. Module: PRM Sample ACPI Parameter Buffer \u00b6 Name: PrmSampleAcpiParameterBufferModule GUID: dc2a58a6-5927-4776-b995-d118a27335a2 Purpose: Provides an example of how to configure an ACPI parameter buffer Handlers: Handler: Check Parameter Buffer PRM Handler \u00b6 Name: CheckParamBufferPrmHandler GUID: 2e4f2d13-6240-4ed0-a401-c723fbdc34e8 Actions: Checks for the data signature \u2018T\u2019, \u2018E\u2019, \u2018S\u2019, \u2018T\u2019 (DWORD) at the beginning of the parameter buffer. Parameter Buffer Required: Yes Parameter Buffer Contents: A data signature of ['T', 'E', 'S', 'T'] (DWORD) at the beginning of the buffer. Context Buffer Required: No Runtime MMIO Range(s) Required: No Module: PRM Sample Context Buffer \u00b6 Name: PrmSampleContextBufferModule GUID: 5a6cf42b-8bb4-472c-a233-5c4dc4033dc7 Purpose: Provides an example of how to configure a static data buffer (which is pointed to in a context buffer) in firmware and consume the buffer contents at runtime Handlers: Handler: Check Static Data Buffer PRM Handler \u00b6 Name: CheckStaticDataBufferPrmHandler GUID: e1466081-7562-430f-896b-b0e523dc335a Actions: Checks that the context buffer signature and static data buffer signature match in the context buffer provided. Parameter Buffer Required: No Context Buffer Required: Yes Static Data Buffer Contents: #define SOME_VALUE_ARRAY_MAX_VALUES 16 typedef struct { BOOLEAN Policy1Enabled ; BOOLEAN Policy2Enabled ; UINT8 SomeValueArray [ SOME_VALUE_ARRAY_MAX_VALUES ]; } STATIC_DATA_SAMPLE_CONTEXT_BUFFER_MODULE ; Runtime MMIO Range(s) Required: No Module: PRM Sample Hardware Access Buffer \u00b6 Name: PrmSampleHardwareAccessModule GUID: 0ef93ed7-14ae-425b-928f-b85a6213b57e Purpose: Demonstrate access of several types of hardware resources from a PRM module Handlers: Handler: MSR Access Microcode Signature PRM Handler \u00b6 Name: MsrAccessMicrocodeSignaturePrmHandler GUID: 2120cd3c-848b-4d8f-abbb-4b74ce64ac89 Actions: Access the loaded microcode signature at MSR 0x8B. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: No Handler: MSR Access MTRR Dump PRM Handler \u00b6 Name: MsrAccessMtrrDumpPrmHandler GUID: ea0935a7-506b-4159-bbbb-48deeecb6f58 Actions: Access the fixed and variable MTRR values using MSRs. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: No Handler: HPET MMIO Access PRM Handler \u00b6 Name: MmioAccessHpetPrmHandler GUID: 1bd1bda9-909a-4614-9699-25ec0c2783f7 Actions: Access some HPET registers using MMIO at 0xFED00000. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: Yes Physical Base Address: 0xFED00000 Length: 0x1000","title":"Samples"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#platform-runtime-mechanism-sample-modules","text":"The PRM module samples provided here serve as focused examples of how to perform various tasks in a PRM module. The samples can also be used to verify the basic infrastructure needed in your firmware implementation is working as expected by checking that the sample modules are found properly and the handlers perform their tasks as noted.","title":"Platform Runtime Mechanism Sample Modules"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#important-note","text":"The sample modules have currently only been tested on the Visual Studio compiler tool chain. Sample module build may fail on other tool chains. A future work item is to enable broader build support.","title":"IMPORTANT NOTE"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#how-to-build-prm-sample-modules","text":"The sample modules are built as part of the normal PrmPkg build so you can follow the package build instructions and then find the PRM sample binaries in your workspace build output directory. For example, if your build workspace is called \"edk2\" and you build 64-bit binaries on the Visual Studio 2017 tool chain, your sample module binaries will be in the following location: \\ edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples","title":"How to Build PRM Sample Modules"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#build-an-individual-prm-sample-module","text":"Note that the build command does provide the option to build a specific module in a package which can result in faster build time. If you would like to just build a single PRM module that can be done by specifying the path to the module INF file with the \"-m\" argument to build . For example, this command builds 32-bit and 64-bit binaries with Visual Studio 2019: \\ build -p PrmPkg/PrmPkg.dsc -m PrmPkg/Samples/PrmSampleContextBufferModule/PrmSampleContextBufferModule.inf -a IA32 -a X64 -t VS2019","title":"Build an Individual PRM Sample Module"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#prm-sample-module-users-guide","text":"The following table provides an overview of each sample module provided. By nature, different PRM handlers have different requirements. The information here is summarized for a user to understand how to use a given sample PRM handler along with GUID/name information to identify the sample PRM modules and their PRM handlers. It is recommended that all PRM authors write a similar set of documentation for their users to better understand and interact with their PRM modules.","title":"PRM Sample Module User's Guide"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-acpi-parameter-buffer","text":"Name: PrmSampleAcpiParameterBufferModule GUID: dc2a58a6-5927-4776-b995-d118a27335a2 Purpose: Provides an example of how to configure an ACPI parameter buffer Handlers:","title":"Module: PRM Sample ACPI Parameter Buffer"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-check-parameter-buffer-prm-handler","text":"Name: CheckParamBufferPrmHandler GUID: 2e4f2d13-6240-4ed0-a401-c723fbdc34e8 Actions: Checks for the data signature \u2018T\u2019, \u2018E\u2019, \u2018S\u2019, \u2018T\u2019 (DWORD) at the beginning of the parameter buffer. Parameter Buffer Required: Yes Parameter Buffer Contents: A data signature of ['T', 'E', 'S', 'T'] (DWORD) at the beginning of the buffer. Context Buffer Required: No Runtime MMIO Range(s) Required: No","title":"Handler: Check Parameter Buffer PRM Handler"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-context-buffer","text":"Name: PrmSampleContextBufferModule GUID: 5a6cf42b-8bb4-472c-a233-5c4dc4033dc7 Purpose: Provides an example of how to configure a static data buffer (which is pointed to in a context buffer) in firmware and consume the buffer contents at runtime Handlers:","title":"Module: PRM Sample Context Buffer"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-check-static-data-buffer-prm-handler","text":"Name: CheckStaticDataBufferPrmHandler GUID: e1466081-7562-430f-896b-b0e523dc335a Actions: Checks that the context buffer signature and static data buffer signature match in the context buffer provided. Parameter Buffer Required: No Context Buffer Required: Yes Static Data Buffer Contents: #define SOME_VALUE_ARRAY_MAX_VALUES 16 typedef struct { BOOLEAN Policy1Enabled ; BOOLEAN Policy2Enabled ; UINT8 SomeValueArray [ SOME_VALUE_ARRAY_MAX_VALUES ]; } STATIC_DATA_SAMPLE_CONTEXT_BUFFER_MODULE ; Runtime MMIO Range(s) Required: No","title":"Handler: Check Static Data Buffer PRM Handler"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-hardware-access-buffer","text":"Name: PrmSampleHardwareAccessModule GUID: 0ef93ed7-14ae-425b-928f-b85a6213b57e Purpose: Demonstrate access of several types of hardware resources from a PRM module Handlers:","title":"Module: PRM Sample Hardware Access Buffer"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-msr-access-microcode-signature-prm-handler","text":"Name: MsrAccessMicrocodeSignaturePrmHandler GUID: 2120cd3c-848b-4d8f-abbb-4b74ce64ac89 Actions: Access the loaded microcode signature at MSR 0x8B. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: No","title":"Handler: MSR Access Microcode Signature PRM Handler"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-msr-access-mtrr-dump-prm-handler","text":"Name: MsrAccessMtrrDumpPrmHandler GUID: ea0935a7-506b-4159-bbbb-48deeecb6f58 Actions: Access the fixed and variable MTRR values using MSRs. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: No","title":"Handler: MSR Access MTRR Dump PRM Handler"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-hpet-mmio-access-prm-handler","text":"Name: MmioAccessHpetPrmHandler GUID: 1bd1bda9-909a-4614-9699-25ec0c2783f7 Actions: Access some HPET registers using MMIO at 0xFED00000. Parameter Buffer Required: No Context Buffer Required: No Runtime MMIO Range(s) Required: Yes Physical Base Address: 0xFED00000 Length: 0x1000","title":"Handler: HPET MMIO Access PRM Handler"}]}