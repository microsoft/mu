{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Project Mu","text":"<p>Project Mu is a modular adaptation of TianoCore's edk2 tuned for building modern devices using a scalable, maintainable, and reusable pattern.  Mu is built around the idea that shipping and maintaining a UEFI product is an ongoing collaboration between numerous partners.  For too long, the industry has built products using a \"forking\" model combined with copy/paste/rename and with each new product, the maintenance burden grows to such a level that updates are near impossible due to cost and risk.</p> <p>Project Mu also tries to address the complex business relationships and legal challenges facing partners today.  To build most products,  it often requires both closed-source, proprietary assets as well as open-source and industry-standard code.  The distributed build system and multi-repository design allow product teams to keep code separate and connected to their original source while respecting legal and business boundaries.</p> <p>Project Mu originated from building modern Windows PCs but its patterns and design allow it to be scaled down or up for whatever the final product's intent.  IoT, Server, PC, or any other form factor should be able to leverage the content.</p>"},{"location":"#primary-goals","title":"Primary Goals","text":"<p>Initially, this project will focus on two central goals.</p>"},{"location":"#share","title":"Share","text":"<p>We will share our active code tree to both solicit feedback and entice partners to collaborate.</p> <p>Project Mu is an active project.  This is not a side project, mirror, clone, or example.  This is the same code used today on many of Microsoft's 1st party devices and it will be kept current because it must be to continue to enable shipping products.</p>"},{"location":"#support-an-industry-shift-to-a-more-collaborative-environment-to-lower-costs-and-raise-quality","title":"Support an industry shift to a more collaborative environment to lower costs and raise quality","text":"<p>We will use this project to promote, evangelize, and support an industry shift to a more collaborative environment so that the entire ecosystem can develop and maintain products with lower costs and higher quality.</p> <p>Today's open source projects, although extremely valuable, are very resource-intensive to interact with.  This friction leads to major industry players avoiding public interaction, thus diminishing the overall community\u2019s value.  The modern era of open source projects has incorporated new tools and procedures to lower this friction and it is our goal to leverage those tools.  GitHub provides issue tracking, Pull Requests, Gated builds, tracked/required web-based code reviews, and CI/CD (Continuous integration and delivery).   It is our belief that by leveraging and extending this automation and workflow, we can lower the friction and foster a safe place for all contributors to work.</p>"},{"location":"#guiding-principles","title":"Guiding Principles","text":"<ul> <li>Less is More *</li> <li>Be open to change / flexible - Keep learning.  If it was easy this would have been solved before</li> <li>Design for code reuse</li> <li>Leverage tools / invest in automation</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<p>Have a look around this site to see what is Project Mu.  Start by reviewing the details of the community and our process. See how to interact and get involved, why it's different, how to work within or extend it, as well as where everything is located.  Finally, explore the Developer Docs if you want to review more in-depth details.</p>"},{"location":"#having-trouble","title":"Having trouble","text":"<p>Skim the FAQ</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>After the first few months of Mu, our initial roadmap is largely complete. Any remaining items have been moved to the GitHub Issues and will continue to be tracked there. We hope to use GitHub Issues to track new roadmap items going forwards.</p> <p>Project Mu GitHub Issues</p>"},{"location":"#join-us","title":"Join Us","text":"<p>Contact info and additional methods to collaborate coming soon.</p>"},{"location":"#code-of-conduct","title":"Code of conduct","text":"<p>This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"#reporting-issues","title":"Reporting Issues","text":"<p>Short answer: Open a github issue. More details: Contributing</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Short answer: Open a pull request. More details: Contributing</p>"},{"location":"#license","title":"License","text":"<p>Refer to License</p> <p>Documentation Build Information</p> <p>Version: 0.9.1 Build Time: 2023-01-31 21:00</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#purposegoals","title":"Purpose/Goals","text":""},{"location":"faq/#how-is-this-related-to-tianocore","title":"How is this related to TianoCore","text":"<p>As you can probably tell, Project Mu is based on TianoCore. It represents a variant of TianoCore that was customized within Microsoft for scaling and maintainability. It's not exactly a staging branch for TianoCore, as there are some changes that may not have application within or meet the explicit goals of that project, but it is a place where features and changes can be publicly featured and discussed.</p>"},{"location":"faq/#so-is-this-a-fork","title":"So, is this a fork","text":"<p>Not entirely. It is our goal to continue to treat TianoCore as a true upstream. Our release branches will always be based on the latest stable TianoCore release, and we will always try to PR viable fixes and features into the TianoCore project.</p>"},{"location":"faq/#what-is-it-where-is-it-going","title":"What is it? Where is it going","text":"<p>Project Mu is a product of the Microsoft Core UEFI team and is the basis for the system firmware within a number of Microsoft products. It will continue to be maintained to reflect the FW practices and features leveraged for the best experience with Windows and other Microsoft products.</p> <p>A secondary purpose is to engage with the community, both in TianoCore and the industry at large. We hope that Project Mu serves as a concrete example for discussing different approaches to managing the challenges faced by the UEFI ecosystem.</p>"},{"location":"faq/#contentstructure","title":"Content/Structure","text":""},{"location":"faq/#is-this-really-following-less-is-more","title":"Is this really following \"Less is More\"","text":"<p>Yes.  The idea is lowering the entanglement of code, lowering the coupling, and allowing the product to pick and choose the code it needs.  This means when building any given product, you don't need all the Project Mu code.</p>"},{"location":"faq/#why-are-there-so-many-repos","title":"Why are there so many repos","text":"<p>Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal.</p> <p>For details, see \"Repo Philosophy\" in What and Why.</p>"},{"location":"license/","title":"Licensing for Project Mu","text":"<p>Project Mu has numerous repositories.  Each of these can have different licenses depending on the content and partner but in general we want OSS friendly licenses.  For this documentation we use the following license.  </p>"},{"location":"license/#license","title":"License","text":"<p>BSD 2-Clause License</p> <p>Copyright \u00a9 Microsoft All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"CodeDevelopment/compile/","title":"How to Build/Compile","text":"<p>Info</p> <p>MAJOR UPDATE -- The Project Mu Python packages for UEFI support and build tools have migrated to Tianocore and as a result things have changed.  These docs are now updated to leverage building with \"edk2-pytools\".</p> <p>The repository/product/project should describe the unique steps required to build and test.  The build tools are now a set of unique single purpose built tools called \"stuart\".  These tools together support building, updating binary dependencies, updating git dependencies, and other functions.  Project Mu has two main patterns for building.  Those will be described here to encourage pattern/code reuse and limit the required repository specific documentation.  More details for pytools can be found here:</p> <ul> <li>https://github.com/tianocore/edk2-pytool-extensions/tree/master/docs</li> <li>https://github.com/tianocore/edk2-pytool-library/tree/master/docs</li> </ul>"},{"location":"CodeDevelopment/compile/#ci-multi-package-building-and-testing-aka-stuart_ci_build","title":"CI multi-package Building and Testing aka stuart_ci_build","text":"<p>stuart_ci_build is a framework for running a battery of tests against a single Mu repository (and its dependencies). A plugin model is used for adding additional tests.  Today one such plugin is a basic compile test.  Another plugin compiles host based unit tests and runs them.  A third plugin checks for misspellings.  Check out the repository for details on the tests.  Additional test plugins are usually found in <code>.pytool/Plugin</code></p> <p>It is often desirable to compile test code and at times there might not be a product to test with.  This is also how the Pull Requests gates are implemented and enforced.</p>"},{"location":"CodeDevelopment/compile/#ci-build-process","title":"CI Build Process","text":"<ol> <li>Open cmd prompt at workspace root</li> <li>Activate your python virtual environment</li> <li> <p>Install or update Python dependencies using pip</p> <pre><code>pip install --upgrade -r pip_requirements.txt\n</code></pre> </li> <li> <p>Run stuart_setup to download required submodules.</p> <pre><code>stuart_setup -c &lt;PyTool Config File&gt;\n</code></pre> </li> <li> <p>Run stuart_ci_setup to download CI only dependencies</p> <pre><code>stuart_ci_setup -c &lt;PyTool Config File&gt;\n</code></pre> </li> <li> <p>Run stuart_update to download or update binary dependencies</p> <pre><code>stuart_update -c &lt;PyTool Config File&gt;\n</code></pre> </li> <li> <p>Run stuart_ci_build to build and test the packages</p> <pre><code>stuart_ci_build -c &lt;PyTool Config File&gt;\n</code></pre> </li> <li> <p>Open TestResults.xml in the build output for results (usually in workspace/Build)</p> </li> <li>Open log files to debug any errors</li> </ol> Info <ul> <li>In Project Mu repos the config file is generally at <code>.pytool/CISettings.py</code></li> <li>Project Mu runs on Windows 10 using the following tags: VS2019 and VS2022</li> <li>Project Mu runs on Ubuntu 18.04 using the tags: GCC5</li> <li>Each of the stuart commands can take in additional parameters.  To see customized help run   <code>&lt;stuart cmd&gt; -c .pytool/CISettings.py -h</code></li> <li>Some common optional parameters that might allow the stuart operation to optimize for expected usage.   For example if only building for X64 ARCH then the ARM compilers might not be   downloaded.  Or if using the Visual Studio toolchain then GCC specific assets aren't needed.  If you only want   to run CI against the MdePkg and MdeModulePkg then you can do that with <code>-p</code>.<ul> <li><code>-a &lt;arch csv&gt;</code> - list of architectures to run for</li> <li><code>-p &lt;packages csv&gt;</code> - list of packages to run against</li> <li><code>-t &lt;targets csv&gt;</code> - list of targets to run for</li> <li><code>TOOL_CHAIN_TAG=&lt;tag&gt;</code> - set toolchain for operation</li> </ul> </li> </ul>"},{"location":"CodeDevelopment/compile/#project-build-aka-platformbuild-aka-stuart_build","title":"Project Build aka PlatformBuild aka stuart_build","text":"<p>When you actually want to compile for a platform that will create a firmware binary which can be flashed and execute on a platform the process is generally as follows.  Again the platform repository should have details but this is generally the process.</p>"},{"location":"CodeDevelopment/compile/#platform-build-process","title":"Platform Build Process","text":"<ol> <li>Open cmd prompt at workspace root</li> <li>Activate your python virtual environment</li> <li> <p>Install or update Python dependencies using pip</p> <pre><code>pip install --upgrade -r &lt;pip_requirements.txt file&gt;\n</code></pre> </li> <li> <p>Run stuart_setup to download required submodules.</p> <pre><code>stuart_setup -c &lt;platform Config File&gt;\n</code></pre> </li> <li> <p>Run stuart_update to download or update binary dependencies</p> <pre><code>stuart_update -c &lt;platform Config File&gt;\n</code></pre> </li> <li> <p>Run stuart_build to build and test the packages</p> <pre><code>stuart_build -c &lt;platform Config File&gt;\n</code></pre> </li> <li> <p>Open the build output for log files to debug any errors (usually in workspace/Build)</p> </li> </ol> Info <ul> <li>In Project Mu repos the platform config file is generally in the platform package.</li> <li>Toolchains and host OS support is defined by the platform documentation.</li> <li>Each of the stuart commands can take in additional parameters.  To see customized help run   <code>&lt;stuart cmd&gt; -c &lt;platform config file&gt; -h</code></li> </ul>"},{"location":"CodeDevelopment/compile/#other-features","title":"Other features","text":"<p>stuart_build leverages a common UefiBuild python component.  This component provides a common set of features. The UefiBuild component documentation is published from the edk2-pytool-extensions repository but here are a few of the common features developers find useful.</p> <ul> <li>Control the target of the build.  Pass <code>Target=RELEASE</code></li> <li>Build a single module: <code>BuildModule=MdePkg/ModuleToBuild.inf</code></li> <li>Build with reporting:</li> <li>Single report type <code>BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD\"</code></li> <li>Change report file <code>BUILDREPORT_FILE=filename.txt</code> default is BUILD_REPORT.TXT</li> <li>All report types. <code>BUILDREPORTING=TRUE BUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\"</code></li> <li>Clean build: <code>--clean</code></li> <li>Clean only (no compile): <code>--cleanonly</code></li> <li>Skip some of the build steps:</li> <li>Skip the Edk2 build step: <code>--skipbuild</code></li> <li>Skip pre or post build steps: <code>--skipprebuild</code> or <code>--skippostbuild</code></li> <li>Change a Build variable that is used in Edk2 build process:</li> <li><code>BLD_*_DEBUG_OUTPUT_LEVEL=0x80000004</code> will be passed to DSC/FDF as DEBUG_OUTPUT_LEVEL.  These variable names and     behavior are platform defined.</li> <li><code>BLD_*_&lt;var name&gt;</code> is used for builds of any target type unless there is a more specific version for the given     target type.</li> <li><code>BLD_DEBUG_&lt;var name&gt;</code> is used for debug builds only</li> <li><code>BLD_RELEASE_&lt;var name&gt;</code> is used for release builds only</li> <li>Using a config file.  To simplify calling of PlatformBuild.py if there is a BuildConfig.conf in the root of   your UEFI workspace those parameters will be used as well.  The command line overrides anything from the conf file.</li> </ul>"},{"location":"CodeDevelopment/compile/#example-buildconfigconf","title":"Example BuildConfig.conf","text":"<pre><code># Turn on full build reports\nBUILDREPORTING=TRUE\nBUILDREPORT_TYPES=\"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\"\n</code></pre>"},{"location":"CodeDevelopment/overview/","title":"Code Development Overview","text":""},{"location":"CodeDevelopment/overview/#tools","title":"Tools","text":"<p>First you will need to setup your UEFI development environment.  Project Mu leverages most of the tools from TianoCore EDK2.  We have streamlined the process for the tool chains and systems we use but our project's goals are to support various tool chains and development environments.  For the best experience or for those new to UEFI and Project Mu we have provided guidance in our prerequisites page.</p>"},{"location":"CodeDevelopment/overview/#code","title":"Code","text":"<p>Next you will need to clone a repository or set of repositories to work on.</p> <p>For core work (Project Mu Repos) you can clone the desired repo, make your changes, run CI builds, run your tests, and submit a PR.</p> <p>For platform work (outside of Project Mu) you will need to clone the platform repository and then follow the platform setup process.</p> <p>See details on the compile page for more information about CI builds and how to compile a package or platform.</p> <p>Code should follow best practices.  We are working to add some best practices on the requirements page. We also attempt to enforce these best practices thru our CI build process.</p>"},{"location":"CodeDevelopment/overview/#tests","title":"Tests","text":"<p>One area of focus for Project Mu is on testing.  Firmware testing has traditionally been hard and very manual.  With Project Mu and our recent contributions to Tianocore, we now have a unit test framework available to developers.  Host based tests written in this framework will be automatically run during CI passes and are required for new contributions.  Check out the testing page for more details.</p>"},{"location":"CodeDevelopment/prerequisites/","title":"Prerequisites for building Code","text":"<p>Generally there are a set of tools required on the platform.  Project Mu tries to minimize the number of global tools but there are a few.  There could be more depending on the repository/product/platform you are building but this should get you started.  If the repo requires other tools those should be documented within the repo. The tools also vary by Operating System and Compiler choice.  Project Mu will document what is currently supported but the expectation is that between Project Mu and TianoCore Edk2 you could use any of those tool sets.</p>"},{"location":"CodeDevelopment/prerequisites/#windows-10-x64","title":"Windows 10 x64","text":""},{"location":"CodeDevelopment/prerequisites/#python","title":"Python","text":"<ol> <li> <p>Download latest Python from https://www.python.org/downloads</p> <pre><code>https://www.python.org/ftp/python/3.10.7/python-3.10.7-amd64.exe\n</code></pre> </li> <li> <p>It is recommended you use the following options when installing python:</p> <ol> <li>include pip support</li> <li>include test support</li> <li>include venv virtual environment support</li> </ol> </li> </ol>"},{"location":"CodeDevelopment/prerequisites/#git","title":"Git","text":"<ol> <li> <p>Download latest Git For Windows from https://git-scm.com/download/win</p> <pre><code>https://github.com/git-for-windows/git/releases/download/v2.37.3.windows.1/Git-2.37.3-64-bit.exe\n</code></pre> </li> <li> <p>It is recommended you use the following options:</p> <ol> <li>Checkout as is, commit as is.</li> <li>Native Channel support (this will help in corp environments)</li> <li>Check the box to \"Enable Git Credential Manager\"</li> </ol> </li> </ol>"},{"location":"CodeDevelopment/prerequisites/#visual-studio-2022-preferred","title":"Visual Studio 2022 preferred","text":"<ol> <li> <p>Download latest version of VS build Tools to c:\\TEMP</p> <pre><code>https://aka.ms/vs/17/release/vs_buildtools.exe\n</code></pre> </li> <li> <p>Install from cmd line with required features (this set will change over time).</p> <pre><code>C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^\n--add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^\n--add Microsoft.VisualStudio.Component.Windows11SDK.22000 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^\n--add Microsoft.VisualStudio.Component.VC.Tools.ARM64\n</code></pre> </li> </ol> <p>See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2022</p>"},{"location":"CodeDevelopment/prerequisites/#visual-studio-2019","title":"Visual Studio 2019","text":"<ol> <li> <p>Download latest version of VS build Tools to c:\\TEMP</p> <pre><code>https://aka.ms/vs/16/release/vs_buildtools.exe\n</code></pre> </li> <li> <p>Install from cmd line with required features (this set will change over time).</p> <pre><code>C:\\TEMP\\vs_buildtools.exe --quiet --wait --norestart --nocache --installPath C:\\BuildTools ^\n--add Microsoft.VisualStudio.Component.VC.CoreBuildTools --add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 ^\n--add Microsoft.VisualStudio.Component.Windows10SDK.19041 --add Microsoft.VisualStudio.Component.VC.Tools.ARM ^\n--add Microsoft.VisualStudio.Component.VC.Tools.ARM64\n</code></pre> </li> </ol> <p>See component list here for more options. https://docs.microsoft.com/en-us/visualstudio/install/workload-component-id-vs-build-tools?view=vs-2019</p>"},{"location":"CodeDevelopment/prerequisites/#optional-windows-driver-kit","title":"Optional - Windows Driver Kit","text":"<p>Provides Inf2Cat.exe, needed to prepare Windows firmware update packages for signing.</p> <ol> <li> <p>Download the WDK installer</p> <pre><code>https://go.microsoft.com/fwlink/?linkid=2085767\n</code></pre> </li> <li> <p>Install from cmd line with required features (this set will change over time).</p> <pre><code>wdksetup.exe /features OptionId.WindowsDriverKitComplete /q\n</code></pre> </li> </ol>"},{"location":"CodeDevelopment/prerequisites/#optional-create-an-omnicache","title":"Optional - Create an Omnicache","text":"<p>An Omnicache is a Project Mu tool that leverages git features to speed up git update operations.  This helps speed up git operations if you have multiple workspaces by using the git \"--reference\" feature.</p>"},{"location":"CodeDevelopment/prerequisites/#windows-subsystem-for-linux-wsl-and-linux","title":"Windows Subsystem For Linux (WSL) and Linux","text":"<p>Basic directions here. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_linux.md</p>"},{"location":"CodeDevelopment/prerequisites/#all-operating-systems-python-virtual-environment-and-pytools","title":"All Operating Systems - Python Virtual Environment and PyTools","text":"<p>In all Operating Systems environments the PyTools python modules are needed.</p> <p>Python virtual environments are strongly suggested especially when doing development in multiple workspaces.  Each workspace should have its own virtual environment as to not modify the global system state. Since Project Mu uses Pip modules this allows each workspace to keep the versions in sync with the workspace requirements.</p> <p>More info on Python Virtual Environments: https://docs.python.org/3/library/venv.html</p>"},{"location":"CodeDevelopment/prerequisites/#workspace-virtual-environment-setup-process","title":"Workspace Virtual Environment Setup Process","text":""},{"location":"CodeDevelopment/prerequisites/#a-sample-directory-layout-of-workspaces-and-python-virtual-environments","title":"A sample directory layout of workspaces and Python Virtual Environments","text":"<pre><code>    /Workspace1Root (basic platform)\n    |-- src_of_project1\n    |-- venv        &lt;-- Virtual environment for Project in workspace root 1\n    |\n    /Workspace2Root (basic + local pytool dev support)\n    | -- src_of_project2\n    | -- venv       &lt;-- Virtual environment for Project in workspace root 2 pip requirements\n    | -- venv_dev   &lt;-- Virtual environment configured to use local python modules\n    | -- edk2-pytool-library    &lt;-- local clone of python modules in library\n    | -- edk2-pytool-extensions &lt;-- local clone of python modules in extensions\n</code></pre> <p>Virtual environments only need to be created once per workspace.  They must be activated in each new cmd shell.</p> <ol> <li>Open Cmd Prompt in the directory where you want to store your virtual environment.  A directory adjacent to    workspace directories is convenient.</li> <li> <p>run python cmd</p> <pre><code>python -m venv &lt;your virtual env name&gt;\n</code></pre> </li> <li> <p>Activate it for your session.</p> </li> </ol>"},{"location":"CodeDevelopment/prerequisites/#activate-virtual-environment","title":"Activate Virtual Environment","text":"<p>Do this each time you open a new command window to build your workspace.</p> <ol> <li>Open Cmd Prompt</li> <li> <p>run activate script - for windows cmd prompt (cmd.exe) do this</p> <pre><code>&lt;your virtual env name&gt;\\Scripts\\activate\n</code></pre> </li> <li> <p>cd into your workspace directory</p> </li> <li> <p>Update/Install your python pip requirements.  This is generally at the workspace root.</p> <pre><code>pip install --upgrade -r pip-requirements.txt\n</code></pre> </li> <li> <p>Do dev work and run your builds!</p> </li> </ol>"},{"location":"CodeDevelopment/requirements/","title":"Requirements for contributing Source Code","text":""},{"location":"CodeDevelopment/requirements/#basics","title":"Basics","text":"<ol> <li>Make sure it follows the package, repo, and codebase rules</li> <li>Make sure it builds</li> <li>Write a unit test for it.  Test positive cases as well as negative cases.</li> <li>Make sure it has docs.  Even a minimal readme.md will get collected and added to the docs.</li> <li>Make sure it has only valid characters encoded (often copy paste from Microsoft Word docs or the internet will lead    to invalid characters)</li> <li> <p>Any changes made to code that originates from outside Project Mu (e.g. upstream project TianoCore, OpenSSL, etc.)    should be surrounded with comments/tags indicating that it is a \"MU_CHANGE\".</p> <ul> <li>Most of the contents of <code>mu_basecore</code>, <code>mu_tiano_plus</code>, <code>mu_silicon_arm_tiano</code>, and <code>mu_silicon_intel_tiano</code>   fall under this requirement.</li> <li>Example:</li> </ul> <pre><code>EFI_STATUS\nEFIAPI\nSomeFunction (\nVOID\n)\n{\nEFI_STATUS      Status;\n// MU_CHANGE [BEGIN] - Add new counters for Feature X\nUINTN           CounterA;\nUINTN           CounterB;\n// MU_CHANGE [END]\n\nStatus = EFI_ABORTED;\n...\n}\n</code></pre> </li> </ol>"},{"location":"CodeDevelopment/requirements/#uefi-package","title":"Uefi Package","text":""},{"location":"CodeDevelopment/requirements/#uefi-components","title":"UEFI Components","text":"<ol> <li>All new modules must be listed in their containing package DSC in the components section</li> <li>All modules must follow the dependency rules of their containing package</li> <li>All modules within common layers should avoid silicon or architecture dependencies.<ul> <li>Use existing libraries and functionality when possible</li> <li>Build out minimal required abstraction to allow other silicon or architectures to leverage common capabilities</li> </ul> </li> </ol>"},{"location":"CodeDevelopment/requirements/#public-header-files","title":"Public Header files","text":"<ol> <li>Don't include other header files</li> <li>Don't mix public and private information in the same header file<ul> <li>Implementation details should be contained to the instance</li> </ul> </li> <li>Use \"doxygen\" style function header comments to clearly specify parameters and return results.</li> <li>Use a guidgen tool to define any guids</li> <li>For libraries:<ul> <li>Library class should be listed in Package DEC file</li> <li>A NULL instance must be created that allows compiling and linking with minimal dependencies.</li> </ul> </li> </ol>"},{"location":"CodeDevelopment/requirements/#library-instance","title":"Library Instance","text":"<ol> <li> <p>The supported module types in the INFs must be accurate.</p> <pre><code>LIBRARY_CLASS: &lt;Library Class Name&gt;|&lt;Module types supported by this instance&gt;\n</code></pre> </li> <li> <p>Use STATIC on each non-public function and non-public global to avoid conflicts with other modules.</p> </li> <li>Use EFIAPI on all public library class functions.</li> </ol>"},{"location":"CodeDevelopment/requirements/#more-info","title":"More info","text":"<p>For general Edk2 and UEFI development additional information can be found at the TianoCore.org website.</p>"},{"location":"CodeDevelopment/test/","title":"Tests","text":"<p>Testing firmware is critical and should be done so much more than it is today. So please, start writing tests. A lot of work has been done to make it easier.</p>"},{"location":"CodeDevelopment/test/#static-code-tests-analysis","title":"Static Code Tests (analysis)","text":"<p>stuart_ci_build provides a framework for running static tests on the code base.  More details of the ever changing tests can be found here. https://github.com/microsoft/mu_basecore/tree/release/202002/.pytool/Plugin</p>"},{"location":"CodeDevelopment/test/#uefi-unit-tests-c-code","title":"UEFI Unit Tests - C code","text":"<p>It now exists!! There is a framework available in Tianocore and Project Mu basecore. Simple API here. https://github.com/microsoft/mu_basecore/blob/release/202002/MdePkg/Include/Library/UnitTestLib.h Implementation details here. https://github.com/microsoft/mu_basecore/tree/release/202002/UnitTestFrameworkPkg</p>"},{"location":"CodeDevelopment/test/#host-based-console-app","title":"Host Based - console app","text":"<p>Host based allow you to run your tests on the same machine in which you are compiling your code.  These tests will run as applications within the operating system host environment.  This is the preferred route when possible as these tests will automatically roll into the CI process and are much faster and easier to run.  Obviously this means you will need to write your code and tests with limited UEFI dependencies.  Any dependency your code has will need to be mocked or faked for the unit test scenario.  The host test does leverage cmocka so lightweight mocking is possible.</p>"},{"location":"CodeDevelopment/test/#target-based-uefi-firmware-on-a-device","title":"Target Based (UEFI Firmware on a device)","text":"<p>Some testing just doesn't make sense to run as a host test.  Tests that rely on system hardware and system state might only work as target tests.  The unit test framework supports this and the implementation works for both.  This can also include features that require reboots and saving state before the reboot so that tests can resume upon continued execution.</p>"},{"location":"CodeDevelopment/test/#uefi-shell-based-functional-tests","title":"UEFI Shell Based Functional Tests","text":"<p>These can also leverage the UEFI target based tests.</p>"},{"location":"CodeDevelopment/test/#uefi-shell-based-audit-tests","title":"UEFI Shell Based Audit Tests","text":"<p>These tests are often one off UEFI shell applications that collect system data and then compare that data against known good values for a system.  This is because these types of tests have no right or wrong answer.  Often we have a python script/component to the test to compare expected result to actual result.  If the actual result doesn't match then this type of test should fail.</p>"},{"location":"CodeDevelopment/test/#testing-automation-for-physical-hardware","title":"Testing Automation for physical hardware","text":"<p>The Project Mu team has done a lot of work with the open source project \"robot framework\".  This framework provides a great logging and execution environment but at this time it is out of scope for Project Mu docs.  If you want to know more, contact us as we are definitely willing to partner/share/engage.</p>"},{"location":"CodeDevelopment/test/#testing-python","title":"Testing Python","text":"<ul> <li>Create pytest and/or python unit-test compatible tests.</li> <li>Make sure the python code passes the <code>flake8</code> \"linter\"</li> </ul>"},{"location":"DeveloperDocs/attribution/","title":"Documentation framework attribution","text":"<p>A special thank you to the people and projects that helped make Project Mu Documentation possible.</p>"},{"location":"DeveloperDocs/attribution/#projects","title":"Projects","text":""},{"location":"DeveloperDocs/attribution/#mkdocs","title":"Mkdocs","text":"<p>https://www.mkdocs.org/</p> <p>MkDocs License (BSD) Copyright \u00a9 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"DeveloperDocs/attribution/#mkdocs-macros-plugin","title":"mkdocs macros plugin","text":"<p>https://github.com/fralau/mkdocs_macros_plugin</p> <p>MIT License Copyright (C) 2018 Laurent Franceschetti Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"DeveloperDocs/attribution/#material-for-mkdocs","title":"Material for MkDocs","text":"<p>https://squidfunk.github.io/mkdocs-material/</p> <p>License MIT License Copyright \u00a9 2016 - 2017 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"DeveloperDocs/attribution/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>https://facelessuser.github.io/pymdown-extensions/</p> <p>PyMdown Extensions</p> <p>The MIT License (MIT) (Except where stated below) Copyright \u00a9 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"DeveloperDocs/build_community_docs/","title":"Building Community Docs","text":"<p>Info</p> <p>Today this process has been validated for use on Windows 10. This setup process is expected to roughly the same on other operating systems and none of the actual documentation source or tools should have any OS dependency.</p>"},{"location":"DeveloperDocs/build_community_docs/#get-the-docs-repository","title":"Get the docs repository","text":"<p>First, you need to clone the project mu docs repository.</p> <pre><code>git clone https://github.com/Microsoft/mu.git\n</code></pre>"},{"location":"DeveloperDocs/build_community_docs/#install-required-tools","title":"Install required tools","text":"<ol> <li>Install python (Current suggested version is 3.7.x).  Current min requirement is python 3.4+.  Checkout python.org for    directions.</li> <li>Install pip.  Generally, this is done when installing python but can also be done as its own process.    Details here https://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip</li> <li> <p>Update pip.</p> <pre><code>python -m pip install --upgrade pip\n</code></pre> </li> <li> <p>Install dependencies.</p> <pre><code>pip install --upgrade -r requirements.txt\n</code></pre> </li> <li> <p>Install nodejs for more tooling</p> </li> <li>Install nodejs from https://nodejs.org/en/</li> <li> <p>Include npm for package management</p> </li> <li> <p>Install markdownlint cli tool for linting the markdown</p> <pre><code>npm install -g markdownlint-cli\n</code></pre> </li> <li> <p>Install cspell cli tool for spell checking the markdown</p> <pre><code>npm install -g cspell\n</code></pre> </li> <li> <p>Install Git on your path (Required for generating dynamic repo based content during pre-process)</p> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#general-suggested-documentation-workflow","title":"General Suggested documentation workflow","text":"<ol> <li>open two command windows at the root of docs repository<ol> <li>Window 1: Use to serve files locally<ul> <li>Use <code>mkdocs serve</code></li> <li>Any changes from the DocBuild process will be picked up and served</li> </ul> </li> <li>Window 2: Use to pre-process the source repo files<ul> <li>Run the DocBuild.py command from this window</li> </ul> </li> </ol> </li> <li>Make changes to the docs in source repos or this repo and then re-run the DocBuild.py build command</li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#pre-process-with-dynamic-content-from-source-repos","title":"Pre-process with dynamic content from source repo(s)","text":"<ol> <li>Create \"repos\" folder (somewhere outside of workspace)</li> <li>Clone all repositories for dynamic content here</li> <li>Set each repo to the branch/commit that you want to document</li> <li> <p>run the DocBuild.py command supplying the parameters</p> <pre><code>DocBuild.py --clean --build --OutputDir docs --yml mkdocs_base.yml --RootDir ..\\repos\n</code></pre> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#pre-process-with-no-source-repos-content","title":"Pre-process with no source repo(s) content","text":"<ol> <li> <p>run the DocBuild.py command supplying minimal parameters</p> <pre><code>DocBuild.py --clean --build --yml mkdocs_base.yml\n</code></pre> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#clean-remove-all-pre-processed-content","title":"Clean / Remove all pre-processed content","text":"<ol> <li> <p>use DocBuild.py command</p> <pre><code>DocBuild.py --clean --yml &lt;path to yml base file&gt; --OutputDir &lt;docs folder&gt;\n</code></pre> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#check-for-character-encoding-issues","title":"Check for character encoding issues","text":"<ol> <li>navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things)</li> <li>open command window</li> <li> <p>run  Utf8Test python script cmd prompt</p> <pre><code>Utf8Test.py --RootDir docs\n</code></pre> </li> <li> <p>should complete with no errors</p> </li> </ol> <p>Note</p> <ul> <li>Note you can also run it on any dynamic content by using a different RootDir parameter.</li> <li>Use -h for usage to get more detailed information of any failures</li> </ul>"},{"location":"DeveloperDocs/build_community_docs/#use-mkdocs-to-build-the-docs","title":"Use mkdocs to build the docs","text":"<ol> <li>navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things)</li> <li>open command window</li> <li> <p>run  mkdocs build from cmd prompt at root</p> <pre><code>mkdocs build -s -v\n</code></pre> </li> <li> <p>should complete with no errors</p> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#spell-check-the-docs","title":"Spell check the docs","text":"<ol> <li>navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things)</li> <li>open command window</li> <li> <p>run command to spell check</p> <pre><code>cspell \"docs/**/*.md\"\n</code></pre> </li> <li> <p>should complete with no errors</p> False Spelling Errors <p>If the spelling error is a false positive there are two solutions:     1. If it is a valid word or commonly understood term then add the word to the cspell.json     config file <code>words</code> section     2. Update the cspell.json file <code>ignorePaths</code> element to ignore the entire file.</p> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#lint-the-markdown","title":"Lint the Markdown","text":"<ol> <li>navigate to root of repository (should see a docs folder, the mkdocs_base.yml file, and a few other things)</li> <li>open command window</li> <li> <p>run command to lint the markdown</p> <pre><code>markdownlint \"**/*.md\"\n</code></pre> </li> <li> <p>Should complete with no errors.</p> <ul> <li>Rules can be found here https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md</li> <li>Configuration info here https://github.com/DavidAnson/markdownlint#configuration</li> <li>Project specific configuration is is in <code>.markdownlint.yaml</code> file at the root</li> </ul> </li> </ol>"},{"location":"DeveloperDocs/build_community_docs/#locally-serve-the-docs","title":"Locally serve the docs","text":"<p>One great feature of mkdocs is how easy it is to locally serve the docs to validate your changes.</p> <ol> <li> <p>Use mkdocs to serve your local copy</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>navigate to 127.0.0.1:8000 in web browser</p> </li> </ol> <p>Important</p> <p>If you get an error like <code>Config file 'mkdocs.yml' does not exist</code> you must run the pre-process step.</p>"},{"location":"DeveloperDocs/build_community_docs/#advanced-doc-features","title":"Advanced doc features","text":"<p>We do turn on a few advanced/extension features.  Please use these carefully as they may break compatibility if the publishing engine is changed.  Checkout the sample syntax / test page for syntax and information.</p>"},{"location":"DeveloperDocs/developer_docs/","title":"Developer Docs","text":""},{"location":"DeveloperDocs/developer_docs/#philosophy","title":"Philosophy","text":"<p>Documentation is critical.  There is a steep learning curve in UEFI and no amount of documentation will change that, but at a minimum quick, clear, and easy documentation can help everyone adopt features faster and with higher confidence.  Our documentation system will focus on making this an easy, low friction, and collaborative process. The pull request process will eventually compel developers to submit documentation whenever they submit new components and refactoring.</p> <p>Documentation will be done in markdown as this has the benefit of being easily readable in both plain text as well as transformed into a richer experience. It also is quick to learn and to write. Currently, we leverage mkdocs as our publishing engine but since all content is in markdown it could be transitioned to another engine without significant reinvestment.  </p>"},{"location":"DeveloperDocs/developer_docs/#community-documentation","title":"Community documentation","text":"<p>This content is documented in static markdown files within the Project Mu repository.  We leverage mkdocs to generate web-hosted content on every change and host these using github.io. These static files focus on how the project and community interact.  We strongly encourage contribution and follow the standard PR model for all changes, big and small.</p>"},{"location":"DeveloperDocs/developer_docs/#developer-documentation","title":"Developer documentation","text":"<p>This content is documented in a couple of ways.</p> <ol> <li> <p>There are static markdown files in the Project Mu repository.  This contains details about high level concepts,    how-to articles, and features of the project and all repos within Project Mu.  Examples: Code layout, git usage,    tools, building, packaging, etc.</p> </li> <li> <p>There is repo and package level documentation for features.  These are also static markdown files but these are    contained within the repo that contains the feature.  A \u201cdocs\u201d folder for each repo and each package will host this    content. Changes will also follow the standard PR model for the containing repo.</p> </li> <li> <p>Next, there is feature and instance documentation.  This should inform a developer interested in the implementation    specifics of what this module is and what additional requirements it has including code dependencies and    limitations.  This should be documented in markdown files located with the component.  These should be updated    whenever the component is updated and should be part of a code PR.</p> </li> <li> <p>Finally, for API and traditional functional documentation, our current stance is this is required in code    (public APIs) but the published documentation (doxygen html, pdf, etc) is not necessary.  Code tools like vscode    already provide a lower friction method to index, find def, and search that uses this content directly embedded in    the code.</p> </li> </ol>"},{"location":"DeveloperDocs/doc_sample_test/","title":"Documentation Sample / Test file / Advanced doc features","text":""},{"location":"DeveloperDocs/doc_sample_test/#mkdocs-macros-plugin","title":"mkdocs macros plugin","text":"<p>This plugin allows providing some variables in mkdocs.yml file and then reference those variables using jinja2 syntax in md files.  Most of these variables are populated and created during the DocBuild step and inserted into the yml file.</p> <ul> <li> <p>Docs: https://mkdocs-macros-plugin.readthedocs.io/en/latest/</p> </li> <li> <p>Src Project: https://github.com/fralau/mkdocs_macros_plugin</p> </li> </ul>"},{"location":"DeveloperDocs/doc_sample_test/#material-theme","title":"Material theme","text":"<p>This theme provides the skin for the site.  This also provides capabilities thru plugins.</p> <p>https://squidfunk.github.io/mkdocs-material/</p>"},{"location":"DeveloperDocs/doc_sample_test/#markdown-extensions","title":"Markdown Extensions","text":"<p>The Material theme supports markdown extensions.  Check the yml file for what extensions are currently on.  Below is more specific info.</p> <p>https://squidfunk.github.io/mkdocs-material/extensions/permalinks/ https://squidfunk.github.io/mkdocs-material/extensions/pymdown/</p>"},{"location":"DeveloperDocs/doc_sample_test/#admonition-plugin","title":"Admonition plugin","text":"<p>This plugin in combo with the material theme provides great looking ways for doc developers to highlight parts of their message. Please check out: https://squidfunk.github.io/mkdocs-material/extensions/admonition/ for the capabilities and syntax.</p> <p>One example:</p> <p>Note</p> <p>Sample note here.</p>"},{"location":"DeveloperDocs/doc_sample_test/#emoji-support","title":"emoji support","text":"<p>Who doesn't love using emojis. Icon usage has shown to help communicate directions and cross language barriers. https://facelessuser.github.io/pymdown-extensions/extensions/emoji/</p> <p> </p> <p>Twitter, github, and emojione tags available.</p>"},{"location":"DeveloperDocs/doc_sample_test/#tab-support","title":"Tab support","text":"<p>You can now use tabs to organize your content.</p> Basic Example Tab1 <p>Some content in tab1</p> Example Tab2 <p>More content in tab2</p> Link to More details <p>https://facelessuser.github.io/pymdown-extensions/extensions/tabbed/</p>"},{"location":"DeveloperDocs/doc_sample_test/#mermaid-charts","title":"Mermaid Charts","text":"<p>A picture is worth 1000 words so lets make a few.  Mermaid supports a rich, easily integrated set. https://mermaid-js.github.io/mermaid/</p> <p>This is done with custom superfences configuration. See here: https://github.com/squidfunk/mkdocs-material/issues/693#issuecomment-591933381</p> <p>To support this the Mermaid format is supported.</p> Chart Result graph TD;     A--&gt;B;     A--&gt;C;     B--&gt;D;     C--&gt;D; Markdown Syntax <pre><code>    ```mermaid\n    graph TD;\n        A--&gt;B;\n        A--&gt;C;\n        B--&gt;D;\n        C--&gt;D;\n    ```\n</code></pre>"},{"location":"DeveloperDocs/doc_sample_test/#others","title":"Others","text":"<p>Check out the mkdocs.yml file for other extensions and details can be found in the links above.</p>"},{"location":"DeveloperDocs/requirements/","title":"Requirements for contributing documentation","text":""},{"location":"DeveloperDocs/requirements/#conventions-and-lessons-learned","title":"Conventions and lessons learned","text":"<p>Please update this list as you learn more.</p> <ol> <li>filenames should all be lowercase.</li> <li>filenames should use \"_\" to separate words and should not have spaces.</li> <li>all links to pages are case sensitive (when published to GitHub the server is case sensitive)</li> <li>use a code editor like vscode for markdown.  It has linting support and will identify issues prior to build.</li> <li>For rare cases you need to break a linter rule you can do so using the syntax defined here:      https://github.com/DavidAnson/markdownlint#configuration</li> <li>If you markdown has images:<ol> <li>Awesome.  Images help make docs more informative and easier to understand</li> <li>Path in markdown to image must be relative</li> <li>Suggested to put in same directory as md file</li> <li>image filename must end with _mu.extension.  Example my_image_name_mu.png</li> <li>Supported image extensions are gif, jpg, png</li> </ol> </li> </ol>"},{"location":"How/contributing/","title":"How to contribute","text":"<p>There are three common ways to contribute.</p> <ol> <li>Participate in discussions using GitHub issues.</li> <li>Contribute documentation by opening a GitHub Pull Request.</li> <li>Contribute code by opening a GitHub Pull Request</li> </ol>"},{"location":"How/contributing/#filing-issues","title":"Filing Issues","text":"<p>File a GitHub issue in the corresponding Project Mu repository.</p>"},{"location":"How/contributing/#general-feedback-and-discussions","title":"General feedback and discussions","text":"<p>If the feedback is actionable, such as a feature request, file a feature request issue. Otherwise, start a new thread in the GitHub Discussions section of the corresponding Project Mu GitHub repository.</p>"},{"location":"How/contributing/#bugs-and-feature-requests","title":"Bugs and feature requests","text":"<p>For non-security related bugs, please submit a new issue in the Project Mu GitHub repository that contains the code related to the issue.</p> <p>The best way to get your bug fixed is to be as detailed as you can be about the problem. Providing a code snippet or sample driver that exposes the issue with steps to reproduce the problem is ideal.</p>"},{"location":"How/contributing/#reporting-security-issues-and-bugs","title":"Reporting security issues and bugs","text":"<p>Security issues and bugs should be reported privately, via email, to the Microsoft Security Response Center (MSRC) secure@microsoft.com. You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Further information, including the MSRC PGP key, can be found in the Security TechCenter.</p>"},{"location":"How/contributing/#contributions-of-documentation-andor-code","title":"Contributions of Documentation and/or Code","text":""},{"location":"How/contributing/#pull-requests","title":"Pull Requests","text":"<p>If you don't know what a pull request is read this article: https://help.github.com/articles/about-pull-requests. Make sure the repository can build and all tests pass. Familiarize yourself with the project workflow and our coding conventions.</p>"},{"location":"How/contributing/#general-workflow","title":"General workflow","text":"<ol> <li>Fork Repository in GitHub</li> <li>Make desired changes.</li> <li>Build it, test it, document it</li> <li>Submit a Pull Request back to the development branch you would like to target.</li> <li>You will be asked to digitally sign a CLA</li> <li>The server will run some builds and tests and report status</li> <li>Community and reviewers will provide feedback in the Pull Request</li> <li>Make changes / adjust based on feedback and discussion</li> <li>Keep your PR branch in-sync with the branch you are targeting and resolve any merge conflicts</li> <li>Once the the PR status is all passing it can be squashed and merged (just press the button in the PR).  If the PR     is ready the maintainers may complete it for you.</li> </ol> <p>That is it.  Thanks for contributing.</p> <p>More details on:</p> <ol> <li>Code Development</li> <li>Tests Development</li> <li>Documentation Development</li> </ol>"},{"location":"How/contributing/#contributor-license-agreement-cla","title":"Contributor License Agreement (CLA)","text":"<p>This project welcomes contributions and suggestions.  Most (code and documentation) contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com.</p> <p>When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p>"},{"location":"How/integration_checklist/","title":"Steps for a New Integration","text":""},{"location":"How/integration_checklist/#overview","title":"Overview","text":"<p>In Project Mu, any time we snap to a new commit from our upstream project, Tianocore, we call that an Integration. This usually happens when Tianocore releases a new stable tag, but it can happen at other times, as needed.</p> <p>Below, you will find a checklist of the steps that should be followed by any project maintainers when performing a new upstream integration. This is for reference by the maintainers and by any of the community interested in the process.</p> <p>We will do our best to keep this up to date, so it's an excellent reference for what to expect if you're waiting on an integration.</p>"},{"location":"How/integration_checklist/#1-announce","title":"1) Announce","text":"<p>Advertise the upcoming update, where it will start from, how long it will take, and what will happen with the existing release branch afterwards. This should be done in the Release Announcements channel in the Project Mu Team.</p>"},{"location":"How/integration_checklist/#2-rebase-and-test","title":"2) Rebase and Test","text":"<p>Much of this process is designed to be run on every Mu repo. When deciding which repos to update first, refer to the CI dependencies documented in each repo. See here for an example.</p>"},{"location":"How/integration_checklist/#a-prep-for-the-naive-rebase","title":"a) Prep for the Naive Rebase","text":"<ul> <li>Create <code>rebase/*_naive</code> branch by starting at the very tip of the current (latest) release branch</li> <li>There may be reasons to choose a commit other than the very tip, but this is the default</li> <li>Update the readme with new branch info and update all CI badges to look for the new branch</li> <li>Make sure to update source and destination commits</li> <li>When selecting the destination [upstream] commit...<ul> <li>For <code>mu_basecore</code>, this will tend to be the latest stable tag (e.g. <code>edk2-stable202111</code>), but   that's not always true. Make a selection based on the state of <code>edk2</code> and the requirements of   Mu</li> <li>For other repos, generally you want to pick the exact same commit as <code>mu_basecore</code>. If not, you should   probably make a note about why in the Readme</li> </ul> </li> <li>Check all tools and other dependencies (probably only in <code>mu_basecore</code>) to see whether they make sense to move forwards,   including...</li> <li>pip modules in <code>pip-requirements.txt</code></li> <li>markdownlint-cli</li> <li>cspell</li> <li>nasm</li> <li>ACPI tools</li> <li>etc.</li> <li>Sync the Azure pipelines, pip, gitignore files, configs, and other docs with <code>mu_basecore</code>. Try to keep things consistent   where possible</li> <li>Easiest way to do this is just a Beyond Compare with Basecore and look at the <code>.azurepipelines</code> and <code>.pytool</code>     directories, as well as the <code>pip_requirements.txt</code>, <code>.gitignore</code>, <code>RepoDetails.txt</code>, and <code>Readme.rst</code> files</li> <li>There may be other files that need to be checked as well</li> </ul>"},{"location":"How/integration_checklist/#b-perform-the-naive-rebase","title":"b) Perform the Naive Rebase","text":"<p>NOTE: This process will not be followed the same way on \"pure Mu\" repos such as <code>mu_plus</code>. For each repo, refer to the Readme for any special maintenance instructions.</p> <ul> <li>Work through the Naive Rebase</li> <li>Make sure to pay attention to any \"TCMORPH\" commits and whether any new packages/files/submodules need to be dropped</li> <li>Make sure to drop any new <code>.pytool/Plugins</code> that may have been added to other repos that are only needed in     <code>mu_basecore</code>. Some plugins may have been added by the upstream project, but most plugins should only live in     <code>mu_basecore</code></li> <li>Keep notes of any major conflicts/sightings, how they were resolved, and any follow up steps that may be needed</li> </ul>"},{"location":"How/integration_checklist/#c-clean-the-rebase","title":"c) Clean the Rebase","text":"<p>This is an optional -- though desireable -- step where we have the opportunity to squash small bugfixes, drop temporary/testing commits, update features with new testing requirements, and any other behavior that helps keep the history clean and readable.</p> <ul> <li>Create <code>rebase/*_1</code> branch and perform initial cleaning</li> <li>Repeat with as many new cleaning branches as necessary</li> <li>Always diff with the <code>rebase/*_naive</code> branch to ensure changes are understood</li> <li>Create the <code>rebase/*_staging</code> branch when complete</li> </ul>"},{"location":"How/integration_checklist/#d-prepare-for-testing","title":"d) Prepare for Testing","text":"<ul> <li>Tag the branch as <code>*_Rebase</code> and push tag to remotes</li> <li>NOTE: From here on out, you can only perform a rebase above the <code>*_Rebase</code> tag</li> </ul>"},{"location":"How/integration_checklist/#e-take-care-of-binary-deliverables-mu_basecore","title":"e) Take care of binary deliverables (<code>mu_basecore</code>)","text":"<ul> <li>Disable the ext deps for BaseTools   and Crypto</li> <li>Run the BaseTools release pipeline</li> <li>Trigger the actual release once the build passes</li> <li>Tag the commit that these were released from</li> <li>Update the Basetools version and re-enable the extdep</li> <li>See here for more   details</li> </ul>"},{"location":"How/integration_checklist/#f-run-testing","title":"f) Run Testing","text":"<ul> <li>Repeatedly run the PR gate or CI pipelines (must use the pipelines on the servers) and resolve build   issues as they emerge</li> <li>Each issue should be solved in it's own commit and include an update to the Readme with details and potential     follow-up actions</li> </ul>"},{"location":"How/integration_checklist/#g-clean-up","title":"g) Clean Up","text":"<ul> <li>Confirm all CI Build notes were updated in the Readme</li> <li>Tag as <code>*_CIBuild</code> and push to all remotes</li> <li>NOTE: Again, from here on out we can only rebase above this tag</li> <li>Create <code>release/*</code> branch in all repos and push branch to remotes</li> <li>From now on, fixes will have to come through PRs</li> </ul>"},{"location":"How/integration_checklist/#3-boot-a-reference-platform","title":"3) Boot a Reference Platform","text":"<p>Once rebase has been completed on all repos...</p> <ul> <li>On a reference platform, create a new branch for integration testing</li> <li>Pivot all Mu submodules to the new <code>release/*</code> branches</li> <li>Build platform and fix issues as discovered</li> <li>Update individual Readme files with notes on changes required</li> <li>Try to keep these notes associated with the correct repo. Example: if the platform requires a new PCD to build     and this PCD is defined in <code>UefiCpuPkg</code>, update the <code>mu_basecore</code> Readme with a note about the platform decision     (and ideally include recommendations)</li> <li>Once built, boot platform and fix issues as discovered</li> <li>Update individual Readme files with notes on changes required</li> </ul>"},{"location":"How/integration_checklist/#4-change-default-branches","title":"4) Change Default Branches","text":"<p>Once a reference platform successfully boots to Windows...</p> <ul> <li>Tag all repos as <code>*_RefBoot</code> and push tag to remotes</li> <li>Follow the steps in the tutorial videos to move the public and   internal defaults</li> </ul>"},{"location":"How/integration_checklist/#5-update-security-repos","title":"5) Update Security Repos","text":"<ul> <li>Follow the steps in the tutorial video   to update all current Security Patch repos</li> </ul>"},{"location":"How/integration_checklist/#6-announce-completion","title":"6) Announce Completion","text":"<ul> <li>Use the <code>Release Announcements</code> channel in the Project Mu Team to announce completion</li> </ul>"},{"location":"How/release_process/","title":"Release Process","text":""},{"location":"How/release_process/#overview","title":"Overview","text":"<p>Contents and Process Under Active Development</p> <p>While we've been using this process for a couple of years now and think we've worked out all the kinks, it is still subject to change at any time and evolve with our relationship to the upstream project as well as requests and requirements from our downstream consumers and the community.</p> <p>In the interest of maintaining a close, well-defined relationship with the upstream project, TianoCore, the active release branch of Project Mu is periodically deprecated and all Mu-related changes are rebased onto a selected commit of TianoCore. This keeps Project Mu up to date with TianoCore while highlighting all Project Mu differences in the most recent commits and encouraging the reverse integration of all changes/fixes back into TianoCore.</p> <p>In general, the life-cycle of active code follows the following path:</p> <p></p> <p>All active work in Project Mu is performed on a <code>release/*</code> branch, named sequentially according to the date of TianoCore commit that it's based on (e.g. <code>release/201808</code> is based on the <code>edk2-stable201808</code> branch in TianoCore). Work proceeds on that branch until a new TianoCore integration is targeted, at which point a new branch is created and all existing changes are rebased onto the new branch and the new branch is used for all active development going forward. At this point, the previous branch enters a stabilization period where further tests are performed and only bug/security fixes are allowed to be committed. Once in stabilization, the branch will receive a Release Candidate tag (like <code>2002_RC1</code>) to provide synchronization across all Mu repos and represents releases of the code that has been tested and is known to work together.</p> <p><code>release/*</code> branches will be maintained in LTS (Long-Term Support) for at least the next two releases (though it may be longer based on community needs). Once LTS has ended, the branch will be archived following the process described below.</p> <p></p> <p>The below diagram illustrates the life-cycle of a single branch and indicates the critical points in its lifetime. These critical points will be applied as tags for reference and documentation. The tags are given a name relative to the target branch and consist of: Upstream base, Rebase complete, Rebase builds and passes CI, Rebase boots on a designated reference platform, and stabilized Release Candidates. These tags are discussed in more detail below.</p> <p> </p> <p>Important</p> <p>Due to the impacts of the rebase process on the history of Mu release branches, any downstream consumers will have to follow a similar integration process when upgrading to a new release. Any custom changes made within the Project Mu repos will have to be rebased from one release to the next. This is why we strongly discourage forking Project Mu for direct modification (ie. consumption, not contribution). Instead, leverage the distributed repo management system and override management system to integrate proprietary code/modules.</p>"},{"location":"How/release_process/#current-branch-status","title":"Current Branch Status","text":"<p>The status of each branch will be recorded in the ReadMe.rst file at the root of the branch. In general, the ReadMe found in Basecore will contain information that is common to all of the Mu submodules, but each submodule will also have its own ReadMe for each release branch that contains notes specific to the development that occurs in that submodule during a release cycle.</p> <p>The ReadMe will also contain a summary of the branch status at a given time. For example, here is a sample status for Basecore <code>release/202008</code> as of the time of this writing:</p> <pre><code>:Status:\n  In Development\n\n:Entered Development:\n  2020/09/23\n\n:Anticipated Stabilization:\n  November 2020\n</code></pre> <p>In addition, the ReadMe.rst file contains information related to the target upstream commit (\"Destination commit\") for the current integration as well as the final commit (\"Source commit\") from the previous <code>release/*</code> branch when the integration commenced.</p>"},{"location":"How/release_process/#upstream-integration-phase","title":"Upstream Integration Phase","text":"<p>At this time, we are targeting upstream integrations for roughly once a quarter, attempting to align 1:1 with the TianoCore stable release cadence. Prior to an integration, the Project Mu Teams channel will be updated with the target date of completion and the target TianoCore commit and/or release. For example, a plan was made to transition off of <code>release/20180529</code> when TianoCore announced the <code>edk2-stable201808</code> release.</p> <p>Once a commit is selected, a set of rebase commits will be chosen from the active (previous) <code>release/*</code> branch. Ideally, these commits would include everything from the previous rebase through the most recent <code>*_RC</code> tag. For example, when moving from the <code>release/201808</code> branch, the commits will be selected from <code>1808_Upstream</code> (not inclusive) tag to <code>1808_RC1</code>.</p> <p>After selection, this list of commits will be evaluated to determine whether any changes are no longer needed in the Mu history. The most likely causes of this action are:</p> <ul> <li>A change was submitted to TianoCore and has been accepted since the last rebase. Therefore, the change is no longer   needed in Mu history.</li> <li>A change was reverted or modified more recently in Mu history, and the history of this change was squashed to   maintain simplicity when comparing with upstream (TianoCore).</li> </ul> <p>Once all evaluation is completed, the rebase will be performed in the new <code>release/*</code> branch. This branch will then be submitted for the same CI/PR gates that any commit would be required to pass to ensure that there have been no regressions and to guarantee that dev work can transition to the new branch. Finally, the new release branches will be integrated into a designated reference platform and porting notes will be written in the ReadMe.rst file describing any known breaking changes.</p> <p>Once all these milestones have been passed, the new <code>release/*</code> branch will be made the default branch for all repos and the old branch will enter a brief stabilization period before receiving an <code>*_RC</code> tag.</p>"},{"location":"How/release_process/#integration-milestone-tags","title":"Integration Milestone Tags","text":"<p>During integration, multiple tags are applied to the branch to serve as milestones. They also serve as reference point for changelog documentation that is produced during the integration process. Not all repos will have all tags, because not all repos have an upstream. These tags are described below:</p> <ul> <li><code>*_Upstream</code><ul> <li>This tag is placed on the exact TianoCore commit that a given release branch started from. This is used as a reference point between branches and relative to the rebase operation. The documentation produced for this tag contains the differences in TianoCore between this branch and the previous branch. For branches that originated from TianoCore releases, this changelog should be identical to the TianoCore changelog. (Does not exist on all repos.)</li> </ul> </li> <li><code>*_Rebase</code><ul> <li>This tag is placed on the commit at the branch HEAD once the rebase is completed. The only changes to the commits from the last branch should be merge conflict resolutions and any history simplification as described above. The documentation produced for this tag contains a record of these resolutions and simplifications. (Does not exist on all repos.)</li> </ul> </li> <li><code>*_CIBuild</code><ul> <li>This tag is placed on the commit where all code in the given repo passes all CI/PR checks that would normally be required of any commit to the branch. These checks include comprehensive compilation checks as well as things like: spelling, library declarations, code format, etc. The documentation produced for this tag contains any changes required to pass these checks.</li> </ul> </li> <li><code>*_RefBoot</code><ul> <li>This tag is placed on the commit where a reference platform consuming a large portion of the Mu code can successfully boot. The documentation produced for this tag contains any changes required to get the reference platform building and booting. It includes a list of changes outside the Mu project that are recommended for any consuming platform.</li> </ul> </li> </ul> <p>In each of these cases, the <code>*</code> will be replaced with a corresponding branch name. For example, the tags associated with <code>release/201808</code> will be prefixed with <code>1808</code> (e.g. <code>1808_Rebase</code>, <code>1808_RC1</code>, etc.).</p>"},{"location":"How/release_process/#active-development-phase","title":"Active Development Phase","text":"<p>During the active development phase, the release branch is open for comment and contribution both internally and publicly. All work contributed by the Project Mu team will be publicly available after an internal PR review. These commits will automatically be mirrored to the public repos. Similarly, all completed public PRs are mirrored in internal review repos (with preference being given to the public PR in event of a conflict). While this means that there will be times where Project Mu team will make contributions without going through a full public PR review, all code is open to comment and contribution, up to and including a full revert of the internal Mu team contribution.</p>"},{"location":"How/release_process/#public-contributioncommentary","title":"Public Contribution/Commentary","text":"<p>For information on the contribution policies and steps, see the How to Contribute document.</p>"},{"location":"How/release_process/#upstream-cherry-picks","title":"Upstream Cherry-Picks","text":"<p>In the event that a critical change is made in the TianoCore upstream during the Active Development phase, the Project Mu team (with any suggestions or comment from downstream contributors) will evaluate the change for a mid-release cherry pick. If warranted, the commit(s) will be cherry-picked directly from TianoCore using the <code>-x</code> parameter so that it is obvious which upstream commit corresponds to the cherry-pick. This is for provenance as well as ensuring that these commits are cleaned up on the next integration.</p>"},{"location":"How/release_process/#stabilization-phase","title":"Stabilization Phase","text":"<p>Once active development has moved off of a given <code>release/*</code> branch, the branch will undergo a period of stabilization where no major changes will be made while additional hours are gained and -- potentially -- additional tests are run. Once sufficient confidence is built, the branch will be tagged with an <code>*_RC1</code> tag. Only major bug fixes and features that have reached community consensus will be accepted from then on.</p> <p>It is Project Mu's goal that this cadence be aligned with the TianoCore release cadence, with the previous branch stabilizing at the same time a new TianoCore release is available. In this way, development can seamlessly move to the next <code>release/*</code> branch without lapse in availability.</p> <p>Note</p> <p>It is possible that multiple <code>*_RCn</code> tags may be useful to distinguish between milestones of a particularly protracted Stabilization phase, or if major issues were found after the initial <code>*_RC</code> tag. If this occurs, the ReadMe.rst file will be updated with the motivation behind the extra release. It should also be noted that this will cause a new release across all the Project Mu repos to confirm that the code has been tested together. As a result, there may exist a single commit with multiple <code>*_RC</code> tags.</p>"},{"location":"How/release_process/#transition-branches","title":"Transition Branches","text":"<p>In the event that it becomes necessary to stabilize a <code>release/*</code> branch prior to the availability of a suitable TianoCore commit for rebasing, all active development will move to a <code>dev/*</code> branch that will branch from the previous <code>*_RC1</code> tag. If bugs are discovered in the Stabilization phase for the <code>release/*</code> branch, they will also be fixed in the <code>dev/*</code> branch and all changes made in the <code>dev/*</code> branch will be rebased as part of the next <code>release/*</code> branch when it is ready.</p>"},{"location":"How/release_process/#long-term-support-lts","title":"Long-Term Support (LTS)","text":"<p>It is Project Mu's goal that all <code>release/*</code> branches continue to be maintained with active bug fixes -- as necessary -- for at least two full releases after the branch becomes stable. The Project Mu team will serve as the primary deciding body for whether a bug fix to the current <code>release/*</code> branch merits porting back to the prior two branches, but community input or suggestions are always welcome.</p> <p>All release branches that make it to the Stabilization phase will be hosted and kept in the repository in perpetuity. If any change was required to this policy (perhaps for server considerations), the branches will remain archived for posterity and should be available by request.</p>"},{"location":"How/release_process/#post-lts-and-archiving","title":"Post-LTS and Archiving","text":"<p>LTS branch maintenance requires significant resources, both to human (to manually curate and port critical fixes, as well as documentation) and computational (to run regular CI on all active branches across all repos). As such, while we try to keep these branches stable and active for as long as possible, we cannot do it forever.</p> <p>To uphold our commitment to persist any branch that makes it to the LTS phase, these branches will instead be \"archived\". Prior to archival, a notice will be posted to the Project Mu Teams channel announcing the planned dates. The actual process for archiving on the server is:</p> <ol> <li>Create a new branch under the <code>archived/*</code> namespace at the exact commit of the existing branch.<ul> <li><code>release/202008</code> \u2192 <code>archived/release/202008</code></li> </ul> </li> <li>Push this new branch to the server.</li> <li>Delete the old branch on the server.</li> </ol> <p>This process is repeated across all Mu repos. Since the commit history always has a Git branch referencing it, all of the commits will be preserved and any projects that are currently consuming the commit will continue to function as expected.</p> <p>However, after this point the branch will receive no further updates and all consumers are encouraged to move to one of the active LTS branches.</p>"},{"location":"How/using_project_mu/","title":"How to setup a new Repo for a Platform that will use Project MU","text":"<p>This document will describe the base guidelines for setting up a Project MU repo.</p> <ol> <li>You will need to install the prerequisites tools</li> <li>Determine how to layout your project and the content<ul> <li>Look at layout to understand our recommended repository layout.</li> <li>You can also look at ms-iot iMX8 for a real platform    implementation.</li> <li>Check out our docs in our Project Mu Teams channel as we have presentations on OVMF and Intel    OpenKBL platforms.</li> </ul> </li> </ol>"},{"location":"How/using_project_mu/#nomenclature","title":"Nomenclature","text":"<p>I will use the term workspace root to reference the base folder for your code tree.</p> <p>Ordinarily, we use the Platform Repository as the outer-most layer. This means that the outermost git repository is  where we store Platform specific files and libraries. In this case, our Platform Repo is also our workspace root.  If you choose to have a different repository layout, it will be important to note what your workspace root is, as  it should still be the base folder of your code tree.</p> <p>Submodules are full git repos on their own. What we do with these repos is add them as sub-repos to the workspace root. Git will create a <code>.gitmodules</code> file that contains links to the repo and default branches. There are git submodule commands that you can use to work with your submodules, such as:</p> <pre><code>git submodule add &lt;url&gt; &lt;path&gt;  # url to submodule, path to submodule installation\ngit submodule update --init --recursive  # Recursively initializes and updates all submodules.\ngit submodule foreach git status  # git submodule foreach can be used to run a command in each submodule.\n# git status is just an example.\n</code></pre> <p>For more information available here.</p>"},{"location":"How/using_project_mu/#create-git-repo","title":"Create Git Repo","text":"<p>Make new directory.</p> <pre><code>mkdir NewPlatformRepo\ncd NewPlatformRepo\ngit init\n</code></pre> <p>This will serve as our Platform Repository as well as our Workspace Root.</p> <p>For more information on creating a Git repo, here are command line instructions and here are web instructions.</p>"},{"location":"How/using_project_mu/#add-pertinent-submodules","title":"Add pertinent submodules","text":"<p>Project MU is separated into submodules. For each submodule that you need for your project, run the \"git submodule add\" command to add it to your base Repository. The path after the URL is the path we typically use to group the submodules. You can change it if you'd like, just remember your environment will diverge from the one in these instructions.</p>"},{"location":"How/using_project_mu/#mu_basecore","title":"MU_BASECORE","text":"<p>This is the core section of TianoCore. Contains the guts of UEFI, forked from TianoCore, as well as the BaseTools needed to build. You will need this to continue.</p> <pre><code>git submodule add https://github.com/Microsoft/mu_basecore.git MU_BASECORE\n</code></pre>"},{"location":"How/using_project_mu/#mu_plus","title":"MU_PLUS","text":"<p>Additional, optional libraries and tools we've added to make MU great!</p> <pre><code>git submodule add https://github.com/Microsoft/mu_plus.git Common/MU\n</code></pre>"},{"location":"How/using_project_mu/#mu_tiano_plus","title":"MU_TIANO_PLUS","text":"<p>Additional, optional libraries and tools forked from TianoCore.</p> <pre><code>git submodule add https://github.com/Microsoft/mu_tiano_plus.git Common/TIANO\n</code></pre>"},{"location":"How/using_project_mu/#mu_oem_sample","title":"MU_OEM_SAMPLE","text":"<p>This module is a sample implementation of a FrontPage and several BDS support libraries. This module is intended to be forked and customized.</p> <pre><code>git submodule add https://github.com/Microsoft/mu_oem_sample.git Common/MU_OEM_SAMPLE\n</code></pre>"},{"location":"How/using_project_mu/#mu_silicon_arm_tiano","title":"MU_SILICON_ARM_TIANO","text":"<p>Silicon code from TianoCore has been broken out into individual submodules. This is the ARM specific submodule.</p> <pre><code>git submodule add https://github.com/Microsoft/mu_silicon_arm_tiano.git Silicon/ARM/TIANO\n</code></pre>"},{"location":"How/using_project_mu/#mu_silicon_intel_tiano","title":"MU_SILICON_INTEL_TIANO","text":"<p>Silicon code from TianoCore has been broken out into individual submodules. This is the Intel specific submodule.</p> <pre><code>git submodule add https://github.com/Microsoft/mu_silicon_intel_tiano.git Silicon/INTEL/TIANO\n</code></pre> <p>You can run <code>git submodule --update --init</code> to make sure all the submodules are set up.</p>"},{"location":"How/using_project_mu/#adding-your-platform-contents","title":"Adding your platform contents","text":"<pre><code>New_Platform_Repo/\n\u251c\u2500\u2500 Common/\n\u2502   \u2514\u2500\u2500 ...                    # MU_PLUS, MU_OEM_SAMPLE, MU_TIANO_PLUS are generally created by the \"git submodule ...\"\n\u251c\u2500\u2500 MU_BASECORE/\n\u251c\u2500\u2500 PlatformGroup/\n\u2502   \u2514\u2500\u2500 PlatformName/\n\u2502       \u2514\u2500\u2500 PlatformBuild.py   # Python script to provide information to the build process.\n\u2502       \u2514\u2500\u2500 Platform.dsc       # List of UEFI libraries and drivers to compile, as well as platform settings.\n\u2502       \u2514\u2500\u2500 Platform.fdf       # List of UEFI Drivers to put into Firmware Volumes.\n\u251c\u2500\u2500 Silicon/\n\u2502   \u2514\u2500\u2500 SiProvider/            # You should create a separate git repo for Silicon code for development with partners.\n\u2502       \u2514\u2500\u2500 REF_CODE/          # Enablement code for your architecture\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 .gitmodules\n</code></pre> <p>You will need to create PlatformBuild.py, Platform.dsc, and Platform.fdf. These files will go inside the platform folder, which will be <code>New_Platform_Repo/PlatformGroup/PlatformName</code>. The ms-iot iMX8 repo can help you get started as a layout reference and can demonstrate the PlatformBuild file. More information about PlatformBuild can be found here.</p>"},{"location":"WhatAndWhy/features/","title":"Features","text":""},{"location":"WhatAndWhy/features/#summary","title":"Summary","text":"<p>Project Mu features will generally be found in a \"MU\" sub-module, for example, \"Common/MU\" or \"Silicon/Intel/MU\". What major features does Project Mu bring to the table above/beyond EDK2?</p>"},{"location":"WhatAndWhy/features/#feature-list","title":"Feature List","text":"<ul> <li>Pluggable, cross-device, performance-optimized BDS</li> <li>Device Firmware Configuration Interface (DFCI) - enables practical MDM management</li> <li>PBKDF2-based BIOS password example</li> <li>Support for EKU-based trust anchors during signature validation</li> <li>Microsoft unit test framework</li> <li>Audit, function, &amp; performance tests for platform features</li> <li>Scalable Python build environment</li> <li>Build plug in: override tracking tool</li> <li>Build plug in: flash descriptor analysis</li> <li>Binary package management via NuGet</li> <li>Capsule signing via signtool.exe</li> <li>Up-to-date Visual Studio compiler support</li> <li>Base64 encode for binary objects</li> <li>XML Support Package</li> </ul>"},{"location":"WhatAndWhy/features/#features-coming-soon","title":"Features Coming Soon","text":"<ul> <li>Modern BIOS menu example (Surface inspired)</li> <li>On screen keyboard (OSK) with mouse, touch support</li> <li>Graphical end-to-end boot performance analysis library and tool</li> <li>Infineon TPM firmware update via Capsule</li> <li>On screen notifications: color bars to inform users that a device is not in a production configuration</li> </ul>"},{"location":"WhatAndWhy/features/#features-integrated-into-tiano","title":"Features integrated into Tiano","text":"<ul> <li>Safe Integer library</li> <li>Heap Guard</li> <li>ESRT DXE driver</li> <li>Scalable device FMP framework</li> <li>Progress bar for Capsule Updates</li> <li>TCG FV pre hashing optimization</li> <li>NVME shutdown</li> </ul>"},{"location":"WhatAndWhy/layout/","title":"Dependencies and Layout","text":""},{"location":"WhatAndWhy/layout/#conceptual-layers","title":"Conceptual Layers","text":"<p>A modern, full-featured, product-ready UEFI firmware codebase combines code from a multitude of sources:</p> <ul> <li>TianoCore EDK2 UEFI standard-based code</li> <li>Value-add code from TianoCore</li> <li>Silicon vendor hardware initialization code</li> <li>Silicon vendor value-add code</li> <li>Independent BIOS Vendor code</li> <li>ODM/OEM customization code</li> <li>OS firmware support code</li> <li>Legacy BIOS compatibility code</li> <li>Board-specific code</li> <li>etc.</li> </ul> <p>Some of the above components come from closed-source projects (silicon vendors, IBVs, OEMs), others are open source. Each component is supported at its own schedule with new features and bug fixes, creating a problem of stale code if not synced up regularly. Compound the version and source problem with the sheer size: a common UEFI codebase is typically well above 1 million LOC and only goes up from there.  </p>"},{"location":"WhatAndWhy/layout/#what-is-a-dependency","title":"What is a dependency","text":"<p>To understand the layering you must first understand the terminology.  There are two types of code assets.</p> <ol> <li>A definition of something.  Generally, this is defined in an accessible header file.  This is the API provided by      some asset.  This API can be \"depended\" upon to provide some capability.</li> <li>An implementation of something.</li> </ol>   flowchart BT     id1[\"Implementation/Module &lt;br&gt; (Inf/C)\"]     id2[\"Definition/Declaration &lt;br&gt;(Public Header file)\"]     id1 -.-&gt; id2 <p>Example of a build time/link dependency: DxeCore in the Basecore layer depends on the TimerLib interface.  TimerLib interface is defined in the same Basecore layer as DxeCore, so in this case a Basecore module is depending on a Basecore interface. This is allowed. </p> flowchart BT   id1[\"DxeCore Module\"]   id2[\"TimerLib Interface\"]   id1 -.-&gt; id2  <p>To extend this example even more into construction details.  Often the logic of a library will be implemented in the silicon layer.  This means the code may vary based on which silicon is used in the product but because the interface is defined in the basecore layer this is allowed and working as designed.  The core module can be optimized and targeted for a specific silicon implementation.  </p> flowchart BT   subgraph bc [Basecore]     id1[\"DxeCore\"]     id2[\"TimerLib\"]     id1 -.-&gt; id2   end   subgraph sl [Silicon layer]     id3[\"Silicon TimerLib\"]   end   id3 --&gt;id2 <p>An example of an unacceptable/unsustainable dependency is if the core module starts to use the silicon layer directly. For example if a feature was introduced that used a silicon special widget in the DxeCore then this would fail our dependency checks.  </p> flowchart BT   subgraph bc [Basecore]     id1[\"DxeCore\"]   end   subgraph sl [Silicon layer]     id3[\"Silicon Special Widget Lib&lt;br&gt;Implementations\"]     id4[\"Silicon SpecialWidgetLib\"]     id3 --&gt;id4   end   id1 -. NOT ALLOWED .-&gt; id4"},{"location":"WhatAndWhy/layout/#architecture","title":"Architecture","text":"<p>Project Mu is an attempt to create a rigid layering scheme that defines the hierarchy of dependencies.  Architectural goal kept in mind when designing this layering scheme is a controlled, limited scope, and allowed dependencies for each module within a given layer.  It is important to know, when implementing a module, what the module is allowed to depend on. When creating an interface, it is important to identify the correct layer for it such that all the consuming modules are located in the layers below.</p> <p>Motivation and goals of the layering scheme:</p> <ul> <li>Easy component integration</li> <li>Code reuse</li> <li>Only carry relevant code</li> </ul>"},{"location":"WhatAndWhy/layout/#dependency-block-diagram","title":"Dependency Block Diagram","text":""},{"location":"WhatAndWhy/layout/#file-layout","title":"File Layout","text":"<p>To best preserve and delineate these concepts of componentization and unidirectional dependency, we have chosen to lay out our repository files in a structure that reinforces the same mentality.</p> <p>The underlying logic of this layout is to clearly distinguish each layer from the rest. As such, the Basecore -- which is considered foundational -- is broken out on its own, followed by the Common repos, followed by the Silicon, followed by the Platform. As mentioned elsewhere, Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the firmware ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. One of the goals of Project Mu is to make this seemingly complicated layout easier to work with.</p>"},{"location":"WhatAndWhy/layout/#min-platform-example","title":"Min Platform Example","text":"<p>A simple tree might look like this...</p> <pre><code>project_mu/\n\u251c\u2500\u2500 Build/\n\u251c\u2500\u2500 Common/\n\u2502   \u2514\u2500\u2500 ...                     # Common code optional, but probably not required\n\u251c\u2500\u2500 Conf/\n\u251c\u2500\u2500 MU_BASECORE/\n\u251c\u2500\u2500 Platform/\n\u2502   \u2514\u2500\u2500 Sample/\n\u2502       \u2514\u2500\u2500 MyMinPlatform       # Platform-specific build files and code\n\u251c\u2500\u2500 Silicon/\n\u2502   \u2514\u2500\u2500 SiProvider/\n\u2502       \u2514\u2500\u2500 REF_CODE/           # Enablement code for your architecture\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 .gitmodules\n</code></pre> <p>Note that this file structure is likely located in a Git repository, and every \"ALL CAPS\" directory in this example is a Git submodule/nested repository.</p>"},{"location":"WhatAndWhy/layout/#surface-laptop-example","title":"Surface Laptop Example","text":"<p>For a real-world example, this is a tree that could build the Surface Laptop product, including both open- and closed-source repositories:</p> <pre><code>project_mu/\n\u251c\u2500\u2500 Build/\n\u251c\u2500\u2500 Common/\n\u2502   \u251c\u2500\u2500 MSCORE_INTERNAL/        # Proprietary code and code not yet approved for public distribution\n\u2502   \u251c\u2500\u2500 MU/\n\u2502   \u251c\u2500\u2500 MU_TIANO/\n\u2502   \u2514\u2500\u2500 SURFACE/                # Shared code to enable common features like FrontPage\n\u251c\u2500\u2500 Conf/\n\u251c\u2500\u2500 MU_BASECORE/\n\u251c\u2500\u2500 Platform/\n\u2502   \u251c\u2500\u2500 Surface/\n\u2502   \u2502   \u251c\u2500\u2500 SurfKbl/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Laptop/         # Surface Laptop-Specific Platform Code\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 Others/\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 Silicon/\n\u2502   \u251c\u2500\u2500 Intel/\n\u2502   \u2502   \u251c\u2500\u2500 KBL/                # Intel KBL Reference Code\n\u2502   \u2502   \u251c\u2500\u2500 MU/                 # Project Mu Intel Common Code\n\u2502   \u2502   \u251c\u2500\u2500 MU_TIANO/           # Project Mu Intel Code from TianoCore\n\u2502   \u2502   \u2514\u2500\u2500 SURF_KBL/           # Surface Customizations/Overrides for KBL Ref Code\n\u2502   \u2514\u2500\u2500 SURFACE/                # Shared code to enable common HW like ECs\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 .gitmodules\n</code></pre> <p>Once again, the \"ALL CAPS\" directories are submodules.</p>"},{"location":"WhatAndWhy/overview/","title":"Overview","text":""},{"location":"WhatAndWhy/overview/#project-organization","title":"Project Organization","text":"<p>This documentation is hosted in the main repository for Project Mu, which is used as a central collection point for community interaction and documentation. The build system and firmware code for the project is hosted in a number of other repositories, grouped/divided by function, partner, license, and dependencies. Several of these repositories are brought together by the build system to create a FW project, but we'll get into those details later. </p> <p>For now, an overview of the repositories and what code you'll find there...</p>"},{"location":"WhatAndWhy/overview/#mu-basecore","title":"Mu Basecore","text":"<p>This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this code should be one or more of the following:</p> <ul> <li>Part of the build system</li> <li>Common to any silicon architecture</li> <li>Part of the \"API layer\" that contains protocol and library definitions including</li> <li>Industry Standards</li> <li>UEFI Specifications</li> <li>ACPI Specifications</li> <li>Part of the \"PI\" layer that contains driver dispatch logic, event/signaling logic, or memory management logic</li> <li>This can also include central technologies like variable services</li> </ul>"},{"location":"WhatAndWhy/overview/#mu-common-plus","title":"Mu Common Plus","text":"<p>The packages found in this repository are contributed entirely by Project Mu. They should be common to all silicon architectures and only depend on Mu Basecore. These packages provide features and functionality that are entirely optional, but may be recommended for PC platform FW.</p>"},{"location":"WhatAndWhy/overview/#mu-tiano-plus","title":"Mu Tiano Plus","text":"<p>This repository contains only modules that were originally sourced from TianoCore. They are not essential for any particular platform, but are likely useful to many platforms. The versions contained in this repo are modified and/or improved to work with the rest of Project Mu.</p>"},{"location":"WhatAndWhy/overview/#repo-philosophy","title":"Repo Philosophy","text":"<p>Project Mu makes liberal use of multiple repositories due to the mixture of requirements in the UEFI ecosystem. Some repos are split for technical reasons, some for organizational, and some for legal. Examples of this are:</p> <ul> <li> <p>A downstream contributor wants to add a generic feature with a silicon-specific implementation. This feature would   be leveraged by Common code. If all code were in one repository, no barriers would be in place to prevent the   contributor from directly calling from Common code into the Silicon implementation. By forcing the API/interface to   be published in a separate repository, we can ensure that the unidirectional dependency relationship is maintained.</p> </li> <li> <p>Module A and Module B both provide optional functionality. However, Module A is far more likely to be consume by a   wide audience than Module B. To achieve \"Less is More\", Module A may be placed in a different repos to enable   downstream consumers to carry as little \"unused\" code as possible, since it's likely they would not need Module B   in their code tree.</p> </li> <li> <p>A downstream consumer is producing a product in conjunction with a vendor/partner. While most of the enabling code   for the vendor component is open-source, a portion of it is only released under NDA. By having multiple repositories   comprise a single workspace, the downstream consumer is able to maximize their open-source consumption (which minimizes   forking) while maintaining the legal requirements of closed-source/proprietary partitioning.</p> </li> </ul>"},{"location":"WhatAndWhy/security/","title":"Active Security Patching","text":""},{"location":"WhatAndWhy/security/#summary","title":"Summary","text":"<p>In order to simplify adoption and to ensure that security fixes make it into the core repository as quickly as possible, Project Mu maintains \"Security Patch\" versions of all applicable repos that are constantly synced with the public versions. These Security Patch repos are identical to the top of tree in the public repos, but already have all known (and relevant) security patches applied, to the best of our judgement (any choices that were required when authoring the patch are described in the patch notes).</p> <p>Each of the security-specific patches are noted with <code>SECURITY PATCH</code> in the commit title and a <code>MU_SEC_***</code> tag in the commit title that indicates the related bug database tracking the issue (e.g. TianoCore Bugzilla, CVE, etc.).</p>"},{"location":"WhatAndWhy/security/#requesting-access","title":"Requesting Access","text":"<p>Due to a number of factors including disclosure embargoes, these repos are available to the public by request only. If you are interested in getting access, please contact us through the Project Mu Team. Access will be granted to any members who can establish that they have already been given prior clearance to the relevant bug tracking databases.</p>"},{"location":"WhatAndWhy/security/#usage","title":"Usage","text":"<p>The Security Patch repos maintain branches that are 1:1 matches with public branches. All that is necessary to ingest the security patches is to re-target your Git submodule at the Security Patch repo and pull the branch with the same name. They are also kept in sync with any <code>*_RC</code> tags that are applied to the public repo, so it should be simple to identify which public commit corresponds to which SP repo commit.</p>"},{"location":"Where/external_resources/","title":"External Resources","text":""},{"location":"Where/external_resources/#uefi-industry-organization","title":"UEFI Industry Organization","text":"<p>UEFI is the industry standards body that develops and distributes the UEFI, PI, and ACPI specifications.  These specifications govern the firmware interfaces between OS, OEM/Device Manufacturer, and Silicon partner. This is a great site to download the industry specifications and if you are a member you can join working groups for future specifications.</p>"},{"location":"Where/external_resources/#tianocore-project","title":"TianoCore Project","text":"<p>Tianocore is an existing open source project. Their EDK2 repository is the basis for many/most UEFI implementations used on products today.  It provides UEFI spec compliant code modules, supports industry standard hardware, and a multi-platform build environment.  This is a great site to download specifications for the different file types and build process.  It also has links to repositories that Project Mu tracks as \"upstreams\".</p>"},{"location":"Where/external_resources/#mkdocs","title":"MkDocs","text":"<p>Great tool for creating documentation websites based on markdown.  In fact it was used to generate this documentation.</p>"},{"location":"Where/external_resources/#markdown-help","title":"Markdown Help","text":"<p>Quick link for common markdown support.</p>"},{"location":"Where/project_resources/","title":"Project Resources","text":""},{"location":"Where/project_resources/#public-source-code-repositories","title":"Public Source Code Repositories","text":"<p>Listed here:  GitHub Project Mu Repo List</p>"},{"location":"Where/project_resources/#issuebugfeature-tracking","title":"Issue/Bug/Feature Tracking","text":"<p>https://github.com/Microsoft/mu/issues</p>"},{"location":"Where/project_resources/#builds","title":"Builds","text":"<p>https://dev.azure.com/projectmu/mu/_build</p>"},{"location":"Where/project_resources/#docs","title":"Docs","text":"<p>https://microsoft.github.io/mu/</p>"},{"location":"Where/project_resources/#collaborate","title":"Collaborate","text":"<p>Send an email request to join the discussion on our Teams channels.</p>"},{"location":"Where/project_resources/#help","title":"Help","text":"<p>For one-off questions, feel free to start a new thread in the Discussions section of this repository.</p> <p>For deeper discussion &amp; faster communication, join our Microsoft Teams channels.  To join send an email request.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_basecore/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_basecore/RepoDetails/","title":"Project Mu Basecore Repository","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_basecore.git Branch:         release/202208 Commit:         f6ba44028a7e9171ac5d921c7279fa5f4cf5bf11 Commit Date:    2023-01-31 19:11:20 +0000</p> <p>This repository is considered foundational and fundamental to Project Mu. The guiding philosophy is that this any code within this repository should be one or more of the following</p> <ul> <li>Part of the build system</li> <li>Common to any silicon architecture</li> <li>Part of the \"API layer\" that contains protocol and library definitions   including</li> <li>Industry Standards</li> <li>UEFI Specifications</li> <li>ACPI Specifications</li> <li>Part of the \"PI\" layer that contains driver dispatch logic, event/signaling   logic, or memory management logic</li> <li>This can also include central technologies like variable services</li> </ul>"},{"location":"dyn/mu_basecore/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_basecore/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_basecore/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_basecore/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_basecore/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/","title":".ver file specification","text":""},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#1-introduction","title":"1 Introduction","text":"<p>This document describes file format for .ver files. The end goal is to add a VERSIONINFO resource to a UEFI driver or application. The .ver file provides a convenient method to declare the version information. The build system first converts the .VER file to a resource-definition file (.ARC), which is then compiled into a binary resource file and finally linked to the module.</p> <p>The .ver file is referred to as the version info file. VERSIONINFO refers to the format that is specified by the resource compiler.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#11-related-information","title":"1.1 Related Information","text":"<p>The following publications and sources of information may be useful to you or are referred to by this specification:</p> <ul> <li>Unified Extensible Firmware Interface Specifications</li> <li>EDK2 Documents</li> <li>EDK II Build Specification, Intel, 2016.</li> <li>EDK II DEC File Specification, Intel, 2016.</li> <li>EDK II INF File Specification, Intel, 2016.</li> <li>EDK II DSC File Specification, Intel, 2016.</li> <li>EDK II FDF File Specification, Intel, 2016.</li> <li>EDK II Expression Syntax Specification, Intel, 2015.</li> <li>EDK II C Coding Standards Specification, Intel, 2015.</li> </ul> <p>Copyright \u00a9 Microsoft</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#12-terms","title":"1.2 Terms","text":"<p>The following terms are used throughout this document:</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#efi","title":"EFI","text":"<p>Generic term that refers to one of the versions of the EFI specification: EFI 1.02, EFI 1.10, or UEFI 2.0.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#module","title":"Module","text":"<p>A module is either an executable image or a library instance. For a list of module types supported by this package, see module type.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#uefi-application","title":"UEFI Application","text":"<p>An application that follows the UEFI specification. The only difference between a UEFI application and a UEFI driver is that an application is unloaded from memory when it exits regardless of return status, while a driver that returns a successful return status is not unloaded when its entry point exits.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#uefi-driver","title":"UEFI Driver","text":"<p>A driver that follows the UEFI specification.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#2-version-info-file-format","title":"2 Version Info File Format","text":"<p>The format is JSON files with the extension .ver that encodes the VERSIONINFO metadata according to the PE spec here.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#21-version-info-file-examples","title":"2.1 Version Info file examples","text":"<p>When specifying a version info file (.ver), there are two modes: minimal and full.</p> <p>An example of the minimal file would be:</p> <pre><code>{\n\"FileVersion\": \"1.0.0.0\",\n\"CompanyName\": \"Example Company\",\n\"OriginalFilename\": \"ExampleApp.efi\",\n}\n</code></pre> <p>or equivalently:</p> <pre><code>{\n\"Minimal\": true,\n\"FileVersion\": \"1.0.0.0\",\n\"CompanyName\": \"Example Company\",\n\"OriginalFilename\": \"ExampleApp.efi\",\n}\n</code></pre> <p>The <code>Minimal</code> attribute if not defined is considered to be true. Other values are inferred using the defaults specified in this document. However, if <code>Minimal</code> is set to false, you must define more attributes. However, many more additional attributes can be included. Details are listed on the VERSIONINFO spec here.</p> <p>A full example follows:</p> <pre><code>{\n\"Minimal\": false,\n\"FileVersion\": \"1.0.0.0\",\n\"ProductVersion\": \"1.0.0.0\",\n\"FileFlagsMask\": \"VS_FFI_FILEFLAGSMASK\",\n\"FileFlags\": \"0\",\n\"FileOS\": \"VOS_NT\",\n\"FileType\": \"VFT_DRV\",\n\"FileSubtype\": \"VFT2_DRV_SYSTEM\",\n\"StringFileInfo\": {\n\"CompanyName\": \"Example Company\",\n\"OriginalFilename\": \"ExampleApp.efi\",\n\"FileVersion\": \"1.0.0.0\",\n},\n\"VarFileInfo\": {\n\"Translation\": \"0x0409 0x04b0\"\n}\n}\n</code></pre> <p>These three examples produce the same results as the values used in the above example are the default values used by versioninfo_tool.</p> <p>StringFileInfo and VarFileInfo can both have many more entries. More information is available here.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#22-versioninfo-data-format","title":"2.2 VERSIONINFO data format","text":"<p>The attributes of VERSIONINFO are listed below:</p> Attribute Description FileVersion Binary version number for the file. The version consists of four 16-bit integers ProductVersion Binary version number for the product with which the file is distributed. The version parameter is four 16-bit integers FileFlagsMask Indicates which bits in the FILEFLAGS statement are valid. For 16-bit Windows, this value is 0x3f. FileFlags Attributes of the file. See the spec FileOS Operating system for which this file was designed. The fileos parameter can be one of the operating system values given in the spec FileType General type of file. The filetype parameter can be one of the file type values listed in the spec. FileSubtype Function of the file. The subtype parameter is zero unless the filetype parameter in the FILETYPE statement is VFT_DRV, VFT_FONT, or VFT_VXD. For a list of file subtype values, see the spec. StringFileInfo Contains details around the file information such as CompanyName or OriginalFilename VarFileInfo Contains data around the language and character set in the file <p>The spec referred to above is the VERSIONINFO spec.</p> <p>For <code>VarFileInfo</code> in the .ver file, it has a single member <code>Translation</code>, which is two hexadecimal numbers separated by a space. The two number represent, the <code>langId</code> and <code>charsetId</code> respectively.</p> <p>Currently the recommend value for <code>Translation</code> is \"0x0409 0x04b0\", which corresponds to English and Unicode. More information can be found here.</p>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#3-build-system-support","title":"3 Build System Support","text":"<p>The EDK2 build system supports adding version info files (.ver) to UEFI applications, modules, and drivers. By adding a .ver file to the sources of the inf, the build system will process it.</p> <p>An example follows:</p> <pre><code>##\n#  Sample UEFI Application Reference EDKII Module.\n#  SPDX-License-Identifier: BSD-2-Clause-Patent\n##\n\n[Defines]\nINF_VERSION                    = 0x00010005\nBASE_NAME                      = HelloWorld\nMODULE_UNI_FILE                = HelloWorld.uni\nFILE_GUID                      = 6987936E-ED34-44db-AE97-1FA5E4ED2116\nMODULE_TYPE                    = UEFI_APPLICATION\nVERSION_STRING                 = 1.0\nENTRY_POINT                    = UefiMain\n\n[Sources]\nHelloWorld.c\nHelloWorldStr.uni\nHelloWorld.ver\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#31-a-detailed-flow","title":"3.1 A Detailed Flow","text":"<ol> <li>First, versioninfo_tool is invoked on the .ver file. More information is available here: or at the edk2-pytool-extensions repo. The versioninfo_tool creates a temporary file ending in .arc, which is the metadata encoded in the proper resource compiler format.</li> <li>The .arc file is processed by the Microsoft Resource Compiler (x86_64-w64-mingw32-windres on Linux and rc.exe on windows) to produce an object file.</li> <li>This file is then linked in to the resulting binary, the .rsrc section being present in the final PE formatted image.</li> </ol>"},{"location":"dyn/mu_basecore/BaseTools/Docs/feature_ver_spec/#32-current-constraints","title":"3.2 Current Constraints","text":"<p>Currently, Linux is not supported. You can track the progress of this work with this GitHub issue.</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/","title":"Mu BaseTools Notes","text":"<p>This is a set of compiled tools for Edk2 development on x86 for Windows and Linux.  This set has both the standard Edk2 tools as well as additional tools created for Project Mu.</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#where","title":"Where","text":"<p>Information about the TianoCore Edk2 Basetools can be found here:</p> <ul> <li>https://tianocore.org</li> <li>https://github.com/tianocore/edk2</li> <li>https://github.com/tianocore/edk2-BaseTools-win32</li> </ul> <p>Information about Project Mu can be found here:</p> <ul> <li>https://microsoft.github.io/mu/</li> <li>https://github.com/Microsoft/mu</li> <li>https://github.com/microsoft/mu_basecore</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#what","title":"What","text":"<p>TianoCore/Project Mu Edk2 Build tools</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#version","title":"Version","text":"<p>BaseTools binaries are versioned based on the Release branch they are associated with (e.g. release/201808, release/201811, etc.). The version format is YYYY.MM.XX where:</p> <ul> <li>YYYY is the 4-digit year</li> <li>MM is the 2-digit month</li> <li>XX is a point-release in case fixes are required</li> </ul> <p>Nuget version is AA.BB.CC</p> <ul> <li>If the version is a single number then make it the AA field and use zeros   for BB.CC</li> <li>Example:  version command is 20160912  then NuGet version is     20160912.0.0</li> <li>If a version has two numbers partitioned by a \"-\" then make those the AA.BB   fields and use zero for the CC</li> <li>Example: version command is 1234-56 then NuGet version is 1234.56.0</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Basetools/#process-to-publish-new-version-of-tool","title":"Process to publish new version of tool","text":"<ol> <li>Download desired version from</li> <li>Unzip</li> <li>Make a new folder (for my example I will call it \"new\")</li> <li>Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md)</li> <li>Copy the assets to publish into this new folder</li> <li>Run the &lt;TOOL&gt; -v command to see the version.</li> <li>Open cmd prompt in the NugetPublishing dir</li> <li>Pack and push</li> </ol> <pre><code>NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Basetools.config.json --Version &lt;nuget version here&gt; --InputFolderPath &lt;path to newly created folder here&gt;  --ApiKey &lt;your key here&gt;\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/","title":"Mu-Nasm Notes","text":"<p>This tool is the open source NASM assembler.  More information can be found at https://nasm.us/</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#where","title":"Where","text":"<p>Go to https://nasm.us and find the desired download.</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#what","title":"What","text":"<p>nasm.exe is the assembler.</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#version","title":"Version","text":"<pre><code>nasm.exe -v\n</code></pre> <p>Nuget version is AA.BB.CC</p> <ul> <li>The version command generally outputs a version in AA.BB.CC format.</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/Mu-Nasm/#process-to-publish-new-version-of-tool","title":"Process to publish new version of tool","text":"<ol> <li>Download desired version from nasm.us (Windows .exe and Linux .rpm)</li> <li>Unzip (unzipping RPM requires fork of 7z that supports Zstandard compression)</li> <li>Make a new folder (for my example I will call it \"new\")</li> <li>Make proper subfolders for each host. (Details in NugetPublishing/ReadMe.md)</li> <li>Copy the assets to publish into this new folder (in this case just nasm and ndisasm)</li> <li>Run the nasm.exe -v command to see the version.</li> <li>Open cmd prompt in the NugetPublishing dir</li> <li>Pack and push</li> </ol> <pre><code>NugetPublishing.py --Operation PackAndPush --ConfigFilePath Mu-Nasm.config.json --Version &lt;nuget version here&gt; --InputFolderPath &lt;path to newly created folder here&gt;  --ApiKey &lt;your key here&gt;\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/","title":"NugetPublishing","text":"<p>Tool to help create and publish nuget packages for Project Mu resources</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#usage","title":"Usage","text":"<p>See NugetPublishing.py -h  </p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#optional-host_specific-folders","title":"OPTIONAL: host_specific folders","text":"<p>The possible different setups for the host are: OS: Linux, Windows, Java Architecture: x86 or ARM Highest Order Bit: 32 or 64</p> <p>Before the path to the NuGet package contents is published, the Python environment can look inside at several subfolders and decide which one to use based on the Host OS, highest order bit available, and the architecture of the processor. To do so, add \"separated\" to your flags like so:</p> <pre><code>\"flags\": [\"host_specific\"],\n</code></pre> <p>If this flag is present, the environment will make a list possible subfolders that would be acceptable for the host machine. For this example, a 64 bit Windows machine with an x86 processor was used:</p> <ol> <li>Windows-x86-64</li> <li>Windows-x86</li> <li>Windows-64</li> <li>x86-64</li> <li>Windows</li> <li>x86</li> <li>64</li> </ol> <p>The environment will look for these folders, following this order, and select the first one it finds. If none are found, the flag will be ignored.</p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#authentication","title":"Authentication","text":"<p>For publishing most service providers require authentication.  The --ApiKey parameter allows the caller to supply a unique key for authorization.  There are numerous ways to authenticate. For example</p> <ul> <li>Azure Dev Ops:</li> <li>VSTS credential manager.  In an interactive session a dialog will popup for     the user to login</li> <li>Tokens can also be used as the API key.  Go to your account page to generate     a token that can push packages</li> <li>NuGet.org</li> <li>Must use an API key.  Go to your account page and generate a key.  </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#example-creating-new-config-file-for-first-use","title":"Example: Creating new config file for first use","text":"<p>This will create the config files and place them in the current directory:</p> <pre><code>NugetPublishing.py --Operation New --Name iasl --Author ProjectMu --ConfigFileFolderPath . --Description \"Description of item.\" --FeedUrl https://api.nuget.org/v3/index.json --ProjectUrl http://aka.ms/projectmu --LicenseType BSD2\n</code></pre> <p>For help run: <code>NugetPublishing.py --Operation New --help</code></p>"},{"location":"dyn/mu_basecore/BaseTools/NugetPublishing/ReadMe/#example-publishing-new-version-of-tool","title":"Example: Publishing new version of tool","text":"<p>Using an existing config file publish a new iasl.exe.  See the example file iasl.config.json</p> <ol> <li>Download version from acpica.org</li> <li>Unzip</li> <li>Make a new folder (for my example I will call it \"new\")</li> <li>Copy the assets to publish into this new folder (in this case just iasl.exe)</li> <li>Run the iasl.exe -v command to see the version.</li> <li>Open cmd prompt in the NugetPublishing dir</li> <li>Pack and push (here is my example command. )</li> </ol> <pre><code>NugetPublishing.py --Operation PackAndPush --ConfigFilePath iasl.config.json --Version 20180209.0.0 --InputFolderPath \"C:\\temp\\iasl-win-20180209\\new\"  --ApiKey &lt;your key here&gt;\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/","title":"Flash Descriptor Size Report Generator Plugin and Command Line Tool","text":""},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#about","title":"About","text":"<p>FdSizeReportGenerator is a UEFI Build Plugin and Command Line Tool used to parse EDK2 build reports and FDF files and then produce an HTML report of the module sizes and fd sizes.  The HTML report then allows deeper analysis of the Flash Usage, the Module Sizes, and overall breakdown of usage.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#uefi-build-plugin","title":"UEFI Build Plugin","text":"<p>When used in the plugin capacity this plugin will do its work in the do_post_build function.  This plugin uses the following variables from the build environment:</p> <ol> <li>BUILDREPORTING - [REQUIRED] - must be True otherwise plugin will not run</li> <li>BUILDREPORT_TYPES - [REQUIRED] - for FdSizeReport, should at least contain the FLASH parameter.</li> <li>FLASH_DEFINITION - [REQUIRED] - must point to the platform FDF file</li> <li>BUILDREPORT_FILE - [REQUIRED] - must point to the build report file</li> <li>FDSIZEREPORT_FILE - [OPTIONAL] - should be path for output HTML report.  If     not set default path will be set based on BUILD_OUTPUT_BASE variable</li> <li>PRODUCT_NAME - [OPTIONAL] - should give friendly product name</li> <li>BUILDID_STRING - [OPTIONAL] - should give friendly version string of     firmware version</li> </ol>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#integrating-into-a-self-describing-build-environment","title":"Integrating into a self describing build environment","text":"<p>In a self describing build environment, the self.env.SetValue can be used to set the environment variables</p> <p>The below example is relevant to supporting QemuQ35 platform</p> <pre><code>   self.env.SetValue(\"BUILDREPORTING\", \"TRUE\", \"Platform Hardcoded\")\nself.env.SetValue(\"BUILDREPORT_TYPES\", \"PCD DEPEX FLASH BUILD_FLAGS LIBRARY\", \"Platform Hardcoded\")\nself.env.SetValue(\"FLASH_DEFINITION\", \"QemuQ35Pkg.fdf\", \"Platform Hardcoded\")\nself.env.SetValue(\"BUILDREPORT_FILE\", \"BuildReport.txt\", \"Platform Hardcoded\")\nself.env.SetValue(\"PRODUCT_NAME\", \"QemuQ35\", \"Platform Hardcoded\")\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/FdSizeReport/ReadMe/#command-line-tool","title":"Command Line Tool","text":"<p>When used as a command line tool check the required parameters by using the -h option.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/","title":"Override Validation Plugin","text":"<p>Module Level Override Validation Plugin and Linkage Creation Command Line Tool</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#about","title":"About","text":"<p>OverrideValidation is a UEFI Build Plugin and Command Line Tool used to create linkage between overriding and overridden modules and parse INF files referenced in platform DSC files during build process and then produce a TXT report of the module overriding status.  The TXT report then allows deeper analysis of the Overriding Hierarchy, the Override Linkage Validity, the Override Linkage Ages, and overall breakdown of usage.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#uefi-build-plugin","title":"UEFI Build Plugin","text":"<p>When used in the plugin capacity this plugin will do its override linkage validation work in the do_pre_build function.  This plugin uses the following variables from the build environment:</p> <ol> <li>ACTIVE_PLATFORM - [REQUIRED] - must be workspace relative or package path     relative pointing to the target platform dsc file, otherwise this validation     will not run</li> <li>BUILD_OUTPUT_BASE - [REQUIRED] - must be an absolute path specified to store     override log at $(BUILD_OUTPUT_BASE)/OVERRIDELOG.TXT, otherwise no report     will be generated</li> <li>BUILDSHA - [OPTIONAL] - should have valid commit sha value for report     purpose, if not provided, 'None' will be used for the corresponding field</li> <li>PRODUCT_NAME - [OPTIONAL] - should give friendly product name, if not     provided, 'None' will be used for the corresponding field</li> <li>BUILDID_STRING - [OPTIONAL] - should give friendly version string of     firmware version, if not provided, 'None' will be used for the corresponding     field</li> </ol> <p>This tool provides two types of validation, determined by the type of tags included in the overriding module:</p> <ul> <li>Override: Override validation, as indicated by override tags, intends to enforce the validity of a linkage. Thus if the target that is overridden is either not found or has an change since the last linkage update, the build will break.</li> <li>Track: Track validation, indicated by track tags from tracking modules, intends to soft-track updates of certain module with various flavors across upstream changes. This validation will ignore this tag if the corresponding target is not found. If a single target is found in multiple track tags, there must be one and only one linkage that matches the current status of target, otherwise build will break.</li> </ul> <p>Note: If one module contains one or more track tags, at least one tracked target needs to be found, otherwise build   will break.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#command-line-tool","title":"Command Line Tool","text":"<p>When used as a command line tool, this tool takes the absolute path of workspace (the root directory of Devices repo) as well as the absolute path of overridden module's inf file and then generate a screen-print line for users to include in overriding modules in order to create override linkage. Check the required parameters by using the -h option for command line argument details.</p> <p>The override can also be used on the Active Platform DSC or the Flash Definition FDF defined by the DSC.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#example","title":"Example","text":"<p>Command to generate an override record:</p> <pre><code>OverrideValidation.py -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf\n</code></pre> <p>Override record to be included in overriding module's inf:</p> <pre><code>#Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17\n</code></pre> <p>Command to generate a track record:</p> <pre><code>OverrideValidation.py --track -w C:\\Repo -m C:\\Repo\\SM_UDK\\MdePkg\\Library\\BaseMemoryLib\\BaseMemoryLib.inf\n</code></pre> <p>Track record to be included in tracking module's inf:</p> <pre><code>#Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f\n</code></pre> <p>Track records to be included in tracking multiple flavors of the same module's inf (you should do not need this in a perfect world):</p> <pre><code># Production build\n#Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | 5bca19892b2e9f4c00a74041fa6b1eab | 2021-12-07T04-25-21 | 5c76ea08864294e11f8d7d1ac2ccf76c72673c8f\n# Debug build\n#Track : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | dbfc0ece0cb8fa499ac2141c80107926 | 2022-02-09T00-31-30 | fd114d321703a32c4684d8411ba0fe7dd7012c14\n</code></pre> <p>Command to generate an override record for a target file or directory:</p> <pre><code>OverrideValidation.py -w C:\\Repo -t C:\\Repo\\MU_BASECORE\\MdeModulePkg\\Library\\BaseSerialPortLib16550\n</code></pre> <p>Override record to be included in overriding module's inf:</p> <pre><code>#Override : 00000002 | MdeModulePkg/Library/BaseSerialPortLib16550 | 140759cf30a73b02f48cc1f226b015d8 | 2021-12-07T05-30-10 | fa99a33fdb7e8bf6063513fddb807105ec2fad81\n</code></pre> <p>Override log generated during pre-build process:</p> <pre><code>Platform:     PlatformName\nVersion:      123.456.7890\nDate:         2018-05-11T17-56-27\nCommit:       _SHA_2c9def7a4ce84ef26ed6597afcc60cee4e5c92c0\nState:        3/4\n\nOverrides\n----------------------------------------------------------------\n\nOVERRIDER: MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf\nORIGINALS:\n  + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days\n\nOVERRIDER: PlatformNamePkg/Library/NvmConfigLib/NvmConfigLib.inf\nORIGINALS:\n  + MdeModulePkg/Bus/Pci/NvmExpressDxe/NvmExpressDxe.inf | MISMATCH | 35 days\n  | Current State: 62929532257365b261080b7e7b1c4e7a | Last Fingerprint: dc9f5e3af1efbac6cf5485b672291903\n  + MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf | SUCCESS | 0 days\n  + MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | SUCCESS | 2 days\n  + MdeModulePkg/Library/BaseSerialPortLib16550 | SUCCESS | 7 days\n</code></pre> <p>Command to regenerate the override records in a given .inf file:</p> <pre><code>OverrideValidation.py -w c:\\src -r c:\\src\\FooPkg\\OverridingModule.inf\n</code></pre> <p>an example of the diff produced when using -r:</p> <pre><code>diff --git a/FooPkg/OverridingModule.inf b/FooPkg/OverridingModule.inf\nindex 2d4ca47299..90da207a39 100644\n--- a/FooPkg/OverridingModule.inf\n+++ b/FooPkg/OverridingModule.inf\n@@ -8,7 +8,7 @@\n#\n #\n-#Override : 00000002 | BarPkg/OverridenModule.inf | 4f7eed98e3c084eecdff5fa2e1e57db1 | 2021-11-23T21-41-21 | 44b40c0358489da6c444e7cfb2be26e56b7c16a1\n+#Override : 00000002 | BarPkg/OverridenModule.inf | 143b08782a2abc620d1eb57461c6e290 | 2022-03-10T23-09-45 | 6f8c53a3fcd79b202c708e7aa58256cafbf24bc4\n#\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#versions","title":"Versions","text":"<p>There are two versions of the override format.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#version-1","title":"Version 1","text":"<pre><code>#Override : 00000001 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#version-2","title":"Version 2","text":"<pre><code>#Override : 00000002 | MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf | cc255d9de141fccbdfca9ad02e0daa47 | 2018-05-09T17-54-17 | 575096df6a\n</code></pre> <p>Version 2 includes a second hash at the end, which is the git commit that the upstream was last updated. This allows to tools to do a <code>git diff</code> between what you currently have and what is in the tree. It currently only diffs the overridden file (the INF or DSC) and the overriding file.</p>"},{"location":"dyn/mu_basecore/BaseTools/Plugin/OverrideValidation/ReadMe/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright \u00a9 Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/BaseTools/Scripts/PackageDocumentTools/Readme/","title":"Package Document Tool","text":"<p>Prerequisite Tools:</p> <ol> <li>Install Python 2.7.3 from https://www.python.org/download/releases/2.7.3/</li> <li>Install wxPython 2.8.12.1 from https://sourceforge.net/projects/wxpython/files/wxPython/2.8.12.1/    generally the libraries will be installed at python's subfolder, for example in windows: c:\\python27\\Lib\\site-packages\\</li> <li>Install DoxyGen 1.8.6 from https://sourceforge.net/projects/doxygen/files/rel-1.8.6/</li> <li>(Windows only) Install Htmlhelp tool from https://msdn.microsoft.com/en-us/library/windows/desktop/ms669985(v=vs.85).aspx</li> </ol> <p>Limitation:</p> <ul> <li>Current tool doesn't work on latest wxPython and DoxyGen tool. Please use the sepecific version in above.</li> </ul> <p>Run the Tool:</p> <ul> <li> <p>Run with GUI:</p> <ol> <li>Enter src folder, double click \"packagedocapp.pyw\" or run command \"python packagedocapp.pyw\" to open the GUI.</li> <li>Make sure all the information in blank are correct.</li> <li>Click \"Generate Package Document!\"</li> </ol> </li> <li> <p>Run with command line:</p> <ol> <li>Open command line window</li> <li>Enter src folder, for example: \"cd C:\\PackageDocumentTools\\src\"</li> <li>Run \"python packagedoc_cli.py --help\" for detail command.</li> </ol> </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/","title":"Edk2 Basetools","text":"<p>This folder has traditionally held the source of Python based tools used by EDK2. The official repo this source has moved to https://github.com/tianocore/edk2-basetools. This folder will remain in the tree until the next stable release (expected 202102). There is a new folder under Basetools <code>BinPipWrappers</code> that uses the pip module rather than this tree for Basetools. By adding the scope <code>pipbuild-win</code> or <code>pipbuild-unix</code> (depending on your host system), the SDE will use the <code>BinPipWrappers</code> instead of the regular <code>BinWrappers</code>.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/#why-move-it","title":"Why Move It","text":"<p>The discussion is on the mailing list. The RFC is here: https://edk2.groups.io/g/rfc/topic/74009714#270 The benefits allow for the Basetools project to be used separately from EDK2 itself as well as offering it in a globally accessible manner. This makes it much easier to build a module using Basetools. Separating the Basetools into their own repo allows for easier CI and contribution process. Additional pros, cons, and process can be found on the mailing list.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/#how-do-i-install-it","title":"How Do I Install It","text":"<p>By default, EDK2 is tied to and tested with a specific version of the Basetools through <code>pip-requirements.txt</code>. You can simply run:</p> <pre><code>pip install -r pip-requirements.txt\n</code></pre> <p>This will install the required module, thought we strongly suggest setting up a virtual environment. Additionally, you can also install a local clone of the Basetools as well as a specific git commit.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/","title":"FMMT","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#overview","title":"Overview","text":"<p>This FMMT tool is the python implementation of the edk2 FMMT tool which locates at https://github.com/tianocore/edk2-staging/tree/FceFmmt This implementation has the same usage as the edk2 FMMT, but it's more readable and relaiable.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#fmmt-user-guide","title":"FMMT User Guide","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#last-updated-april-28-2022","title":"Last updated April 28, 2022","text":"<p>Important Changes and Updates:</p> <ul> <li>Oct 13, 2021 Initial Draft of FMMT Python Tool</li> <li>Apr 28, 2022 Optimize functions &amp; Command line</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#note","title":"Note","text":"<ul> <li>FMMT Python Tool keeps same function with origin FMMT C Tool. It is much easier to maintain and extend other functions.</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#known-issue","title":"Known issue","text":"<ul> <li>Currently, FMMT Python tool does not support PEIM rebase feature, this feature will be added in future update.</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#1-introduction","title":"1. Introduction","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#11-overview","title":"1.1  Overview","text":"<p>The Firmware Device is a persistent physical repository that contains firmware code and/or data. The firmware code and/or data stored in Firmware Volumes. Detail layout of Firmware Volumes is described in ?Figure 1. The Firmware Volume Format?.</p> <p></p> <p>?                                                   Figure 1. The Firmware Volume Format</p> <p>In firmware development, binary file has its firmware layout following the Platform-Initialization Specification. Thus, operation on FV file / FFS file (Firmware File) is an efficient and convenient way for firmware function testing and developing. FMMT Python tool is used for firmware files operation.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#12-tool-capabilities","title":"1.2  Tool Capabilities","text":"<p>The FMMT tool is capable of:</p> <ul> <li> <p>Parse a FD (Firmware Device) / FV (Firmware Volume) / FFS (Firmware Files)</p> </li> <li> <p>Add a new FFS into a FV file (both included in a FD file or not)</p> </li> <li> <p>Replace an FFS in a FV file with a new FFS file</p> </li> <li> <p>Delete an FFS in a FV file (both included in a FD file or not)</p> </li> <li> <p>Extract the FFS from a FV file (both included in a FD file or not)</p> </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#13-references","title":"1.3  References","text":"Document UEFI Platform Initialization (PI)  Specification"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#2-fmmt-python-tool-usage","title":"2. FMMT Python Tool Usage","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#21-required-files","title":"2.1  Required Files","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#211-independent-use","title":"2.1.1  Independent use","text":"<p>When independent use the FMMT Python Tool, the following files and settings are required:</p> <ul> <li> <p>GuidTool executable files used for Decompress/Compress Firmware data.</p> </li> <li> <p>Environment variables path with GuidTool path setting.</p> </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#212-use-with-build-system","title":"2.1.2  Use with Build System","text":"<p>When use the FMMT Python Tool with Build System:</p> <ul> <li> <p>If only use Edk2 based GuidTool, do not need other preparation.</p> </li> <li> <p>If use other customized GuidTool, need prepare the config file with GuidTool info. The syntax for GuidTool definition shown as follow:</p> </li> </ul> <p>ToolsGuid ShortName Command</p> <p>-- Example:  3d532050-5cda-4fd0-879e-0f7f630d5afb BROTLI BrotliCompress</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#22-syntax","title":"2.2  Syntax","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#221-syntax-for-parse-file","title":"2.2.1  Syntax for Parse file","text":"<p>-v &lt; Inputfile &gt; &lt; Outputfile &gt; -l &lt; LogFileType &gt; -c &lt; ConfigFilePath &gt;</p> <ul> <li>Parse Inputfile, show its firmware layout with log file. Outputfile is optional, if inputs, the Inputfile will be encapsulated into Outputfile following the parsed firmware layout. \"-l LogFileType\" is optional, it decides the format of log file which saves Binary layout. Currently supports: json, txt. More formats will be added in the future. \"-c ConfigFilePath \" is optional, target FmmtConf.ini file can be selected with this parameter. If not provided, default FmmtConf.ini file will be used.</li> <li>Ex: py -3 FMMT.py -v test.fd</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#222-syntax-for-add-a-new-ffs","title":"2.2.2  Syntax for Add a new FFS","text":"<p>-a  &lt; Inputfile &gt; &lt; TargetFvName/TargetFvGuid &gt; &lt; NewFfsFile &gt; &lt; Outputfile &gt;</p> <ul> <li>Add the NewFfsFile into Inputfile. TargetFvName/TargetFvGuid (Name or Guid) is the TargetFv which NewFfsFile will be added into.</li> <li>Ex: py -3 FMMT.py -a Ovmf.fd 6938079b-b503-4e3d-9d24-b28337a25806 NewAdd.ffs output.fd</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#223-syntax-for-delete-an-ffs","title":"2.2.3  Syntax for Delete an FFS","text":"<p>-d  &lt; Inputfile &gt; &lt; TargetFvName/TargetFvGuid &gt; &lt; TargetFfsName &gt; &lt; Outputfile &gt;</p> <ul> <li>Delete the Ffs from Inputfile. TargetFfsName (Guid) is the TargetFfs which will be deleted. TargetFvName/TargetFvGuid is optional, which is the parent of TargetFfs*.*</li> <li>Ex: py -3 FMMT.py -d Ovmf.fd 6938079b-b503-4e3d-9d24-b28337a25806 S3Resume2Pei output.fd</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#224-syntax-for-replace-an-ffs","title":"2.2.4  Syntax for Replace an FFS","text":"<p>?  -r  &lt; Inputfile &gt; &lt; TargetFvName/TargetFvGuid &gt; &lt; TargetFfsName &gt; &lt; NewFfsFile &gt; &lt; Outputfile &gt;</p> <ul> <li>Replace the Ffs with the NewFfsFile. TargetFfsName (Guid) is the TargetFfs which will be replaced. TargetFvName/TargetFvGuid is optional, which is the parent of TargetFfs*.*</li> <li>Ex: py -3 FMMT.py -r Ovmf.fd 6938079b-b503-4e3d-9d24-b28337a25806 S3Resume2Pei NewS3Resume2Pei.ffs output.fd</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#225-syntax-for-extract-an-ffs","title":"2.2.5  Syntax for Extract an FFS","text":"<p>-e  &lt; Inputfile &gt; &lt; TargetFvName/TargetFvGuid &gt; &lt; TargetFfsName &gt; &lt; Outputfile &gt;</p> <ul> <li>Extract the Ffs from the Inputfile. TargetFfsName (Guid) is the TargetFfs which will be extracted. TargetFvName/TargetFvGuid is optional, which is the parent of TargetFfs*.*</li> <li>Ex: py -3 FMMT.py -e Ovmf.fd 6938079b-b503-4e3d-9d24-b28337a25806 S3Resume2Pei output.fd</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#3-fmmt-python-tool-design","title":"3. FMMT Python Tool Design","text":"<p>FMMT Python Tool uses the NodeTree saves whole Firmware layout. Each Node have its Data field, which saves the FirmwareClass(FD/FV/FFS/SECTION/BINARY) Data. All the parse/add/delete/replace/extract operations are based on the NodeTree (adjusting the layout and data).</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#31-nodetree","title":"3.1  NodeTree","text":"<p>A whole NodeTree saves all the Firmware info.</p> <ul> <li> <p>Parent &amp; Child relationship figured out the Firmware layout.</p> </li> <li> <p>Each Node have several fields. ?Data? field saves an FirmwareClass instance which contains all the data info of the info.</p> </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#311-nodetree-format","title":"3.1.1  NodeTree Format","text":"<p>The NodeTree will be created with parse function. When parse a file, a Root Node will be initialized firstly. The Data split and Tree construction process is described with an FD file shown as ?Figure 2. The NodeTree format?:</p> <ul> <li> <p>A Root Node is initialized.</p> </li> <li> <p>Use the ?FV Signature? as FV key to split Whole FD Data. ?FV0?, ?FV1?, ?FV2?? Node created.</p> </li> <li> <p>After FV level Node created, use the ?Ffs Data Size? as FFS key to split each FV Data. ?Ffs0?...Node created.</p> </li> <li> <p>After FFS level Node created, use the ?Section Data Size? as Section key to split each Ffs Data. ?Section0?...Node created.</p> </li> <li> <p>If some of Section includes other Sections, continue use the ?Section Data Size? as Section key to split each Section Data.</p> </li> <li> <p>After all Node created, the whole NodeTree saves all the info. (Can be used in other functions or print the whole firmware layout into log file)</p> </li> </ul> <p></p> <p>?                                                         Figure 2. The NodeTree format</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#312-node-factory-and-product","title":"3.1.2  Node Factory and Product","text":"<p>As 3.1.1, Each Node is created by data split and recognition. To extend the NodeTree usage, Factory pattern is used in Node created process.</p> <p>Each Node have its Factory to create Product and use Product ParserData function to deal with the data.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#32-guidtool","title":"3.2  GuidTool","text":"<p>There are two ways to set the GuidTool. One from Config file, another from environment variables.</p> <p>Current GuidTool first check if has Config file.</p> <ul> <li> <p>If have, load the config GuidTool Information.</p> </li> <li> <p>Else get from environment variables.</p> </li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#321-get-from-config-file","title":"3.2.1  Get from Config file","text":"<ul> <li> <p>Config file should in same folder with FMMT.py or the path in environment variables.</p> </li> <li> <p>Content should follow the format:</p> </li> </ul> <p>ToolsGuid ShortName Command</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#322-get-from-environment-variables","title":"3.2.2  Get from Environment Variables","text":"<ul> <li>The GuidTool Command used must be set in environment variables.</li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/FMMT/#323-edk2-based-guidtool","title":"3.2.3  Edk2 Based GuidTool","text":"Guid ShortName Command a31280ad-481e-41b6-95e8-127f4c984779 TIANO TianoCompress ee4e5898-3914-4259-9d6e-dc7bd79403cf LZMA LzmaCompress fc1bcdb0-7d31-49aa-936a-a4600d9dd083 CRC32 GenCrc32 d42ae6bd-1352-4bfb-909a-ca72a6eae889 LZMAF86 LzmaF86Compress 3d532050-5cda-4fd0-879e-0f7f630d5afb BROTLI BrotliCompress"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/","title":"Step by step to generate sample self-signed X.509 certificate chain and sign data with PKCS7 structure","text":"<p>This readme demonstrates how to generate 3-layer X.509 certificate chain (RootCA -&gt; IntermediateCA -&gt; SigningCert) with OpenSSL commands, and user MUST set a UNIQUE Subject Name (\"Common Name\") on these three different certificates.</p>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#how-to-generate-a-self-signed-x509-certificate-chain-via-openssl","title":"How to generate a self-signed X.509 certificate chain via OPENSSL","text":""},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#set-openssl-environment","title":"Set OPENSSL environment","text":"<p>NOTE: Below steps are required for Windows. Linux may already have the OPENSSL environment correctly.</p> <pre><code>set OPENSSL_HOME=c:\\home\\openssl\\openssl-[version]\nset OPENSSL_CONF=%OPENSSL_HOME%\\apps\\openssl.cnf\n</code></pre> <p>When a user uses OpenSSL (req or ca command) to generate the certificates, OpenSSL will use the openssl.cnf file as the configuration data (can use \"-config path/to/openssl.cnf\" to describe the specific config file).</p> <p>The user need check the openssl.cnf file, to find your CA path setting, e.g. check if the path exists in [ CA_default ] section.</p> <pre><code>[ CA_default ]\n    dir = ./demoCA              # Where everything is kept\n</code></pre> <p>You may need the following steps for initialization:</p> <pre><code>rd ./demoCA /S/Q\nmkdir ./demoCA\necho.&gt;./demoCA/index.txt\necho 01 &gt; ./demoCA/serial\nmkdir ./demoCA/newcerts\n</code></pre> <p>OpenSSL will apply the options from the specified sections in openssl.cnf when creating certificates or certificate signing requests. Make sure your configuration in <code>openssl.cnf</code> is correct and rational for certificate constraints. The following sample sections were used when generating test certificates in this readme.</p> <pre><code>[ req ]\ndefault_bits        = 2048\ndefault_keyfile     = privkey.pem\ndistinguished_name  = req_distinguished_name\nattributes          = req_attributes\nx509_extensions     = v3_ca       # The extensions to add to the self signed cert\n...\n[ v3_ca ]\n# Extensions for a typical Root CA.\nsubjectKeyIdentifier=hash\nauthorityKeyIdentifier=keyid:always,issuer\nbasicConstraints = critical,CA:true\nkeyUsage = critical, digitalSignature, cRLSign, keyCertSign\n...\n[ v3_intermediate_ca ]\n# Extensions for a typical intermediate CA.\nsubjectKeyIdentifier = hash\nauthorityKeyIdentifier = keyid:always,issuer\nbasicConstraints = critical, CA:true\nkeyUsage = critical, digitalSignature, cRLSign, keyCertSign\n...\n[ usr_cert ]\n# Extensions for user end certificates.\nbasicConstraints = CA:FALSE\nnsCertType = client, email\nsubjectKeyIdentifier = hash\nauthorityKeyIdentifier = keyid,issuer\nkeyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, emailProtection\n...\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-the-certificate-chain","title":"Generate the certificate chain","text":"<p>NOTE: User MUST set a UNIQUE \"Common Name\" on the different certificate</p> <p>1) Generate the Root Pair:</p> <pre><code>* Generate a root key:\n\n    ```cmd\n    openssl genrsa -aes256 -out TestRoot.key 2048\n    ```\n\n* Generate a self-signed root certificate:\n\n    ```cmd\n    openssl req -extensions v3_ca -new -x509 -days 3650 -key TestRoot.key -out TestRoot.crt\n    openssl x509 -in TestRoot.crt -out TestRoot.cer -outform DER\n    openssl x509 -inform DER -in TestRoot.cer -outform PEM -out TestRoot.pub.pem\n    ```\n</code></pre> <p>2) Generate the Intermediate Pair:</p> <pre><code>* Generate the intermediate key:\n\n    ```cmd\n    openssl genrsa -aes256 -out TestSub.key 2048\n    ```\n\n* Generate the intermediate certificate:\n\n    ```cmd\n    openssl req -new -days 3650 -key TestSub.key -out TestSub.csr\n    openssl ca -extensions v3_intermediate_ca -in TestSub.csr -days 3650 -out TestSub.crt -cert TestRoot.crt -keyfile TestRoot.key\n    openssl x509 -in TestSub.crt -out TestSub.cer -outform DER\n    openssl x509 -inform DER -in TestSub.cer -outform PEM -out TestSub.pub.pem\n    ```\n</code></pre> <p>3) Generate User Key Pair for Data Signing:</p> <pre><code>* Generate User key:\n\n```cmd\nopenssl genrsa -aes256 -out TestCert.key 2048\n```\n\n* Generate User certificate:\n\n```cmd\nopenssl req -new -days 3650 -key TestCert.key -out TestCert.csr\nopenssl ca -extensions usr_cert -in TestCert.csr -days 3650 -out TestCert.crt -cert TestSub.crt -keyfile TestSub.key\nopenssl x509 -in TestCert.crt -out TestCert.cer -outform DER\nopenssl x509 -inform DER -in TestCert.cer -outform PEM -out TestCert.pub.pem\n```\n\n* Convert Key and Certificate for signing  Password is removed with -nodes flag for convenience in this sample.\n\n```cmd\nopenssl pkcs12 -export -out TestCert.pfx -inkey TestCert.key -in TestCert.crt\nopenssl pkcs12 -in TestCert.pfx -nodes -out TestCert.pem\n```\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#verify-data-signing-verification-with-new-x509-certificate-chain","title":"Verify Data Signing &amp; Verification with new X.509 Certificate Chain","text":"<p>1) Sign a Binary File to generate a detached PKCS7 signature:</p> <pre><code>```cmd\nopenssl smime -sign -binary -signer TestCert.pem -outform DER -md sha256 -certfile TestSub.pub.pem -out test.bin.p7 -in test.bin\n```\n</code></pre> <p>2) Verify PKCS7 Signature of a Binary File:</p> <pre><code>```cmd\nopenssl smime -verify -inform DER -in test.bin.p7 -content test.bin -CAfile TestRoot.pub.pem -out test.org.bin\n```\n</code></pre>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-dsc-pcd-include-files-for-certificate","title":"Generate DSC PCD include files for Certificate","text":"<p>The <code>BinToPcd</code> utility can be used to convert the binary Certificate file to a text file can be included from a DSC file to set a PCD to the contents of the Certificate file.</p> <p>The following 2 PCDs can be set to the PKCS7 Certificate value.  The first one supports a single certificate.  The second one supports multiple certificate values using the XDR format.</p> <ul> <li><code>gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer</code></li> <li><code>gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr</code></li> </ul>"},{"location":"dyn/mu_basecore/BaseTools/Source/Python/Pkcs7Sign/Readme/#generate-dsc-pcd-include-files","title":"Generate DSC PCD include files","text":"<pre><code>BinToPcd.py -i TestRoot.cer -p gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer -o TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc\nBinToPcd.py -i TestRoot.cer -p gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr -x -o TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc\n</code></pre> <p>These files can be used in <code>!include</code> statements in DSC file PCD sections.  For example:</p> <ul> <li> <p>Platform scoped fixed at build PCD section</p> <pre><code>[PcdsFixedAtBuild]\n!include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gEfiSecurityPkgTokenSpaceGuid.PcdPkcs7CertBuffer.inc\n</code></pre> </li> <li> <p>Platform scoped patchable in module PCD section</p> <pre><code>[PcdsPatchableInModule]\n!include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc\n</code></pre> </li> <li> <p>Module scoped fixed at build PCD section</p> <pre><code>[Components]\nFmpDevicePkg/FmpDxe/FmpDxe.inf {\n    &lt;PcdsFixedAtBuild&gt;\n    !include BaseTools/Source/Python/Pkcs7Sign/TestRoot.cer.gFmpDevicePkgTokenSpaceGuid.PcdFmpDevicePkcs7CertBufferXdr.inc\n}\n</code></pre> </li> </ul>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/","title":"Crypto Driver","text":"<p>This is a potentially prepacked version of the BaseCryptLib and TlsLib, delivered via protocol.</p> <p>There are two routes: using the pre-compiled version and compiling it into your platform.</p>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#benefits","title":"Benefits","text":"<p>But first, why would you care about this?</p> <p>It has a few benefits, namely:</p> <ul> <li>Smaller Binary sizes</li> <li>Easier to service/upgrade</li> <li>Transparency on what version of crypto you're using</li> <li>Reduced build times (if using pre-compiled version)</li> </ul> <p>There are different flavors of Crypto available, with different functions supported. Don't need to use HMAC in your PEI phase? Select a service level or flavor that doesn't include HMAC in your platform.</p>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#how-include-on-your-platform","title":"How include on your platform","text":"<p>Now there are a few options for you. We'll start with the pre-compiled route.</p>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#the-pre-compiled-easy-way","title":"The Pre-compiled (easy) way","text":"<p>The easy way involves setting a few variables and a few includes. The hard way is just to do it yourself.</p> <p>First the easy way:</p> <ol> <li> <p>Define the service level that you want for each phase of UEFI in the defines section of your DSC.</p> <pre><code>[Defines]\n    DEFINE PEI_CRYPTO_SERVICES = TINY_SHA\n    DEFINE DXE_CRYPTO_SERVICES = STANDARD\n    DEFINE SMM_CRYPTO_SERVICES = STANDARD\n    DEFINE PEI_CRYPTO_ARCH = IA32\n    DEFINE DXE_CRYPTO_ARCH = X64\n    DEFINE SMM_CRYPTO_ARCH = X64\n</code></pre> <p>The above example is for a standard intel platform, and the service levels or flavors available.</p> </li> <li> <p>Add the DSC include</p> <pre><code>!include CryptoPkg/Driver/Bin/CryptoDriver.inc.dsc\n</code></pre> <p>This sets the definitions for BaseCryptLib as well as includes the correct flavor level of the component you wish to use.</p> </li> <li> <p>Add the FDF includes to your platform FDF</p> <p>Currently, it isn't possible in an FDF to redefine a FV section and have them be combined. There are two includes: BOOTBLOCK and DXE. The first includes the PEI phase and is meant to be stuck in your BOOTBLOCK FV. The second contains the DXE and SMM modules and is meant to be stuck in your FVDXE.</p> <pre><code>[FV.FVBOOTBLOCK]\n  ...\n!include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf\n...\n\n[FV.FVDXE]\n  ...\n  !include CryptoPkg/Driver/Bin/CryptoDriver.DXE.inc.fdf\n</code></pre> </li> </ol>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#recommendations","title":"Recommendations","text":"<p>It is highly recommended to put this logic behind conditionals like so:</p> <pre><code>[FV.FVBOOTBLOCK]\n!if $(ENABLE_SHARED_CRYPTO) == TRUE\n  !include CryptoPkg/Driver/Bin/CryptoDriver.BOOTBLOCK.inc.fdf\n!endif\n</code></pre> <p>This allows developers on the platform to use their own BaseCryptLib or TlsLib if they want. Just add a check if it's not defined in your DSC like so.</p> <pre><code>!ifndef ENABLE_SHARED_CRYPTO # by default true\n  ENABLE_SHARED_CRYPTO = TRUE\n!endif\n</code></pre>"},{"location":"dyn/mu_basecore/CryptoPkg/Driver/readme/#the-diy-way","title":"The DIY way","text":"<p>If you want to take advantage of the BaseCryptOnProtocol but don't want to use a pre-compiled method, you can compile it within your platform itself.</p> <p>Shown here is for an Intel platform, adjust the architectures as needed.</p> <pre><code>[LibraryClasses.IA32]\n  BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf\n  TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/PeiCryptLib.inf\n\n[LibraryClasses.X64]\n  BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf\n  TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/DxeCryptLib.inf\n\n[LibraryClasses.X64.DXE_SMM_DRIVER]\n  BaseCryptLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf\n  TlsLib|CryptoPkg/Library/BaseCryptLibOnProtocolPpi/SmmCryptLib.inf\n\n[Components.IA32]\n  CryptoPkg/Driver/CryptoPei.inf {\n      &lt;LibraryClasses&gt;\n        BaseCryptLib|CryptoPkg/Library/BaseCryptLib/PeiCryptLib.inf\n        TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf\n      &lt;PcdsFixedAtBuild&gt;\n        .. All the flavor PCDs here ..\n  }\n\n[Components.X64]\n  CryptoPkg/Driver/CryptoDxe.inf {\n      &lt;LibraryClasses&gt;\n        BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf\n        TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf\n      &lt;PcdsFixedAtBuild&gt;\n        .. All the flavor PCDs here ..\n  }\n  CryptoPkg/Driver/CryptoSmm.inf {\n      &lt;LibraryClasses&gt;\n        BaseCryptLib|CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf\n        TlsLib|CryptoPkg/Library/TlsLibNull/TlsLibNull.inf\n      &lt;PcdsFixedAtBuild&gt;\n        .. All the flavor PCDs here ..\n  }\n</code></pre> <p>The PCDs are long and default to all false. The flavors are stored as .inc.dsc files at <code>CryptoPkg\\Driver\\Packaging</code>. An example would be <code>CryptoPkg\\Driver\\Packaging\\Crypto.pcd.TINY_SHA.inc.dsc</code> which is a flavor that just has Sha1, Sha256, and Sha386.</p> <p>You'll need to include these components in your FDF as well.</p> <pre><code>[FV.FVBOOTBLOCK]\n  INF CryptoPkg/Driver/CryptoPei.inf\n[FV.FVDXE]\n  INF CryptoPkg/Driver/CryptoSmm.inf\n  INF CryptoPkg/Driver/CryptoDxe.inf\n</code></pre>"},{"location":"dyn/mu_basecore/CryptoPkg/Library/BaseCryptLibOnProtocolPpi/readme/","title":"BaseCryptLibOnProtocolPpi","text":"<p>This is an implementation of BaseCryptLib that uses a protocol.</p> <p>This makes binaries smaller, makes servicing easier, and allows crypto to be pre-compiled.</p> <p>See CryptoPkg/Driver/readme.md for more information.</p>"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/","title":"OpenSSL Native Instructions","text":"<p>The OpenSSL assembly files are traditionally generated at build time using a perl script. To avoid that burden on EDK2 users, these end-result assembly files are generated during the configuration steps through process_files.pl.</p>"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/#generating-the-assembly-files","title":"Generating the assembly files","text":"<p>This only needs to be done when updating to a new OpenSSL version.</p> <p>Due to the script wrapping required to process the OpenSSL configuration data, each native architecture must be processed individually (in addition to the standard version). Furthermore the standard version must be processed first before processing any other ARCH.</p> <p>Current supported ARCHs: [X64, X64Gcc, A32].</p> <p>[From the OpenSSL library directory]</p> <ol> <li>./process_files.pl</li> <li>./process_files.pl X64</li> <li>./process_files.pl [Arch] etc.</li> </ol>"},{"location":"dyn/mu_basecore/CryptoPkg/Library/OpensslLib/readme/#how-include-on-your-platform","title":"How include on your platform","text":"<p>To include the precompiled OpenSSL native instructions you need to reference the specific architecture .inf file within you dsc file as well as include the appropriate align size within the build options.</p> <p>Note: In the build options the correct alignments are:</p> <ol> <li>256 for 64-bit</li> <li>64 for 32-bit</li> </ol> <p>Note: Specificity of where to put the buildoptions and library class references will vary.</p> <p>Example with X64:</p> <pre><code>[LibraryClasses]\n  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibX64.inf\n</code></pre> <pre><code>[BuildOptions.X64]\n  MSFT:*_*_*_DLINK_FLAGS = /ALIGN:256\n</code></pre> <p>Example with IA32:</p> <pre><code>[LibraryClasses]\n  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLibIA32.inf\n</code></pre> <pre><code>[BuildOptions.X64]\n  MSFT:*_*_*_DLINK_FLAGS = /ALIGN:64\n</code></pre>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/","title":"Memory Protections","text":"<p>The Memory Protection Settings add safety functionality such as page and pool guards, stack guard and null pointer detection. The settings are split between MM and DXE environments for modularity. The target audience for this doc has intermediate knowledge of systems programming and working with EDK II.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#useful-terms-and-concepts-linked-in-text-if-used","title":"Useful Terms and Concepts (Linked in Text if Used)","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#option-rom","title":"Option ROM","text":"<p>A driver that interfaces between BIOS services and hardware.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#boot-strap-processor-bsp","title":"Boot Strap Processor (BSP)","text":"<p>The bootstrap processor (BSP) handles initialization procedures for the system as a whole. These procedures include checking the integrity of memory, identifying properties of the system logic and starting the remaining processors.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#application-processor-ap","title":"Application Processor (AP)","text":"<p>A system processor used for processing signals in embedded systems.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#boot-loader","title":"Boot Loader","text":"<p>Places into working memory the required resources for runtime.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#read-only-ro","title":"Read Only (RO)","text":"<p>A bit used to mark certain areas of memory as non-writeable.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#no-executeexecute-neverexecute-disable-attribute-nxxnxd","title":"No eXecute/eXecute Never/eXecute Disable Attribute (NX/XN/XD)","text":"<p>A bit used to mark certain areas of memory as non-executable. NX is a term usually used by AMD whereas XD is used by Intel and XN by Qualcomm. The only difference between NX, XD, and XN are their names.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#physicalpage-address-extension","title":"Physical/Page Address Extension","text":"<p>A memory management feature in x86 architecture which defines a page table heirarchy with table entries of 64 bits allowing CPUs to directly address physical address spaces larger than 32 bits (4 GB).</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#model-specific-register-msr","title":"Model-specific Register (MSR)","text":"<p>Any of the various control registers in the x86 instruction set used for debugging, execution tracing, performance monitoring and CPU feature toggling.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#endofdxe","title":"EndOfDxe","text":"<p>The point at which the driver execution (DXE) phase has ended and all drivers provided by the mfg (as part of the built-in ROM or loaded directly from another driver) should be loaded now, or else they have failed their dependency expressions. UEFI drivers and OpROMs have not yet been started.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#page-fault-exception-pf","title":"Page Fault Exception (#PF)","text":"<p>An exception raised when EDK II code attempts to access memory which is not present or settings for the page make it invisible.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#task-state-segment-tss","title":"Task State Segment (TSS)","text":"<p>A structure on x86-based CPUs which holds information about a unit of execution.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#cpu-context-dump","title":"Cpu Context Dump","text":"<p>A routine which prints to serial out the module in which the fault occurred, type of fault which occurred and contents of each CPU register.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#memory-management-unit-mmu","title":"Memory Management Unit (MMU)","text":"<p>Hardware on a CPU which is primarily responsible for translating Virtual Memory addresses to Physical ones.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#translation-lookaside-buffer-tlb","title":"Translation Lookaside Buffer (TLB)","text":"<p>A memory cache which is part of the CPUs MMU and stores translations of Virtual Memory to Physical Memory. The addresses stored in the TLB are dictated by some algorithm intended to decrease amount of memory accesses for which the address translation is outside the TLB.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nxcompat","title":"NXCOMPAT","text":"<p>NXCOMPAT is a DLL flag which indicates that the loaded binary expects memory allocations to have the NX attribute applied which will be removed when the code is copied into the memory. NXCOMPAT images should also apply RO to the memory before execution to ensure that, at any point in time, all memory is executable or read-only but not both.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nonstop-mode","title":"Nonstop Mode","text":"<p>In the case of Non-Stop mode being enabled for either HeapGuardPolicy or NullPointerDetectionPolicy, two exception handlers are registered. The first handler runs whenever the heap guard or null pointer page absences trigger a #PF. If Non-Stop mode is enabled for this type of #PF, the absent page(s) are temporarily set to be present and a Cpu Context Dump is run after which the second exception handler registered (the debug handler) is run. The debug handler sets the page to be present and clears the TLB to remove the current translation for the page which caused the #PF. Once these two handlers have run, code execution continues.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#stack-cookies","title":"Stack Cookies","text":"<p>A stack cookie (also called stack canary) is an integer placed in memory just before the stack return pointer. Most buffer overflows overwrite memory from lower to higher memory addresses, so in order to overwrite the return pointer (and thus take control of the process) the canary value must also be overwritten. This value is checked to make sure it has not changed before a routine uses the return pointer on the stack.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#null-pointer-detection","title":"Null Pointer Detection","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary","title":"Summary","text":"<p>Pages are allocated in 4KB chunks. This policy marks the 4KB page at the NULL address to be not present to detect NULL pointer references in Dxe and/or platform MM.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#dxe-available-settings","title":"Dxe Available Settings","text":"<ul> <li>UefiNullDetection  - Enable NULL pointer detection for DXE</li> <li>DisableEndOfDxe    - Disable NULL pointer detection just after EndOfDxe</li> <li>DisableReadyToBoot - Disable NULL pointer detection just after ReadyToBoot</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#mm-available-settings","title":"MM Available Settings","text":"<p>If NullPointerDetectionPolicy is TRUE, the present bit for the NULL page is cleared for SMM address space.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#image-protection-policy","title":"Image Protection Policy","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_1","title":"Summary","text":"<p>This policy enables an image to be protected by DxeCore if it is page-aligned, meaning the code sections become read-only, and the data sections become non-executable. This policy is only available in the DXE environment.</p> <p>There are 3 environment assumptions for enabling image protection:</p> <ol> <li> <p>The PE code section and data sections are not merged. If those 2 sections are merged, a [#PF](#page-fault-exception-(aka-#pf) exception might be generated because the CPU may try to write read-only data in data section or execute an NX instruction in the code section.</p> </li> <li> <p>The PE image can be protected if it is page aligned. This feature should NOT be used if there is any self-modifying code in the code region.</p> </li> <li> <p>A platform may not disable NX in the DXE phase. If a platform disables NX in the DXE phase, the x86 page table will become invalid because the NX bit in the page table entry becomes a RESERVED bit and a #PF exception will be generated. If a platform wants to disable the NX bit, it must occur in the PEI phase.</p> </li> </ol>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead","title":"Overhead","text":"<p>O(n) time and space overhead. Each image requires a 6K attributes header, so if there are n images the space overhead will be 6K*n and thus O(n) time to populate the headers. In most cases the number of images is in the order of hundreds making this feature relatively inexpensive.</p> <p>Because this feature requires aligned images, there will likely be an increased size footprint for each image.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings","title":"Available Settings","text":"<ul> <li>FromUnknown                  - Protect images from unknown devices</li> <li>FromFv                       - Protect images from firmware volume</li> <li>RaiseErrorIfProtectionFails  - If set, images which fail to be protected will be unloaded. This excludes failure because CPU Arch Protocol has not yet been installed</li> <li>BlockImagesWithoutNxFlag     - NX may be set on EfiLoaderCode, EfiBootServicesCode, and EfiRuntimeServicesCode if the setting for each is active in the NX Memory Protection Policy. However, if the image does not indicate support for NX via the NXCOMPAT DLL flag in the header, the logic will cease to set the NX attribute on allocations of memory of type EfiLoaderCode, EfiBootServicesCode, and/or EfiRuntimeServicesCode. Using the BlockImagesWithoutNxFlag setting in this policy will prevent images which don't support NXCOMPAT from loading and thus cause NX to continue to be applied to allocations of a code memory type based on their respective setting in the NX Memory Protection Policy.</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#nx-memory-protection-policy","title":"NX Memory Protection Policy","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_2","title":"Summary","text":"<p>This policy sets the NX attribute to memory of the associated memory type. This setting does not apply to MM.</p> <p>Every active memory type will be mapped as non-executable. Note that a portion of memory will only be marked as non-executable once the CPU Architectural Protocol is available. Also note that in order to enable Data Execution Protection, the operating system needs to set the IA32_EFER.NXE bit in the IA32_EFER MSR, and then set the XD bit in the CPU PAE page table.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_1","title":"Overhead","text":"<p>O(n) time where n is the number of memory mapped regions. The number of actual set bits beyond one is inconsequential because every memory region must be checked if at least one bit is set. There is no extra space complexity due to using the already present NX bit.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings_1","title":"Available Settings","text":"<ul> <li>EfiReservedMemoryType</li> <li>EfiLoaderCode - If an image does not indicate support for NX via the NXCOMPAT DLL flag, the logic will cease to set the NX attribute on allocations of memory this type. Using the BlockImagesWithoutNxFlag in the Image Protection Policy will prevent images which don't support NXCOMPAT.</li> <li>EfiLoaderData</li> <li>EfiBootServicesCode - Same note as EfiLoaderCode.</li> <li>EfiBootServicesData</li> <li>EfiRuntimeServicesCode - Same note as EfiLoaderCode.</li> <li>EfiRuntimeServicesData</li> <li>EfiConventionalMemory</li> <li>EfiUnusableMemory</li> <li>EfiACPIReclaimMemory</li> <li>EfiACPIMemoryNVS</li> <li>EfiMemoryMappedIO</li> <li>EfiMemoryMappedIOPortSpace</li> <li>EfiPalCode</li> <li>EfiPersistentMemory</li> <li>OEMReserved</li> <li>OSReserved</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#page-guards","title":"Page Guards","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_3","title":"Summary","text":"<p>The HeapGuardPageType policy implements guard pages on the specified memory types to detect heap overflow. If a bit is set, a guard page will be added before and after the corresponding type of page allocated if there's enough free pages for all of them. Guard pages are set to NOT PRESENT so any attempt to access them will cause a #PF. The system will do its best to ensure that only one guard page separates two allocated pages to avoid wasted space.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_2","title":"Overhead","text":"<p>O(n) time where n is the number of page allocations/frees. Because there are 2 extra pages allocated for every call to AllocatePages(), O(n) space is also required.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings-for-dxe-and-mm","title":"Available Settings for DXE and MM","text":"<ul> <li>EfiReservedMemoryType</li> <li>EfiLoaderCode</li> <li>EfiLoaderData</li> <li>EfiBootServicesCode</li> <li>EfiBootServicesData</li> <li>EfiRuntimeServicesCode</li> <li>EfiRuntimeServicesData</li> <li>EfiConventionalMemory</li> <li>EfiUnusableMemory</li> <li>EfiACPIReclaimMemory</li> <li>EfiACPIMemoryNVS</li> <li>EfiMemoryMappedIO</li> <li>EfiMemoryMappedIOPortSpace</li> <li>EfiPalCode</li> <li>EfiPersistentMemory</li> <li>OEMReserved</li> <li>OSReserved</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#pool-guards","title":"Pool Guards","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_4","title":"Summary","text":"<p>The HeapGuardPoolType policy is essentially the same as HeapGuardPageType policy. For each active memory type, a guard page will be added just before and after the portion of memory which the allocated pool occupies. The only added complexity comes when the allocated pool is not a multiple of the size of a page. In this case, the pool must align with either the head or tail guard page, meaning either overflow or underflow can be caught consistently but not both. The head/tail alignment is set in HeapGuardPolicy - look there for additional details.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_3","title":"Overhead","text":"<p>Same as above: O(n) time and space for same reasons as HeapGuardPageType. Note that this functionality requires creating guard pages, meaning that for n allocations, 4k * (n + 1) (assuming each of the n pools is adjacent to another pool) additional space is required.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#available-settings-for-dxe-and-mm_1","title":"Available Settings for DXE and MM","text":"<ul> <li>EfiReservedMemoryType</li> <li>EfiLoaderCode</li> <li>EfiLoaderData</li> <li>EfiBootServicesCode</li> <li>EfiBootServicesData</li> <li>EfiRuntimeServicesCode</li> <li>EfiRuntimeServicesData</li> <li>EfiConventionalMemory</li> <li>EfiUnusableMemory</li> <li>EfiACPIReclaimMemory</li> <li>EfiACPIMemoryNVS</li> <li>EfiMemoryMappedIO</li> <li>EfiMemoryMappedIOPortSpace</li> <li>EfiPalCode</li> <li>EfiPersistentMemory</li> <li>OEMReserved</li> <li>OSReserved</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#heapguardpolicy","title":"HeapGuardPolicy","text":""},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#summary_5","title":"Summary","text":"<p>While the above two policies (Pool Guards and Page Guards act as a switch for each protectable memory type, this policy is an enable/disable switch for those two policies (ex. if UefiPageGuard is unset, page guards in DXE are inactive regardless of the Page Guard settings).</p> <p>The only aspect of this policy which should be elaborated upon is Direction. Direction dictates whether an allocated pool which does not fit perfectly into a multiple of pages is aligned to the head or tail guard. The following Figure shows examples of the two:</p> <p></p> <p>On free the pool head/tail is checked to ensure it was not overwritten while the not-present page will trigger a page fault immediately.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_4","title":"Overhead","text":"<p>Overhead is same as Page Guards and Pool Guards.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#dxe-available-settings_1","title":"DXE Available Settings","text":"<ul> <li>UefiPageGuard - Enable UEFI page guard</li> <li>UefiPoolGuard - Enable UEFI pool guard</li> <li>UefiFreedMemoryGuard - Enable Use-After-Free memory detection</li> <li>Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#mm-available-settings_1","title":"MM Available Settings","text":"<ul> <li>SmmPageGuard - Enable SMM page guard</li> <li>SmmPoolGuard - Enable SMM pool guard</li> <li>Direction - Specifies the direction of Guard Page for Pool Guard. If 0, the returned pool is near the tail guard page. If 1, the returned pool is near the head guard page. The default value for this is 0</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#cpu-stack-guard","title":"CPU Stack Guard","text":"<p>The CpuStackGuard policy indicates if UEFI Stack Guard will be enabled.</p> <p>The stack guards add two additional pages to the bottom of the stack(s). The first page is simply the guard page which is set to not present. When a page fault occurs, the current stack address is invalid and so it is not possible to push the error code and architecture status onto the current stack. Because of this, there is a special \"Exception Stack\" or \"Known Good Stack\" which is the second page placed at the bottom of the stack. This page is reserved for use by the exception handler and ensures that a valid stack is always present when an exception occurs for error reporting.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#a-note-on-smm","title":"A note on SMM","text":"<p>An equivalent SMM stack guard feature is contained in PiSmmCpuDxeSmm and is not dictated by this policy.</p> <p>Note that the UEFI stack protection starts in DxeIpl, because the region is fixed, and requires PcdDxeIplBuildPageTables to be TRUE. In Project Mu, we have hard-coded CpuStackGuard to be TRUE in PEI phase, so we always set up a switch stack, clear the PRESENT bit in the page table for the guard page of the Boot Strap Processor stack, and build the page tables. However, the stack switch handlers will still only be installed in DXE phase if CpuStackGuard is TRUE.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#overhead_5","title":"Overhead","text":"<p>O(1) time and space.</p> <p>Setting:</p> <ul> <li>If TRUE, UEFI Stack Guard will be enabled.</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#stack-cookies_1","title":"Stack Cookies","text":"<p>Stack Cookies enable protection of the stack return pointer. The stack cookie value is specific to each loaded image and is generated at random on image load. Stack cookies are enabled at compile time, but if this setting is FALSE the interrupts generated by stack cookie check failures should be ignored.</p> <p>Setting:</p> <ul> <li>If TRUE, stack cookie failures will cause a warm reset. If FALSE, stack cookie failure interrupts will be ignored.</li> </ul>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#how-to-set-the-memory-protection-policy","title":"How to Set the Memory Protection Policy","text":"<p>For DXE settings, add the following to the platform DSC file:</p> <pre><code>[LibraryClasses.Common.DXE_DRIVER, LibraryClasses.Common.DXE_CORE, LibraryClasses.Common.UEFI_APPLICATION]\nDxeMemoryProtectionHobLib|MdeModulePkg/Library/MemoryProtectionHobLib/DxeMemoryProtectionHobLib.inf\n</code></pre> <p>For MM settings, add the following to the platform DSC file if the platform utilizes SMM:</p> <pre><code>[LibraryClasses.common.SMM_CORE, LibraryClasses.common.DXE_SMM_DRIVER]\nMmMemoryProtectionHobLib|MdeModulePkg/Library/MemoryProtectionHobLib/SmmMemoryProtectionHobLib.inf\n</code></pre> <p>or the following if the platform utilizes Standalone MM:</p> <pre><code>[LibraryClasses.common.MM_CORE_STANDALONE, LibraryClasses.common.MM_STANDALONE]\nMmMemoryProtectionHobLib|MdeModulePkg/Library/MemoryProtectionHobLib/StandaloneMmMemoryProtectionHobLib.inf\n</code></pre> <p>Create the HOB entry in any PEI module by adding the include:</p> <pre><code>#include &lt;Guid/DxeMemoryProtectionSettings.h&gt;\n#include &lt;Guid/MmMemoryProtectionSettings.h&gt;\n</code></pre> <p>and somewhere within the code doing something like:</p> <pre><code>  DXE_MEMORY_PROTECTION_SETTINGS  DxeSettings;\nMM_MEMORY_PROTECTION_SETTINGS   MmSettings;\n\nDxeSettings = (DXE_MEMORY_PROTECTION_SETTINGS)DXE_MEMORY_PROTECTION_SETTINGS_DEBUG;\nMmSettings  = (MM_MEMORY_PROTECTION_SETTINGS)MM_MEMORY_PROTECTION_SETTINGS_DEBUG;\n\nBuildGuidDataHob (\n&amp;gDxeMemoryProtectionSettingsGuid,\n&amp;DxeSettings,\nsizeof (DxeSettings)\n);\n\nBuildGuidDataHob (\n&amp;gMmMemoryProtectionSettingsGuid,\n&amp;MmSettings,\nsizeof (MmSettings)\n);\n</code></pre> <p>This will also require you to add gMemoryProtectionSettingsGuid under the Guids section in the relevant INF.</p> <p>If you want to deviate from one of the settings profile definitions in DxeMemoryProtectionSettings.h and/or MmMemoryProtectionSettings, it is recommended that you start with the one which most closely aligns with your desired settings and update from there in a manner similar to below:</p> <pre><code>  MmSettings.HeapGuardPolicy.Fields.MmPageGuard                    = 0;\nMmSettings.HeapGuardPolicy.Fields.MmPoolGuard                    = 0;\nDxeSettings.ImageProtectionPolicy.Fields.ProtectImageFromUnknown = 1;\n</code></pre> <p>before building the HOB.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#memory-protection-special-regions","title":"Memory Protection Special Regions","text":"<p>Memory protection is not activated until the CPU Architecture Protocol has been installed because the protocol facilitates access to the attribute manipulation functions in CpuDxe which update the translation/page tables. Many allocations and image loads will have occurred by the time the protocol is published so careful accounting is required to ensure appropriate attributes are applied. An event notification triggered on the CPU Architecture Protocol installation will combine the GCD and EFI memory maps to create a full map of memory for use internally by the memory protection initialization logic. Because image memory is allocated for the entire image and not each section (code and data), the images are separated within the combined map so NX can be applied to data regions and RO can be applied to code regions. After breaking up the map so each DXE image section has its own descriptor, every non-image descriptor will have its attributes set based on its EFI memory type. There are cases where the platform will want to apply attributes to a region of memory which is different than what would be applied based on its EFI memory type. In this case,</p> <p>platforms can utilize the Memory Protection Special Region interface to specify regions which should have specific attributes applied during memory protection initialization.</p>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#example-declaration-of-special-region-in-pei","title":"Example Declaration of Special Region in PEI:","text":"<pre><code>#include &lt;Guid/MemoryProtectionSpecialRegionGuid.h&gt;\n\nMEMORY_PROTECTION_SPECIAL_REGION SpecialRegion;\nSpecialRegion.Start       = 0x1000;\nSpecialRegion.Length      = 0x1000;\nSpecialRegion.Attributes  = EFI_MEMORY_RO;\n\nBuildGuidDataHob (\n&amp;gMemoryProtectionSpecialRegionHobGuid,\n&amp;SpecialRegion,\nsizeof (SpecialRegion)\n);\n</code></pre>"},{"location":"dyn/mu_basecore/Docs/feature_memory_protection/#example-declaration-of-special-region-in-dxe","title":"Example Declaration of Special Region in DXE:","text":"<pre><code>#include &lt;Protocol/MemoryProtectionSpecialRegionProtocol.h&gt;\n\nMEMORY_PROTECTION_SPECIAL_REGION_PROTOCOL *SpecialRegionProtocol = NULL;\nEFI_PHYSICAL_ADDRESS  BufferStart       = 0x1000;\nUINT64                BufferLength      = 0x1000;\nUINT64                BufferAttributes  = EFI_MEMORY_RO;\n\nStatus = gBS-&gt;LocateProtocol (&amp;gMemoryProtectionSpecialRegionProtocolGuid, NULL, (VOID **)&amp;SpecialRegionProtocol);\nASSERT_EFI_ERROR (Status);\nif (SpecialRegionProtocol != NULL) {\nStatus = SpecialRegionProtocol-&gt;AddSpecialRegion (\nBufferStart,\nBufferLength,\nBufferAttributes\n);\n\nASSERT_EFI_ERROR (Status);\n}\n</code></pre> <p>These special regions also may be used during paging audit tests which check if the page table has secure attributes. For example, an existing test checks to see if there are any Read/Write/Execute memory regions and fail if true. During this test, if a Read/Write/Execute region is found, it will be checked against the special regions and a test failure will not be emitted if the page attributes are consistent with the attributes identified in the overlapping special region.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/","title":"DeviceStateLib","text":""},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/#about","title":"About","text":"<p>The MsCorePkg provides the necessary functions to store platform specific device states.  These device states can then be queried by any element within the boot environment to enable special code paths.  In this library implementation a bitmask is stored in a PCD to signify what modes are active.</p> <p>The default bits in the bitmask are set in DeviceStateLib.h - but each platform is expected to implement its own header to define the platform specific device states or to define any of the unused bits:</p> <ul> <li>BIT 0:  DEVICE_STATE_SECUREBOOT_OFF - UEFI Secure Boot disabled</li> <li>BIT 1:  DEVICE_STATE_MANUFACTURING_MODE - Device is in an OEM defined   manufacturing mode</li> <li>BIT 2:  DEVICE_STATE_DEVELOPMENT_BUILD_ENABLED - Device is a development   build.  Non-production features might be enabled</li> <li>BIT 3:  DEVICE_STATE_SOURCE_DEBUG_ENABLED - Source debug mode is enabled   allowing a user to connect and control the device</li> <li>BIT 4:  DEVICE_STATE_UNDEFINED - Set by the platform</li> <li>BIT 5:  DEVICE_STATE_UNIT_TEST_MODE - Device has a unit test build. Some   features are disabled to allow for unit tests in UEFI Shell</li> <li>BIT 24: DEVICE_STATE_PLATFORM_MODE_0</li> <li>BIT 25: DEVICE_STATE_PLATFORM_MODE_1</li> <li>BIT 26: DEVICE_STATE_PLATFORM_MODE_2</li> <li>BIT 27: DEVICE_STATE_PLATFORM_MODE_3</li> </ul>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/DeviceStateLib/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/","title":"UEFI Variable Policy Whitepaper","text":""},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#summary","title":"Summary","text":"<p>UEFI Variable Policy spec aims to describe the DXE protocol interface which allows enforcing certain rules on certain UEFI variables. The protocol allows communication with the Variable Policy Engine which performs the policy enforcement.</p> <p>The Variable Policy is comprised of a set of policy entries which describe, per UEFI variable (identified by namespace GUID and variable name) the following rules:</p> <ul> <li>Required variable attributes</li> <li>Prohibited variable attributes</li> <li>Minimum variable size</li> <li>Maximum variable size</li> <li>Locking:</li> <li>Locking \"immediately\"</li> <li>Locking on creation</li> <li>Locking based on a state of another variable</li> </ul> <p>The spec assumes that the Variable Policy Engine runs in a trusted enclave, potentially off the main CPU that runs UEFI. For that reason, it is assumed that the Variable Policy Engine has no concept of UEFI events, and that the communication from the DXE driver to the trusted enclave is proprietary.</p> <p>At power-on, the Variable Policy Engine is:</p> <ul> <li>Enabled -- present policy entries are evaluated on variable access     calls.</li> <li>Unlocked -- new policy entries can be registered.</li> </ul> <p>Policy is expected to be clear on power-on. Policy is volatile and not preserved across system reset.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#dxe-protocol","title":"DXE Protocol","text":"<pre><code>typedef struct {\n  UINT64                        Revision;\n  DISABLE_VARIABLE_POLICY       DisableVariablePolicy;\n  IS_VARIABLE_POLICY_ENABLED    IsVariablePolicyEnabled;\n  REGISTER_VARIABLE_POLICY      RegisterVariablePolicy;\n  DUMP_VARIABLE_POLICY          DumpVariablePolicy;\n  LOCK_VARIABLE_POLICY          LockVariablePolicy;\n} _VARIABLE_POLICY_PROTOCOL;\n\ntypedef _VARIABLE_POLICY_PROTOCOL VARIABLE_POLICY_PROTOCOL;\n\nextern EFI_GUID gVariablePolicyProtocolGuid;\n</code></pre> <pre><code>## Include/Protocol/VariablePolicy.h\n  gVariablePolicyProtocolGuid = { 0x81D1675C, 0x86F6, 0x48DF, { 0xBD, 0x95, 0x9A, 0x6E, 0x4F, 0x09, 0x25, 0xC3 } }\n</code></pre>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#disablevariablepolicy","title":"DisableVariablePolicy","text":"<p>Function prototype:</p> <pre><code>EFI_STATUS\nEFIAPI\nDisableVariablePolicy (\nVOID\n);\n</code></pre> <p><code>DisableVariablePolicy</code> call disables the Variable Policy Engine, so that the present policy entries are no longer taken into account on variable access calls. This call effectively turns off the variable policy verification for this boot. This also disables UEFI Authenticated Variable protections including Secure Boot. <code>DisableVariablePolicy</code> can only be called once during boot. If called more than once, it will return <code>EFI_ALREADY_STARTED</code>. Note, this process is irreversible until the next system reset -- there is no \"EnablePolicy\" protocol function.</p> <p>IMPORTANT NOTE: It is strongly recommended that VariablePolicy NEVER be disabled in \"normal, production boot conditions\". It is expected to always be enforced. The most likely reasons to disable are for Manufacturing and Refurbishing scenarios. If in doubt, leave the <code>gEfiMdeModulePkgTokenSpaceGuid.PcdAllowVariablePolicyEnforcementDisable</code> PCD set to <code>FALSE</code> and VariablePolicy will always be enabled.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#isvariablepolicyenabled","title":"IsVariablePolicyEnabled","text":"<p>Function prototype:</p> <pre><code>EFI_STATUS\nEFIAPI\nIsVariablePolicyEnabled (\nOUT BOOLEAN   *State\n);\n</code></pre> <p><code>IsVariablePolicyEnabled</code> accepts a pointer to a Boolean in which it will store <code>TRUE</code> if Variable Policy Engine is enabled, or <code>FALSE</code> if Variable Policy Engine is disabled. The function returns <code>EFI_SUCCESS</code>.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#registervariablepolicy","title":"RegisterVariablePolicy","text":"<p>Function prototype:</p> <pre><code>EFI_STATUS\nEFIAPI\nRegisterVariablePolicy (\nIN CONST VARIABLE_POLICY_ENTRY  *PolicyEntry\n);\n</code></pre> <p><code>RegisterVariablePolicy</code> call accepts a pointer to a policy entry structure and returns the status of policy registration. If the Variable Policy Engine is not locked and the policy structures are valid, the function will return <code>EFI_SUCCESS</code>. If the Variable Policy Engine is locked, <code>RegisterVariablePolicy</code> call will return <code>EFI_WRITE_PROTECTED</code> and will not register the policy entry. Bulk registration is not supported at this time due to the requirements around error handling on each policy registration.</p> <p>Upon successful registration of a policy entry, Variable Policy Engine will then evaluate this entry on subsequent variable access calls (as long as Variable Policy Engine hasn't been disabled).</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#dumpvariablepolicy","title":"DumpVariablePolicy","text":"<p>Function prototype:</p> <pre><code>EFI_STATUS\nEFIAPI\nDumpVariablePolicy (\nOUT     UINT8     *Policy,\nIN OUT  UINT32    *Size\n);\n</code></pre> <p><code>DumpVariablePolicy</code> call accepts a pointer to a buffer and a pointer to the size of the buffer as parameters and returns the status of placing the policy into the buffer. On first call to <code>DumpVariablePolicy</code> one should pass <code>NULL</code> as the buffer and a pointer to 0 as the <code>Size</code> variable and <code>DumpVariablePolicy</code> will return <code>EFI_BUFFER_TOO_SMALL</code> and will populate the <code>Size</code> parameter with the size of the needed buffer to store the policy. This way, the caller can allocate the buffer of correct size and call <code>DumpVariablePolicy</code> again. The function will populate the buffer with policy and return <code>EFI_SUCCESS</code>.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#lockvariablepolicy","title":"LockVariablePolicy","text":"<p>Function prototype:</p> <pre><code>EFI_STATUS\nEFIAPI\nLockVariablePolicy (\nVOID\n);\n</code></pre> <p><code>LockVariablePolicy</code> locks the Variable Policy Engine, i.e. prevents any new policy entries from getting registered in this boot (<code>RegisterVariablePolicy</code> calls will fail with <code>EFI_WRITE_PROTECTED</code> status code returned).</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#policy-structure","title":"Policy Structure","text":"<p>The structure below is meant for the DXE protocol calling interface, when communicating to the Variable Policy Engine, thus the pragma pack directive. How these policies are stored in memory is up to the implementation.</p> <pre><code>#pragma pack(1)\ntypedef struct {\nUINT32    Version;\nUINT16    Size;\nUINT16    OffsetToName;\nEFI_GUID  Namespace;\nUINT32    MinSize;\nUINT32    MaxSize;\nUINT32    AttributesMustHave;\nUINT32    AttributesCantHave;\nUINT8     LockPolicyType;\nUINT8     Reserved[3];\n// UINT8  LockPolicy[]; // Variable Length Field\n// CHAR16 Name[];       // Variable Length Field\n} VARIABLE_POLICY_ENTRY;\n</code></pre> <p>The struct <code>VARIABLE_POLICY_ENTRY</code> above describes the layout for a policy entry. The first element, <code>Size</code>, is the size of the policy entry, then followed by <code>OffsetToName</code> -- the number of bytes from the beginning of the struct to the name of the UEFI variable targeted by the policy entry. The name can contain wildcards to match more than one variable, more on this in the Wildcards section. The rest of the struct elements are self-explanatory.</p> <pre><code>#define VARIABLE_POLICY_TYPE_NO_LOCK            0\n#define VARIABLE_POLICY_TYPE_LOCK_NOW           1\n#define VARIABLE_POLICY_TYPE_LOCK_ON_CREATE     2\n#define VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE  3\n</code></pre> <p><code>LockPolicyType</code> can have the following values:</p> <ul> <li><code>VARIABLE_POLICY_TYPE_NO_LOCK</code> -- means that no variable locking is performed. However,     the attribute and size constraints are still enforced. LockPolicy     field is size 0.</li> <li><code>VARIABLE_POLICY_TYPE_LOCK_NOW</code> -- means that the variable starts being locked     immediately after policy entry registration. If the variable doesn't     exist at this point, being LockedNow means it cannot be created on     this boot. LockPolicy field is size 0.</li> <li><code>VARIABLE_POLICY_TYPE_LOCK_ON_CREATE</code> -- means that the variable starts being locked     after it is created. This allows for variable creation and     protection after LockVariablePolicy() function has been called. The     LockPolicy field is size 0.</li> <li><code>VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE</code> -- means that the Variable Policy Engine will     examine the state/contents of another variable to determine if the     variable referenced in the policy entry is locked.</li> </ul> <pre><code>typedef struct {\nEFI_GUID  Namespace;\nUINT8     Value;\nUINT8     Reserved;\n// CHAR16 Name[];   // Variable Length Field\n} VARIABLE_LOCK_ON_VAR_STATE_POLICY;\n</code></pre> <p>If <code>LockPolicyType</code> is <code>VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE</code>, then the final element in the policy entry struct is of type <code>VARIABLE_LOCK_ON_VAR_STATE_POLICY</code>, which lists the namespace GUID, name (no wildcards here), and value of the variable which state determines the locking of the variable referenced in the policy entry. The \"locking\" variable must be 1 byte in terms of payload size. If the Referenced variable contents match the Value of the <code>VARIABLE_LOCK_ON_VAR_STATE_POLICY</code> structure, the lock will be considered active and the target variable will be locked. If the Reference variable does not exist (ie. returns <code>EFI_NOT_FOUND</code>), this policy will be considered inactive.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#variable-name-wildcards","title":"Variable Name Wildcards","text":"<p>Two types of wildcards can be used in the UEFI variable name field in a policy entry:</p> <ol> <li>If the Name is a zero-length array (easily checked by comparing    fields <code>Size</code> and <code>OffsetToName</code> -- if they're the same, then the    <code>Name</code> is zero-length), then all variables in the namespace specified    by the provided GUID are targeted by the policy entry.</li> <li>Character \"#\" in the <code>Name</code> corresponds to one numeric character    (0-9, A-F, a-f). For example, string \"Boot####\" in the <code>Name</code>    field of the policy entry will make it so that the policy entry will    target variables named \"Boot0001\", \"Boot0002\", etc.</li> </ol> <p>Given the above two types of wildcards, one variable can be targeted by more than one policy entry, thus there is a need to establish the precedence rule: a more specific match is applied. When a variable access operation is performed, Variable Policy Engine should first check the variable being accessed against the policy entries without wildcards, then with 1 wildcard, then with 2 wildcards, etc., followed in the end by policy entries that match the whole namespace. One can still imagine a situation where two policy entries with the same number of wildcards match the same variable -- for example, policy entries with Names \"Boot00##\" and \"Boot##01\" will both match variable \"Boot0001\". Such situation can (and should) be avoided by designing mutually exclusive Name strings with wildcards, however, if it occurs, then the policy entry that was registered first will be used. After the most specific match is selected, all other policies are ignored.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#available-testing","title":"Available Testing","text":"<p>This functionality is current supported by two kinds of tests: there is a host-based unit test for the core business logic (this test accompanies the <code>VariablePolicyLib</code> implementation that lives in <code>MdeModulePkg/Library</code>) and there is a functional test for the protocol and its interfaces (this test lives in the <code>MdeModulePkg/Test/ShellTest</code> directory).</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#host-based-unit-test","title":"Host-Based Unit Test","text":"<p>MU_CHANGE</p> <p>This test:</p> <p><code>MdeModulePkg\\Library\\VariablePolicyLib\\VariablePolicyUnitTest\\VariablePolicyUnitTest.inf</code></p> <p>can be run as part of the Host-Based Unit Testing infrastructure provided by EDK2 PyTools (documented elsewhere). It will test all internal guarantees and is where you will find test cases for most of the policy matching and security of the Variable Policy Engine.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#shell-based-functional-test","title":"Shell-Based Functional Test","text":"<p>This test -- Variable Policy Functional Unit Test -- can be built as a UEFI Shell application and run to validate that the Variable Policy Engine is correctly installed and enforcing policies on the target system.</p> <p>NOTE: This test must be run prior to calling <code>DisableVariablePolicy</code> for all test cases to pass. For this reason, it is recommended to run this on a test-built FW for complete results, and then again on a production-built FW for release results.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#use-cases","title":"Use Cases","text":"<p>The below examples are hypothetical scenarios based on real-world requirements that demonstrate how Variable Policies could be constructed to solve various problems.</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#uefi-setup-variables-example-1","title":"UEFI Setup Variables (Example 1)","text":"<p>Variables containing values of the setup options exposed via UEFI menu (setup variables). These would be locked based on a state of another variable, \"ReadyToBoot\", which would be set to 1 at the ReadyToBoot event. Thus, the policy for the setup variables would be of type <code>LockOnVarState</code>, with the \"ReadyToBoot\" listed as the name of the variable, appropriate GUID listed as the namespace, and 1 as value. Entry into the trusted UEFI menu app doesn't signal ReadyToBoot, but booting to any device does, and the setup variables are write-protected. The \"ReadyToBoot\" variable would need to be locked-on-create. (THIS IS ESSENTIALLY LOCK ON EVENT, BUT SINCE THE POLICY ENGINE IS NOT IN THE UEFI ENVIRONMENT VARIABLES ARE USED)</p> <p>For example, \"AllowPXEBoot\" variable locked by \"ReadyToBoot\" variable.</p> <p>(NOTE: In the below example, the emphasized fields ('Namespace', 'Value', and 'Name') are members of the <code>VARIABLE_LOCK_ON_VAR_STATE_POLICY</code> structure.)</p> Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType <code>VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE</code> Namespace ... Value 1 Name \"ReadyToBoot\" //Name \"AllowPXEBoot\""},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#manufacturing-vpd-example-2","title":"Manufacturing VPD (Example 2)","text":"<p>Manufacturing Variable Provisioning Data (VPD) is stored in variables and is created while in Manufacturing (MFG) Mode. In MFG Mode Variable Policy Engine is disabled, thus these VPD variables can be created. These variables are locked with lock policy type <code>LockNow</code>, so that these variables can't be tampered with in Customer Mode. To overwrite or clear VPD, the device would need to MFG mode, which is standard practice for refurbishing/remanufacturing scenarios.</p> <p>Example: \"DisplayPanelCalibration\" variable...</p> Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType <code>VARIABLE_POLICY_TYPE_LOCK_NOW</code> // Name \"DisplayPanelCalibration\""},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#3rd-party-calibration-data-example-3","title":"3rd Party Calibration Data (Example 3)","text":"<p>Bluetooth pre-pairing variables are locked-on-create because these get created by an OS application when Variable Policy is in effect.</p> <p>Example: \"KeyboardBTPairing\" variable</p> Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType <code>VARIABLE_POLICY_TYPE_LOCK_ON_CREATE</code> // Name \"KeyboardBTPairing\""},{"location":"dyn/mu_basecore/MdeModulePkg/Library/VariablePolicyLib/ReadMe/#software-based-variable-policy-example-4","title":"Software-based Variable Policy (Example 4)","text":"<p>Example: \"Boot####\" variables (a name string with wildcards that will match variables \"Boot0000\" to \"BootFFFF\") locked by \"LockBootOrder\" variable.</p> Size ... OffsetToName ... NameSpace ... MinSize ... MaxSize ... AttributesMustHave ... AttributesCantHave ... LockPolicyType <code>VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE</code> Namespace ... Value 1 Name \"LockBootOrder\" //Name \"Boot####\""},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/","title":"Variable Policy Unit Tests","text":""},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/#copyright","title":"\ud83d\udd39 Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/MdeModulePkg/Test/ShellTest/VariablePolicyFuncTestApp/Readme/#about-this-test","title":"About This Test","text":"<p>This test verifies functionality of the Variable Policy Protocol by registering various variable policies and exercising them, as well as tests locking the policy, disabling it, and dumping the policy entries.</p> <p>Only policies that are created as a part of this test will be tested.</p> <ol> <li>Try getting test context, if empty then get VP protocol, confirm that VP is not disabled by calling IsVariablePolicyEnabled.    Log VP revision.</li> <li>\"No lock\" policies:<ul> <li>check minsize enforcement</li> <li>check maxsize enforcement</li> <li>check musthave attr enforcement</li> <li>check canthave attr enforcement</li> <li>check one of the above with empty string policy i.e. name wildcard</li> <li>check another one of the above with a \"#\" containing policy string</li> <li>check policy prioritization by having a namespace-wide policy, a policy with a # wildcard,   and a one-var specific policy and testing which one is enforced</li> </ul> </li> <li>\"Lock now\" policies (means if the var doesn't exist, it won't be created; if one exists, it    can't be updated):<ul> <li>test a policy for an already existing variable, verify we can't write into that variable</li> <li>create a policy for a non-existing variable and attempt to register such var</li> </ul> </li> <li>\"Lock on create\" policies (means the var can still be created, but no updates later, existing    vars can't be updated):<ul> <li>create a var, lock it with LockOnCreate, attempt to update its contents</li> <li>create LockOnCreate VP, attempt to create var with invalid size, then invalid attr, then create   valid var, attempt to update its contents</li> </ul> </li> <li>\"Lock on var state\" policies (means the var protected by this policy can't be created or updated    once the trigger is set)<ul> <li>create VP, trigger lock with a valid var, attempt to create a locked var, then modify the   trigger var, create locked var</li> <li>create VP, create targeted var, modify it, trigger lock, attempt to modify var</li> <li>create VP, trigger lock with invalid (larger than one byte) var, see if VPE allows creation   of the locked var (it should allow)</li> <li>create VP, set locking var with wrong value, see if VPE allows creation of the locked var (should allow)</li> </ul> </li> <li>Attempt registering invalid policy entries<ul> <li>invalid required and banned attributes</li> <li>large min size - let's say 2GB</li> <li>max size equal to 0</li> <li>invalid policy type</li> </ul> </li> <li>Exercise dumping policy. No need to check the validity of the dump blob.</li> <li>Test registering a policy with a random version.</li> <li>Lock VPE, make sure old policies are enforced, new ones can't be registered.<ul> <li>Register a LockOnCreate policy</li> <li>Lock VPE</li> <li>Test locking it again.</li> <li>Verify one of the prior policies is enforced</li> <li>Make sure we can create variables even if those are protected by LockOnCreate policy, after locking the VPE</li> <li>Attempt to register new policies</li> <li>Make sure can't disable VPE</li> <li>Cleanup: save context and reboot</li> </ul> </li> <li>Disable variable policy and try some things<ul> <li>Locate Variable Policy Protocol</li> <li>Make sure VP is enabled</li> <li>Register a policy</li> <li>Disable VPE</li> <li>Call IsVariablePolicyEnabled to confirm it's disabled.</li> <li>Make sure can't lock policy</li> <li>Make sure the policy from a is no longer enforced</li> <li>Final cleanup: delete vars that were created in some earlier test suites</li> </ul> </li> </ol>"},{"location":"dyn/mu_basecore/MdePkg/Library/FltUsedLib/Readme/","title":"FltUsedLib","text":"<p>This library provides a global (fltused) that needs to be defined anywhere floating point operations are used. The C compiler produces the _fltused symbol by default, this is just to satisfy the linker.</p>"},{"location":"dyn/mu_basecore/MdePkg/Library/FltUsedLib/Readme/#using","title":"Using","text":"<p>To use FltUsedLib, just include it in the INF of the module that uses floating point.</p> <pre><code>[LibraryClasses]\n  BaseLib\n  BaseMemoryLib\n  FltUsedLib\n</code></pre>"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/","title":"Memory Attribute Protocol UEFI shell functional Test","text":""},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#copyright","title":"\ud83d\udd39 Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#attribution","title":"Attribution","text":"<p>This test is a modified version of https://github.com/jyao1/edk2/commit/5828d4c755658eba06d838edee9a7b4d72a9f8b3.</p>"},{"location":"dyn/mu_basecore/MdePkg/Test/ShellTest/MemoryAttributeProtocolFuncTestApp/Readme/#about-this-test","title":"About This Test","text":"<p>Tests does basic verification of the Memory Attribute Protocol</p> <ul> <li>Make sure protocol exists</li> <li>Basic \"good path\" usage of Get/Clear/Set functions</li> <li>Get Attributes of a newly allocated EfiLoaderCode buffer</li> <li>Verify Attributes of running code (this test code)</li> </ul>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/","title":"SharedNetworking","text":"<p>Similar to SharedCrypto (https://github.com/microsoft/mu_plus/tree/release/201911/SharedCryptoPkg), SharedNetworking is a collection of pre-built network binaries you can include in your platform or other EDK2 project.</p> <p>SharedNetworking requires SharedCrypto for BaseCryptLib functionality (this only applies to TlsLib and IScsiDxe)</p> <p>The build script for this (SharedNetworkSettings.py) pulls in MU_PLUS as it has a dependency on SharedCrypto (which currently resides in MU_PLUS). This is temporary and will not carry forward to 202002. It also doesn't apply to the remainder of Basecore or CI. The dependency is only pulled in when build SharedNetworking itself, which doesn't happen often.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/#advantages","title":"Advantages","text":"<ul> <li>Faster Compile Times</li> <li>Potentially smaller binary sizes (depending on compression and a variety of   other factors)</li> <li>Easier to update and service since network binaries are packaged in an FV.</li> </ul>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/#including-it-in-your-project","title":"Including it in your project","text":"<p>Just !include the SharedNetworking.fdf.inc as the example below shows:</p> <pre><code>[FV.FVDXE]\n  ...\n  !include NetworkPkg/SharedNetworking.fdf.inc\n</code></pre>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/","title":"Shared Networking DXE","text":""},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#what-is-it","title":"What is it","text":"<p>Shared Networking is a packaged versions of networking components from EDK II. Similar to SharedCrypto (see the SharedCryptoPkg), it precompiles certain components and allows them to be included in a platform without having to build the underlying library.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#how-it-works","title":"How it works","text":"<p>Since many parts of the network simply publish a protocol (like TlsDxe), it was fairly trivial to compile that into an EFI. This EFI is then downloaded via a NuGet External Dependency (see SharedNetworking_ext_dep.json). Versions are modified in a similar way to SharedCrypto.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#versioning","title":"Versioning","text":"<p>A typical version consists of 4 numbers. The year, the month of the EDK II release, the revision number, and the build number. An example of this would be 2019.03.02.01, which would translate to EDK II 1903 release, the second revision and the first build. This means that there were two code changes within 1903 (either in BaseCryptLib or OpenSSL). Release notes will be provided on the NuGet package page and on this repo. Build numbers are reved whenever there needs to be a recompiled binary due to a mistake on our part or a build flag is tweaked.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#how-to-use-it","title":"How to use it","text":"<p>There are two ways to use SharedNetworking. For first way is to use the FV, which contains all the networking components needed. The second is to replace individual components with INF's.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#dscinf-way","title":"DSC/INF way","text":"<p>Including it in your platform is easy peezy lemon squeezy. In fact, you only need three changes. In the example below we show X64, which happens to correspond with DXE but that could easily be changed. Look at your platform for where Networking is already defined. One thing to note is that each binary is released for two targets, RELEASE and DEBUG. Make sure to include the right INF.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#dsc-changes","title":"DSC Changes","text":"<p>Parts need to be replaced on a compoenent by component basis. For example, here is how to move over TlsDxe. You need to remove the reference to TLSLib since we no longer need it (the only consumer is TlsDxe). Then switch the component to the Shared version of TLS. It looks like this:</p> <pre><code>[LibraryClasses.X64]\n  #TlsLib|CryptoPkg/Library/TlsLib/TlsLib.inf # remove this line\n\n[Components.X64]\n  NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf\n</code></pre>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#fdf-changes","title":"FDF Changes","text":"<pre><code>[FV.FVDXE]\n INF  NetworkPkg/SharedNetworking/TlsDxe.$(TARGET).inf # Shared_TLS instead of TlsDxe\n ...\n</code></pre>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#fv-way","title":"FV way","text":"<p>This way is still under development, so it maybe subject to change. In your FDF, add these lines.</p> <pre><code>[FV.FVDXE]\n\nFILE FV_IMAGE = {GUID} {\n  SECTION FV_IMAGE = NetworkPkg/SharedNetworking/Mu-SharedNetworking_extdep/$(TARGET)/{ARCH of your platform}/FVDXE.fv # Shared_Networking\n  SECTION UI = \"SharedNetworking\"\n}\n</code></pre> <p>With {GUID} being a guid you generated. We use E205F779-07E3-4B64-A2E2-EEDE717B0F59. {Arch of your platform} being the platform you're using. We currently support IA32, X64, and AARCH64. as supposered values You'll also need to remove the networking components that were already in your FDF.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#why-to-use-sharednetworking","title":"Why to Use SharedNetworking","text":"<p>Depending on your platform, it could net you some small space savings depending on your linker. The main advantage is that when used with SharedCrypto, you can remove the need to compile OpenSSL, reducing compile times.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/SharedNetworking/#questions","title":"Questions","text":"<p>If you have any questions about anything in this package or the universe in general, feel free to comment on our Github or contact the Project Mu team.</p>"},{"location":"dyn/mu_basecore/NetworkPkg/SharedNetworking/release_notes/","title":"Shared Network Release Notes","text":"<p>This is the packaged version of NetworkPkg. Please see more documentation here: https://github.com/microsoft/mu_basecore/tree/release/201911/NetworkPkg/SharedNetworking</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/","title":"Policy Service","text":"<p>Documents the interface, design, and implementation of the Policy service split across PEI and DXE modules as well as any supporting libraries or best practices.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#overview","title":"Overview","text":"<p>The generalized policy service, implemented in DXE and PEI, provides interfaces for components to publish and consume generic policies between components in the UEFI environment. This policy takes the form of generic data and it is up to the producer and consumer to agree upon the contents and format of that policy. This document makes recommendations as to best practices to sustainably format policy data, but the service is agnostic to the format or meaning of the policy.</p> <p>Policy is a data block containing configurations or settings relating to the silicon, platform, or feature state of the system. This information can originate from PCD entries, platform/silicon configuration code, user settings, or otherwise determined at runtime. A policy may be entirely defined by a single component or it can be built and transformed by several components each further customizing or locking down the system.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#background","title":"Background","text":"<p>In UEFI there is a need to share these Policy data blocks across components or phases. This could be specific device configuration, settings data, platform information, etc. The Policy service is intended to give an easy, abstracted, and extensible interface for accomplishing this data publishing.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#previous-technologies","title":"Previous Technologies","text":"<p>There are several existing mechanisms that can be used to share configuration and data with the rest of the UEFI environment, but currently these mechanisms either don't perfectly align with the Policy Service's use case or are not suitable for adoption across all platforms. Below is a comparison to some of the currently existing methods for sharing data blocks in UEFI.</p> <p>NVRAM Variables - Because NVRAM will be implemented at the platform level, leveraging across silicon or other base code causes a inverse dependency.</p> <p>Hand Off Blocks - While handoff blocks can be used to share data, they only solve the particular case from where the data is sourced from PEI. HOBs do not provide any robust data management features. Additionally, HOBs can be easily misused, for example by storing direct references to the HOB across memory initialization.</p> <p>Config Blocks - Config blocks serve a similar use case as the Policy service, but is not currently in a position to be used across the UEFI ecosystem. Config Blocks lack some of the features such as data management abilities, or features such as the ability to dispatch and notify on data updates. Additionally Config Blocks lack public documentation to be widely adopted.</p> <p>Platform Configuration Database - PCDs, in particular dynamic PCDs, can also be used to share data across components. However, PCDs are more focused and prescriptive in the data type and use case while also lacking some of the data management features and extensibility. Due to it's dependence on the build system PCDs can also be problematic when integrating pre-compiled binary components. The Policy Service is not intended to replace PCDs, but to provide a more light weight and simple method for components to share data.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#data-format","title":"Data Format","text":"<p>The Policy service only implements a generic blob storage and should not be directly used in many scenarios. For managed configuration and data format, see the Policy Library ReadMe.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-management-process","title":"Policy Management Process","text":"<p>Policies are uniquely defined by a GUID. This GUID should only be used for a specific data type and purpose. Only one policy may be published under a specific GUID at any given time. Duplicates will overwrite the original policy unless the policy has been finalized via the policy attributes. Policies are managed through a simple Get/Set/Remove interface detailed below. After their creation, policies are universally available to all components and supported environments unless otherwise specified in the policy attributes.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-components","title":"Policy Components","text":"<p>The policy will be accessed by two types of components: producers and consumers. There may be some components that are both consumers and producers by altering an existing policy, possibly using notifications to alter the policy as soon as it is made available.</p> <pre><code>Producer - Creates original policy\n|---&gt;[Consumer/Producer - Alters policy]\n|---&gt;Consumer 1 - Reads altered policy\n|---&gt;Consumer 2 - Reads altered Policy\n</code></pre> <p>The original policy will often be created in PEI to be available as soon as possible, and may be consumed in PEI or may not be consumed until DXE. Implementors of a new policy should consider what component is the origin of the the data, what components may need to edit the data, and what components will eventually use the data. In the sample code, the PEI sample module is the producer and the DXE sample module is the consumer for the example policy shared from PEI to DXE.</p> <p>Producers may also finalize the policy to prevent future accessors from writing to the data. Finalizing will prevent specialization of a policy and so should be done sparingly in silicon or other low-level components.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#attributes","title":"Attributes","text":"<p>Policies can be can be set with attribute flags allowing the policy provider to specify on how the policy is handled. For example, this can be used to finalize the policy making it read-only or can be used to limit access to the policy to a phase of boot. See the PolicyInterface header definitions for full list of attributes.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-notification-protocols-ppis","title":"Policy Notification Protocols &amp; PPIs","text":"<p>When a policy is set or updated a PPI or Protocol will be installed with the GUID of the policy. Consumers may use this GUID to either set Protocol/PPI notifications, or create a DEPEX dependency so that the consumer is not dispatched until the policy is made available. The protocol/PPI will not contain any useful interface and consumers are expected to use the protocol interface to retrieve the policy data after being notified or dispatched.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-interface","title":"Policy Interface","text":"<p>Both the PEI and DXE implementation provide the following interfaces.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#setpolicy","title":"SetPolicy","text":"<p>Creates a new or overwrites and existing policy. Policies can only be overwritten if the policy has not be finalized. The policy will be copied from the provided buffer to an internal store, so all further edits must be done though additional calls to SetPolicy.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#getpolicy","title":"GetPolicy","text":"<p>Returns a copy of the policy for the provided policy GUID and its current attributes. The caller is responsible for allocating the buffer the policy is copied into.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#removepolicy","title":"RemovePolicy","text":"<p>Removes a policy from the policy list, freeing it when possible.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#policy-service-implementation","title":"Policy Service Implementation","text":"<p>The policy interfaces use a pass-by-copy scheme to ensure that the producers and consumers cannot directly edit the policy data and all interactions are done in transactions. This also allows for attributes such as finalized to be strongly enforced. Internally the PEI and DXE phase implementation have their own method for storing policy data.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#pei-phase","title":"PEI Phase","text":"<p>Policies created during PEI are immediately stored into a HOB. All policy HOBs are given the same well-known GUID, gPolicyHobGuid, with a POLICY_HOB_HEADER header to track it's metadata. When a given policy is requested the PEIM will search the HOBs with the well-known GUID to find the matching policy header. If a policy is removed or made obsolete with a larger version of the policy, the header will be set with the removed flag and will no longer be evaluated by the service.</p> <p>When a policy is created or updated in the PEI phase, a NULL PPI will be installed, or reinstalled, with the GUID of the policy. This PPI is intended to allow for notification and dispatch of consumers when the policy becomes available.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#dxe-phase","title":"DXE Phase","text":"<p>During it's initialization, the DXE driver will process the HOB list to discover any valid policies that may exist. These HOB policy blocks will then be added to the DXE driver's linked list structure of the active policies on the system. Any policies created or updated in the DXE phase will be allocated in pool memory and freed when removed or expanded.</p> <p>Like the PEIM, the DXE driver will install/reinstall a NULL protocol with the given policies GUID when it is created or updated to allow for notification and dispatch on the policy availability.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#yaml-based-policy-definition","title":"YAML Based Policy Definition","text":"<p>This section provides an overview of YAML based policy definition and how platform can integrate them.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#yaml-definition-for-policy-structures","title":"YAML Definition for Policy Structures","text":"<p>When used, the YAML based policy definition is treated as the ground truth of policy structure and default data. The YAML parser is largely inheritted from Intel's slim bootloader. Thus, the YAML syntax follows the specification defined in slim bootloader as well.</p> <p>Such YAML definition will be used to generate header files and the field accessors for platform consumption.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#mu-added-rules","title":"MU Added Rules","text":"<p>In addition to aforementioned YAML specification from slim bootloader, a few extra rules was added to the existing specification to facilitate the adaptation of policy specific usage. These rules will be enforced by a Pre-Build plugin, more details in its implementation section.</p> <ol> <li> <p>Each policy definition group must include a <code>POLICY_HEADER_TMPL</code> section, as provided in this template here. This section should include a 64-bit signature, an expected major version, an maximally expected minor version and a size of such structure. This data will mainly be used as metadata instead of policy data. Platforms could <code>!include</code> the provided template for easier inclusion.</p> </li> <li> <p>For each non-header fields defined in the YAML policy file, developers could optionally add a <code>minver</code> field, which denotes at which minor version this field is added. If not added, this field will be treated as 0 for default value.</p> </li> <li> <p>Under the same major value, all new minor fields should only be appended after the fields with lower minor version values, otherwise the build will break.</p> </li> <li> <p>This YAML definition is not created to support UI configuration features, thus no UI related configuration fields will be recognized in the context of policy YAML definition.</p> </li> </ol>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#field-accessors","title":"Field Accessors","text":"<p>For each fields defined in YAML structures, 4 accessor functions will be created. These functions will cover the functionality of setting this field to target value or default value, get current or default value from policy handle.</p> <p>All autogen functions will be created under the naming scheme of <code>SET_POLICY_STRUCTURE_NAME_Field_Name</code>, <code>SET_POLICY_STRUCTURE_NAME_Field_Name_default</code>, <code>GET_POLICY_STRUCTURE_NAME_Field_Name</code> and <code>GET_POLICY_STRUCTURE_NAME_Field_Name_default</code>.</p> <p>The internal implementation of these functions are dependent on <code>PolicyLib</code>, specifically the verified policy related functionalities.</p> <p>In order to simplify the usage of policy initialization, a function of <code>SET_POLICY_STRUCTURE_NAME_default</code> is created. This function could be invoked for a platform to initialize the newly created policy handle.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#pre-build-plugin","title":"Pre-Build Plugin","text":"<p>A pre-build plugin is created to enforce rules indicated in the previous section.</p> <p>This plugin requires 3 build environment variable to execute properly:</p> <ul> <li><code>BUILD_OUTPUT_BASE</code>: This is used to create a temporary folder to contain intermediate files</li> <li><code>UPDATE_SETTINGS</code>: Setting this to <code>false</code> to disable this plugin</li> <li><code>POLICY_REPORT_FOLDER</code>: This optional variable can be used to indicate where the plugin should output the report.</li> <li><code>POLICY_IGNORE_PATHS</code>: This optional variable can be used by platform to specify which directories or files the autogen should ignore. Each entry should be relative UEFI path separated by colons (';'). If not supplied this report will be save to the same folder of <code>ACTIVE_PLATFORM</code>.</li> </ul> <p>A policy report is the collateral output after codebase analyzing:</p> <ul> <li> <p>During pre-build, this plugin will search through all the included package paths for files ending with <code>_policy_def.yaml</code> or <code>_policy_def.yml</code>. Each policy component should have its own <code>*_policy_def.yaml</code> file. i.e. <code>USB_policy_def.yaml</code> for USB policies and <code>PCI_policy_def.yaml</code> for PCI policies.</p> </li> <li> <p>For each discovered policy definition, the plugin will compute a hash value of each defined minor version with the structure and its content. This value will be compared to the value from previously output report, if this report does not exist, the plugin will create one.</p> </li> <li> <p>If the any of the rules does not meet, or any field change is detected, the build will halt and notify the developers to fix the unexpected and update the report file.</p> </li> <li> <p>The plugin will also generate the header file from this YAML definition automatically, which includes the header structure and its accessors.</p> </li> </ul>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#platform-integration","title":"Platform Integration","text":"<p>For a platform to integrate the changes, the following needs to be satisfied:</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#silicon-packages","title":"Silicon Packages","text":"<ul> <li> <p>Define and create component policy defintions in YAML.</p> </li> <li> <p>Use autogen accessors and <code>PolicyLib</code> to consume policy values.</p> </li> </ul>"},{"location":"dyn/mu_basecore/PolicyServicePkg/#platform-packages","title":"Platform Packages","text":"<ul> <li> <p>Use autogen accessors and <code>PolicyLib</code> to publish and/or override policy values.</p> </li> <li> <p>Include <code>POLICY_REPORT.xml</code> for version tracking purpose.</p> </li> <li> <p>Add <code>PolicyLib</code> instances to platform descriptor file.</p> </li> </ul>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/","title":"Policy Library","text":"<p>The policy library is responsible for handling more robust features on top of the basic policy store provided by the policy. The primary use case of this library would be to use verified policies stored in the policy store.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-overview","title":"Verified Policy Overview","text":"<p>Verified policy is a set of library functions and tools around policy that provides a more type and version safe way of sharing data structures between components in different code bases or firmware layers. Using the verified policy functions in the library, combined with a per-data-structure generated header, callers can set and read data from a policy with automatic checks and guarantees to ensure the data being read correctly. This also provides useful concepts such as default values allowing for structure-safe version mismatch.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-components","title":"Verified Policy Components","text":"<p>The following are a few key components for utilizing verified policies.</p> <p>Policy Guid - As with all policies, a single instance of a policy should have a unique GUID. This GUID is not associated with the policy structure and only represents the data instance, not the data type or structure.</p> <p>Verified Policy Descriptor - The verified policy descriptor is a auto generated structure which describes the expected data structure. This includes a unique tag for the data, version info, size info, etc. The policy library will use this information to check the policy data to ensure it matches the expected type and required version.</p> <p>Attributes - Similar to all other policies, attributes can be used to enforce access restrictions on the policy instance.</p> <p>Verified Policy Handle - To enforce the verified policy abstraction, the caller will not be provided a direct pointer to the data. Instead they will be provided a policy handle which should be used with the auto-generated accessors. This allows for automatic checks to be done to ensure safe access of data.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#verified-policy-functions","title":"Verified Policy Functions","text":"<p>The policy library provides the following functions for accessing verified policy.</p> <p>GetVerifiedPolicy - Retrieves a verified policy from the policy store, checking that the data is the expected type and version. The returned handle references a copy of the policy and so a set is required to store and changes.</p> <p>CreateVerifiedPolicy - Creates a new verified policy data instance. This routine does not add the data to the policy store.</p> <p>SetVerifiedPolicy - Sets the provided verified policy data into the policy store.</p> <p>CloseVerifiedPolicy - Closes the local handle to the verified policy, freeing and resources.</p> <p>ReportVerifiedPolicyAccess - A API used to communicate access between the generated accessors and the generic library. This routine should not be manually called.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Library/#generating-verified-policy-headers","title":"Generating Verified Policy Headers","text":"<p>Details regarding generating verified policies are not yet documented here.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyDefinitions/","title":"Policy YAML Definition Sample","text":"<p>This directory contains sample policy definitions using YAML files to demonstrate a basic use of the policy autogen output. The GFX header file demonstrates all the structures, templates and interfaces generated.</p> <p>The functions are directly invocable from firmware code and template can be used verified policy operations.</p>"},{"location":"dyn/mu_basecore/PolicyServicePkg/Samples/PolicyInterface/","title":"Policy Sample","text":"<p>This directory contains sample PEI and DXE modules to demonstrate a basic use of the policy service. The PEI module demonstrates all the interfaces available, and creates a policy to be made available to DXE. The DXE module demonstrates retrieving this policy passed from PEI to DXE.</p> <p>In this example the policy is a simple C struct, but a policy may be in whatever data format the provider/suppliers wish.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/","title":"Unit Test Framework Package","text":""},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#about","title":"About","text":"<p>This package adds a unit test framework capable of building tests for multiple contexts including the UEFI shell environment and host-based environments. It allows for unit test development to focus on the tests and leave error logging, result formatting, context persistance, and test running to the framework. The unit test framework works well for low level unit tests as well as system level tests and fits easily in automation frameworks.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestlib","title":"UnitTestLib","text":"<p>The main \"framework\" library. The core of the framework is the Framework object, which can have any number of test cases and test suites registered with it. The Framework object is also what drives test execution.</p> <p>The Framework also provides helper macros and functions for checking test conditions and reporting errors. Status and error info will be logged into the test context. There are a number of Assert macros that make the unit test code friendly to view and easy to understand.</p> <p>Finally, the Framework also supports logging strings during the test execution. This data is logged to the test context and will be available in the test reporting phase. This should be used for logging test details and helpful messages to resolve test failures.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestpersistencelib","title":"UnitTestPersistenceLib","text":"<p>Persistence lib has the main job of saving and restoring test context to a storage medium so that for tests that require exiting the active process and then resuming state can be maintained. This is critical in supporting a system reboot in the middle of a test run.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unittestresultreportlib","title":"UnitTestResultReportLib","text":"<p>Library provides function to run at the end of a framework test run and handles formatting the report. This is a common customization point and allows the unit test framework to fit its output reports into other test infrastructure. In this package a simple library instances has been supplied to output test results to the console as plain text.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#samples","title":"Samples","text":"<p>There is a sample unit test provided as both an example of how to write a unit test and leverage many of the features of the framework. This sample can be found in the <code>Test/UnitTest/Sample/SampleUnitTest</code> directory.</p> <p>The sample is provided in PEI, SMM, DXE, and UEFI App flavors. It also has a flavor for the HOST_APPLICATION build type, which can be run on a host system without needing a target.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#usage","title":"Usage","text":"<p>This section is built a lot like a \"Getting Started\". We'll go through some of the components that are needed when constructing a unit test and some of the decisions that are made by the test writer. We'll also describe how to check for expected conditions in test cases and a bit of the logging characteristics.</p> <p>Most of these examples will refer to the SampleUnitTestUefiShell app found in this package.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#requirements-inf","title":"Requirements - INF","text":"<p>In our INF file, we'll need to bring in the <code>UnitTestLib</code> library. Conveniently, the interface header for the <code>UnitTestLib</code> is located in <code>MdePkg</code>, so you shouldn't need to depend on any other packages. As long as your DSC file knows where to find the lib implementation that you want to use, you should be good to go.</p> <p>See this example in 'SampleUnitTestUefiShell.inf'...</p> <pre><code>[Packages]\n  MdePkg/MdePkg.dec\n\n[LibraryClasses]\n  UefiApplicationEntryPoint\n  BaseLib\n  DebugLib\n  UnitTestLib\n  PrintLib\n</code></pre> <p>Also, if you want you test to automatically be picked up by the Test Runner plugin, you will need to make sure that the module <code>BASE_NAME</code> contains the word <code>Test</code>...</p> <pre><code>[Defines]\n  BASE_NAME      = SampleUnitTestUefiShell\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#requirements-code","title":"Requirements - Code","text":"<p>Not to state the obvious, but let's make sure we have the following include before getting too far along...</p> <pre><code>#include &lt;Library/UnitTestLib.h&gt;\n</code></pre> <p>Now that we've got that squared away, let's look at our 'Main()'' routine (or DriverEntryPoint() or whatever).</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#configuring-the-framework","title":"Configuring the Framework","text":"<p>Everything in the UnitTestPkg framework is built around an object called -- conveniently -- the Framework. This Framework object will contain all the information about our test, the test suites and test cases associated with it, the current location within the test pass, and any results that have been recorded so far.</p> <p>To get started with a test, we must first create a Framework instance. The function for this is <code>InitUnitTestFramework</code>. It takes in <code>CHAR8</code> strings for the long name, short name, and test version. The long name and version strings are just for user presentation and relatively flexible. The short name will be used to name any cache files and/or test results, so should be a name that makes sense in that context. These strings are copied internally to the Framework, so using stack-allocated or literal strings is fine.</p> <p>In the 'SampleUnitTestUefiShell' app, the module name is used as the short name, so the init looks like this.</p> <pre><code>DEBUG(( DEBUG_INFO, \"%a v%a\\n\", UNIT_TEST_APP_NAME, UNIT_TEST_APP_VERSION ));\n\n//\n// Start setting up the test framework for running the tests.\n//\nStatus = InitUnitTestFramework( &amp;Framework, UNIT_TEST_APP_NAME, gEfiCallerBaseName, UNIT_TEST_APP_VERSION );\n</code></pre> <p>The <code>&amp;Framework</code> returned here is the handle to the Framework. If it's successfully returned, we can start adding test suites and test cases.</p> <p>Test suites exist purely to help organize test cases and to differentiate the results in reports. If you're writing a small unit test, you can conceivably put all test cases into a single suite. However, if you end up with 20+ test cases, it may be beneficial to organize them according to purpose. You must have at least one test suite, even if it's just a catch-all. The function to create a test suite is <code>CreateUnitTestSuite</code>. It takes in a handle to the Framework object, a <code>CHAR8</code> string for the suite title and package name, and optional function pointers for a setup function and a teardown function.</p> <p>The suite title is for user presentation. The package name is for xUnit type reporting and uses a '.'-separated hierarchical format (see 'SampleUnitTestApp' for example). If provided, the setup and teardown functions will be called once at the start of the suite (before any tests have run) and once at the end of the suite (after all tests have run), respectively. If either or both of these are unneeded, pass <code>NULL</code>. The function prototypes are <code>UNIT_TEST_SUITE_SETUP</code> and <code>UNIT_TEST_SUITE_TEARDOWN</code>.</p> <p>Looking at 'SampleUnitTestUefiShell' app, you can see that the first test suite is created as below...</p> <pre><code>//\n// Populate the SimpleMathTests Unit Test Suite.\n//\nStatus = CreateUnitTestSuite( &amp;SimpleMathTests, Fw, \"Simple Math Tests\", \"Sample.Math\", NULL, NULL );\n</code></pre> <p>This test suite has no setup or teardown functions. The <code>&amp;SimpleMathTests</code> returned here is a handle to the suite and will be used when adding test cases.</p> <p>Great! Now we've finished some of the cruft, red tape, and busy work. We're ready to add some tests. Adding a test to a test suite is accomplished with the -- you guessed it -- <code>AddTestCase</code> function. It takes in the suite handle; a <code>CHAR8</code> string for the description and class name; a function pointer for the test case itself; additional, optional function pointers for prerequisite check and cleanup routines; and and optional pointer to a context structure.</p> <p>Okay, that's a lot. Let's take it one piece at a time. The description and class name strings are very similar in usage to the suite title and package name strings in the test suites. The former is for user presentation and the latter is for xUnit parsing. The test case function pointer is what is actually executed as the \"test\" and the prototype should be <code>UNIT_TEST_FUNCTION</code>. The last three parameters require a little bit more explaining.</p> <p>The prerequisite check function has a prototype of <code>UNIT_TEST_PREREQUISITE</code> and -- if provided -- will be called immediately before the test case. If this function returns any error, the test case will not be run and will be recorded as <code>UNIT_TEST_ERROR_PREREQUISITE_NOT_MET</code>. The cleanup function (prototype <code>UNIT_TEST_CLEANUP</code>) will be called immediately after the test case to provide an opportunity to reset any global state that may have been changed in the test case. In the event of a prerequisite failure, the cleanup function will also be skipped. If either of these functions is not needed, pass <code>NULL</code>.</p> <p>The context pointer is entirely case-specific. It will be passed to the test case upon execution. One of the purposes of the context pointer is to allow test case reuse with different input data. (Another use is for testing that wraps around a system reboot, but that's beyond the scope of this guide.) The test case must know how to interpret the context pointer, so it could be a simple value, or it could be a complex structure. If unneeded, pass <code>NULL</code>.</p> <p>In 'SampleUnitTestUefiShell' app, the first test case is added using the code below...</p> <pre><code>AddTestCase( SimpleMathTests, \"Adding 1 to 1 should produce 2\", \"Addition\", OnePlusOneShouldEqualTwo, NULL, NULL, NULL );\n</code></pre> <p>This test case calls the function <code>OnePlusOneShouldEqualTwo</code> and has no prerequisite, cleanup, or context.</p> <p>Once all the suites and cases are added, it's time to run the Framework.</p> <pre><code>//\n// Execute the tests.\n//\nStatus = RunAllTestSuites( Framework );\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#a-simple-test-case","title":"A Simple Test Case","text":"<p>We'll take a look at the below test case from 'SampleUnitTestApp'...</p> <pre><code>UNIT_TEST_STATUS\nEFIAPI\nOnePlusOneShouldEqualTwo (\nIN UNIT_TEST_FRAMEWORK_HANDLE  Framework,\nIN UNIT_TEST_CONTEXT           Context\n)\n{\nUINTN     A, B, C;\n\nA = 1;\nB = 1;\nC = A + B;\n\nUT_ASSERT_EQUAL(C, 2);\nreturn UNIT_TEST_PASSED;\n} // OnePlusOneShouldEqualTwo()\n</code></pre> <p>The prototype for this function matches the <code>UNIT_TEST_FUNCTION</code> prototype. It takes in a handle to the Framework itself and the context pointer. The context pointer could be cast and interpreted as anything within this test case, which is why it's important to configure contexts carefully. The test case returns a value of <code>UNIT_TEST_STATUS</code>, which will be recorded in the Framework and reported at the end of all suites.</p> <p>In this test case, the <code>UT_ASSERT_EQUAL</code> assertion is being used to establish that the business logic has functioned correctly. There are several assertion macros, and you are encouraged to use one that matches as closely to your intended test criterium as possible, because the logging is specific to the macro and more specific macros have more detailed logs. When in doubt, there are always <code>UT_ASSERT_TRUE</code> and <code>UT_ASSERT_FALSE</code>. Assertion macros that fail their test criterium will immediately return from the test case with <code>UNIT_TEST_ERROR_TEST_FAILED</code> and log an error string. Note that this early return can have implications for memory leakage.</p> <p>At the end, if all test criteria pass, you should return <code>UNIT_TEST_PASSED</code>.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#more-complex-cases","title":"More Complex Cases","text":"<p>To write more advanced tests, first take a look at all the Assertion and Logging macros provided in the framework.</p> <p>Beyond that, if you're writing host-based tests and want to take a dependency on the UnitTestFrameworkPkg, you can leverage the <code>cmocka.h</code> interface and write tests with all the features of the Cmocka framework.</p> <p>Documentation for Cmocka can be found here: https://api.cmocka.org/</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#development","title":"Development","text":""},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#iterating-on-a-single-test","title":"Iterating on a Single Test","text":"<p>When using the EDK2 Pytools for CI testing, the host-based unit tests will be built and run on any build that includes the <code>NOOPT</code> build target.</p> <p>If you are trying to iterate on a single test, a convenient pattern is to build only that test module. For example, the following command will build only the SafeIntLib host-based test from the MdePkg...</p> <pre><code>stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG=VS2017 -p MdePkg -t NOOPT BUILDMODULE=MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLib.inf\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#hooking-baselib","title":"Hooking BaseLib","text":"<p>Most unit test mocking can be performed by the functions provided in the UnitTestFramework libraries, but since BaseLib is consumed by the Framework itself, it requires different techniques to substitute parts of the functionality.</p> <p>To solve some of this, the UnitTestFramework consumes a special implementation of BaseLib for host-based tests. This implementation contains a hook table that can be used to substitute test functionality for any of the BaseLib functions. By default, this implementation will use the underlying BaseLib implementation, so the unit test writer only has to supply minimal code to test a particular case.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#debugging-the-framework-itself","title":"Debugging the Framework Itself","text":"<p>While most of the tests that are produced by the UnitTestFramework are easy to step through in a debugger, the Framework itself consumes code (mostly Cmocka) that sets its own build flags. These flags cause parts of the Framework to not export symbols and captures exceptions, and as such are harder to debug. We have provided a Stuart parameter to force symbolic debugging to be enabled.</p> <p>You can run a build by adding the <code>BLD_*_UNIT_TESTING_DEBUG=TRUE</code> parameter to enable this build option.</p> <pre><code>stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG=VS2019 -p MdePkg -t NOOPT BLD_*_UNIT_TESTING_DEBUG=TRUE\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#building-and-running-host-based-tests","title":"Building and Running Host-Based Tests","text":"<p>The EDK2 CI infrastructure provides a convenient way to run all host-based tests -- in the the entire tree or just selected packages -- and aggregate all the the reports, including highlighting any failures. This functionality is provided through the Stuart build system (published by EDK2-PyTools) and the <code>NOOPT</code> build target.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#building-locally","title":"Building Locally","text":"<p>First, to make sure you're working with the latest PyTools, run the following command:</p> <pre><code># Would recommend to run this in a Python venv, but that's out of scope for this doc.\npython -m pip install --upgrade -r ./pip-requirements.txt\n</code></pre> <p>After that, the following commands will set up the build and run the host-based tests.</p> <pre><code># Setup repo for building\n# stuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=&lt;GCC5, VS2019, etc.&gt;\nstuart_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=VS2019\n\n# Mu specific step to clone mu repos required for ci check\n# stuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=&lt;GCC5, VS2019, etc.&gt;\nstuart_ci_setup -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=VS2019\n\n# Update all binary dependencies\n# stuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=&lt;GCC5, VS2019, etc.&gt;\nstuart_update -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=VS2019\n\n# Build and run the tests\n# stuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=&lt;GCC5, VS2019, etc.&gt; -t NOOPT [-p &lt;Package Name&gt;]\nstuart_ci_build -c ./.pytool/CISettings.py TOOL_CHAIN_TAG=VS2019 -t NOOPT -p MdePkg\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#evaluating-the-results","title":"Evaluating the Results","text":"<p>In your immediate output, any build failures will be highlighted. You can see these below as \"WARNING\" and \"ERROR\" messages.</p> <pre><code>(edk_env) PS C:\\_uefi\\edk2&gt; stuart_ci_build -c .\\.pytool\\CISettings.py TOOL_CHAIN_TAG=VS2019 -t NOOPT -p MdePkg\n\nSECTION - Init SDE\nSECTION - Loading Plugins\nSECTION - Start Invocable Tool\nSECTION - Getting Environment\nSECTION - Loading plugins\nSECTION - Building MdePkg Package\nPROGRESS - --Running MdePkg: Host Unit Test Compiler Plugin NOOPT --\nWARNING - Allowing Override for key TARGET_ARCH\nPROGRESS - Start time: 2020-07-27 17:18:08.521672\nPROGRESS - Setting up the Environment\nPROGRESS - Running Pre Build\nPROGRESS - Running Build NOOPT\nPROGRESS - Running Post Build\nSECTION - Run Host based Unit Tests\nSUBSECTION - Testing for architecture: X64\nWARNING - TestBaseSafeIntLibHost.exe Test Failed\nWARNING -   Test SafeInt8ToUint8 - UT_ASSERT_EQUAL(0x5b:5b, Result:5c)\nc:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure!\nERROR - Plugin Failed: Host-Based Unit Test Runner returned 1\nCRITICAL - Post Build failed\nPROGRESS - End time: 2020-07-27 17:18:19.792313  Total time Elapsed: 0:00:11\nERROR - ---&gt;Test Failed: Host Unit Test Compiler Plugin NOOPT returned 1\nERROR - Overall Build Status: Error\nPROGRESS - There were 1 failures out of 1 attempts\nSECTION - Summary\nERROR - Error\n\n(edk_env) PS C:\\_uefi\\edk2&gt;\n</code></pre> <p>If a test fails, you can run it manually to get more details...</p> <pre><code>(edk_env) PS C:\\_uefi\\edk2&gt; .\\Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe\n\nInt Safe Lib Unit Test Application v0.1\n---------------------------------------------------------\n------------     RUNNING ALL TEST SUITES   --------------\n---------------------------------------------------------\n---------------------------------------------------------\nRUNNING TEST SUITE: Int Safe Conversions Test Suite\n---------------------------------------------------------\n[==========] Running 71 test(s).\n[ RUN      ] Test SafeInt8ToUint8\n[  ERROR   ] --- UT_ASSERT_EQUAL(0x5b:5b, Result:5c)\n[   LINE   ] --- c:\\_uefi\\edk2\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure!\n[  FAILED  ] Test SafeInt8ToUint8\n[ RUN      ] Test SafeInt8ToUint16\n[       OK ] Test SafeInt8ToUint16\n[ RUN      ] Test SafeInt8ToUint32\n[       OK ] Test SafeInt8ToUint32\n[ RUN      ] Test SafeInt8ToUintn\n[       OK ] Test SafeInt8ToUintn\n...\n</code></pre> <p>You can also, if you are so inclined, read the output from the exact instance of the test that was run during <code>stuart_ci_build</code>. The ouput file can be found on a path that looks like:</p> <p><code>Build/&lt;Package&gt;/HostTest/&lt;Arch&gt;/&lt;TestName&gt;.&lt;TestSuiteName&gt;.&lt;Arch&gt;.result.xml</code></p> <p>A sample of this output looks like:</p> <pre><code>&lt;!--\n  Excerpt taken from:\n  Build\\MdePkg\\HostTest\\NOOPT_VS2019\\X64\\TestBaseSafeIntLibHost.exe.Int Safe Conversions Test Suite.X64.result.xml\n  --&gt;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;testsuites&gt;\n&lt;testsuite name=\"Int Safe Conversions Test Suite\" time=\"0.000\" tests=\"71\" failures=\"1\" errors=\"0\" skipped=\"0\" &gt;\n&lt;testcase name=\"Test SafeInt8ToUint8\" time=\"0.000\" &gt;\n&lt;failure&gt;&lt;![CDATA[UT_ASSERT_EQUAL(0x5c:5c, Result:5b)\nc:\\_uefi\\MdePkg\\Test\\UnitTest\\Library\\BaseSafeIntLib\\TestBaseSafeIntLib.c:35: error: Failure!]]&gt;&lt;/failure&gt;\n&lt;/testcase&gt;\n&lt;testcase name=\"Test SafeInt8ToUint16\" time=\"0.000\" &gt;\n&lt;/testcase&gt;\n&lt;testcase name=\"Test SafeInt8ToUint32\" time=\"0.000\" &gt;\n&lt;/testcase&gt;\n&lt;testcase name=\"Test SafeInt8ToUintn\" time=\"0.000\" &gt;\n&lt;/testcase&gt;\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#xml-reporting-mode","title":"XML Reporting Mode","text":"<p>Since these applications are built using the CMocka framework, they can also use the following env variables to output in a structured XML rather than text:</p> <pre><code>CMOCKA_MESSAGE_OUTPUT=xml\nCMOCKA_XML_FILE=&lt;absolute or relative path to output file&gt;\n</code></pre> <p>This mode is used by the test running plugin to aggregate the results for CI test status reporting in the web view.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#code-coverage","title":"Code Coverage","text":"<p>Host based Unit Tests will automatically include GCC build flags to enable coverage data. This is primarily leveraged for pipeline builds, but this can be leveraged locally using the lcov linux tool, and parsed using the lcov_cobertura python tool. pycobertura is used to covert this coverage data to a human readable HTML file. These tools must be installed to parse code coverage.</p> <pre><code>sudo apt-get install -y lcov\npip install lcov_cobertura\npip install pycobertura\n</code></pre> <p>During CI builds, use the  <code>CODE_COVERAGE=TRUE</code> flag to generate the code coverage XML files, and additionally use the <code>CC_HTML=TRUE</code> flag to generate the HTML file. This will be generated in Build/coverage.html.</p> <p>There is currently no official guidance or support for code coverage when compiling in Visual Studio at this time.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#important-note","title":"Important Note","text":"<p>This works on both Windows and Linux, but is currently limited to x64 architectures. Working on getting others, but we also welcome contributions.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#known-limitations","title":"Known Limitations","text":""},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#pei-dxe-smm","title":"PEI, DXE, SMM","text":"<p>While sample tests have been provided for these execution environments, only cursory build validation has been performed. Care has been taken while designing the frameworks to allow for execution during boot phases, but only UEFI Shell and host-based tests have been thoroughly evaluated. Full support for PEI, DXE, and SMM is forthcoming, but should be considered beta/staging for now.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#host-based-support-vs-other-tests","title":"Host-Based Support vs Other Tests","text":"<p>The host-based test framework is powered internally by the Cmocka framework. As such, it has abilities that the target-based tests don't (yet). It would be awesome if this meant that it was a super set of the target-based tests, and it worked just like the target-based tests but with more features. Unfortunately, this is not the case. While care has been taken to keep them as close a possible, there are a few known inconsistencies that we're still ironing out. For example, the logging messages in the target-based tests are cached internally and associated with the running test case. They can be saved later as part of the reporting lib. This isn't currently possible with host-based. Only the assertion failures are logged.</p> <p>We will continue trying to make these as similar as possible.</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#unit-test-locationlayout-rules","title":"Unit Test Location/Layout Rules","text":"Code/Test Location Host-Based Unit Tests for a Library/Protocol/PPI/GUID Interface If what's being tested is an interface (e.g. a library with a public header file, like DebugLib), the test should be scoped to the parent package.Example: <code>MdePkg/Test/UnitTest/[Library/Protocol/Ppi/Guid]/</code>A real-world example of this is the BaseSafeIntLib test in MdePkg.<code>MdePkg/Test/UnitTest/Library/BaseSafeIntLib/TestBaseSafeIntLibHost.inf</code> Host-Based Unit Tests for a Library/Driver (PEI/DXE/SMM) implementation If what's being tested is a specific implementation (e.g. BaseDebugLibSerialPort for DebugLib), the test should be scoped to the implementation directory itself, in a UnitTest subdirectory.Module Example: <code>MdeModulePkg/Universal/EsrtFmpDxe/UnitTest/</code>Library Example: <code>MdePkg/Library/BaseMemoryLib/UnitTest/</code> Host-Based Tests for a Functionality or Feature If you're writing a functional test that operates at the module level (i.e. if it's more than a single file or library), the test should be located in the package-level Tests directory under the HostFuncTest subdirectory.For example, if you were writing a test for the entire FMP Device Framework, you might put your test in:<code>FmpDevicePkg/Test/HostFuncTest/FmpDeviceFramework</code>If the feature spans multiple packages, it's location should be determined by the package owners related to the feature. Non-Host-Based (PEI/DXE/SMM/UefiShell) Tests for a Functionality or Feature Similar to Host-Based, if the feature is in one package, should be located in the <code>*Pkg/Test/[UefiShell/Dxe/Smm/Pei]Test</code> directory.If the feature spans multiple packages, it's location should be determined by the package owners related to the feature.USAGE EXAMPLESPEI Example: MP_SERVICE_PPI. Or check MTRR configuration in a notification function. SMM Example: a test in a protocol callback function. (It is different with the solution that SmmAgent+ShellApp)DXE Example: a test in a UEFI event call back to check SPI/SMRAM status.  Shell Example: the SMM handler audit test has a shell-based app that interacts with an SMM handler to get information. The SMM paging audit test gathers information about both DXE and SMM. And the SMM paging functional test actually forces errors into SMM via a DXE driver."},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#example-directory-tree","title":"Example Directory Tree","text":"<pre><code>&lt;PackageName&gt;Pkg/\n  ComponentY/\n    ComponentY.inf\n    ComponentY.c\n    UnitTest/\n      ComponentYUnitTestHost.inf      # Host-Based Test for Driver Module\n      ComponentYUnitTest.c\n\n  Library/\n    GeneralPurposeLibBase/\n      ...\n\n    GeneralPurposeLibSerial/\n      ...\n\n    SpecificLibDxe/\n      SpecificLibDxe.c\n      SpecificLibDxe.inf\n      UnitTest/                      # Host-Based Test for Specific Library Implementation\n        SpecificLibDxeUnitTest.c\n        SpecificLibDxeUnitTestHost.inf\n  Test/\n    &lt;Package&gt;HostTest.dsc             # Host-Based Test Apps\n    UnitTest/\n      InterfaceX\n        InterfaceXUnitTestHost.inf    # Host-Based App (should be in Test/&lt;Package&gt;HostTest.dsc)\n        InterfaceXUnitTestPei.inf     # PEIM Target-Based Test (if applicable)\n        InterfaceXUnitTestDxe.inf     # DXE Target-Based Test (if applicable)\n        InterfaceXUnitTestSmm.inf     # SMM Target-Based Test (if applicable)\n        InterfaceXUnitTestUefiShell.inf # Shell App Target-Based Test (if applicable)\n        InterfaceXUnitTest.c          # Test Logic\n\n      GeneralPurposeLib/              # Host-Based Test for any implementation of GeneralPurposeLib\n        GeneralPurposeLibTest.c\n        GeneralPurposeLibUnitTestHost.inf\n\n  &lt;Package&gt;Pkg.dsc          # Standard Modules and any Target-Based Test Apps (including in Test/)\n</code></pre>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#future-locations-in-consideration","title":"Future Locations in Consideration","text":"<p>We don't know if these types will exist or be applicable yet, but if you write a support library or module that matches the following, please make sure they live in the correct place.</p> Code/Test Location Host-Based Library Implementations Host-Based Implementations of common libraries (eg. MemoryAllocationLibHost) should live in the same package that declares the library interface in its .DEC file in the <code>*Pkg/Test/Library</code> directory. Should have 'Host' in the name. Host-Based Mocks and Stubs Mock and Stub libraries that require test infrastructure should live in the <code>UefiTestFrameworkPkg/Library</code> with either 'Mock' or 'Stub' in the library name."},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#if-still-in-doubt","title":"If still in doubt","text":"<p>Hop on GitHub and ask @corthon, @mdkinney, or @spbrogan. ;)</p>"},{"location":"dyn/mu_basecore/UnitTestFrameworkPkg/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_basecore/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_basecore/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_basecore/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/","title":"Character Encoding Check Plugin","text":"<p>This CiBuildPlugin scans all the files in a package to make sure each file is correctly encoded and all characters can be read.  Improper encoding causes tools to fail in some situations especially in different locals.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin can be configured to ignore certain files.</p> <pre><code>\"CharEncodingCheck\": {\n\"IgnoreFiles\": []\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/CharEncodingCheck/Readme/#ignorefiles","title":"IgnoreFiles","text":"<p>OPTIONAL List of file to ignore.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/","title":"CodeQL Plugin","text":"<p>The set of CodeQL plugins provided include two main plugins that seamlessly integrate into a Stuart build environment:</p> <ol> <li><code>CodeQlBuildPlugin</code> - Used to produce a CodeQL database from a build.</li> <li><code>CodeQlAnalyzePlugin</code> - Used to analyze a CodeQL database.</li> </ol> <p>While CodeQL can be run in a CI environment with other approaches. This plugin offers the following advantages:</p> <ol> <li>Provides exactly the same results locally as on a CI server.</li> <li>Integrates very well into VS Code.</li> <li>Very simple to use - just use normal Stuart update and build commands.</li> <li>Very simple to understand - minimally wraps the official CodeQL CLI.</li> <li>Very simple to integrate - works like any other Stuart build plugin.</li> <li>Integration is usually just a few lines of code.</li> <li>Portable - not tied to Azure DevOps specific, GitHub specific, or other host infrastructure.</li> <li>Versioned - the query and filters are versioned in source control so easy to find and track.</li> </ol> <p>\u2757 It is very important to read the Integration Instructions in this file and determine how to best integrate the CodeQL plugin into your environment.</p> <p>Due to the total size of dependencies required to run CodeQL and the flexibility needed by a platform to determine what CodeQL queries to run and how to interpret results, a number of configuration options are provided to allow a high degree of flexibility during platform integration.</p> <p>This document is focused on those setting up the CodeQL plugin in their environment. Once setup, end users simply need to use their normal build commands and process and CodeQL will be integrated with it. The most relevant section for such users is Local Development Tips.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Database and Analysis Result Locations</li> <li>Global Configuration</li> <li>Package-Specific Configuration</li> <li>Filter Patterns</li> <li>Integration Instructions</li> <li>Integration Step 1 - Choose Scopes<ul> <li>Scopes Available</li> </ul> </li> <li>Integration Step 2 - Choose CodeQL Queries</li> <li>Integration Step 3 - Determine Global Configuration Values</li> <li>Integration Step 4 - Determine Package-Specific Configuration Values</li> <li>Integration Step 5 - Testing</li> <li>Integration Step 6 - Define Inclusion and Exclusion Filter Patterns</li> <li>High-Level Operation</li> <li>CodeQlBuildPlugin</li> <li>CodeQlAnalyzePlugin</li> <li>Local Development Tips</li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#database-and-analysis-result-locations","title":"Database and Analysis Result Locations","text":"<p>The CodeQL database is written to a directory unique to the package and target being built:</p> <p><code>Build/codeql-db-&lt;package&gt;-&lt;target&gt;-&lt;instance&gt;</code></p> <p>For example: <code>Build/codeql-db-mdemodulepkg-debug-0</code></p> <p>The plugin does not delete or overwrite existing databases, the instance value is simply increased. This is because databases are large, take a long time to generate, and are important for reproducing analysis results. The user is responsible for deleting database directories when they are no longer needed.</p> <p>Similarly, analysis results are written to a directory unique to the package and target. For analysis, results are stored in individual files so those files are stored in a single directory.</p> <p>For example, all analysis results for the above package and target will be stored in:   <code>codeql-analysis-mdemodulepkg-debug</code></p> <p>CodeQL results are stored in SARIF (Static Analysis Results Interchange Format) (CodeQL SARIF documentation) files. Each SARIF file corresponding to a database will be stored in a file with an instance matching the database instance.</p> <p>For example, the analysis result file for the above database would be stored in this file:   <code>codeql-analysis-mdemodulepkg-debug/codeql-db-mdemodulepkg-debug-0.sarif</code></p> <p>Result files are overwritten. This is because result files are quick to generate and need to represent the latest results for the last analysis operation performed. The user is responsible for backing up SARIF result files if they need to saved.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#global-configuration","title":"Global Configuration","text":"<p>Global configuration values are specified with build environment variables.</p> <p>These values are all optional. They provide a convenient mechanism for a build script to set the value for all packages built by the script.</p> <ul> <li><code>STUART_CODEQL_AUDIT_ONLY</code> - If <code>true</code> (case insensitive), <code>CodeQlAnalyzePlugin</code> will be in audit-only mode. In this   mode all CodeQL failures are ignored.</li> <li><code>STUART_CODEQL_PATH</code> - The path to the CodeQL CLI application to use.</li> <li><code>STUART_CODEQL_QUERY_SPECIFIERS</code> - The CodeQL CLI query specifiers to use. See Running codeql database analyze   for possible options.</li> <li><code>STUART_CODEQL_FILTER_FILES</code> - The path to \"filter\" files that contains filter patterns as described in   Filter Patterns.</li> <li>More than one file may be specified by separating each absolute file path with a comma.<ul> <li>This might be useful to reference a global filter file from an upstream repo and also include a global filter   file for the local repo.</li> <li>Filters are concatenated in the order of files in the variable. Patterns in later files can override patterns   in earlier files.</li> </ul> </li> <li> <p>The file only needs to contain a list of filter pattern strings under a <code>\"Filters\"</code> key. For example:</p> <pre><code>  {\n\"Filters\": [\n\"&lt;pattern-line-1&gt;\",\n\"&lt;pattern-line-2&gt;\"\n]\n}\n...\n</code></pre> <p>Comments are allowed in the filter files and begin with <code>#</code> (like a normal YAML file).</p> </li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#package-specific-configuration","title":"Package-Specific Configuration","text":"<p>Package-specific configuration values reuse existing package-level configuration approaches to simplify adjusting CodeQL plugin behavior per package.</p> <p>These values are all optional. They provide a convenient mechanism for a package owner to adjust settings specific to the package.</p> <pre><code>  \"CodeQlAnalyze\": {\n\"AuditOnly\": False,         # Don't fail the build if there are errors. Just log them.\n\"QuerySpecifiers\": \"\"       # Query specifiers to pass to CodeQL CLI.\n\"Filters\": \"\"               # Inclusion/exclusion filters\n}\n</code></pre> <p>NOTE: If a global filter set is provided via <code>STUART_CODEQL_FILTER_FILES</code> and a package has a package-specific list, then the package-specific filter list (in a package CI YAML file) is appended onto the global filter list and may be used to override settings in the global list.</p> <p>The format used to specify items in <code>\"Filters\"</code> is specified in Filter Patterns.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#filter-patterns","title":"Filter Patterns","text":"<p>As you inspect results, you may want to include or exclude certain sets of results. For example, exclude some files by file path entirely or adjust the CodeQL rule applied to a certain file. This plugin reuses logic from a popular GitHub Action called <code>filter-sarif</code> to allow filtering as part of the plugin analysis process.</p> <p>If any results are excluded using filters, the results are removed from the SARIF file. This allows the exclude results seen locally to exactly match the results on the CI server.</p> <p>Read the \"Patterns\" section there for more details. The patterns section is also copied below with some updates to make the information more relevant for an edk2 codebase for convenience.</p> <p>Each pattern line is of the form:</p> <pre><code>[+/-]&lt;file pattern&gt;[:&lt;rule pattern&gt;]\n</code></pre> <p>For example:</p> <pre><code>-**/*Test*.c:**             # exclusion pattern: remove all alerts from all test files\n-**/*Test*.c                # ditto, short form of the line above\n+**/*.c:cpp/infiniteloop    # inclusion pattern: This line has precedence over the first two\n# and thus \"allow lists\" alerts of type \"cpp/infiniteloop\"\n**/*.c:cpp/infiniteloop     # ditto, the \"+\" in inclusion patterns is optional\n**                          # allow all alerts in all files (reverses all previous lines)\n</code></pre> <ul> <li>The path separator character in patterns is always <code>/</code>, independent of the platform the code is running on and   independent of the paths in the SARIF file.</li> <li><code>*</code> matches any character, except a path separator</li> <li><code>**</code> matches any character and is only allowed between path separators, e.g. <code>/**/file.txt</code>, <code>**/file.txt</code> or <code>**</code>.   NOT allowed: <code>**.txt</code>, <code>/etc**</code></li> <li>The rule pattern is optional. If omitted, it will apply to alerts of all types.</li> <li>Subsequent lines override earlier ones. By default all alerts are included.</li> <li>If you need to use the literals <code>+</code>, <code>-</code>, <code>\\</code> or <code>:</code> in your pattern, you can escape them with <code>\\</code>, e.g.   <code>\\-this/is/an/inclusion/file/pattern\\:with-a-semicolon:and/a/rule/pattern/with/a/\\\\/backslash</code>. For <code>+</code> and <code>-</code>, this   is only necessary if they appear at the beginning of the pattern line.</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-instructions","title":"Integration Instructions","text":"<p>First, note that most CodeQL CLI operations will take a long time the first time they are run. This is due to:</p> <ol> <li>Downloads - Downloading the CodeQL CLI binary (during <code>stuart_update</code>) and downloading CodeQL queries during    CodeQL plugin execution</li> <li>Cache not established - CodeQL CLI caches data as it performs analysis. The first time analysis is performed will    take more time than in the future.</li> </ol> <p>Second, these are build plugins. This means a build needs to take place for the plugins to run. This typically happens in the following two scenarios:</p> <ol> <li><code>stuart_build</code> - A single package is built and the build process is started by the stuart tools.</li> <li><code>stuart_ci_build</code> - A number of packages may be built and the build process is started by the <code>CompilerPlugin</code>.</li> </ol> <p>In any case, each time a package is built, the CodeQL plugins will be run if their scopes are active.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-1-choose-scopes","title":"Integration Step 1 - Choose Scopes","text":"<p>Decide which scopes need to be enabled in your platform, see Scopes Available.</p> <p>Consider using a build profile to enable CodeQL so developers and pipelines can use the profile when they are interested in CodeQL results but in other cases they can easily work without CodeQL in the way.</p> <p>Furthermore, build-script specific command-line parameters might be useful to control CodeQL scopes and other behavior.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#scopes-available","title":"Scopes Available","text":"<p>This CodeQL plugin leverages scopes to control major pieces of functionality. Any combination of scopes can be returned from the <code>GetActiveScopes()</code> function in the platform settings manager to add and remove functionality.</p> <p>Plugin scopes:</p> <ul> <li><code>codeql-analyze</code> - Activate <code>CodeQlAnalyzePlugin</code> to perform post-build analysis of the last generated database for   the package and target specified.</li> <li><code>codeql-build</code> - Activate <code>CodeQlBuildPlugin</code> to hook the firmware build in pre-build such that the build will   generate a CodeQL database during build.</li> </ul> <p>In most cases, to perform a full CodeQL run, <code>codeql-build</code> should be enabled so a new CodeQL database is generated during build and <code>codeql-analyze</code> should be be enabled so analysis of that database is performed after the build is completed.</p> <p>External dependency scopes:</p> <ul> <li><code>codeql-ext-dep</code> - Downloads the cross-platform CodeQL CLI as an external dependency.</li> <li><code>codeql-linux-ext-dep</code> - Downloads the Linux CodeQL CLI as an external dependency.</li> <li><code>codeql-windows-ext-dep</code> - Downloads the Windows CodeQL CLI as an external dependency.</li> </ul> <p>Note, that the CodeQL CLI is large in size. Sizes as of the v2.11.2 release.</p> Cross-platform Linux Windows 934 MB 415 MB 290 MB <p>Therefore, the following is recommended:</p> <ol> <li>Ideal - Create container images for build agents and install the CodeQL CLI for the container OS into the    container.</li> <li>Leverage host-OS detection (e.g. <code>GetHostInfo()</code>) to set the scope for the appropriate operating system. This will download the much smaller OS-specific application.</li> </ol> <p>NOTE: You should never have more than one CodeQL external dependency scope enabled at a time.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-2-choose-codeql-queries","title":"Integration Step 2 - Choose CodeQL Queries","text":"<p>Determine which queries need to be run against packages in your repo. In most cases, the same set of queries will be run against all packages. It is also possible to customize the queries run at the package level.</p> <p>The default set of Project Mu CodeQL queries is specified in the <code>MuCodeQlQueries.qls</code> file in this plugin.</p> <p>NOTE: The queries in <code>MuCodeQlQueries.qls</code> may change at any time. If you do not want these changes to impact your platform, do not relay on option (3).</p> <p>The plugin decides what queries to run based on the following, in order of preference:</p> <ol> <li>Package CI YAML file query specifier</li> <li>Build environment variable query specifier</li> <li>Plugin default query set file</li> </ol> <p>For details on how to set (1) and (2), see the Package CI Configuration and Environment Variable sections respectively.</p> <p>NOTE: The value specified is directly passed as a <code>query specifier</code> to CodeQL CLI. Therefore, the arguments allowed by the <code>&lt;query-specifiers&gt;</code> argument of CodeQL CLI are allowed here. See Running codeql database analyze.</p> <p>A likely scenario is that a platform needs to run local/closed source queries in addition to the open-source queries. There's various ways to handle that:</p> <ol> <li>Create a query specifier that includes all the queries needed, both public and private and use that query specifier,    either globally or at package-level.</li> </ol> <p>For example, at the global level - <code>STUART_CODEQL_QUERY_SPECIFIERS</code> = \"Absolute_path_to_AllMyQueries.qls\"</p> <ol> <li>Specify a query specifier that includes the closed sources queries and reuse the public query list provided by    this plugin.</li> </ol> <p>For example, at the global level - <code>STUART_CODEQL_QUERY_SPECIFIERS</code> = \"Absolute_path_to_MuCodeQlQueries.qls    Absolute_path_to_ClosedSourceQueries.qls\"</p> <p>Refer to the CodeQL documentation noted above on query specifiers to devise other options.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-3-determine-global-configuration-values","title":"Integration Step 3 - Determine Global Configuration Values","text":"<p>Review the Environment Variable section to determine which, if any, global values need to be set in your build script.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-4-determine-package-specific-configuration-values","title":"Integration Step 4 - Determine Package-Specific Configuration Values","text":"<p>Review the Package CI Configuration section to determine which, if any, global values need to be set in your package's CI YAML file.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-5-testing","title":"Integration Step 5 - Testing","text":"<p>Verify a <code>stuart_update</code> and <code>stuart_build</code> (or <code>stuart_ci_build</code>) command work.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#integration-step-6-define-inclusion-and-exclusion-filter-patterns","title":"Integration Step 6 - Define Inclusion and Exclusion Filter Patterns","text":"<p>After reviewing the test results from Step 5, determine if you need to apply any filters as described in Filter Patterns.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#high-level-operation","title":"High-Level Operation","text":"<p>This section summarizes the complete CodeQL plugin flow. This is to help developers understand basic theory of operation behind the plugin and can be skipped by anyone not interested in those details.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#codeqlbuildplugin","title":"CodeQlBuildPlugin","text":"<ol> <li>Register a pre-build hook</li> <li>Determine the package and target being built</li> <li>Determine the best CodeQL CLI path to use</li> <li>First choice, the <code>STUART_CODEQL_PATH</code> environment variable<ul> <li>Note: This is set by the CodeQL CLI external dependency if that is used</li> </ul> </li> <li>Second choice, <code>codeql</code> as found on the system path</li> <li>Determine the directory name for the CodeQL database</li> <li>Format: <code>Build/codeql-db-&lt;package&gt;-&lt;target&gt;-&lt;instance&gt;</code></li> <li>Clean the build directory of the active platform and target</li> <li>CodeQL database generation only works on clean builds</li> <li>Ensure the \"build\" step is not skipped as a build is needed to generate a CodeQL database</li> <li>Build a CodeQL file that wraps around the edk2 build</li> <li>Written to the package build directory<ul> <li>Example: <code>Build/MdeModulePkg/VS2022/codeql_build_command.bat</code></li> </ul> </li> <li>Set the variables necessary for stuart to call CodeQL CLI during the build phase</li> <li>Sets <code>EDK_BUILD_CMD</code> and <code>EDK_BUILD_PARAMS</code></li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#codeqlanalyzeplugin","title":"CodeQlAnalyzePlugin","text":"<ol> <li>Register a post-build hook</li> <li>Determine the package and target being built</li> <li>Determine the best CodeQL CLI path to use</li> <li>First choice, the <code>STUART_CODEQL_PATH</code> environment variable<ul> <li>Note: This is set by the CodeQL CLI external dependency if that is used</li> </ul> </li> <li>Second choice, <code>codeql</code> as found on the system path</li> <li>Determine the directory name for the most recent CodeQL database</li> <li>Format: <code>Build/codeql-db-&lt;package&gt;-&lt;target&gt;-&lt;instance&gt;</code></li> <li>Determine plugin audit status for the given package and target</li> <li>Check if <code>AuditOnly</code> is enabled either globally or for the package</li> <li>Determine the CodeQL query specifiers to use for the given package and target</li> <li>First choice, the package CI YAML file value</li> <li>Second choice, the <code>STUART_CODEQL_QUERY_SPECIFIERS</code></li> <li>Third choice, use <code>MuCodeQlQueries.qls</code> (in the plugin directory)</li> <li>Run CodeQL CLI to perform database analysis</li> <li>Parse the analysis SARIF file to determine the number of CodeQL failures</li> <li>Return the number of failures (or zero if <code>AuditOnly</code> is enabled)</li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/CodeQL/Readme/#local-development-tips","title":"Local Development Tips","text":"<p>This section contains helpful tips to expedite common scenarios when working with CodeQL locally.</p> <ol> <li>Pre-build, Build, and Post-Build</li> </ol> <p>Generating a database requires the pre-build and build steps. Analyzing a database requires the post-build step.</p> <p>Therefore, if you are making tweaks that don't affect the build, such as modifying the CodeQL queries used or level    of severity reported, you can save time by skipping pre-build and post-build (e.g. <code>--skipprebuild</code> and    <code>--skipbuild</code>).</p> <ol> <li>Scopes</li> </ol> <p>Similar to (1), add/remove <code>codeql-build</code> and <code>codeql-analyze</code> from the active scopes to save time depending on what    you are trying to do.</p> <p>If you are focusing on coding, remove the code CodeQL scopes if they are active. If you are ready to check your    changes against CodeQL, simply add the scopes back. It is recommended to use build profiles to do this more    conveniently.</p> <p>If you already have CodeQL CLI enabled, you can remove the <code>codeql-ext-dep</code> scope locally. The build will use the    <code>codeql</code> command on your path.</p> <ol> <li>CodeQL Output is in the CI Build Log</li> </ol> <p>To see exactly which queries CodeQL ran or why it might be taking longer than expected, look in the CI build log    (i.e. <code>Build/CI_BUILDLOG.txt</code>) where the CodeQL CLI application output is written.</p> <p>Search for the text you see in the progress output (e.g. \"Analyzing MdeModulePkg (DEBUG) CodeQL database at\")    to jump to the section of the log just before the CodeQL CLI is invoked.</p> <ol> <li>Use a SARIF Viewer to Read Results</li> </ol> <p>The SARIF Viewer extension for VS Code can open the .sarif file generated by this plugin and allow you to click links directly to the problem area in source files.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/","title":"Compiler Plugin","text":"<p>This CiBuildPlugin compiles the package DSC from the package being tested.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/#configuration","title":"Configuration","text":"<p>The package relative path of the DSC file to build.</p> <pre><code>\"CompilerPlugin\": {\n\"DscPath\": \"&lt;path to dsc from root of pkg&gt;\"\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/CompilerPlugin/Readme/#dscpath","title":"DscPath","text":"<p>Package relative path to the DSC file to build.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/","title":"Debug Macro Check","text":"<p>This Python application scans all files in a build package for debug macro formatting issues. It is intended to be a fundamental build-time check that is part of a normal developer build process to catch errors right away.</p> <p>As a build plugin, it is capable of finding these errors early in the development process after code is initially written to ensure that all code tested is free of debug macro formatting errors. These errors often creep into debug prints in error conditions that are not frequently executed making debug even more difficult and confusing when they are encountered. In other cases, debug macros with these errors in the main code path can lead to unexpected behavior when executed. As a standalone script, it can be easily run manually or integrated into other CI processes.</p> <p>The plugin is part of a set of debug macro check scripts meant to be relatively portable so they can be applied to additional code bases with minimal effort.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#1-buildplugindebugmacrocheckbuildpluginpy","title":"1. BuildPlugin/DebugMacroCheckBuildPlugin.py","text":"<p>This is the build plugin. It is discovered within the Stuart Self-Describing Environment (SDE) due to the accompanying file <code>DebugMacroCheck_plugin_in.yaml</code>.</p> <p>Since macro errors are considered a coding bug that should be found and fixed during the build phase of the developer process (before debug and testing), this plugin is run in pre-build. It will run within the scope of the package being compiled. For a platform build, this means it will run against the package being built. In a CI build, it will run in pre-build for each package as each package is built.</p> <p>The build plugin has the following attributes:</p> <ol> <li> <p>Registered at <code>global</code> scope. This means it will always run.</p> </li> <li> <p>Called only on compilable build targets (i.e. does nothing on <code>\"NO-TARGET\"</code>).</p> </li> <li> <p>Runs as a pre-build step. This means it gives results right away to ensure compilation follows on a clean slate.      This also means it runs in platform build and CI. It is run in CI as a pre-build step when the <code>CompilerPlugin</code>      compiles code. This ensures even if the plugin was not run locally, all code submissions have been checked.</p> </li> <li> <p>Reports any errors in the build log and fails the build upon error making it easy to discover problems.</p> </li> <li> <p>Supports two methods of configuration via \"substitution strings\":</p> <ol> <li> <p>By setting a build variable called <code>DEBUG_MACRO_CHECK_SUB_FILE</code> with the name of a substitution YAML file to     use.</p> <p>Example:</p> <pre><code>shell_environment.GetBuildVars().SetValue(\n                                    \"DEBUG_MACRO_CHECK_SUB_FILE\",\n                                    os.path.join(self.GetWorkspaceRoot(), \"DebugMacroCheckSub.yaml\"),\n                                    \"Set in CISettings.py\")\n</code></pre> <p>Substitution File Content Example:</p> <pre><code>---\n# OvmfPkg/CpuHotplugSmm/ApicId.h\n# Reason: Substitute with macro value\nFMT_APIC_ID: 0x%08x\n\n# DynamicTablesPkg/Include/ConfigurationManagerObject.h\n# Reason: Substitute with macro value\nFMT_CM_OBJECT_ID: 0x%lx\n\n# OvmfPkg/IntelTdx/TdTcg2Dxe/TdTcg2Dxe.c\n# Reason: Acknowledging use of two format specifiers in string with one argument\n#         Replace ternary operator in debug string with single specifier\n'Index == COLUME_SIZE/2 ? \" | %02x\" : \" %02x\"': \"%d\"\n\n# DynamicTablesPkg/Library/Common/TableHelperLib/ConfigurationManagerObjectParser.c\n# ShellPkg/Library/UefiShellAcpiViewCommandLib/AcpiParser.c\n# Reason: Acknowledge that string *should* expand to one specifier\n#         Replace variable with expected number of specifiers (1)\nParser[Index].Format: \"%d\"\n</code></pre> </li> <li> <p>By entering the string substitutions directory into a dictionary called <code>StringSubstitutions</code> in a     <code>DebugMacroCheck</code> section of the package CI YAML file.</p> <p>Example:</p> <pre><code>\"DebugMacroCheck\": {\n\"StringSubstitutions\": {\n\"SUB_A\": \"%Lx\"\n}\n}\n</code></pre> </li> </ol> </li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#debug-macro-check-build-plugin-simple-disable","title":"Debug Macro Check Build Plugin: Simple Disable","text":"<p>The build plugin can simply be disabled by setting an environment variable named <code>\"DISABLE_DEBUG_MACRO_CHECK\"</code>. The plugin is disabled on existence of the variable. The contents of the variable are not inspected at this time.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#2-debugmacrocheckpy","title":"2. DebugMacroCheck.py","text":"<p>This is the main Python module containing the implementation logic. The build plugin simply wraps around it.</p> <p>When first running debug macro check against a new, large code base, it is recommended to first run this standalone script and address all of the issues and then enable the build plugin.</p> <p>The module supports a number of configuration parameters to ease debug of errors and to provide flexibility for different build environments.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#edk-2-pytool-library-dependency","title":"EDK 2 PyTool Library Dependency","text":"<p>This script has minimal library dependencies. However, it has one dependency you might not be familiar with on the Tianocore EDK 2 PyTool Library (edk2toollib):</p> <pre><code>from edk2toollib.utility_functions import RunCmd\n</code></pre> <p>You simply need to install the following pip module to use this library: <code>edk2-pytool-library</code> (e.g. <code>pip install edk2-pytool-library</code>)</p> <p>More information is available here:</p> <ul> <li>PyPI page: edk2-pytool-library</li> <li>GitHub repo: tianocore/edk2-pytool-library</li> </ul> <p>If you strongly prefer not including this additional dependency, the functionality imported here is relatively simple to substitute with the Python <code>subprocess</code> built-in module.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#examples","title":"Examples","text":"<p>Simple run against current directory:</p> <p><code>&gt; python DebugMacroCheck.py -w .</code></p> <p>Simple run against a single file:</p> <p><code>&gt; python DebugMacroCheck.py -i filename.c</code></p> <p>Run against a directory with output placed into a file called \"debug_macro_check.log\":</p> <p><code>&gt; python DebugMacroCheck.py -w . -l</code></p> <p>Run against a directory with output placed into a file called \"custom.log\" and debug log messages enabled:</p> <p><code>&gt; python DebugMacroCheck.py -w . -l custom.log -v</code></p> <p>Run against a directory with output placed into a file called \"custom.log\", with debug log messages enabled including python script function and line number, use a substitution file called \"file_sub.yaml\", do not show the progress bar, and run against .c and .h files:</p> <p><code>&gt; python DebugMacroCheck.py -w . -l custom.log -vv -s file_sub.yaml -n -e .c .h</code></p> <p>Note: It is normally not recommended to run against .h files as they and many other non-.c files normally do   not have full <code>DEBUG</code> macro prints.</p> <pre><code>usage: Debug Macro Checker [-h] (-w WORKSPACE_DIRECTORY | -i [INPUT_FILE]) [-l [LOG_FILE]] [-s SUBSTITUTION_FILE] [-v] [-n] [-q] [-u]\n                           [-df] [-ds] [-e [EXTENSIONS ...]]\n\nChecks for debug macro formatting errors within files recursively located within a given directory.\n\noptions:\n  -h, --help            show this help message and exit\n  -w WORKSPACE_DIRECTORY, --workspace-directory WORKSPACE_DIRECTORY\n                        Directory of source files to check.\n\n  -i [INPUT_FILE], --input-file [INPUT_FILE]\n                        File path for an input file to check.\n\n                        Note that some other options do not apply if a single file is specified such as the\n                        git options and file extensions.\n\n  -e [EXTENSIONS ...], --extensions [EXTENSIONS ...]\n                        List of file extensions to include.\n                        (default: ['.c'])\n\nOptional input and output:\n  -l [LOG_FILE], --log-file [LOG_FILE]\n                        File path for log output.\n                        (default: if the flag is given with no file path then a file called\n                        debug_macro_check.log is created and used in the current directory)\n\n  -s SUBSTITUTION_FILE, --substitution-file SUBSTITUTION_FILE\n                        A substitution YAML file specifies string substitutions to perform within the debug macro.\n\n                        This is intended to be a simple mechanism to expand the rare cases of pre-processor\n                        macros without directly involving the pre-processor. The file consists of one or more\n                        string value pairs where the key is the identifier to replace and the value is the value\n                        to replace it with.\n\n                        This can also be used as a method to ignore results by replacing the problematic string\n                        with a different string.\n\n  -v, --verbose-log-file\n                        Set file logging verbosity level.\n                         - None:    Info &amp; &gt; level messages\n                         - '-v':    + Debug level messages\n                         - '-vv':   + File name and function\n                         - '-vvv':  + Line number\n                         - '-vvvv': + Timestamp\n                        (default: verbose logging is not enabled)\n\n  -n, --no-progress-bar\n                        Disables progress bars.\n                        (default: progress bars are used in some places to show progress)\n\n  -q, --quiet           Disables console output.\n                        (default: console output is enabled)\n\n  -u, --utf8w           Shows warnings for file UTF-8 decode errors.\n                        (default: UTF-8 decode errors are not shown)\n\n\nOptional git control:\n  -df, --do-not-ignore-git-ignore-files\n                        Do not ignore git ignored files.\n                        (default: files in git ignore files are ignored)\n\n  -ds, --do-not-ignore-git_submodules\n                        Do not ignore files in git submodules.\n                        (default: files in git submodules are ignored)\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#string-substitutions","title":"String Substitutions","text":"<p><code>DebugMacroCheck</code> currently runs separate from the compiler toolchain. This has the advantage that it is very portable and can run early in the build process, but it also means pre-processor macro expansion does not happen when it is invoked.</p> <p>In practice, it has been very rare that this is an issue for how most debug macros are written. In case it is, a substitution file can be used to inform <code>DebugMacroCheck</code> about the string substitution the pre-processor would perform.</p> <p>This pattern should be taken as a warning. It is just as difficult for humans to keep debug macro specifiers and arguments balanced as it is for <code>DebugMacroCheck</code> pre-processor macro substitution is used. By separating the string from the actual arguments provided, it is more likely for developers to make mistakes matching print specifiers in the string to the arguments. If usage is reasonable, a string substitution can be used as needed.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#ignoring-errors","title":"Ignoring Errors","text":"<p>Since substitution files perform a straight textual substitution in macros discovered, it can be used to replace problematic text with text that passes allowing errors to be ignored.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DebugMacroCheck/Readme/#python-version-required-310","title":"Python Version Required (3.10)","text":"<p>This script is written to take advantage of new Python language features in Python 3.10. If you are not using Python 3.10 or later, you can:</p> <ol> <li>Upgrade to Python 3.10 or greater</li> <li>Run this script in a virtual environment with Python 3.10      or greater</li> <li>Customize the script for compatibility with your Python version</li> </ol> <p>These are listed in order of recommendation. (1) is the simplest option and will upgrade your environment to a newer, safer, and better Python experience. (2) is the simplest approach to isolate dependencies to what is needed to run this script without impacting the rest of your system environment. (3) creates a one-off fork of the script that, by nature, has a limited lifespan and will make accepting future updates difficult but can be done with relatively minimal effort back to recent Python 3 releases.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/","title":"Depdendency Check Plugin","text":"<p>A CiBuildPlugin that finds all modules (inf files) in a package and reviews the packages used to confirm they are acceptable.  This is to help enforce layering and identify improper dependencies between packages.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin must be configured with the acceptabe package dependencies for the package.</p> <pre><code>\"DependencyCheck\": {\n\"AcceptableDependencies\": [],\n\"AcceptableDependencies-&lt;MODULE_TYPE&gt;\": [],\n\"IgnoreInf\": []\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#acceptabledependencies","title":"AcceptableDependencies","text":"<p>Package dec files that are allowed in all INFs.  Example: MdePkg/MdePkg.dec</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#acceptabledependencies-","title":"AcceptableDependencies- <p>OPTIONAL Package dependencies for INFs that have module type . Example: AcceptableDependencies-HOST_APPLICATION.","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/DependencyCheck/Readme/#ignoreinf","title":"IgnoreInf <p>OPTIONAL list of INFs to ignore for this dependency check.</p>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/","title":"Dsc Complete Check Plugin","text":"<p>This CiBuildPlugin scans all INF files from a package and confirms they are listed in the package level DSC file. The test considers it an error if any INF does not appear in the <code>Components</code> section of the package-level DSC (indicating that it would not be built if the package were built). This is critical because much of the CI infrastructure assumes that all modules will be listed in the DSC and compiled.</p> <p>This test will ignore INFs in the following cases:</p> <ol> <li>When MODULE_TYPE = HOST_APPLICATION</li> <li>When a Library instance only supports the HOST_APPLICATION environment</li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin has a few configuration options to support the UEFI codebase.</p> <pre><code>\"DscCompleteCheck\": {\n\"DscPath\": \"\",   # Path to dsc from root of package\n\"IgnoreInf\": []  # Ignore INF if found in filesystem but not dsc\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#dscpath","title":"DscPath","text":"<p>Path to DSC to consider platform dsc</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/DscCompleteCheck/Readme/#ignoreinf","title":"IgnoreInf","text":"<p>Ignore error if Inf file is not listed in DSC file</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/EccCheck/Readme/","title":"EFI Coding style Check Plugin","text":"<p>This CiBuildPlugin finds the Ecc issues of newly added code in pull request.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/EccCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin can be configured to ignore certain files and issues.</p> <p>\"EccCheck\": {         \"ExceptionList\": [],         \"IgnoreFiles\": []     },     \"\"\"</p> <p>OPTIONAL List of file to ignore.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/","title":"Guid Check Plugin","text":"<p>This CiBuildPlugin scans all the files in a code tree to find all the GUID definitions.  After collection it will then look for duplication in the package under test.  Uniqueness of all GUIDs are critical within the UEFI environment. Duplication can cause numerous issues including locating the wrong data structure, calling the wrong function, or decoding the wrong data members.</p> <p>Currently Scanned:</p> <ul> <li>INF files are scanned for there Module guid</li> <li>DEC files are scanned for all of their Protocols, PPIs, and Guids as well as   the one package GUID.</li> </ul> <p>Any GUID value being equal to two names or even just defined in two files is considered an error unless in the ignore list.</p> <p>Any GUID name that is found more than once is an error unless all occurrences are Module GUIDs.  Since the Module GUID is assigned to the Module name it is common to have numerous versions of the same module named the same.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin has numerous configuration options to support the UEFI codebase.</p> <pre><code>\"GuidCheck\": {\n\"IgnoreGuidName\": [],\n\"IgnoreGuidValue\": [],\n\"IgnoreFoldersAndFiles\": [],\n\"IgnoreDuplicates\": []\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreguidname","title":"IgnoreGuidName","text":"<p>This list allows strings in two formats.</p> <ul> <li>GuidName</li> <li>This will remove any entry with this GuidName from the list of GUIDs     therefore ignoring any error associated with this name.</li> <li>GuidName=GuidValue</li> <li>This will also ignore the GUID by name but only if the value equals the     GuidValue.</li> <li>GuidValue should be in registry format.</li> <li>This is the suggested format to use as it will limit the ignore to only the     defined case.</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreguidvalue","title":"IgnoreGuidValue","text":"<p>This list allows strings in guid registry format GuidValue.</p> <ul> <li>This will remove any entry with this GuidValue from the list of GUIDs   therefore ignoring any error associated with this value.</li> <li>GuidValue must be in registry format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignorefoldersandfiles","title":"IgnoreFoldersAndFiles","text":"<p>This supports .gitignore file and folder matching strings including wildcards</p> <ul> <li>Any folder or file ignored will not be parsed and therefore any GUID defined   will be ignored.</li> <li>The plugin will always ignores the following [\"/Build\", \"/Conf\"]</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/GuidCheck/Readme/#ignoreduplicates","title":"IgnoreDuplicates","text":"<p>This supports strings in the format of GuidName=GuidName=GuidName</p> <ul> <li>For the error with the GuidNames to be ignored the list must match completely   with what is found during the code scan.</li> <li>For example if there are two GUIDs that are by design equal within the code     tree then it should be GuidName=GuidName</li> <li>If instead there are three GUIDs then it must be     GuidName=GuidName=GuidName</li> <li>This is the best ignore list to use because it is the most strict and will   catch new problems when new conflicts are introduced.</li> <li>There are numerous places in the UEFI specification in which two GUID names   are assigned the same value.  These names should be set in this ignore list so   that they don't cause an error but any additional duplication would still be   caught.</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/","title":"Host UnitTest Compiler Plugin","text":"<p>A CiBuildPlugin that compiles the dsc for host based unit test apps.</p> <p>To run the unit tests and collect the results after successful compilation, The host UnitTest Compliler Plugin will execute any IUefiBuildPlugin that has the scope 'host-based-test'.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#configuration","title":"Configuration","text":"<p>The package relative path of the DSC file to build.</p> <pre><code>\"HostUnitTestCompilerPlugin\": {\n\"DscPath\": \"&lt;path to dsc from root of pkg&gt;\"\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#dscpath","title":"DscPath","text":"<p>Package relative path to the DSC file to build.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestCompilerPlugin/Readme/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/","title":"Host Unit Test Dsc Complete Check Plugin","text":"<p>This CiBuildPlugin scans all INF files from a package for those related to host based unit tests confirms they are listed in the unit test DSC file for the package. The test considers it an error if any INF meeting the requirements does not appear in the <code>Components</code> section of the unit test DSC. This is critical because much of the CI infrastructure assumes that  modules will be listed in the DSC and compiled.</p> <p>This test will only require INFs in the following cases:</p> <ol> <li>When MODULE_TYPE = HOST_APPLICATION</li> <li>When a Library instance supports the HOST_APPLICATION environment</li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin has a few configuration options to support the UEFI codebase.</p> <pre><code>\"HostUnitTestDscCompleteCheck\": {\n\"DscPath\": \"\", # Path to Host based unit test DSC file\n\"IgnoreInf\": []  # Ignore INF if found in filesystem but not dsc\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#dscpath","title":"DscPath","text":"<p>Path to DSC to consider platform dsc</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/HostUnitTestDscCompleteCheck/Readme/#ignoreinf","title":"IgnoreInf","text":"<p>Ignore error if Inf file is not listed in DSC file</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/","title":"PECOFF Image Validation - Post Build pe Image Validation Plugin","text":"<p>This tool will validate all pe images against a set of tests and their associated requirements as defined below. A configuration file is used to describe different profiles, and their associated requirements. A configuration file path is provided via the command line as <code>PE_VALIDATION_PATH=&lt;PATH&gt;</code> or can be configured in the the PlatformBuild.py within the <code>SetPlatformEnv()</code> method using  <code>self.env.SetValue(\"PE_VALIDATION_PATH\", &lt;PATH&gt;, \"Platform Hardcoded\")</code>. A  profile is equivalent to the file types defined in the platform's fdf. All profiles must be defined, forcing the developer to acklowedge each, however requirements for each profile do not need to be specified... If one or more requirement does not exist, the \"DEFAULT\" profile requirements will be used. The developer can have default requirements via the \"DEFAULT\" profile then override those requirements in other profiles. An example of a full config file can be seen at the bootom of the readme.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#common-errors","title":"Common Errors","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profile-type-is-invalid-exiting","title":"Profile type  is invalid. Exiting... <p>PROFILE_NAME is not specified in the configuration file, but is defined in the platform's fdf. The profile needs to be added to the configuration file, even if the requirements are the same as the DEFAULT requirements. This was a design choice to ensure the platform is not accidently passing due to falling back to the DEFAULT profile if a profile is missing.</p>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#test-specific-failures","title":"Test specific failures <p>See the below Tests section for test specific failures.</p>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#tests","title":"Tests","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#section-data-code-separation-verification","title":"Section Data / Code Separation Verification <ul> <li> <p>Description: This test ensures that each section of the binary is not both write-able and execute-able. Sections can only be one or the other (or neither). This test is done by iterating over each section and checking the characteristics label for the Write Mask (0x80000000) and Execute Mask (0x20000000).</p> </li> <li> <p>JSON File Requirements: <code>\"DATA_CODE_SEPARATION\": &lt;True or False&gt;</code></p> </li> <li> <p>Output:</p> </li> <li>@Success: Only one (or neither) of the two masks (Write, Execute) are present</li> <li> <p>@Fail   : Both the Write and Execute flags are present</p> </li> <li> <p>Possible Solution: Update the failed section's characteristics to ensure it is either Write-able or Read-able, but not both.</p> </li> </ul>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#section-alignment-verification","title":"Section Alignment Verification <ul> <li> <p>Description: Checks the section alignment value found in the optional header. This value must meet the requirements specified in the config file.</p> </li> <li> <p>JSON File Requirements: An array of dictionaries that contain a Comparison and a value for the particular MachineType and FV file type. See the below example. Can optionally describe an Alignment logic separator when doing multiple comparisons.</p> </li> </ul> <pre><code>\"ALIGNMENT_LOGIC_SEP\": \"OR\",\n\"ALIGNMENT\" : [\n    {\n        \"COMPARISON\" : \"==\",\n        \"VALUE\"      : 64\n    },\n    {\n        \"COMPARISON\" : \"==\",\n        \"VALUE\"      : 32\n    }\n]\n</code></pre> <ul> <li>Output:</li> <li>@Success: Image alignment passes all requirements specified in the config   file</li> <li>@Warn   : Image alignment value is not found in the optional header, or the   value is set to 0</li> <li> <p>@Fail   : Image alignment does not meet the requirements specified in the   config file</p> </li> <li> <p>Possible Solution: Update the section alignment of the binary to match the requirements specified in the config file.</p> </li> </ul>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#target-subsystem-type-verification","title":"Target Subsystem Type Verification <ul> <li> <p>Description: Checks the subsystem value by accessing the optional header, then subsystem value. This value must match the subsystem described in the config file.</p> </li> <li> <p>JSON File Requirements: An updated list of allowed subsystems, using the offical name. See the below example.</p> </li> </ul> <pre><code>\"ALLOWED_SUBSYSTEMS\" : [\n    \"IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\",\n    \"IMAGE_SUBSYSTEM_EFI_ROM\"\n]\n</code></pre> <ul> <li>Output:</li> <li>@Success: Subsystem type found in the optional header matches the   subsystem type described in the config file</li> <li>@Warn   : Subsystem type is not found in the optional header</li> <li> <p>@Fail   : Subsystem type found in the optional header does not match   the subsystem type described in the config file</p> </li> <li> <p>Possible Solution: Verify which of the two subsystem type's is incorrect. If it is the subsystem type found in the config file, update the config file. If it is the subsystem type found in the binary, update the machine type in the source code and re-compile.</p> </li> </ul>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#example","title":"Example <pre><code>\"IMAGE_FILE_MACHINE_ARM64\" : {\n    \"BASE\" : {\n        \"ALIGNMENT\" : [\n            {\n                \"COMPARISON\" : \"&gt;=\",\n                \"VALUE\"      : 4096   \n            },\n            {\n                \"COMPARISON\" : \"!=\",\n                \"VALUE\"      : 65536\n            }     \n        ]\n    },\n    \"SEC\" : {\n        \"ALIGNMENT\" : []\n    },\n}\n</code></pre>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#writing-your-own-tests","title":"Writing your own tests <p>If a developer wishes to write their own test, they must implement the interface described in the Test Interface class:</p> <pre><code>class TestInterface:\n    def name(self):\n        \"\"\"Returns the name of the test\"\"\"\n        raise NotImplementedError(\"Must Override Test Interface\")\n\n    def execute(self, parser, config_data):\n        \"\"\"Executes the test\"\"\"\n        raise NotImplementedError(\"Must Override Test Interface\")\n</code></pre> <p>The parser is the parsed pe file that you are testing. Documentation on how to use the parser can be found by looking up the documentation for the pefile module. The config_data provided to the test will is the filtered data from the config file based upon the compilation target and profile. As an example, looking at the above json file, if a pe that is being validated is of type IMAGE_FILE_MACHINE_ARM64 and profile BASE, the config_data provided will be:</p> <pre><code>\"ALIGNMENT\" : [\n    {\n        \"COMPARISON\" : \"&gt;=\",\n        \"VALUE\"      : 4096   \n    },\n    {\n        \"COMPARISON\" : \"!=\",\n        \"VALUE\"      : 65536\n    }     \n]\n</code></pre> <p>The developer also has the ability to provide additional requirements other then ALIGNMENT, and those requirements will also be provided to the test as seen in the below example:</p> <pre><code>\"ALIGNMENT\" : [\n    {\n        \"COMPARISON\" : \"&gt;=\",\n        \"VALUE\"      : 4096   \n    },\n    {\n        \"COMPARISON\" : \"!=\",\n        \"VALUE\"      : 65536\n    }     \n],\n\"OTHER_REQUIREMENT\"  : 5,\n\"OTHER_REQUIREMENT2\" : {\"Req1\" : 1, \"Req2\" : 2}\n</code></pre> <p>For the test to be executed, provide the test to the test manager using <code>add_test(test)</code> or <code>add_tests(tests)</code> functions</p>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#config-file-example","title":"Config File Example","text":"<p>The config file is used to describe all requirements for the scanned pe file. The configuration data provided to each test is provided to the test by first locating the Compilation Target, then by the optional profile parameter. If no profile parameter is provided, \"DEFAULT\" is used. The current allowed  settings are as follows:</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#top-level-settings","title":"Top Level Settings","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#target_arch","title":"TARGET_ARCH","text":"<p>This defines a dictionary between the build name using by stuart and the actual Image File Machine Constant name found at https://docs.microsoft.com/en-us/windows/win32/sysinfo/image-file-machine-constants.</p> <pre><code>TARGET_ARCH : {\"&lt;Build Name&gt;\" : \"&lt;Image File Machine Constant&gt;\"}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#ignore_list","title":"IGNORE_LIST","text":"<p>This defines a list of all pe file names that this tool should not execute on.</p> <pre><code>\"IGNORE_LIST\" : [\"efi1\", \"efi2\", \"etc\"]\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#image_file_machine_xxxx","title":"IMAGE_FILE_MACHINE_XXXX","text":"<p>This will be any number of supported Image File Machine Constants that are supported by the build system. This will not be a list (using [ ]), rather a comma separated list of all machine constants.</p> <pre><code>\"IMAGE_FILE_MACHINE_XXX1\" : {\"&lt;Profiles&gt;\"},\n\"IMAGE_FILE_MACHINE_XXX2\" : {\"&lt;Profiles&gt;\"},\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#machine-level-settings","title":"Machine Level Settings","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profiles","title":"Profiles","text":"<p>This will be any number of supported profiles for the particular Image File Machine Constant. This will not be a list (using [ ]), rather a comma separated list of all machine constants.</p> <pre><code>\"Profile1\" : {\"&lt;Settings&gt;\"},\n\"Profile2\" : {\"&lt;Settings&gt;\"}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#profile-level-settings","title":"Profile Level Settings","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#data_code_separation","title":"DATA_CODE_SEPARATION","text":"<p>This setting controls if data code separation (cannot be both write and execute) are required for this profile.</p> <pre><code>\"DATA_CODE_SEPARATION\" : &lt;bool&gt;\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#allowed_subsystems","title":"ALLOWED_SUBSYSTEMS","text":"<p>This setting allows the developer to specify the type of subsystem the efi should be for a particular profile. Subystems are defined at https://docs.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170.</p> <pre><code>\"ALLOWED_SUBSYSTEMS\": [\"subsystem1\", \"subsystem2\", \"etc\"]\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#alignment","title":"ALIGNMENT","text":"<p>This setting allows the developer to specify memory alignment requirements for a particular profile as a list of requirements.</p> <pre><code>\"ALIGNMENT\" : [\n{\n\"COMPARISON\" : \"&lt;Comparison Operator&gt;\",\n\"VALUE\" : &lt;Value&gt;\n},\n{\n\"COMPARISON\" : \"&lt;Comparison Operator&gt;\",\n\"VALUE\" : &lt;Value&gt;\n}\n]\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#alignment_logic_sep","title":"ALIGNMENT_LOGIC_SEP","text":"<p>This setting is only used if the alignment requirements specify multiple requirements. It is used to specify how the multiple requirements interact.</p> <pre><code>\"ALIGNMENT_LOGIC_SEP\" : \"&lt;Logical Operator&gt;\"\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/ImageValidation/ReadMe/#full-configuration-file-example","title":"Full Configuration File Example <pre><code>{   \n    \"TARGET_ARCH\" : {\n        \"X64\"     : \"IMAGE_FILE_MACHINE_AMD64\",\n        \"IA32\"    : \"IMAGE_FILE_MACHINE_I386\",\n        \"AARCH64\" : \"IMAGE_FILE_MACHINE_ARM64\",\n        \"ARM\"     : \"IMAGE_FILE_MACHINE_ARM\"\n    },\n    \"IGNORE_LIST\" : [\"Shell.efi\"],\n    \"IMAGE_FILE_MACHINE_AMD64\" : {\n        \"DEFAULT\" : {\n            \"DATA_CODE_SEPARATION\": true,\n            \"ALIGNMENT_LOGIC_SEP\": \"OR\",\n            \"ALIGNMENT\" : [\n                {\n                    \"COMPARISON\" : \"==\",\n                    \"VALUE\"      : 64\n                },\n                {\n                    \"COMPARISON\" : \"==\",\n                    \"VALUE\"      : 32\n                }\n            ]\n        },\n        \"APPLICATION\" : {\n            \"ALLOWED_SUBSYSTEMS\" : [\"EFI_APPLICATION\"],\n            \"ALIGNMENT\" : [\n                {\n                    \"COMPARISON\" : \"==\",\n                    \"VALUE\"      : 64\n                }\n            ]\n        },\n        \"UEFI_APPLICATION\" : {\n            \"ALLOWED_SUBSYSTEMS\" : [\"EFI_APPLICATION\"],\n            \"ALIGNMENT\" : [\n                {\n                    \"COMPARISON\" : \"==\",\n                    \"VALUE\"      : 32\n                }\n            ]\n        }\n    },\n    \"IMAGE_FILE_MACHINE_ARM\" : {\n        \"DEFAULT\": {\"DATA_CODE_SEPARATION\": true}\n    },\n    \"IMAGE_FILE_MACHINE_ARM64\" : {\n        \"DEFAULT\": {\"DATA_CODE_SEPARATION\": true}\n    },\n    \"IMAGE_FILE_MACHINE_I386\" : {\n        \"DEFAULT\" : {\n            \"DATA_CODE_SEPARATION\": true,\n            \"ALIGNMENT\" : [\n                {\n                    \"COMPARISON\" : \"&gt;=\",\n                    \"VALUE\"      : 4096\n                }\n            ]\n        },\n        \"APPLICATION\" : {\n            \"ALLOWED_SUBSYSTEMS\" : [\"EFI_APPLICATION\"]\n        }\n    }  \n}\n</code></pre>","text":""},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/","title":"Library Class Check Plugin","text":"<p>This CiBuildPlugin scans at all library header files found in the <code>Library</code> folders in all of the package's declared include directories and ensures that all files have a matching LibraryClass declaration in the DEC file for the package. Any missing declarations will cause a failure.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin has a few configuration options to support the UEFI codebase.</p> <pre><code>\"LibraryClassCheck\": {\n    IgnoreHeaderFile: [],  # Ignore a file found on disk\n    IgnoreLibraryClass: [] # Ignore a declaration found in dec file\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#ignoreheaderfile","title":"IgnoreHeaderFile","text":"<p>Ignore a file found on disk</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LibraryClassCheck/Readme/#ignorelibraryclass","title":"IgnoreLibraryClass","text":"<p>Ignore a declaration found in dec file</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/","title":"License Check Plugin","text":"<p>This CiBuildPlugin scans all new added files in a package to make sure code is contributed under BSD-2-Clause-Patent.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin can be configured to ignore certain files.</p> <pre><code>\"LicenseCheck\": {\n\"IgnoreFiles\": []\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/LicenseCheck/Readme/#ignorefiles","title":"IgnoreFiles","text":"<p>OPTIONAL List of file to ignore.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/","title":"Line Ending Check Plugin","text":"<p>This CiBuildPlugin scans all the files in a package to verify that the line endings are CRLF.</p> <p>Note: If you encounter a line ending issue found by this plugin, update your development environment to avoid issues again in the future.</p> <p>Most problems are caused by <code>autocrlf=true</code> in git settings, which will automatically adjust line endings upon checkout and commit which distorts the actual line endings from being consistent locally and remotely. In other cases, developing within a Linux workspace will natively use LF by default.</p> <p>It is simplest to set <code>autocrlf=false</code> to prevent manipulation of line endings outside of the actual values and set up your editor to use CRLF line endings within the project.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin can be configured to ignore certain files.</p> <pre><code>\"LineEndingCheck\": {\n\"IgnoreFiles\": []\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/LineEndingCheck/Readme/#ignorefiles","title":"IgnoreFiles","text":"<p>An optional list of git ignore patterns relative to the package root used to exclude files from being checked.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/","title":"Markdown Lint Plugin","text":"<p>This CiBuildPlugin scans all the markdown files in a given package and checks for linter errors.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#requirements","title":"Requirements","text":"<p>The test case in this plugin will be skipped if the requirements are not met.</p> <ol> <li>NodeJs installed and on your path</li> <li><code>markdownlint-cli</code> NodeJs package installed</li> <li> <p>a <code>.markdownlint.yaml</code> config file either at your repository root or package root.</p> </li> <li> <p>NodeJS: https://nodejs.org/en/</p> </li> <li>markdownlint-cli: https://www.npmjs.com/package/markdownlint-cli</li> <li>Src available:  https://github.com/igorshubovych/markdownlint-cli</li> </ol>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#configuration","title":"Configuration","text":"<p>It is desired to use standard configuration methods so that both local editors (vscode, etc) and the CI process leverage the same configuration.  This mostly works but for ignoring files there is currently a small discrepancy.</p> <p>First there is/can be a <code>.markdownlintignore</code> file at root of the repository.  This file much like a <code>.gitignore</code> is great for broadly ignoring files with patterns.  This works for both editor/ci.</p> <p>But for package based ignores and to keep the control of which files to ignore within the package there is no answer that supports both CI and editors.  Open question here https://github.com/DavidAnson/vscode-markdownlint/issues/130</p> <p>For the CI plugin you can use the IgnoreFiles configuration option described in the Plugin Configuration.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#plugin-configuration","title":"Plugin Configuration","text":"<p>The plugin has only minimal configuration options to support the UEFI codebase.</p> <pre><code>  \"MarkdownLintCheck\": {\n\"AuditOnly\": False,          # If True, log all errors and then mark as skipped\n\"IgnoreFiles\": []            # package root relative file, folder, or glob pattern to ignore\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#auditonly","title":"AuditOnly","text":"<p>Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped.  This allows visibility into the failures without breaking the build.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#ignorefiles","title":"IgnoreFiles","text":"<p>This supports package relative files, folders, and glob patterns to ignore. These are passed to the markdownlint-cli tool as quoted -i parameters.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#linter-configuration","title":"Linter Configuration","text":"<p>All configuration options available to the linter can be set in the  <code>.markdownlint.yaml</code>. This includes customizing rule options and enforcement. See more details here: https://github.com/DavidAnson/markdownlint#configuration Linter Rules are described here: https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/MarkdownLintCheck/Readme/#rule-overrides","title":"Rule Overrides","text":"<p>There are times when a certain rule should not apply to part of a markdown file. Markdownlint has numerous ways to configure this. See the in file Configuration options described at the links above</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/","title":"Spell Check Plugin","text":"<p>This CiBuildPlugin scans all the files in a given package and checks for spelling errors.</p> <p>This plugin requires NodeJs and cspell.  If the plugin doesn't find its required tools then it will mark the test as skipped.</p> <ul> <li>NodeJS: https://nodejs.org/en/</li> <li>cspell: https://www.npmjs.com/package/cspell</li> <li>Src and doc available: https://github.com/streetsidesoftware/cspell</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin has a few configuration options to support the UEFI codebase.</p> <pre><code>  \"SpellCheck\": {\n\"AuditOnly\": False,          # If True, log all errors and then mark as skipped\n\"IgnoreFiles\": [],           # use gitignore syntax to ignore errors in matching files\n\"ExtendWords\": [],           # words to extend to the dictionary for this package\n\"IgnoreStandardPaths\": [],   # Standard Plugin defined paths that should be ignore\n\"AdditionalIncludePaths\": [] # Additional paths to spell check (wildcards supported)\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#auditonly","title":"AuditOnly","text":"<p>Boolean - Default is False. If True run the test in an Audit only mode which will log all errors but instead of failing the build it will set the test as skipped.  This allows visibility into the failures without breaking the build.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#ignorefiles","title":"IgnoreFiles","text":"<p>This supports .gitignore file and folder matching strings including wildcards</p> <ul> <li>All files will be parsed regardless but then any spelling errors found within   ignored files will not be reported as an error.</li> <li>Errors in ignored files will still be output to the test results as   informational comments.</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#extendwords","title":"ExtendWords","text":"<p>This list allows words to be added to the dictionary for the spell checker when this package is tested.  These follow the rules of the cspell config words field.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#ignorestandardpaths","title":"IgnoreStandardPaths","text":"<p>This plugin by default will check the below standard paths.  If the package would like to ignore any of them list that here.</p> <pre><code>[\n# C source\n\"*.c\",\n\"*.h\",\n\n# Assembly files\n\"*.nasm\",\n\"*.asm\",\n\"*.masm\",\n\"*.s\",\n\n# ACPI source language\n\"*.asl\",\n\n# Edk2 build files\n\"*.dsc\", \"*.dec\", \"*.fdf\", \"*.inf\",\n\n# Documentation files\n\"*.md\", \"*.txt\"\n]\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#additionalincludepaths","title":"AdditionalIncludePaths","text":"<p>If the package would to add additional path patterns to be included in spellchecking they can be defined here.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#other-configuration","title":"Other configuration","text":"<p>In the cspell.base.json there are numerous other settings configured.  There is no support to override these on a per package basis but future features could make this available.  One interesting configuration option is <code>minWordLength</code>. Currently it is set to 5 which means all 2,3, and 4 letter words will be ignored.  This helps minimize the number of technical acronyms, register names, and other UEFI specific values that must be ignored.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#false-positives","title":"False positives","text":"<p>The cspell dictionary is not perfect and there are cases where technical words or acronyms are not found in the dictionary.  There are three ways to resolve false positives and the choice for which method should be based on how broadly the word should be accepted.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#cspell-base-config-file","title":"CSpell Base Config file","text":"<p>If the change should apply to all UEFI code and documentation then it should be added to the base config file <code>words</code> section.  The base config file is adjacent to this file and titled <code>cspell.base.json</code>.  This is a list of accepted words for all spell checking operations on all packages.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#package-config","title":"Package Config","text":"<p>In the package <code>*.ci.yaml</code> file there is a <code>SpellCheck</code> config section.  This section allows files to be ignored as well as words that should be considered valid for all files within this package.  Add the desired words to the \"ExtendedWords\" member.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/SpellCheck/Readme/#in-line-file","title":"In-line File","text":"<p>CSpell supports numerous methods to annotate your files to ignore words, sections, etc.  This can be found in CSpell documentation.  Suggestion here is to use a c-style comment at the top of the file to add words that should be ignored just for this file.  Obviously this has the highest maintenance cost so it should only be used for file unique words.</p> <pre><code>// spell-checker:ignore unenroll, word2, word3\n</code></pre> <p>or</p> <pre><code># spell-checker:ignore unenroll, word2, word3\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/","title":"UncrustifyCheck Plugin","text":"<p>This CiBuildPlugin scans all the files in a given package and checks for coding standard compliance issues.</p> <p>This plugin is enabled by default. If a package would like to prevent the plugin from reporting errors, it can do so by enabling <code>AuditOnly</code> mode.</p> <p>This plugin requires the directory containing the Uncrustify executable that should be used for this plugin to be specified in an environment variable named <code>UNCRUSTIFY_CI_PATH</code>. This unique variable name is used to avoid confusion with other paths to Uncrustify which might not be the expected build for use by this plugin.</p> <p>By default, an Uncrustify configuration file named \"uncrustify.cfg\" located in the same directory as the plugin is used. The value can be overridden to a package-specific path with the <code>ConfigFilePath</code> configuration file option.</p> <ul> <li>Uncrustify source code and documentation: https://github.com/uncrustify/uncrustify</li> <li>Project Mu Uncrustify fork source code and documentation: https://dev.azure.com/projectmu/Uncrustify</li> </ul>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#files-checked-in-a-package","title":"Files Checked in a Package","text":"<p>By default, this plugin will discover all files in the package with the following default paths:</p> <pre><code>[\n# C source\n\"*.c\",\n\"*.h\"\n]\n</code></pre> <p>From this list of files, any files ignored by Git or residing in a Git submodule will be removed. If Git is not found, submodules are not found, or ignored files are not found no changes are made to the list of discovered files.</p> <p>To control the paths checked in a given package, review the configuration options described in this file.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#configuration","title":"Configuration","text":"<p>The plugin can be configured with a few optional configuration options.</p> <pre><code>  \"UncrustifyCheck\": {\n\"AdditionalIncludePaths\": [], # Additional paths to check formatting (wildcards supported).\n\"AuditOnly\": False,           # Don't fail the build if there are errors.  Just log them.\n\"ConfigFilePath\": \"\",         # Custom path to an Uncrustify config file.\n\"IgnoreFiles\": [],            # A list of file patterns to ignore.\n\"IgnoreStandardPaths\": [],    # Standard Plugin defined paths that should be ignored.\n\"OutputFileDiffs\": True,      # Output chunks of formatting diffs in the test case log.\n# This can significantly slow down the plugin on very large packages.\n\"SkipGitExclusions\": False    # Don't exclude git ignored files and files in git submodules.\n}\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#additionalincludepaths","title":"<code>AdditionalIncludePaths</code>","text":"<p>A package configuration file can specify any additional paths to be included with this option.</p> <p>At this time, it is recommended all files run against the plugin be written in the C or C++ language.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#auditonly","title":"<code>AuditOnly</code>","text":"<p><code>Boolean</code> - Default is <code>False</code>.</p> <p>If <code>True</code>, run the test in an \"audit only mode\" which will log all errors but instead of failing the build, it will set the test as skipped. This allows visibility into the failures without breaking the build.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#configfilepath","title":"<code>ConfigFilePath</code>","text":"<p><code>String</code> - Default is <code>\"uncrustify.cfg\"</code></p> <p>When specified in the config file, this is a package relative path to the Uncrustify configuration file.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#ignorefiles","title":"<code>IgnoreFiles</code>","text":"<p>This option supports .gitignore file and folder matching strings including wildcards.</p> <p>The files specified by this configuration option will not be processed by Uncrustify.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#ignorestandardpaths","title":"<code>IgnoreStandardPaths</code>","text":"<p>This plugin by default will check the below standard paths. A package configuration file can specify any of these paths to be ignored.</p> <pre><code>[\n# C source\n\"*.c\",\n\"*.h\"\n]\n</code></pre>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#outputfilediffs","title":"<code>OutputFileDiffs</code>","text":"<p><code>Boolean</code> - Default is <code>True</code>.</p> <p>If <code>True</code>, output diffs of formatting changes into the test case log. This is helpful to exactly understand what changes need to be made to the source code in order to fix a coding standard compliance issue.</p> <p>Note that calculating the file diffs on a very large set of of results (e.g. &gt;100 files) can significantly slow down plugin execution.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#skipgitexclusions","title":"<code>SkipGitExclusions</code>","text":"<p><code>Boolean</code> - Default is <code>False</code>.</p> <p>By default, files in paths matched in a .gitignore file or a recognized git submodule are excluded. If this option is <code>True</code>, the plugin will not attempt to recognize these files and exclude them.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#uncrustify_in_placetrue","title":"<code>UNCRUSTIFY_IN_PLACE=TRUE</code>","text":"<p>MU_CHANGE - Feature added.</p> <p>Mu adds support for passing this parameter on the command line when running <code>stuart_ci_build</code>. If passed, it will cause any changes to be made in-place to the files in the workspace, enabling the caller to easily format any failing code before submitting a PR.</p> <p>While this can also be set as an environment variable, it is recommended to only use it as a CLI paramter.</p> <p>NOTE: This is not an option in the config <code>yaml</code>. It is an option passed directly into the tool.</p>"},{"location":"dyn/mu_basecore/pytool/Plugin/UncrustifyCheck/Readme/#high-level-plugin-operation","title":"High-Level Plugin Operation","text":"<p>This plugin generates two main sets of temporary files:</p> <ol> <li>A working directory in the directory <code>Build/.pytool/Plugin/Uncrustify</code></li> <li>For each source file with formatting errors, a sibling file with the <code>.uncrustify_plugin</code> extension</li> </ol> <p>The working directory contains temporary files unique to operation of the plugin. All of these files are removed on exit of the plugin including successful or unsuccessful execution (such as a Python exception occurring). If for any reason, any files in the package exist prior to running the plugin with the <code>.uncrustify_plugin</code> extension, the plugin will inform the user to remove these files and exit before running Uncrustify. This is to ensure the accuracy of the results reported from each execution instance of the plugin.</p> <p>The plugin determines the list of relevant files to check with Uncrustify and then invokes Uncrustify with that file list. For any files not compliant to the configuration file provided, Uncrustify will generate a corresponding file with the <code>.uncrustify_plugin</code> extension. The plugin discovers all of these files. If any such files are present, this indicates a formatting issue was found and the test is marked failed (unless <code>AuditOnly</code> mode is enabled).</p> <p>The test case log will contain a report of which files failed to format properly, allowing the user to run Uncrustify against the file locally to fix the issue. If the <code>OutputFileDiffs</code> configuration option is set to <code>True</code>, the plugin will output diff chunks for all code formatting issues in the test case log.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_common_intel_min_platform/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/","title":"Project Mu Common Intel MinPlatform","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_common_intel_min_platform.git Branch:         release/202208 Commit:         f5d45c4dfbb7180b9bc75896c9294b1fe8005771 Commit Date:    2023-01-31 11:22:21 -0500</p> <p>This repository contains Project Mu code based on TianoCore edk2 code for Intel MinPlatform.</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_common_intel_min_platform/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_common_intel_min_platform/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_common_intel_min_platform/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_common_intel_min_platform/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_common_intel_min_platform/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_feature_config/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_feature_config/RepoDetails/","title":"Project Mu Configuration Repository","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_feature_config.git Branch:         main Commit:         7a37bfbb1d5b6d7f779d1e86d1a605f741f3f8c0 Commit Date:    2023-01-30 22:29:32 -0500</p> <p>This MU Configuration feature repo contains the generic Config Editor tools from Intel's Slim Bootloader repo. This code should be consumed as needed for firmware configuration update feature support.</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#repository-philosophy","title":"Repository Philosophy","text":"<p>Like other Project MU feature repositories, the Configuration feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided.</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#consuming-the-mu-configuration-feature-package","title":"Consuming the MU Configuration Feature Package","text":"<p>Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_config_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired.</p> <pre><code>{\n\"scope\": \"global\",\n\"type\": \"git\",\n\"name\": \"FEATURE_CONFIG\",\n\"var_name\": \"FEATURE_CONFIG_PATH\",\n\"source\": \"https://github.com/microsoft/mu_feature_config.git\",\n\"version\": \"&lt;RELEASE HASH&gt;\",\n\"flags\": [\"set_build_var\"]\n}\n</code></pre> <p>Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build configurations GetPackagesPath list.</p> <pre><code>shell_environment.GetBuildVars().GetValue(\"FEATURE_CONFIG_PATH\", \"\")\n</code></pre> <p>Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string.</p> <p>After this the package should be discoverable to can be used in the build like any other dependency.</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#code-of-conduct","title":"Code of Conduct","text":"<p>This project has adopted the Microsoft Open Source Code of Conduct</p> <p>For more information see the Code of Conduct FAQ or contact <code>opencode@microsoft.com &lt;mailto:opencode@microsoft.com&gt;</code>_. with any additional questions or comments.</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#contributions","title":"Contributions","text":"<p>Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_feature_config/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_feature_config/RepoDetails/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_config/SECURITY/","title":"SECURITY","text":""},{"location":"dyn/mu_feature_config/SECURITY/#security","title":"Security","text":"<p>Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft, Azure, DotNet, AspNet, Xamarin, and our GitHub organizations.</p> <p>If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability, please report it to us as described below.</p>"},{"location":"dyn/mu_feature_config/SECURITY/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report.</p> <p>If you prefer to submit without logging in, send email to secure@microsoft.com.  If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page.</p> <p>You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc. </p> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p> <p>If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.</p>"},{"location":"dyn/mu_feature_config/SECURITY/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"},{"location":"dyn/mu_feature_config/SECURITY/#policy","title":"Policy","text":"<p>Microsoft follows the principle of Coordinated Vulnerability Disclosure.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/","title":"Configuration Files Specification","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Description</li> <li>Revision History</li> <li>Terms</li> <li>Introduction</li> <li>YML Specification Differences</li> <li>XML Specification</li> <li>Merged YAML and XML Operations</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#description","title":"Description","text":"<p>This document is intended to describe the Project MU version of Configuration Files Specification.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#revision-history","title":"Revision History","text":"Revised by Date Changes Kun Qin 11/29/2021 First draft Oliver Smith-Denny 7/22/2022 Add YAML/XML Merged Support Oliver Smith-Denny 9/15/2022 Add Profile Support"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#terms","title":"Terms","text":"Term Description UEFI Unified Extensible Firmware Interface"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#reference-documents","title":"Reference Documents","text":"Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#introduction","title":"Introduction","text":"<p>As Project MU inherits tool set from Slim Bootloader repository to support setup variable feature, certain modifications has been made to improve workflow and architectural abstraction.</p> <p>Although the syntax of configuration YAML files mainly follow Slim Bootloader specification for design simplicity, this document mainly listed the differences between Project MU version and original Slim Bootloader. Additionally, this document describes the XML format that will be accepted.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#yaml-specification-differences","title":"YAML Specification Differences","text":"<ul> <li> <p>All UI related form fields (i.e. <code>name</code>, <code>type</code>, <code>help</code>, etc.) should be described separately from the data definitions.</p> </li> <li> <p>The UI form set should be named as <code>*_UI</code> following the same directory/name of data form sets (see example below). The intention of this separation is to allow cleaner YAML layout for platform configuration template creation while maintaining the ConfigEditor.py capability of updating configuration offline.</p> </li> </ul> <pre><code>  CfgDataDef.yaml\n  CfgDataDef_UI.yaml\n  | Template_USB.yaml\n  | Template_USB_UI.yaml\n</code></pre> <ul> <li> <p>For each configuration yaml file set, the data blob header is no longer required. This will be automatically populated by the GenCfgData.py. The total size will be rounded up to 4KB aligned boundary by used size.</p> </li> <li> <p>All <code>CFGHDR_TMPL</code> can be ignored from YAML files. Instead, use a <code>IdTag</code> to denote a normal ID tag value, or <code>ArrayIdTag</code> to denote an array ID tag value. GenCfgData.py will automatically populate the <code>CFGHDR_TMPL</code> content to backend database and generate the same binary data blob.</p> </li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#xml-specification","title":"XML Specification","text":"<p>See sampleschema.xml for an example XML schema.</p> <p>Configuration will be organized in namespaces, each consisting of various knobs. Knobs may be built of children knobs or be a leaf knob.</p> <p>The XML and artifacts generated from it are not used by the ConfApp or other UEFI components, but support is given to visualize the XML for scenarios that have XML configuration.</p> <p>Supported data types are:</p> <ul> <li>uint8_t</li> <li>int8_t</li> <li>uint16_t</li> <li>int16_t</li> <li>uint32_t</li> <li>int32_t</li> <li>uint64_t</li> <li>int64_t</li> <li>float (note that floats are imprecise, doubles are recommend to avoid rounding errors)</li> <li>double</li> <li>bool</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#config-editor-operations","title":"Config Editor Operations","text":"<p>All of these options except for Load Config File are only available after one or more configuration files have been loaded.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#variable-list-binaries","title":"Variable List Binaries","text":"<p>As described in (#merged-yaml-and-xml-operations), the Config Editor can output variable list binaries. These are created by the GenSetupDataBin.py build plugin to generate profiles (see the Profiles doc for more information).</p> <ul> <li>Save Config Data to Var List Binary:   Create a variable list binary to be used for testing or to load later in the Config Editor tool</li> <li>Load Config Data from Var List Binary:   Load a saved variable list binary (of the same format as the loaded YAML/XML file) into the UI. This can be used   to load previously stored configuration or validate the output of GenSetupDataBin.py.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#svd-files","title":"SVD Files","text":"<p>The SVD is intended for use with the UEFI Conf App, which can take the SVD as input and give an SVD describing the current UEFI settings as an output. The SVD is formatted to be compatible with DFCI.</p> <ul> <li>Save Full Config Data to SVD File:     Saving the entire defined YAML/XML structure into encoded binary settings format. This format is useful when many     tags of settings need updating at once, but this will save all configurations defined.</li> <li>Save Config Changes to SVD File:     Saving only the changed tag setting into corresponding encoded binary value. This will allow the target system to     update only the changed tag setting (i.e. Only disable GFX controllers, and leave USB ports on the same system     intact)</li> <li>Load Config Data from SVD File:     Once the target system has dumped current configuration from ConfApp, the output data can be viewed in     the ConfigEditor on a host system or saved SVDs from the ConfigEditor can be loaded again.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#change-files-delta-or-csv","title":"Change Files (Delta or CSV)","text":"<p>Profiles are represented as delta files on top of the generic profile (for more info see the Profiles doc). In addition, the XML differences between what is set in the UI and the base XML can be saved as CSV files.</p> <p>The UI tool expects the XML file name to be a prefix to the CSV file name. I.e. my_config_1.xml would match with my_config_1_override_all.csv and my_config_1_some_overrides.csv but not i_overrode_my_config_1.csv. This way the CSV will be correctly applied to the appropriate loaded XML file.</p> <ul> <li>Save Full Config Data to Change File   Save all configuration knobs to the change file, even if they do not have a change over the base YAML/XML. This is   helpful to see the whole state of configuration from one file.</li> <li>Save Config Changes to Change File   Save only configuration knobs that have a different value from the base YAML/XML to a change file. This is helpful to   have smaller change files, but looking just at a change file does not describe the whole state.</li> <li>Load Config from Change File   Load a previously save change file into the UI, overwriting any values from the base YAML/XML. It must be loaded onto   a YAML/XML that has the configuration knobs present in the change file.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/ConfigurationFiles/ConfigurationFiles/#merged-yaml-and-xml-operations","title":"Merged YAML and XML Operations","text":"<p>One YAML and one XML file may be loaded at the same time via the CLI as such:</p> <pre><code>python ConfigEditor.py sampleschema.xml samplecfg.yaml\n</code></pre> <p>When saving config changes to delta files, two files will be output: a .dlt file for the YAML config changes and a .csv file for the XML config changes. Either or both of these can be later loaded to modify the current config viewed in the ConfigEditor.</p> <p>As noted above under YAML Specification Differences, the full SVD can be saved in a merged configuration. Config will be stored in individual tags under each variable name.</p> <p>For saving to/loading from a binary file, the merged config will create a list of UEFI variables that will look as such:</p> <p>|   XML Var 1  | |   XML Var 2  | |      ...     | |   XML Var N  | |   YML Var 1  | |   YML Var 2  | |      ...     | |   YML Var N  |</p> <p>(Order not guaranteed)</p> <p>Where XML/YML Var N looks like:</p> <p>|   UINT32   Name Size   | |   UINT32   Data Size   | |   CHAR16   *Name       | |   EFI_GUID GUID        | |   VOID     *Data       | |   UINT32   CRC         |</p> <p>YAML only configuration (or XML only) is the same as the above. The ConfApp uses YAML only configuration.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/","title":"Configuration Applications Design","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Description</li> <li>Revision History</li> <li>Terms</li> <li>Reference Documents</li> <li>Introduction</li> <li>OS Based Configuration App</li> <li>UEFI Boot Application</li> <li>UEFI Build Tool and Plugin</li> <li>UEFI Code Change</li> <li>Configuration Related UEFI Boot Flow</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#description","title":"Description","text":"<p>This document is intended to describe the Setup Variable design on applicable platforms.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#revision-history","title":"Revision History","text":"Revised by Date Changes Kun Qin 09/28/2021 First draft Oliver Smith-Denny 7/22/2022 Add Merged YAML/XML Support Oliver Smith-Denny 9/15/2022 Add Profile Support"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#terms","title":"Terms","text":"Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface BDS Boot Device Selection"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#reference-documents","title":"Reference Documents","text":"Document Link Slim Bootloader Repo https://github.com/slimbootloader/slimbootloader Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained Project Mu Document https://microsoft.github.io/mu/ DFCI Documents https://microsoft.github.io/mu/dyn/mu_plus/DfciPkg/Docs/Dfci_Feature/ Configuration Apps Repo https://windowspartners.visualstudio.com/MSCoreUEFI/_git/mu_config_apps"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#introduction","title":"Introduction","text":"<p>This document is describing how the configuration framework functions and what changes have been made.</p> <p>The proposition of this design intends to facilitate development usage and provide secure usage for production deployment.</p> <p>HII in the system, setup browser in system and/or other advance display capabilities has been convoluted and pertain poor portability. Hence proposed workflow steps away from existing UI applications, HII based form rendering models on the target system and adopts data centric methods to achieve the same results.</p> <p>In addition, tooling workflows are also proposed to enforce security and maintainability rules and best practices for data accessability, version migration, etc.</p> <p>Note: The technical details in this document is meant to reflect the current status of design. Certain topics are still under discussion and subject to change.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-based-configuration-app","title":"OS Based Configuration App","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-configuration-app-overview","title":"OS Configuration App Overview","text":"<ul> <li>The original framework of configuration editor is derived from Intel's open sourced project Slim Bootloader (more information in References). This framework provides graphical user interface on the host side and extensive flexibility to design and optimize configuration per platform usage.</li> <li>Configuration editor is authored in Python which is host platform architecture independent and easy to update per proprietary requirements per projects need.</li> <li>The configuration is driven by YAML and XML files, which can be designed per platform usage. Per YAML specification, please reference to Configuration YAML Spec in References.</li> <li>The slim bootloader framework provides data structure conversion tooling from YAML to C header files, YAML to binary data blob out of the box. XML extensions have been added to support additional use cases. More extensions, such as output data signing, tooling servicing, will be added during the development process.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#os-configuration-workflow","title":"OS Configuration Workflow","text":"<ul> <li>Whenever a configuration change is needed, configuration editor can be launched on a local workstation.</li> <li>Through the UI tool, one can update supported option as needed and export updated options as binary blob. Updated options can also be saved as \"profile\" that can be loaded into editor tool for faster configuration deployment</li> <li>The exported binary blob will be encoded and signed with platform designated certificates and formatted to DFCI standard packet. (more about DFCI please see References).</li> <li>DFCI standard packets can be applied to target system through USB sticks, OS application on target systems, or serial transport through UEFI boot application (more about UEFI configuration app here)</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-boot-application","title":"UEFI Boot Application","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-boot-app-overview","title":"UEFI Boot App Overview","text":"<p>As stated in the introduction section, this proposal intends to replace the existing UI applications, HII forms and other advanced display support. Instead, a Configuration UEFI application will be provided in lieu of traditional UI App to configuration system behavior.</p> <ul> <li>This application is optimized for serial connection. All input and output would go through UEFI standard console, which is connected to BMC through UART. Note: Available input devices will be:</li> <li>Physical USB Keyboard: This will be used for standard keyboard</li> <li>Virtual USB Keyboard: This will be used with BMC based virtual keyboard for remote KVM.</li> <li>Serial console for SAC: this uses VT100 terminal type for UEFI setup/Windows EMC or SAC.</li> <li>The application will provide basic information regarding system status: </li> <li>Firmware version</li> <li>Date/Time</li> <li>Identities</li> <li>Settings</li> <li>A few critical operations is also provided in this application:</li> <li>Secure Boot enable/disable:   </li> <li>Select available boot options:   </li> <li>Apply configuration options from OS configuration application:   </li> <li>USB Stick</li> <li>Network</li> <li>Serial console</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-configuration-workflow","title":"UEFI Configuration Workflow","text":"<p>With the exported configuration change from OS configuration application, this change can be applied within UEFI app:</p> <ul> <li>USB Stick: Store the generated base64 encoded file from previous step and select <code>Update Setup Configuration</code> -&gt; <code>Update from USB Stick</code> from UEFI App.</li> <li>Serial Port: Open the generated base64 encoded file, and select <code>Update Setup Configuration</code> -&gt; <code>Update from Serial port</code> from UEFI App. Then paste the encoded string into serial console.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-build-tool-and-plugin","title":"UEFI Build Tool and Plugin","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#build-tool-and-plugin-overview","title":"Build Tool and Plugin Overview","text":"<p>During UEFI build time, toolings will be provided as plugins to integrate configuration related data and enforce best practices.</p> <p>Toolings from Project will cover:</p> <ul> <li>Converting designed YAML file into binary blob to be included in UEFI firmware volume.</li> <li>Generate C header files, if requested, for platform code consumption, and populate version transition templates.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#build-process","title":"Build Process","text":"<ul> <li>During pre-build step, customized platform YAML file will be used by Project MU plugin to derive configuration header files for platform to consume during development/runtime.</li> <li>Platform will hold a hash value in PlatformBuild.py for all YAML derived C header files for this platform. Project MU plugin will generate temporary C header files per build to compare hash match.</li> <li>If hash changed, a template of library will be generated and allow developer to author transition code if needed.</li> <li>If hash match, build can proceed as usual.</li> <li>At post-build, a binary blob with default configuration values will be derived from YAML files and inserted in UEFI firmware volume.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#uefi-code-change","title":"UEFI Code Change","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#project-mu-code","title":"Project Mu Code","text":"<ul> <li>BDS: Project MU BDS will provide specific event signals and platform entrypoints that are customized for DFCI settings.</li> <li>DFCI: DFCI framework will be used to accept and validate incoming configuration against platform identity associated certificates.</li> <li>MFCI: The MFCI framework will be used to check what mode the system is in, manufacturing mode or customer mode.</li> <li>Settings Manager: Settings manager together with DFCI framework would apply the configuration data through platform configured settings providers.</li> <li>Policy Manager: Policy manager controls the policy publication and revoke. Silicon policy and platform configuration should all conform to policy setter and getter APIs.</li> <li>Profile Manager: ConfProfileMgrDxe validates and enforces profiles (collections of configuration settings for different use cases) when the system is in MFCI Customer Mode.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#platform-and-silicon-code","title":"Platform and Silicon Code","text":"<ul> <li>Silicon Drivers: Silicon code needs to be updated to pull policy settings from silicon policy data when needed.</li> <li>Platform Policy Drivers: Platform owners will first create PEI modules to populate default silicon policy into Policy managers provided by Project MU.</li> <li>Platform YAML Configurations: Platform owners should then design the configuration YAML files. This would expose certain configuration \"knobs\" from silicon policy to be configurable through setup variable flow.</li> <li>Platform Settings Providers: Accordingly, platform owners will develop modules to parse the configuration data and translate the exposed configurations in YAML file to/from standard silicon policies through the interface of Settings Provider (see example from Project MU).</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#profiles","title":"Profiles","text":"<p>See the Profiles doc for details.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#configuration-related-uefi-boot-flow","title":"Configuration Related UEFI Boot Flow","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Overview/Overview/#settings-update-boot-flow","title":"Settings Update Boot Flow","text":"<ul> <li>Formatted update configuration data from USB, serial port or OS application will first be stored to UEFI variable storage, followed by a system reboot.</li> <li>On the next reboot, the formatted configuration data from UEFI variable storage will be authenticated (if the DFCI Unsigned Settings feature is not used) and decoded by DFCI framework. Decoded configuration data will be dispatched to corresponding platform authored setting provider.</li> <li>Platform configuration setting provider will perform sanity check on incoming data and store this data as UEFI variable with the following specifications (source code reference here), followed by a system reboot:</li> </ul> Variable Name Variable GUID Variable Attributes <code>CONF_POLICY_BLOB</code> <code>gSetupConfigPolicyVariableGuid</code> <code>EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS</code> <code>Device.ConfigData.TagID_%08X</code> <code>gSetupConfigPolicyVariableGuid</code> <code>EFI_VARIABLE_NON_VOLATILE + EFI_VARIABLE_BOOTSERVICE_ACCESS</code> <ul> <li>Upon a new boot, entities other than UEFI can consume the aforementioned variable.</li> <li>After entering UEFI firmware, platform policy module will pull previously stored configuration data variable from UEFI variable and parse the data blob based on YAML derived C header files.</li> <li>If any configuration change is required, platform should update the corresponding silicon policy through policy manager.</li> <li>When silicon drivers load, these drivers should fetch latest policy through policy manager and configure hardware resource accordingly.</li> </ul>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/","title":"Configuration Modules Platform Integration","text":"<p>The configuration modules source code is intended to be used with some library classes provided by platforms. In order to integrate configuration modules into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#high-level-considerations","title":"High-Level Considerations","text":"<ol> <li> <p>Configuration Apps Changes - The setup variable feature will replace existing UI application and switch to serial base console input/output. All agents will leverage policy framework to set/get hardware configurations.</p> </li> <li> <p>Silicon Code Changes - The silicon firmware may need changes for:</p> <ol> <li>Add depex statement for drivers to load after policy database</li> <li>Locate policy protocol/ppis for silicon configuration</li> </ol> </li> <li> <p>Platform Data Flow - Modules provided in this package for platform to load/update configuration data.</p> </li> <li> <p>Platform Data Consumption - Description of expected platform workflow on how to consume data from configuration variables convert to policy data.</p> </li> <li> <p>Configuration App Code Integration - How to best integrate the <code>SetupDataPkg</code> collateral into a platform firmware.</p> </li> <li> <p>Profiles Integration - How to integrate Configuration Profiles into platform firmware.</p> </li> </ol>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#configuration-apps-changes","title":"Configuration Apps Changes","text":"<p>The Configuration Applications are based on the framework of policy services and DFCI from Project MU. Start with the fundamentals of these 2 features from MU_BASECORE and MU_PLUS.</p> <p>Instead of rendering all available options in the UEFI front page, which is backed by HII data and complicated UI frameworks, the configuration applications will focus on configuration data pipeline and actual functionality.</p> <p>All configuration data will originate from platform default silicon policy setup, any configuration data will be applied on top of default values. More of this data flow will be documented in Platform Data Flow section.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#silicon-code-changes","title":"Silicon Code Changes","text":"<p>For each applicable silicon drivers that needs to be configured during UEFI operation, the silicon drivers needs to be updated to pull silicon policy data.</p> <p>For each configurable silicon feature/component/module, one needs to define a structure that contains all necessary settings. These settings will be populated with default value during PEI phase.</p> <p>When silicon module is executed, the consuming module should fetch policy data from database and configure the hardware accordingly.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-flow","title":"Platform Data Flow","text":"<p>There will be few modules provided and library classes defined for platform to define their own configuration data. More of modules needed to this feature, please see Configuration App Code Integration.</p> <p>The default policy should be initialized by platform module during early boot phase policy framework is ready.</p> <p>After initial policy data was populated, platform logic should look up corresponding configuration data, if available, from variable storage for the most up-to-date configuration data. Silicon policies defined in Silicon Code Changes should then be overridden after platform translation.</p> <ul> <li>Note: If there is no configuration variable found, the module will attempt to locate default configuration data from UEFI firmware volume blob.</li> </ul> <p>During the rest of boot process, the silicon drivers will consume the updated policy data to configure hardware components.</p> <p>With configuration data, config data library can walk through the configuration blob into and dispatch the data with tag based buffer.</p> <p>During DXE phase, <code>ConfDataSettingProvider.inf</code> will be loaded and register one setting provider for receiving full configuration data (designed to reduce configuration transmission overhead), as well as an individual setting provider per define Tag ID, based on holistic Config data blob carried in FV, in the DFCI framework. The holistic settings setter will walk through the incoming binary data blob and dispatch to individual setting providers, whereas the individual settings providers will directly operate on the <code>SINGLE_SETTING_PROVIDER_TEMPLATE</code> formatted UEFI variables for updating, retrieving.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-consumption","title":"Platform Data Consumption","text":"<p>In order for drivers provided by this package to function as expected, the platform owners are suggested for authoring the following routines to properly consume configuration data:</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-policy-initialization","title":"Platform Policy Initialization","text":"<p>Per silicon policy defintion, platforms are responsible for initializing the silicon policy with a default value when configuration when under the circumstance that its corresponding configuration is not present or not even defined.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#config-data-translation","title":"Config Data Translation","text":"<p>If the corresponding configuration is defined and exposed, the platform developer should query variable with the format of <code>Device.ConfigData.TagID_%08X</code> or defined as <code>SINGLE_SETTING_PROVIDER_TEMPLATE</code>, where the %08X should be populated with the intended Tag ID defined in the configuration YAML file set.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#configuration-app-code-integration","title":"Configuration App Code Integration","text":"<ol> <li>Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202108\")</li> <li>The prerequisites of this feature is Policy services and Project MU based BDS as well as DFCI features. This guideline will omit the integration steps for these features. For more information about DFCI integration, please see here.</li> </ol> <p>Note: A list of the libraries and modules made available by this package is provided in the   Software Component Overview.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-statements","title":"Platform DSC statements","text":"<p>Add the DSC sections below.</p> <p>Note: This is change is on top of Project MU based BDS and DFCI feature.</p> <pre><code>[PcdsFixedAtBuild]\n# The GUID of SetupDataPkg/ConfApp/ConfApp.inf: E3624086-4FCD-446E-9D07-B6B913792071\ngEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ 0x86, 0x40, 0x62, 0xe3, 0xcd, 0x4f, 0x6e, 0x44, 0x9d, 0x7, 0xb6, 0xb9, 0x13, 0x79, 0x20, 0x71 }\n\n[LibraryClasses]\nConfigBlobBaseLib         |SetupDataPkg/Library/ConfigBlobBaseLib/ConfigBlobBaseLib.inf\n  ConfigDataLib             |SetupDataPkg/Library/ConfigDataLib/ConfigDataLib.inf\n  ConfigVariableListLib     |SetupDataPkg/Library/ConfigVariableListLib/ConfigVariableListLib.inf\n\n[Components.X64, Components.AARCH64]\n#\n# Setup variables\n#\nSetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf {\n&lt;PcdsFixedAtBuild&gt;\n      gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000000\n  }\nSetupDataPkg/ConfApp/ConfApp.inf {\n&lt;LibraryClasses&gt;\n      JsonLiteParserLib|MsCorePkg/Library/JsonLiteParser/JsonLiteParser.inf\n  }\n</code></pre> <p>Remove the DSC sections below.</p> <pre><code>[Components.X64, Components.AARCH64]\n# MdeModulePkg/Application/UiApp/UiApp.inf {\n#   &lt;LibraryClasses&gt;\n#     NULL|MdeModulePkg/Library/DeviceManagerUiLib/DeviceManagerUiLib.inf\n#     NULL|MdeModulePkg/Library/BootManagerUiLib/BootManagerUiLib.inf\n#     NULL|MdeModulePkg/Library/BootMaintenanceManagerUiLib/BootMaintenanceManagerUiLib.inf\n#     PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf\n# }\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-statements","title":"Platform FDF statements","text":"<p>Add the FDF sections below.</p> <p>Note: This is change is on top of Project MU based BDS and DFCI feature.</p> <pre><code>[FV.YOUR_DXE_FV]\nINF SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf\n  INF SetupDataPkg/ConfApp/ConfApp.inf\n</code></pre> <p>Remove the FDF sections below.</p> <pre><code>[FV.YOUR_DXE_FV]\n# INF MdeModulePkg/Application/UiApp/UiApp.inf\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#profiles-integration","title":"Profiles Integration","text":"<p>In order to use configuration profiles, the platform must include the above changes as well as include a YAML file that contains the default values for the generic profile. If additional profiles are required, the platform must include YAML delta files for each profile that are overrides on top of the generic profile. These are created through the Config Editor UI tool by choosing <code>Save Config Changes to Change File</code> or <code>Save Full Config to Change File</code> (more details in the Configuration Files doc).</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platformbuildpy-changes","title":"PlatformBuild.py Changes","text":"<p>Add or update the PlatformBuild.py environment variables below, where <code>DELTA_CONF_POLICY</code> is a semicolon delimited list of the delta files representing additional profiles.</p> <pre><code>def SetPlatformEnv(self):\n  ...\n  self.env.SetValue(\"YAML_CONF_FILE\", self.mws.join(self.ws, \"PlatformPkg\", \"CfgData\", \"CfgDataDef.yaml\"), \"Platform Hardcoded\")\nself.env.SetValue(\"DELTA_CONF_POLICY\", self.mws.join(self.ws, \"PlatformPkg\", \"CfgData\", \"Profile1.dlt\") + \";\" +\\\nself.mws.join(self.ws, \"PlatformPkg\", \"CfgData\", \"Profile2.dlt\") + \";\" +\\\n...\n                    self.mws.join(self.ws, \"PlatformPkg\", \"CfgData\", \"ProfileN.dlt\"), \"Platform Hardcoded\")\n...\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dec-changes","title":"Platform DEC Changes","text":"<p>The platform must define GUIDs for each additional profile beyond the generic profile (which has a defined GUID in SetupDataPkg).</p> <pre><code>  [Guids]\n...\n  ## Example Profile 1 will be stored in FV under this GUID\ngPlatformPkgProfile1Guid = { SOME_GUID }\n## Example Profile 2 will be stored in FV under this GUID\ngPlatformPkgProfile2Guid = { SOME_GUID }\n...\n   ## Example Profile N will be stored in FV under this GUID\ngPlatformPkgProfileNGuid = { SOME_GUID }\n...\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-changes","title":"Platform DSC Changes","text":"<p>The platform must add ActiveProfileSelectorLib (whether the null instance or a platform specific instance):</p> <pre><code>  [LibraryClasses]\n...\n    # Platform can override to non-Null Lib\nActiveProfileSelectorLib|SetupDataPkg/Library/ActiveProfileSelectorLibNull/ActiveProfileSelectorLibNull.inf\n    ...\n</code></pre> <p>The platform must build ConfProfileMgrDxe:</p> <pre><code>  [Components.X64, Components.AARCH64]\n...\n    # Profile Enforcement\nSetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf\n    ...\n</code></pre> <p>The platform must also override the below PCD:</p> <pre><code>  [PcdsFixedAtBuild]\n...\n    ## List of valid Profile GUIDs\n## gSetupDataPkgGenericProfileGuid is defaulted to in case retrieved GUID is not in this list\ngSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList|{ GUID(\"SOME_GUID\"), GUID(\"SOME_GUID\"), ..., GUID(\"SOME_GUID\") }\n...\n</code></pre> <p>The platform can optionally override the below default value (only useful if using ActiveProfileSelectorLibNull):</p> <pre><code>  [PcdsDynamicExDefault]\n...\n    # Default this to gSetupDataPkgGenericProfileGuid\ngSetupDataPkgTokenSpaceGuid.PcdSetupConfigActiveProfileFile|{ GUID(\"SOME_GUID\") }\n...\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-changes","title":"Platform FDF Changes","text":"<p>The platform must add ConfProfileMgrDxe and the profiles to the FDF for each desired profile and the generic profile.</p> <pre><code>  [FV.DXEFV]\n...\n    INF SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf\n    ...\n\n    FILE FREEFORM = gSetupDataPkgGenericProfileGuid {\nSECTION RAW = $(CONF_BIN_FILE_0)\n}\nFILE FREEFORM = gPlatformPkgProfile1Guid {\nSECTION RAW = $(CONF_BIN_FILE_1)\n}\nFILE FREEFORM = gPlatformPkgProfile2Guid {\nSECTION RAW = $(CONF_BIN_FILE_2)\n}\n...\n    FILE FREEFORM = gPlatformPkgProfileNGuid {\nSECTION RAW = $(CONF_BIN_FILE_N)\n}\n...\n</code></pre>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/","title":"Software Components of the Configuration Modules","text":"<p>This section of documentation is focused on the software components of configuration modules that are useful during platform integration.</p> <p><code>ConfDataSettingProvider</code> is a shim layer that registers setting provider for configuration data. The underneath implementation is operating on top of the per tag ID based configuration blob, either initialized from FV carried original configuration blob or updated through ConfApp.</p> <p>The implementation of walking through configuration data is expected to be provided by platform level module, which initializes the silicon policy for a given platform and <code>ConfigDataLib</code>, which converts configuration data to silicon policy and serialize them into printable strings.</p> <p><code>ConfApp</code> is a UEFI application that replaces traditional UI application to display basic system information and provide minimal functionalities, including updating system configuration data.</p> <p><code>ConfProfileMgrDxe</code> is a DXE driver that validates and enforces the active configuration profile in MFCI Customer Mode.</p> <p>For more general background about the steps necessary to integrate the configuration modules, please review the Platform Integration Steps.</p> <p><code>ActiveProfileSelectorLib</code> is a library class that should be overwritten by the platform. It provides an interface to retrieve the active configuration profile for this boot.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#dxe-drivers","title":"DXE Drivers","text":"Driver Location ConfDataSettingProvider SetupDataPkg/ConfDataSettingProvider/ConfDataSettingProvider.inf ConfProfileMgrDxe SetupDataPkg/ConfProfileMgrDxe/ConfProfileMgrDxe.inf"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#uefi-applications","title":"UEFI Applications","text":"Application Location ConfApp SetupDataPkg/ConfApp/ConfApp.inf"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#library-classes","title":"Library Classes","text":"Library Class Location ConfigBlobBaseLib SetupDataPkg/Include/Library/ConfigBlobBaseLib.h ConfigDataLib SetupDataPkg/Include/Library/ConfigDataLib.h ActiveProfileSelectorLib SetupDataPkg/Include/Library/ActiveProfileSelectorLib.h"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/","title":"Configuration Profiles (BIOS Flavors) Implementation","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#table-of-contents","title":"Table of Contents","text":"<p>[[TOC]]</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#description","title":"Description","text":"<p>This document describes the requirements, design considerations and APIs for UEFI Configuration Profiles</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#revision-history","title":"Revision History","text":"Revised by Date Changes Oliver Smith-Denny 09/15/2022 Initial design"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#terms","title":"Terms","text":"Term Description UEFI Unified Extensible Firmware Interface DFCI Device Firmware Configuration Interface MFCI Manufacturer Firmware Configuration Interface FV Firmware Volume"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#reference-documents","title":"Reference Documents","text":"Document Link MFCI Documentation Link DFCI Documentation Link UEFI Variable Policy Whitepaper Link SetupVariable Flow Link Configuration YAML Spec https://slimbootloader.github.io/specs/config.html#configuration-description-yaml-explained"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#introduction","title":"Introduction","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#configuration-profiles","title":"Configuration Profiles","text":"<p>UEFI Configuration Profiles, historically called BIOS Flavors, are sets of defined values for UEFI configuration variables. Such profiles are useful where different owners may use the same hardware but have different requirements for UEFI configuration variables, such as one owner requiring Secure Boot enabled and SMT disabled and another owner requiring Secure Boot disabled and SMT enabled. Configuration profiles are provided by the FW as a means to allow both groups to use the same hardware and FW, but choosing different profiles with the set of configuration they require.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#design","title":"Design","text":""},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#flow","title":"Flow","text":"<p>There will be one generic profile that describes the default values for all UEFI configuration variables. This generic profile will be generated during build time from one YAML configuration file specified in PlatformBuild.py as <code>YAML_CONF_FILE</code>. Additional profiles will be represented as delta files (.dlt files generated by the ConfigEditor UI tool) with the profile name as the filename. These will be a semicolon delimited list in PlatformBuild.py under the name <code>DELTA_CONF_POLICY</code>. During build time, the GenSetupDataBin.py build plugin will generate variable list binaries describing each profile under the build variables <code>CONF_BIN_FILE_0</code> ... <code>CONF_BIN_FILE_N</code>. These are expected to be consumed in the platform FDF under the profile GUIDs, where <code>gSetupDataPkgGenericProfileGuid</code> must have a corresponding entry.</p> <p>The platform will override <code>gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList</code> as a FixedAtBuild PCD in their dsc file with a list of the valid profile GUIDs that exist for that platform. Any received or cached active profile GUIDs will be validated against this list. If they are not in this list, <code>gSetupDataPkgGenericProfileGuid</code> will be used as the active profile GUID.</p> <p>Platform owners can develop a configuration profile for their use case. Following examples and the format provided in the ConfigurationFiles doc, these owners can create a YAML delta file describing the set of configuration variables and their values that are in the profile that differ from the generic profile. The ConfigEditor UI tool may be used to assist in loading the YAML and saving the output into delta files, as well as manipulating the values as necessary.</p> <p>The profiles will be used as overrides to the silicon policy published earlier in the boot. It is the responsibility of the drivers that map platform configuration to silicon policy to consume the platform configuration variables. In DXE, the ActiveProfileSelectorLib library class is queried to return the active profile file GUID to use for this boot. ConfProfileMgrDxe will compare this profile GUID against what is loaded into the variable store. If the profile does not match, ConfProfileMgrDxe will write the chosen profile variables into the variable store and reboot the system. The profiles will define the entire set of UEFI configuration variables.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#profile-update","title":"Profile Update","text":"<p>Profiles will only be added and have values updated during build time.</p> <p>If a new configuration knob is required to be added to the configuration profile, it must go into the generic profile with a default value in addition to whichever profiles choose to override it.</p> <p>If a configuration knob is required to change to a new value with the same structure, it can simply be updated using the Config Editor UI tool to the new value.</p> <p>If a new structure is required for an existing configuration knob, then it is required that a new configuration knob be added, with the old knob being removed as soon as feasible.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#active-profile-selection","title":"Active Profile Selection","text":"<p>The ActiveProfileSelectorLib library class is intended to have the platform override the value. It will retrieve the active profile file GUID. If ActiveProfileSelectorLib has a failure or returns a file GUID not in <code>gSetupDataPkgTokenSpaceGuid.PcdConfigurationProfileList</code>, ConfProfileMgrDxe will attempt to fall back to the last used profile, if one exists. If the cached profile is not found or has an invalid value, ConfProfileDxe will use the generic profile, under the GUID <code>gSetupDataPkgGenericProfileGuid</code>, as the active profile.</p> <p>A given platform should override the ActiveProfileSelectorLib library class to retrieve the active profile file GUID from their source of truth.</p>"},{"location":"dyn/mu_feature_config/SetupDataPkg/Docs/Profiles/Overview/#profile-enforcement","title":"Profile Enforcement","text":"<p>In MFCI Customer Mode, the active profile will be enforced on every boot. If the variable store has any values that are invalid according to the profile, ConfProfileMgrDxe will write the profile values and reset the system.</p> <p>In MFCI Manufacturing Mode, the active profile will not be enforced. ConfProfileMgrDxe will not attempt to validate the variable store contents against the profile values.</p>"},{"location":"dyn/mu_feature_config/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_feature_config/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_feature_config/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_feature_config/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_feature_dfci/CODE_OF_CONDUCT/","title":"Microsoft Open Source Code of Conduct","text":"<p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>Resources:</p> <ul> <li>Microsoft Open Source Code of Conduct</li> <li>Microsoft Code of Conduct FAQ</li> <li>Contact opencode@microsoft.com with questions or concerns</li> </ul>"},{"location":"dyn/mu_feature_dfci/RepoDetails/","title":"Project Mu Common Plus","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_feature_dfci.git Branch:         main Commit:         d6d6dbd5a29d24190d5f7216cabfd8f847cfaf39 Commit Date:    2023-01-30 23:42:48 -0500</p> <p>This repo contains Project Mu Feature DFCI common code that should only take Basecore as a dependency and be applicable to almost any FW project. For full documentation, see below.</p>"},{"location":"dyn/mu_feature_dfci/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_feature_dfci/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_feature_dfci/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_feature_dfci/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_feature_dfci/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/SECURITY/","title":"SECURITY","text":""},{"location":"dyn/mu_feature_dfci/SECURITY/#security","title":"Security","text":"<p>Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft, Azure, DotNet, AspNet, Xamarin, and our GitHub organizations.</p> <p>If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability, please report it to us as described below.</p>"},{"location":"dyn/mu_feature_dfci/SECURITY/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report.</p> <p>If you prefer to submit without logging in, send email to secure@microsoft.com.  If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page.</p> <p>You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc. </p> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p> <p>If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.</p>"},{"location":"dyn/mu_feature_dfci/SECURITY/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"},{"location":"dyn/mu_feature_dfci/SECURITY/#policy","title":"Policy","text":"<p>Microsoft follows the principle of Coordinated Vulnerability Disclosure.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Application/DfciMenu/ReadMe/","title":"DFCI Stand Alone Recovery shell application","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/Application/DfciMenu/ReadMe/#overview","title":"Overview","text":"<p>DFCI Stand Alone Recovery is the same code as the menu item Refresh From Network, and is used to execute the Refresh From Network operation with DEBUG prints routed to the console.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Application/DfciMenu/ReadMe/#building-the-dfcisarecovery-module","title":"Building the DfciSARecovery module","text":"<p>To get the debug lib output to the console, build DfciSARecovery with the UefiDebugLibConOut library, add the following to your platform build .dsc file:</p> <pre><code> DfciPkg/Application/DfciMenu/DfciSARecovery.inf {\n&lt;LibraryClasses&gt;\nDebugLib|MdePkg/Library/UefiDebugLibConOut/UefiDebugLibConOut.inf\n}\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Application/DfciMenu/ReadMe/#running-the-dfcisarecovery-application","title":"Running the DfciSARecovery application","text":"<p>In order to run the DfciSARecovery application, the system must be able to boot to the Shell. Insure that any device settings that disable booting from USB are set to enable booting from USB. In addition, the InTune setting Dfci.BootExternalMedia.Enable must be enabled.</p> <p>Prepare a USB drive that will boot to the UEFI Shell. It is beyond the scope of this document to describe how to build the shell itself, or how to create a USB drive that boots to the shell. For information on the UEFI shell, visit:</p> <ul> <li>https://github.com/tianocore/tianocore.github.io/wiki/ShellPkg</li> </ul> <p>Copy the DfciSARecovery.efi application to the USB Drive.</p> <p>Using your platform mechanism, boot to the USB drive just created.</p> <p>At the Shell&gt; prompt, log into the USB drive and run DfciSARecovery. For example:</p> <pre><code>  fs0:\nDfciSARecovery &gt;a RefreshLog.txt\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/AuthManagerNull/","title":"AuthManagerNull","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/AuthManagerNull/#purposes","title":"Purposes","text":"<p>Do not use in production!</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/AuthManagerNull/#frontpage-during-device-bringup","title":"FrontPage during device bringup","text":"<p>This driver can be a stand in for IdentityAndAuthManager, which requires RngLib, to allow FrontPage development if RngLib is not yet functional.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/AuthManagerNull/#unit-testing","title":"Unit Testing","text":"<p>With further development, this \"Null\" driver could be an effective stub for IdentityAndAuthManager, allowing detailed unit testing of DFCI.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/","title":"Device Firmware Configuration Interface (DFCI) Introduction","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#overview","title":"Overview","text":"<p>The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu by a human. High value configuration can be moved to UEFI BIOS where it is resilient against malware, rootkits, and non-persistent physical tampering. Whereas traditional UEFI security implementations required a physical touch, DFCI securely enables zero-touch remote configuration of these settings built uponMicrosoft Intune and authorized by Windows Autopilot. DFCI can provide additional assurance by configuring and locking hardware security features before launching the OS (e.g. disabling microphones or radios). Note that for management of servers in a datacenter, DFCI does not presume to be the solution. Redfish may be a more suitable solution for the datacenter.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#why-zero-touch","title":"Why Zero Touch","text":"<p>Traditional UEFI management solutions were either not secure, allowing malware to control them, or not scalable, requiring a physical touch by IT or OEM for authentication. DFCI is zero touch, leveraging the existing Windows Autopilot device registration for DFCI authorization.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#why-should-i-configure-my-uefi-bios","title":"Why should I configure my UEFI BIOS","text":"<p>PC configuration is typically performed via Active Directory Group Policy, System Center Configuration Manager (SCCM), or Modern Device Management (MDM) such as Microsoft Intune. All of these solutions store their managed configuration in the OS disk partition. Unfortunately, this configuration can be bypassed by the PCs default ability to boot other operating system instances via external media (e.g. USB), network (e.g. PXE), &amp; alternate disk partitions, or by simply re-installing the OS. Device Firmware Configuration Interface (DFCI) places high value configuration settings into PCs UEFI BIOS. UEFI DFCI storage is both visible to all OS instances, persistent, surviving OS reinstalls and disk reformats, and tamper-resistant, defending itself from malware and rootkits. UEFI executes before the OS and can disallow booting of specified devices, for example USB or network PXE. Further, DFCI can leverage hardware security to enforce some policies with higher assurance than typical OS configuration. For example, it could disable power to cameras or radios in a way that they could not be re-enabled by an OS, malware, or rootkit.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#popular-usages","title":"Popular Usages","text":"<ul> <li>Disabling cameras, microphones, and/or radios in manufacturing and other secure facilities</li> <li>Disabling boot to USB and network for single purpose and KIOSK devices</li> <li>Disabling local user access to all UEFI settings to maintain the out of box configuration</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#oem-enablement-summary","title":"OEM Enablement Summary","text":"<p>DFCI enablement is comprised of:</p> <ol> <li>UEFI BIOS implementation</li> <li>Windows Autopilot participation</li> </ol> <p>If an OEM or its Partners already participate in the Windows Autopilot program, no additional Autopilot work is required, the only remaining work should be the UEFI BIOS implementation.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#windows-autopilot-implementation","title":"Windows Autopilot Implementation","text":"<p>The pre-existing Windows Autopilot device registration workflows remain unchanged for DFCI, no additional work is required. It should be noted that Autopilot self-registrations are not trusted for the purpose of DFCI management (e.g. from Intune, Microsoft Store for Business, &amp; Business 365).</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#uefi-bios-implementation","title":"UEFI BIOS Implementation","text":"<p>DFCI enablement in UEFI BIOS requires implementation of DFCI interfaces and semantics, and inclusion of a public Microsoft certificate. There is precisely one (1) Microsoft zero-touch certificate that is shared by all DFCI-enabled systems to authenticate zero-touch provisioning requests. Thus there is no requirement to inject the certificate at manufacturing, it may simply be included in the UEFI BIOS image. The DFCI source code and public certificate are available on GitHub under a permissive open source license (SPDX-License-Identifier: BSD-2-Clause-Patent).</p> <ul> <li>https://github.com/microsoft/mu_plus/tree/dev/201908/DfciPkg</li> <li>https://github.com/microsoft/mu_plus/tree/dev/201908/ZeroTouchPkg</li> </ul> <p>There is also an example UEFI BIOS menu that demonstrates how to integrate DFCI:</p> <ul> <li>https://github.com/microsoft/mu_oem_sample/search?q=dfci&amp;unscoped_q=dfci</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#unsigned-settings","title":"Unsigned Settings","text":"<p>Some platforms may choose to implement less secure deployment methods for certain settings. DFCI allows a platform to supply either an allow list, or a disallow list, of a set of settings that may be deployed using unsigned packets. Unsigned settings may only be deployed when no DFCI Owner has been enrolled in the system unless that DFCI owner has specifically allowed certain settings to be set by unsigned packets. See the section on platform integRation for more information.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#uefi-implementation-details","title":"UEFI Implementation Details","text":"<ol> <li>Scenarios: Building the Microsoft Scenarios with DFCI</li> <li>Integration: Integrating DFCI code into your platforms</li> <li>Architecture: DFCI Code Internals</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Dfci_Feature/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/","title":"DFCI Internals","text":"<p>This section describes the internal operations of DFCI.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#communications-with-provider","title":"Communications with Provider","text":"<p>DFCI communicates with a controlling identity. One of the controlling identities could be Microsoft Intune. The communications path from the controlling identity is though the use of UEFI variables. DFCI processes the mailbox variables during a system restart.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#identity-manager","title":"Identity Manager","text":"<p>In the source code, the Identity manager is implemented in IdentityAndAuthManager is defined in the DfciPkg located in the mu_plus repository https://github.com/microsoft/mu_plus/. Identity and Auth Manager is responsible for managing the Identities. The initial state of the system has the Local User with full authentication to make changes to any of the available settings. There are seven Identities known by DFCI:</p> Identity Owner Mask Use of the Identity Owner 0x80 The system owner. Used by a controlling agent - that authorizes Use to control some settings User 0x40 A delegated user.  Used by Microsoft Intune. User1 0x20 Not currently used User2 0x10 Not currently used Zero Touch 0x08 Limited use Identity to allow an Enroll from a controlling agent.  The system has the Zero Touch Certificate installed during manufacturing.  Zero Touch cannot be enrolled through the normal enroll operation. Zero Touch has no use when a system is enrolled. Reserved 0x04 Unsigned 0x02 Not a certificate - Limited use Identity used as the Identity processing unsigned settings packets Local User 0x01 Not a certificate - just a known, default, user <p>The Identity Manager reads the incoming mailbox to process a Identity enroll, Identity certificate update, and Identity unenroll operations. Except for the Local User, when an Identity is enrolled, it means adding a Certificate that will be used to validate incoming settings.</p> <p>The Identity Manager verifies that the incoming identity mailbox packet:</p> <ol> <li>Is signed by one of the Identities</li> <li>The signed identity has permission to update the target identity.</li> <li>Target information in the packet matches the system information</li> </ol> <p>The one exception is when an new Owner is being enrolled, no Identities validate the mailbox packet, and the Local User has permission to enroll an owner, DFCI will pause booting to prompt the Local User for permission to do the enroll. The user will be asked to validate the enrollment by entering the last two characters of the new owners certificate hash.</p> <p>When installed by the manufacturer of the system, the Zero Touch certificate will have permission to allow the Zero Touch owner packet to be enrolled without user intervention. Hence, the term Zero Touch enrollment.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#permissions-manager","title":"Permissions Manager","text":"<p>The permission manager processes incoming permission mailbox packets. Permission packets must be signed by one of Owner, User, User1 or User2. When processing the incoming permissions XML, the signer permissions are used to enable adding or changing a permission.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#settings-manager","title":"Settings Manager","text":"<p>The settings manager processes incoming settings mailbox packets. Settings packets must be signed by one of Owner, User, User1 or User2. When processing the incoming settings XML, the signer permissions are used to change a setting.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#identity-packet-formats","title":"Identity Packet Formats","text":"<p>An Identity packet consists of a binary header, a DER encoded certificate file, a test signature validating the signing capability, and the signature of the packet:</p> <p></p> <p>The Test Signature is the detached signature of signing the public key certificate by the private key of the public key certificate. The Signature field of the packet is the detached signature of signing Header-PublicCert-TestSignature by:</p> Operation Signing Key Enroll The private key of the matching Public Key Certificate Roll The private key matching the public cert of the Identity being rolled. Unenroll The private key matching the public cert of the Identity being unenrolled. <p></p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#permission-packet-formats","title":"Permission Packet Formats","text":"<p>A Permission packet consists of a binary header, an XML payload, and a signature:</p> <p></p> <p></p> <p>Sample permission packet:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;PermissionsPacket xmlns=\"urn:UefiSettings-Schema\"&gt;\n&lt;CreatedBy&gt;Cloud Controller&lt;/CreatedBy&gt;\n&lt;CreatedOn&gt;2018-03-28&lt;/CreatedOn&gt;\n&lt;Version&gt;1&lt;/Version&gt;\n&lt;LowestSupportedVersion&gt;1&lt;/LowestSupportedVersion&gt;\n&lt;Permissions Default=\"129\" Delegated=\"192\" Append=\"False\"&gt;\n&lt;!--\n\n           Sample DDS initial enroll permissions\n\n           Permission Mask - 128 (0x80) = Owner\n                              64 (0x40) = User\n                              32 (0x20) = User1\n                              16 (0x10) = User2\n                               8 (0X08) = ZTD\n                               2 (0X02) = Unsigned Settings\n                               1 (0x01) = Local User\n           Owner keeps the following settings for itself\n         --&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Dfci.OwnerKey.Enum&lt;/Id&gt;\n&lt;PMask&gt;128&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Dfci.Recovery.Enable&lt;/Id&gt;\n&lt;PMask&gt;128&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;!--\n                   Needs 128 (Owner Permission) to set the key,\n                   Needs  64 (User Permission) for User to roll the key\n             --&gt;\n&lt;Id&gt;Dfci.UserKey.Enum&lt;/Id&gt;\n&lt;PMask&gt;192&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Dfci.RecoveryBootstrapUrl.String&lt;/Id&gt;\n&lt;PMask&gt;128&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Dfci.RecoveryUrl.String&lt;/Id&gt;\n&lt;PMask&gt;128&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Dfci.Hwid.String&lt;/Id&gt;\n&lt;PMask&gt;128&lt;/PMask&gt;\n&lt;DMask&gt;128&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;/Permissions&gt;\n&lt;/PermissionsPacket&gt;\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#settings-packet-formats","title":"Settings Packet Formats","text":"<p>Sample settings payload:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;SettingsPacket xmlns=\"urn:UefiSettings-Schema\"&gt;\n&lt;CreatedBy&gt;Mike Turner&lt;/CreatedBy&gt;\n&lt;CreatedOn&gt;2019-03-06 10:10:00&lt;/CreatedOn&gt;\n&lt;Version&gt;2&lt;/Version&gt;\n&lt;!--\n\n      Make sure you edit DfciSettingsPattern.xml and then\n      run BuildSettings.bat to generate the DfciSettings.xml\n\n      --&gt;\n&lt;LowestSupportedVersion&gt;2&lt;/LowestSupportedVersion&gt;\n&lt;Settings&gt;\n&lt;Setting&gt;\n&lt;Id&gt;Dfci.RecoveryBootstrapUrl.String&lt;/Id&gt;\n&lt;Value&gt;http://some URL to access recovery cert updates/&lt;/Value&gt;\n&lt;/Setting&gt;\n&lt;Setting&gt;\n&lt;Id&gt;Dfci.RecoveryUrl.String&lt;/Id&gt;\n&lt;Value&gt;https://some URL to access recovery update packets/&lt;/Value&gt;\n&lt;/Setting&gt;\n&lt;Setting&gt;\n&lt;Id&gt;Dfci.HttpsCert.Binary&lt;/Id&gt;\n&lt;Value&gt;\n&lt;!--\n                    This is where a BASE64 encoded string of the certificate used for HTTPS operations is stored.\n                --&gt;\nwA==\n            &lt;/Value&gt;\n&lt;/Setting&gt;\n&lt;Setting&gt;\n&lt;Id&gt;Dfci.RegistrationId.String&lt;/Id&gt;\n&lt;Value&gt;\n12345678-1234-5678-1234-012345674321\n            &lt;/Value&gt;\n&lt;/Setting&gt;\n&lt;Setting&gt;\n&lt;Id&gt;Dfci.TenantId.String&lt;/Id&gt;\n&lt;Value&gt;\n98765432-1234-5678-1234-012345674321\n            &lt;/Value&gt;\n&lt;/Setting&gt;\n&lt;/Settings&gt;\n&lt;/SettingsPacket&gt;\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#packet-processing","title":"Packet Processing","text":"<p>In order to minimize rebooting when accepting packets from the owner, there are 6 mailboxes for DFCI There are two for each Identity, Permission, and Settings.  We call them:</p> <ol> <li>Identity</li> <li>Identity2</li> <li>Permission</li> <li>Permission2</li> <li>Settings</li> <li>Settings2</li> </ol> <p>Only packets of the correct type are processed out of each mailbox. Packets are processed in the following order:</p> <ol> <li>Enroll Identity</li> <li>Enroll Identity2</li> <li>Apply Permission</li> <li> <p>Apply Permission2</p> <p>At this point, if there is a severe error, the Identities and Permissions are reverted to what they were before processing the packets. The following are still processed, in order.</p> </li> <li> <p>Settings</p> </li> <li>Settings2</li> <li>Unenroll Identity 2</li> <li>Unenroll Identity</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#uefi-csp","title":"UEFI CSP","text":"<p>Intune accesses the variables through the UEFI CSP provider.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#out-of-band-recovery","title":"Out of band recovery","text":"<p>Normally, the cloud provider would just send unenroll packets through the OS to the UEFICsp.  However, if Windows is unable to boot, the UEFI front page application has a method to contact the owner via HTTPS.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#setting-provider","title":"Setting Provider","text":"<p>Settings providers provide an interface for DFCI to access platform settings. The OEM is responsible for providing one or more settings providers for platform settings. The OEM is required to implement an instance of DfciGroupLib that maps DFCI-standard settings to OEM platform settings. While DFCI-standard settings are abstract (eg. Dfci.OnboardAudio.Enable), a platform may have multiple settings that cover portions of audio. For example, there may be a microphone or other input setting, and a setting to enable or disable the audio output. Using the DfciGroup lib, the individual platform settings can be mapped to the DFCI-standard settings. For more information on groups, see Dfci Groups</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#setting-provider-expected-return-codes","title":"Setting Provider expected return codes","text":"Return Code Reason to return this code EFI_SUCCESS Operation of get or set was successful, and the returned value, if any, is valid EFI_NOT_FOUND Returned by DFCI if a setting provider is not found. See notes EFI_UNSUPPORTED Particular operation is not supported. See notes EFI_BUFFER_TOO_SMALL Get operation called with 0 size to get the size of a buffer to allocate EFI_INVALID_PARAMETER Coding error that provided incorrect parameters EFI_OUT_OF_RESOURCES Possibly out of memory, or some other lower function error"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#notes-on-efi-not-found","title":"Notes on EFI NOT FOUND","text":"<p>There are two expected reasons a settings provider could return EFI_NOT_FOUND. The first is that the settings is a DFCI standard setting from a newer version of DFCI than was implemented in the platform. The second is that the setting does not apply to the platform because it does not contain the feature. For example, if a platform has no cameras at all, it should not implement a Settings Provider for them. When EFI_NOT_FOUND is returned, Intune will additionally compare the DFCI version reported to determine compliance. For example, a platform reporting DFCI v1, and which has no cameras, returns EFI_NOT_FOUND on a request to disable all cameras. Intune infers that the lack of a standard settings provider for a given version of DFCI indicates that a setting is not relevant. On attempts to enable or disable this setting, Intune remaps this error reporting compliant or not-applicable. On a request to disable WPBT (a DFCI version 2 feature), the same platform would return EFI_NOT_FOUND because it lacks a DFCI version 2 Standard WPBT settings provider. Intune would observe the DFCI version, and report non-compliant, because the platform cannot manage or reliably report the status of the requested setting.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#notes-on-efi-unsupported","title":"Notes on EFI UNSUPPORTED","text":"<p>There are reasons for an operation to be not supported. One example is that a platform may provide a setting provider that has a setting that is always disabled, and return EFI_UNSUPPORTED when there is an attempt to enable that setting. Another case is if the hardware doesn't support the setting, or the OEM has chosen not to allow certain settings.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#settings-provider-for-enabled-features-without-platform-control","title":"Settings provider for enabled features without platform control","text":"<p>Please refer to the DfciVirtualizationSettings provider in Project mu_plus for this section. A platform may conform to a Enabled setting, but have no method to control this setting. The CPU and I/O virtualization setting is one of those. The table below indicates the return code for specific cases of of this type of provider:</p> Return Code Reason to return this code EFI_SUCCESS Operation of get was successful, and the returned value is valid EFI_UNSUPPORTED A Set operation is not allowed"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Internals/DfciInternals/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/","title":"DfciDeviceIdSupportLib","text":"<p>DfciDeviceIdSupportLib provides DFCI with three platform strings:</p> <ol> <li>Manufacturer name</li> <li>Product name</li> <li>Serial number</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#restrictions-on-device-identifier-strings","title":"Restrictions on Device Identifier strings","text":"<ol> <li>Null terminated CHAR8 strings</li> <li>Maximum of 64 CHAR8 values plus a NULL terminator, for a maximum size of 65 bytes.</li> <li>The following five characters are not allowed &amp; ' \" &lt; &gt;</li> <li>UTF-8, as per Wikipedia UTF-8, are allowed within the    64 CHAR limit and the character set limitations.</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#interfaces","title":"Interfaces","text":"Interface Function DfciIdSupportV1GetSerialNumber DEPRECATED.  Always return 0. Will be removed. DfciIdSupportGetManufacturer Returns an allocated buffer with the system manufacturer name. DfciIdSupportGetProductName Returns an allocated buffer with the system product name. DfciIdSupportGetSerialNumber Returns an allocated buffer with the system serial number."},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#additional-details","title":"Additional Details","text":"<p>These fields and their values are critical to the security of DFCI. These values should not be user configurable and should be protected from tampering.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#testing-requirements","title":"Testing Requirements","text":"<p>Your DfciDeviceIdSupportLib implementation must be linked with the included DeviceIdTest shell application. This shell application must be run on a system with production product strings for the product strings to be validated.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciDeviceIdSupportLib/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/","title":"DFCI Groups","text":"<p>DFCI Groups allow numerous like typed settings to be managed together. Groups can also be used to provide multiple names for the same setting. This allows actual device settings to be mapped into a different namespaces for settings.</p> <p>One such example from the Microsoft scenario is <code>Dfci.OnboardCameras.Enable.</code> This group setting is used to manage the state of all onboard cameras and gives the management entity an ability to control all cameras regardless of how many each platform has. A platform may have <code>Device.FrontCamera.Enable</code> and <code>Device.RearCamera.Enable</code> settings. Adding those settings to the group <code>Dfci.OnboardCameras.Enable</code> allows a general purpose management entity to control both.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#handling-state-reporting","title":"Handling State Reporting","text":"<p>If all of the settings of the group have the same value then that value will be returned (ie <code>Enabled</code> or <code>Disabled</code> for an Enable type setting). If they are not the same then <code>Inconsistent</code> will be returned. <code>Unknown</code> will be returned if there are no members in a group.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#restrictions-on-group-names","title":"Restrictions on group names","text":"<p>Group names and settings names are in the same name space and duplicate names are not allowed. Like settings names, group names are limited to 96 characters in length, and are null terminated CHAR8 strings.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#dfcigrouplib","title":"DfciGroupLib","text":"<p>The DfciGroupLib is how groups are managed. This library separates the grouping configuration from the setting providers to allow better flexibility and better maintainability.</p> <p>DfciGroupLib is defined in the DfciPkg located in mu_plus repository https://github.com/microsoft/mu_plus/</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#library-interfaces","title":"Library Interfaces","text":"Interfaces Usage DfciGetGroupEntries DfciGetGroupEntries returns an array of groups, and each group points to a list of settings that are members of the group."},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#dfci-standard-groups-for-oem-extension","title":"DFCI Standard Groups for OEM extension","text":"Group Setting String Description \"Dfci.OnboardCameras.Enable\" Enable/Disable all built-in cameras \"Dfci.OnboardAudio.Enable\" Enable/Disable all built-in microphones &amp; speakers \"Dfci.OnboardRadios.Enable\" Enable/Disable all built-in radios (e.g. Wi-Fi, BlueTooth, NFC, Mobile Broadband...) \"Dfci.BootExternalMedia.Enable\" Enable/disable boot from external media \"Dfci.BootOnboardNetwork.Enable\" Enable/disable boot from built-in network adapters \"Dfci.CpuAndIoVirtualization.Enable\" Enable/disable both CPU &amp; IO Virtualization (i.e. prerequisite for Windows Virtualization Based Security (a.k.a. Device Guard, Core Isolation, Secured Core)"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#setting-provider-for-group-settings","title":"Setting Provider for group settings","text":"<p>The individual setting providers that are part of a group are expected to be of type DFCI_SETTING_TYPE_ENABLE. Sample for mapping multiple OEM device settings to a group setting:</p> <p>Declare names for all individual BIOS settings that may be modified by the DFCI-standard settings. The DFCI-standard string values are prefixed with \"<code>Dfci.</code>.\" A naming convention for device-specific setting strings is proposed as \"<code>Device.</code>,\" as follows:</p> <pre><code>// Cameras\n//\n// Group setting                                      \"Dfci.OnboardCameras.Enable\"\n#define DEVICE_SETTING_ID__FRONT_CAMERA               \"Device.FrontCamera.Enable\"\n#define DEVICE_SETTING_ID__REAR_CAMERA                \"Device.RearCamera.Enable\"\n#define DEVICE_SETTING_ID__IR_CAMERA                  \"Device.IRCamera.Enable\"\n</code></pre> <ul> <li>Map the individual settings to the DFCI groups, an example DfciGroups.c is as follows:</li> </ul> <pre><code>STATIC DFCI_SETTING_ID_STRING mAllCameraSettings[] = {\nDEVICE_SETTING_ID__FRONT_CAMERA,\nDEVICE_SETTING_ID__REAR_CAMERA,\nDEVICE_SETTING_ID__IR_CAMERA,\nNULL\n};\nSTATIC DFCI_SETTING_ID_STRING mAllCpuAndIoVirtSettings[] = {\nDEVICE_SETTING_ID__ENABLE_VIRT_SETTINGS,\nNULL\n};\n\nSTATIC DFCI_GROUP_ENTRY mMyGroups[] = {\n{ DFCI_SETTING_ID__ALL_CAMERAS,     (DFCI_SETTING_ID_STRING *) &amp;mAllCameraSettings },\n{ DFCI_SETTING_ID__ALL_AUDIO,       (DFCI_SETTING_ID_STRING *) &amp;mAllAudioSettings },\n{ DFCI_SETTING_ID__ALL_RADIOS,      (DFCI_SETTING_ID_STRING *) &amp;mAllRadiosSettings },\n{ DFCI_SETTING_ID__EXTERNAL_MEDIA,  (DFCI_SETTING_ID_STRING *) &amp;mExternalMediaSettings },\n{ DFCI_SETTING_ID__ENABLE_NETWORK,  (DFCI_SETTING_ID_STRING *) &amp;mOnboardNetworkSettings },\n{ DFCI_SETTING_ID__ALL_CPU_IO_VIRT, (DFCI_SETTING_ID_STRING *) &amp;mAllCpuAndIoVirtSettings },\n{ NULL,                             NULL }\n};\n\n/**\n * Return a pointer to the Group Array to DFCI\n *\n */\nDFCI_GROUP_ENTRY *\nEFIAPI\nDfciGetGroupEntries (VOID) {\n\nreturn (DFCI_GROUP_ENTRY *) &amp;mMyGroups;\n}\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#group-settings-results","title":"Group settings results","text":"<p>When a group setting is accessed, DFCI enumerates the individual settings of the group. The actual return code to the caller is modified by DFCI depending on the individual settings providers return values. Each of the individual settings will be listed in the Settings Result variable, along with the return code from each setting provider. The return value for the group setting will be one of the following:</p> Return Value from DFCI Reason to return this value \"Enabled\" All providers returned the boolean value TRUE \"Disabled\" All providers in the group returned the boolean value FALSE \"Inconsistent\" Different results were returned from the providers"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciGroups/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/","title":"DFCI Settings Providers","text":"<p>Settings providers are the foundation of DFCI. Settings providers provide a common method to get and apply a setting. All of the setting providers are linked to the Settings Manager,which published the Setting Access Protocol.</p> <p>All updates to settings that are provided by an anonymous DFCI settings library should be through the Setting Access protocol.  The Setting Access protocol will validate the permission of the setting before allowing the setting to be changed.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#overview","title":"Overview","text":"<p>A setting provider may publish more than one settings. Multiple setting providers are aggregated and accessed through the DFCI Setting Access Protocol as shown below:</p> <p></p> <p>Lets look at what is needed for a single setting in the Setting Provider environment. A setting provider is an anonymous library linked with the Settings Manager DXE driver. Here is how the DfciSampleProvider library is linked with the Settings Manager as an anonymous library:</p> <pre><code> DfciPkg/SettingsManager/SettingsManagerDxe.inf {\n&lt;PcdsFeatureFlag&gt;\ngDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE\n&lt;LibraryClasses&gt;\nNULL|DfciPkg/Library/DfciSampleProvider/DfciSampleProviderLib.inf\n}\n</code></pre> <p>Any number of anonymous libraries can be linked with the Settings Manager. Referring to the DfciSampleProvider code, a setting provider defines a setting as:</p> <pre><code>DFCI_SETTING_PROVIDER mDfciSampleProviderProviderSetting1 = {\nMY_SETTING_ID__SETTING1,\nDFCI_SETTING_TYPE_ENABLE,\nDFCI_SETTING_FLAGS_NO_PREBOOT_UI,   // NO UI element for user to change\nDfciSampleProviderSet,\nDfciSampleProviderGet,\nDfciSampleProviderGetDefault,\nDfciSampleProviderSetDefault\n};\n</code></pre> <p>This particular setting is a ENABLE/DISABLE type of setting, and is telling DFCI that there is no UI element for this setting.  When there is no UI element for a setting, DFCI will set the value to the setting Default Value when DFCI is unenrolled.</p> <p>Each setting provider library must have a constructor with code that checks the PCD gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider.</p> <p>When the constructor is called with the InstallProvider PCD set to TRUE, the setting provider needs to register for a notification of the Settings Provider Support Protocol. When that notification is called, the Settings Provider calls the RegisterProvider method with each setting that the setting provider provides.</p> <p>The constructor looks like:</p> <pre><code>    if (FeaturePcdGet (PcdSettingsManagerInstallProvider)) {\n//Install callback on the SettingsManager gDfciSettingsProviderSupportProtocolGuid protocol\nmDfciSampleProviderProviderSupportInstallEvent = EfiCreateProtocolNotifyEvent (\n&amp;gDfciSettingsProviderSupportProtocolGuid,\nTPL_CALLBACK,\nDfciSampleProviderProviderSupportProtocolNotify,\nNULL,\n&amp;mDfciSampleProviderProviderSupportInstallEventRegistration\n);\n\nDEBUG((DEBUG_INFO, \"%a: Event Registered.\\n\", __FUNCTION__));\n\n//Initialize the settings store\nStatus = InitializeSettingStore ();\nif (EFI_ERROR(Status)) {\nDEBUG((DEBUG_ERROR, \"%a: Initialize Store failed. %r.\\n\", __FUNCTION__, Status));\n}\n}\nreturn EFI_SUCCESS;\n</code></pre> <p>The notify routine looks like:</p> <pre><code>    //locate protocol\nStatus = gBS-&gt;LocateProtocol (&amp;gDfciSettingsProviderSupportProtocolGuid, NULL, (VOID**)&amp;sp);\nif (EFI_ERROR(Status)) {\nif ((CallCount++ != 0) || (Status != EFI_NOT_FOUND))\n{\nDEBUG ((DEBUG_ERROR, \"%a() - Failed to locate gDfciSettingsProviderSupportProtocolGuid in notify.  Status = %r\\n\", __FUNCTION__, Status));\n}\nreturn;\n}\n\nStatus = sp-&gt;RegisterProvider (sp, &amp;mDfciSampleProviderProviderSetting1);\nif (EFI_ERROR (Status)) {\nDEBUG((DEBUG_ERROR, \"Failed to Register %a.  Status = %r\\n\", mDfciSampleProviderProviderSetting1.Id, Status));\n}\n\n//We got here, this means all protocols were installed and we didn't exit early.\n//close the event as we don't need to be signaled again. (shouldn't happen anyway)\ngBS-&gt;CloseEvent(Event);\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#setting-provider","title":"Setting Provider","text":"<p>When you are writing your setting provider, keep in mind that other, similarly written libraries, are linked together. Define each common routine as STATIC to avoid conflicts with other providers. Refer to the UEFI general timeline here:</p> <p></p> <p>Quite a few settings are only needed in late DXE, BDS or FrontPage.  You may need access to settings values in PEI or in DXE prior to the starting of SettingsManager. To do this, add private methods to your settings library. Doing this will keep a single piece of code that accesses the nonvolatile storage for the settings. Here is a sample local setting function in the Dfci Sample Provider:</p> <pre><code>// Here is where you would have private interfaces to get and or set a settings value\n\nEFI_STATUS\nOEM_GetSampleSetting1 (\nOUT UINT8    *LocalSetting\n) {\n\nUINTN       LocalSettingsSize;\nEFI_STATUS  Status;\n\nLocalSettingSize = sizeof (*LocalSetting);\n\nStatus = DfciSampleProviderGet (\n&amp;mDfciSampleProviderProviderSetting1,\n&amp;LocalSettingSize,\n&amp;LocalSetting\n);\n\nreturn Status;\n}\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciSettingProviders/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciUiSupportLib/","title":"DfciUiSupportLib","text":"<p>DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non-secure environment is available.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/DfciUiSupportLib/#interfaces","title":"Interfaces","text":"Interface Usage DfciUiIsManufacturingMode Returns TRUE or FALSE.  Used to self OptIn a cert used for zero touch enrollment. If the device doesn't support a manufacturing mode, return FALSE. DfciUiIsAvailable For one touch enrollment, the user has to authorize the enrollment.  Since DFCI normally runs before consoles are started, DFCI will wait until END_OF_DXE and then make sure the User Interface (UI) is available.  If no UI is available at that time, the enrollment will fail. DfciUiDisplayMessageBox Displays a message box DfciUiDisplayPasswordDialog Displays a prompt for the ADMIN password DfciUiDisplayAuthDialog Displays a prompt for confirmation of an enrolling certificate.  The response is the last two characters of the thumbprint. If there is an ADMIN password set, then this dialog will also request the ADMIN password. DfciUiExitSecurityBoundary The platform settings application usually runs in a secure state before variables are locked.  The DFCI Menu application will call ExitSecurityBoundary before starting the network or performing USB operations to minimize the security risks associated with external accesses."},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/","title":"Platform Integration of DFCI","text":"<p>This section of documentation is focused on UEFI firmware developers and helping them enable their platforms with the DFCI feature.</p> <p>DFCI consists mostly of a software feature that is written in the DXE phase of UEFI.  It has numerous architecture and platform independent modules with only a few required platform libraries. It also requires the platform adhere to and use the DFCI components to ensure the DFCI features work as designed.  Finally to enable an End-To-End management scenario there maybe custom requirements in adjacent UEFI firmware components.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-menu-application","title":"Dfci Menu application","text":"<p>The DfciMenu application is optimized for mu_plus MsGraphicsPkg. It is VFR but since many platforms use custom layouts and graphical representation this area might need some adjustments.  The DfciMenu application publishes a HII formset that should be located by your pre-boot UEFI menu application (e.g. \"FrontPage\") and displayed.</p> <ul> <li>Formset GUID: <code>gDfciMenuFormsetGuid = {0x3b82283d, 0x7add, 0x4c6a, {0xad, 0x2b, 0x71, 0x9b, 0x8d, 0x7b, 0x77, 0xc9 }}</code></li> <li>Entry Form: <code>#define DFCI_MENU_FORM_ID           0x2000</code></li> <li>Source Location: <code>DfciPkg\\Application\\DfciMenu</code></li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-dxe-drivers","title":"DFCI DXE Drivers","text":"Dxe Driver Location DfciManager.efi DfciPkg/DfciManager/DfciManager.inf IdentityAndAuthManager.efi DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf SettingsManager.efi DfciPkg/SettingsManager/SettingsManagerDxe.inf DfciMenu.inf DfciPkg/Application/DfciMenu/DfciMenu.inf"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-core-libraries","title":"DFCI Core Libraries","text":"<p>These DFCI Standard libraries are expected to be used as is for standard functionality.</p> Library Location DfciRecoveryLib DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf DfciSettingsLib DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf DfciV1SupportLib DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf DfciXmlDeviceIdSchemaSupportLib DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf DfciXmlIdentitySchemaSupportLib DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf DfciXmlPermissionSchemaSupportLib DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf DfciXmlSettingSchemaSupportLib DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf ZeroTouchSettingsLib ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf DfciSettingPermissionLib DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-platform-provided-libraries","title":"DFCI Platform provided libraries","text":"<p>The following libraries have to be provided by the platform:</p> Library Documentation Function DfciDeviceIdSupportLib Documentation Provides SMBIOS information - Manufacturer, Product, and Serial number DfciGroupLib Documentation Provides lists of platform settings that are in the Dfci group settings. DfciUiSupportLib Documentation Provides UI for various user interactions"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#dfci-setting-providers","title":"DFCI Setting Providers","text":"<p>Setting providers is how a platform provides a setting to DFCI</p> <p>Setting detailed overview</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#mu-changes","title":"Mu Changes","text":"<ul> <li>DFCI Recovery service uses HTTPS certificates with Subject Alternative Names.  This requires a source modification to NetworkPkg, removal of EFI_TLS_VERIFY_FLAG_NO_WILDCARDS from TlsConfigureSession().</li> <li>Configure OpenSSL to support modern TLS ciphers</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#platform-dsc-statements","title":"Platform DSC statements","text":"<p>Adding DFCI to your system consists of:</p> <ol> <li>Write your settings providers. Use DfciPkg/Library/DfciSampleProvider.</li> <li>Writing three library classes for the DfciDeviceIdSupportLib, DfciGroupLib, and DfciUiSupportLib.</li> <li>Adding the DSC sections below.</li> <li>Adding the FDF sections below.</li> </ol> <pre><code>[LibraryClasses.XXX]\n  DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf\n  DfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf\n  DfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf\n  DfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf\n  ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf\n  DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf\n  DfciSettingsLib|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf\n  DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf\n\n  DfciDeviceIdSupportLib|YOURPLATFORMPKG/Library/DfciDeviceIdSupportLib/DfciDeviceIdSupportLib.inf\n  DfciUiSupportLib|YOURPLATFORMPKG/Library/DfciUiSupportLib/DfciUiSupportLib.inf\n  DfciGroupLib|YOURPLATFORMPKG/Library/DfciGroupLib/DfciGroups.inf\n\n[Components.XXX]\n  DfciPkg/SettingsManager/SettingsManagerDxe.inf {\n  #Platform should add all it settings libs here\n  &lt;LibraryClasses&gt;\n        NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf\n        NULL|YOUR_PLATFORM_PKG/Library/YOUR_FIRST_SETTING_PROVIDER.inf\n        NULL|YOUR_PLATFORM_PKG/Library/YOUR_SECOND_SETTING_PROVIDER.inf\n        NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf\n        NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf\n        NULL|DfciPkg/Library/DfciVirtualizationSettings/DfciVirtualizationSettings.inf\n        DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf\n  &lt;PcdsFeatureFlag&gt;\n     gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE\n  }\n\n  DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf\n  DfciPkg/DfciManager/DfciManager.inf\n  DfciPkg/Application/DfciMenu/DfciMenu.inf\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#platform-fdf-statements","title":"Platform FDF statements","text":"<pre><code>[FV.YOUR_DXE_FV]\nINF  DfciPkg/SettingsManager/SettingsManagerDxe.inf\nINF  DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf\nINF  DfciPkg/Application/DfciMenu/DfciMenu.inf\nINF  DfciPkg/DfciManager/DfciManager.inf\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#unsigned-settings-packets","title":"Unsigned Settings packets","text":"<p>Dfci has a feature where a platform can enable some settings to be changes with an unsigned packet. This is allowed only when the system is not enrolled in Dfci. This can allow setting parameters that don't affect the security of the system and there is a cost benefit to being able to deploy these setting changes easily, and not step up to full Dfci. To enable to platform to allow unsigned settings, the platform must produce an unsigned permission list in xml format and include this xml file in the platform build .fdf file:</p> <pre><code>&lt;!--\nNOTE:\n    None of the Permission Masks or the Delegated Masks are actually used.\n    However, they must be present for the XML parser used by Dfci.\n    This include Default, Delegated, Append, PMask, and DMask values.\n --&gt;\n&lt;PermissionsPacket xmlns=\"urn:UefiSettings-Schema\"&gt;\n&lt;Permissions Default=\"243\" Delegated=\"0\" Append=\"False\"&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Device.PlatformSetting1.Enable&lt;/Id&gt;\n&lt;PMask&gt;243&lt;/PMask&gt;\n&lt;DMask&gt;0&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;Permission&gt;\n&lt;Id&gt;Device.PlatformSetting2.Enable&lt;/Id&gt;\n&lt;PMask&gt;243&lt;/PMask&gt;\n&lt;DMask&gt;0&lt;/DMask&gt;\n&lt;/Permission&gt;\n\n&lt;Permission&gt;\n&lt;Id&gt;Device.PlatformSetting3.Enable&lt;/Id&gt;\n&lt;PMask&gt;243&lt;/PMask&gt;\n&lt;DMask&gt;0&lt;/DMask&gt;\n&lt;/Permission&gt;\n&lt;/Permissions&gt;\n&lt;/PermissionsPacket&gt;\n</code></pre> <p>To include this file in the platform .fdf file, do the following:</p> <pre><code>FILE FREEFORM = PCD(gDfciPkgTokenSpaceGuid.PcdUnsignedPermissionsFile) {\nSECTION RAW = YourPlatformPkg/StaticFiles/UnsignedPermissions.xml\n}\n</code></pre> <p>Certain platforms may choose to enable all settings to be set via unsigned packets by building with the Pcd PcdUnsignedListFormatAllow set to FALSE. This will enable all settings to be changed using unsigned packets. When PcdUnsignedListFormatAllow is FALSE, the unsigned settings list becomes a disallow list, providing a list of settings that do NOT have the permission to be set by an unsigned packet. An Unsigned Permissions file is required to be read before the Disallow operation is enabled.</p> <p>To generate an unsigned settings packet, refer to the DFCI_UnsignedSettings test case. The GenUsb.bat file will produce an unsigned packet (Unsigned_Settings_apply.bin) from a settings xml file (UnsignedSettings.xml).</p> <p>To deploy the Unsigned_Settings_apply.bin file, set the UEFI Variable gDfciSettingsManagerVarNamespace:DfciSettingsRequest to the contents of the Unsigned_Settings_apply.bin file, and restart the system.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/PlatformIntegration/PlatformIntegrationOverview/#testing-dfci-operation","title":"Testing DFCI operation","text":"<p>Please refer to the DFCI TestCase documentation</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/","title":"Microsoft DFCI Scenarios","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#overview","title":"Overview","text":"<p>Microsoft leverages DFCI to provide automated UEFI settings management via Microsoft Intune. Intune provides the IT manager with abstracted, easy button settings that are generally applicable to all platforms, for example, disable booting USB devices or disable all cameras.  IT managers depend on the UEFI implementation to protect and enforce DFCI configurations such that they cannot be bypassed by an operating system or casual physical attacker. Windows Autopilot provides the trusted device ownership database, mapping devices to Azure Active Directory Tenants. The \"Microsoft Device Management Trust\" certificate must be included in UEFI to act as the root of trust for automated UEFI management.  The Autopilot Service (APS) exposes a cloud endpoint to enable recovery from a BIOS menu in case the device can no longer boot due to misconfiguration or disk corruption.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#microsoft-dfci-scenario-requirements","title":"Microsoft DFCI Scenario Requirements","text":"<ul> <li>PCs must include the DFCI feature in their UEFI</li> <li>PCs must be registered to the Windows Autopilot service by an OEM or Microsoft Cloud Solution Provider</li> <li>PCs must be managed with Microsoft Intune</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#oems-that-support-dfci","title":"OEMs that support DFCI","text":"<p>More are in the works...</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#lifecycle","title":"Lifecycle","text":"<p>The DFCI lifecycle can be viewed as UEFI integration, device registration, profile creation, enrollment, management, retirement, &amp; recovery.</p> <p></p> Stage Description UEFI Integration PCs must first include a UEFI BIOS that integrates the DFCI code and includes the Microsoft Device Management Trust certificate. Device Registration Device ownership must be registered via the Windows Autopilot program by an OEM or Microsoft Cloud Solution Provider Profile Creation An IT administrator leverages Intune to create DFCI Profiles for their devices. Enrollment The DFCI enrollment process is kicked off when a PC is enrolled into Intune and has a matching DFCI Profile.  Enrollment includes Intune requesting enrollment packets from APS, sending the packets to the Windows UEFI configuration service provider (CSP) endpoints, the CSP writes the packets to UEFI variables, and triggers an OS reboot to allow UEFI firmware to process the DFCI packets. Management For day-to-day management, Intune creates device-specific packets, digitally signs them, and sends them through the same UEFI configuration service provider, UEFI variable, and reboot process. Retirement When a device is removed from Windows Autopilot, they are marked as unenrolled in APS.  Intune will attempt to restore permissions (un-grey all settings) and remove its management authority from the device. Recovery Recovery shall be provided via a pre-boot UEFI menu, always available to a physically-present user, that can refresh DFCI configuration via web, USB, or other."},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#enrollment-flow","title":"Enrollment Flow","text":"<p>Prior to the time of Enrollment, Microsoft Device Management Trust delegates management to the APS by signing a wildcard enrollment packet (targeting all manufacturer, model, &amp; serial number) that authorizes enrollment of the APS certificate. At the request of Intune, the APS authorizes enrollment of a device, creates and signs per-device-targeted enrollment packets that enroll the Intune DFCI management certificate.  The APS provides a level of indirection as well as an extra level of recovery via a web recovery service endpoint.  The APS additionally configures recovery settings as well as permissions that deny Intune access to modify them. DEFINED: A device is considered \"enrolled\" when <code>IS_OWNER_IDENTITY_ENROLLED(IdMask)</code> returns TRUE, unenrolled when FALSE. Intune creates device-specific packets to provision the Intune authority and configure DFCI settings and permissions as specified in the matching Intune DFCI Profile.  Intune delivers these packets via the Windows UEFI configuration service provider which writes them to UEFI mailboxes, to be processed by DFCI on the following boot.  Device-specific packets include the SMBIOS manufacturer, model, &amp; serial number, along with an anti-rollback count, to be leveraged by the UEFI DFCI code to determine applicability.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#retirement-recovery-flows","title":"Retirement &amp; Recovery Flows","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#retirement","title":"Retirement","text":"<p>An IT administrator leverages the Intune console to remove devices from Autopilot.  Intune creates and sends device- specific packets that both restore DFCI permissions (effectively un-managing settings, making them available in the BIOS menu) and remove the Intune authority from DFCI.  Note that this does not restore the settings to default values, they remain as is.  Intune also notifies APS that the device is in the unenrolled state.  If the device owner wants to further remove the APS authority and/or opt-out of DFCI management, they must leverage the Recovery flow.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#recovery","title":"Recovery","text":"<p>Recovery is essential because UEFI misconfiguration may prevent booting to an operating system, for example if USB and network boot are disabled and the hard disk becomes corrupted.  When a device is enrolled, UEFI must provide alternative mechanisms for the physically-present user to place packets in the DFCI request mailboxes - this MUST NOT be blocked by a BIOS password or similar.  Note that when a device is not enrolled, a BIOS password should prevent access to DFCI enrollment by a physically-present user until they have entered the correct credential.</p> <p>The APS keeps track of the enrollment state of devices.  When an administrator removes a device from Autopilot, APS creates signed, device-specific un-enrollment packets and makes them available via a REST endpoint at DFCI_PRIVATE_SETTING_ID__DFCI_RECOVERY_URL.  These packets should delete the Intune and APS certificates and provide the local user with access to all settings (they should no longer be greyed out in BIOS menus).  Note that retirement does not restore visible settings to their default values.</p> <p></p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#standard-settings","title":"Standard Settings","text":"<p>The following standard settings are defined for DFCI v1.0, will be exposed by Intune, and Settings Providers for them must be implemented by the UEFI provider.  Note that for device management, the settings apply only to built-in devices, not externally attached devices.</p> <ul> <li>All cameras</li> <li>All audio (microphones &amp; speakers)</li> <li>All radios (Wi-Fi, broadband, NFC, BT, ...)</li> <li>CPU &amp; IO virtualization (exposed, enabled for use by the OS so that Virtualization Based Security may be enabled)</li> <li>Boot to external media (e.g. USB, SD, ...)</li> <li>Boot via on-board network devices</li> </ul> <p>Refer to the \"Group Settings\" section of DfciSettings.h</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#device-ownership","title":"Device Ownership","text":"<p>The Windows Autopilot database is used for authorizing DFCI management.  It includes a map of device identifiers an owner's Azure Active Directory tenant.  It is populated as part of the Windows Autopilot program by OEMs and Microsoft-authorized Cloud Solution Providers. The DFCI UEFI code leverages the SMBIOS manufacturer, model, and serial number for packet targeting. DFCI is a Windows Autopilot feature, available from Microsoft Intune.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#management-authorities","title":"Management Authorities","text":"<p>DFCI supports UEFI settings and permission management by multiple entities. In the recommended configuration, systems are shipped with 1 Microsoft public certificate included, \"CN=Microsoft Device Management Trust\", which provides the root of trust for management.  This certificate authorizes Microsoft to automatically enroll management delegates with varying permissions.  \"Microsoft Device Management Trust\" is only used to delegate management to APS and to provide second-chance recovery.  APS in turn delegates management to Intune and provides a REST endpoint for online recovery. After enrollment, Intune performs the day-to-day UEFI management, whereas APS and Device Management Trust authorities provide various recovery paths.</p> Authority DFCI ID Usage \"CN=Microsoft Device Management Trust\" DFCI_IDENTITY_SIGNER_ZTD Allowed to enroll a management delegates without a physical presence prompt.  Enrolls the Autopilot Service authority.  Can act as a backup recovery service. Autopilot Service (APS) DFCI_IDENTITY_SIGNER_OWNER Enrolls Microsoft Intune as a delegated management provider.  Provides an online recovery service in case the OS is disconnected from Intune. Microsoft Intune DFCI_IDENTITY_SIGNER_USER Performs day-to-day UEFI settings and permissions management"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#security-privacy-considerations","title":"Security &amp; Privacy Considerations","text":"<p>When a DFCI owner is enrolled, DFCI must take precedence over any other UEFI management solution.  Physically-present user, including authenticated, may not bypass DFCI permissions on <code>DFCI_IDENTITY_LOCAL</code>.</p> <p>Protection: The hardware/firmware implementation of DFCI must protect DFCI configuration code and data such that they cannot by bypassed by an operating system or casual physical attacker.  For example, non-volatile storage that is locked prior to Boot Device Selection.</p> <p>Enforcement: The hardware/firmware implementation of DFCI must enforce DFCI configurations such that they cannot by bypassed by an operating system or casual physical attacker.  For example, power to devices is disabled or busses disabled and the configuration is locked prior to Boot Device Selection.</p> <p>It is recommended to include an \"Opt Out\" button that enables a physically-present user on an unenrolled device to eject the DFCI_IDENTITY_SIGNER_ZTD from DFCI.  The effectively disables automated management - any enrollment attempt will display a red prompt at boot.  A user could then prevent enrollment by configuring a BIOS password or enroll their own User certificate (proceeding through the red prompt).</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#online-recovery-via-the-autopilot-service","title":"Online Recovery via the Autopilot Service","text":"<p>The Recovery REST interface includes machine identities.  Before transferring machine identities, the server's authenticity should be verified against DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT.  After authenticating the server, the network traffic, including machine identities, are kept private by HTTPS encryption.  But wait, there's more... the server certificate is updated regularly, so UEFI must first ensure it has the up-to-date DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. DFCI_PRIVATE_SETTING_ID__DFCI_BOOTSTRAP_URL provides a REST API to download a signed settings packet containing DFCI_PRIVATE_SETTING_ID__DFCI_HTTPS_CERT. For this workflow, the server is not authenticated, but the payload will be authenticated prior to consumption.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Docs/Scenarios/DfciScenarios/#unknown-certificate-enrollment","title":"Unknown Certificate Enrollment","text":"<p>This is not a Microsoft-supported scenario but might be encountered during development and testing.  On an unenrolled system, if enrollment packets are supplied to the DFCI mailboxes that are signed by an unknown certificate, a red authorization prompt is displayed during boot.  The prompt requests the physically-present user to authorize the enrollment of the unknown certificate by typing the last 2 characters of the certificate's SHA-1 thumbprint.  If a BIOS password is configured, the password must be entered prior to authorizing the enrollment. This is designed to avoid accidental or nefarious enrollment while allowing for valid custom identity management.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/","title":"Identity and Authentication Manager","text":"<p>Basic overview of the IdentityAndAuthManager module.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#file-overview","title":"File Overview","text":""},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerh","title":"IdentityAndAuthManager.H","text":"<ul> <li>Private header file defining private functions for use across module</li> <li>Define the internal structure that holds the auth handle to identity mapping</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerdxe","title":"IdentityAndAuthManagerDxe","text":"<ul> <li>Implement the Dxe specific parts of this.  Including:</li> <li>Event handling</li> <li>Protocol access</li> <li>Protocol installation</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerc","title":"AuthManager.C","text":"<ul> <li>Provide the implementation for the auth protocol functions</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerprovisionc","title":"AuthManagerProvision.C","text":"<ul> <li>Support using Variable to set, change, or remove the AuthManager Key based identities</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#authmanagerprovisioneddatac","title":"AuthManagerProvisionedData.C","text":"<ul> <li>Support NV storage of Provisioned Data.  This manages loading internal store and saving changes to internal store.</li> <li>This differs from the Provision.c file in that this has nothing to do with User input or applying user changes.  Thi  is internal to the module only.</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#identitymanagerc","title":"IdentityManager.C","text":"<ul> <li>Support the get identity functionality</li> <li>Dispose Auth Handle</li> <li>Private</li> <li>Identity / auth token map management (Add, Free, Find)</li> <li>Add security TODO</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#identityandauthmanagerdxeinf","title":"IdentityAndAuthManagerDxe.INF","text":"<ul> <li>Dxe Module inf file</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/IdentityAndAuthManager/ReadMe/#dfciauthenticationh-public-header-file","title":"DfciAuthentication.h  PUBLIC HEADER FILE","text":"<ul> <li>Defines the DXE protocol to access Identity and Auth management</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Library/DfciSampleProvider/readme/","title":"Dfci Sample Provider","text":"<p>This is a DXE driver that publishes the gDfciSettingsProviderSupportProtocolGuid protocol, which is a settings provider for DFCI.</p> <p>This is not to be used in production but is provided as a sample for reference when creating your own provider.</p> <p>For more information, please refer to the DFCI documentation here</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/Library/DfciSampleProvider/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DeviceIdTest/readme/","title":"Verify DfciDeviceIdLib library functionality","text":"<p>The library DfciDeviceIdLib provided Dfci with platform information that Dfci needs.  This include the manufacturer name, product name, and serial number.  Dfci has limit on the characters supported, and the length of the strings returned.</p> <p>Device Id Library rules:</p> <ol> <li>The following five characters are not allowed: <code>\" ' &lt; &gt; &amp;</code></li> <li>The maximum string length is 64 characters plus a terminating '\\0'</li> <li>'\\0' is a required terminator.  The interfaces return       the string and the size of the string (including the '\\0').</li> <li>The string is a valid UTF-8 string (ie, no 8-bit ASCII)</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DeviceIdTest/readme/#about","title":"About","text":"<p>These tests verify that the DeviceIdLib Library functions properly.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DeviceIdTest/readme/#deviceididtestapp","title":"DeviceIdIdTestApp","text":"<p>This application consumes the DfciDeviceIdLib executed test cases for the verification of the Device Id Strings.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DeviceIdTest/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/","title":"Testing DFCI","text":"<p>This describes the test structure for insuring DFCI operates properly.</p> <ol> <li>A Host System (HOST) to run the test cases.</li> <li>A Device Under Test (DUT) to be tested. with the new DFCI supported also running current Windows.</li> <li>Both systems on the same network.</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#overview","title":"Overview","text":"<p>The DFCI tests are a collection of Robot Framework test cases. Each Robot Framework test case collection is contained in a directory, and, as a minimum, contains a run.robot file.</p> <p>Each test case collection is run manually in a proscribed order, and its status is verified before running the next test case. The tests must be run in order, as they alter the system state, much like the real usage of DFCI.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#equipment-needed","title":"Equipment needed","text":"<p>The following equipment is needed to run the DFCI tests:</p> <ol> <li>A system to run the test cases running a current version of Windows.</li> <li>A System Under Test also running current version of Windows.</li> <li>Both systems able to communicate with each other across the same network.</li> </ol> <p>Optional equipment is a mechanism to collect firmware logs from the system under test. Included is a serial port support function that looks for an FTDI serial connection. See the Platforms\\SimpleFTDI folder.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#setting-up-the-device-under-test-dut","title":"Setting up the Device Under Test (DUT)","text":"<p>Copy the files needed for the DUT. There is a script to help you do this. For example, with a removable device mounted at drive D:, issue the command:</p> <pre><code>DeviceUnderTest\\CollectFilesForDut.cmd D:\\DfciSetup\n</code></pre> <p>This will create a directory on the USB key named <code>DfciSetup</code> with the required files for setting up the remote server. Mount the removable device on the DUT and start an administrator CMD Window, then run (where x: is the drive letter where the USB key is mounted):</p> <pre><code>x:\\DfciSetup\\SetupDUT.cmd\n</code></pre> <p>This will download and install Python, robotframework, robotremoteserver, and pypiwin32. In addition, the SetupDUT command will update the firewall for the robot framework testing, and a make a couple of configuration changes to Windows for a better test experience.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#setting-up-the-host-system","title":"Setting up the HOST system","text":"<p>The HOST system requires the following software (NOTE - There are dependencies on x86-64 versions of Windows):</p> <ol> <li>A current version of Windows x86-64.</li> <li>The current Windows SDK, available here Windows SDK.</li> <li>Python x86-64 (the version tested), available here Python 3.9.4.</li> <li>Copy the DfciTests directory, including all of the contents of the subdirectories, onto the HOST system.</li> <li>Install the required python packages by running using the pip-requirements.txt file in the DfciTests directory:</li> </ol> <pre><code>   python -m pip install --upgrade -r pip-requirements.txt\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#test-cases-collections","title":"Test Cases Collections","text":"<p>Table of DFCI Test case collections:</p> Test Case Collection Description of Test Case DFCI_CertChainingTest Verifies that a ZeroTouch enroll actually prompts for authorization to Enroll when the enroll package is not signed by the proper key. DFCI_InitialState Verifies that the firmware indicates support for DFCI and that the system is Opted In for InTune, and is not already enrolled into DFCI. DFCI_InTuneBadUpdate Tries to apply a settings package signed with the wrong key DFCI_InTunePermissions Applies multiple sets of permissions to an InTune Enrolled system. DFCI_InTuneEnroll Applies a InTune Owner, an InTune Manager, and the appropriate permissions and settings. DFCI_InTuneRollCerts Updates the Owner and Manager certificates. This test can be run multiple times as it just swaps between two sets of certificates. DFCI_InTuneSettings Applies multiple sets of settings to a InTune Enrolled system. DFCI_InTuneUnenroll Applies an InTune Owner unenroll package, that removes both the InTune Owner and the InTune Manager, resets the Permission Database, and restores settings marked No UI to their default state."},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#note-on-the-firmware-for-testing-dfci","title":"Note on the firmware for testing DFCI","text":"<p>Most of DFCI functionality can be tested without regard of the Zero Touch certificate. To test functionality of the Zero Touch feature, the firmware needs to be built with the ZTD_Leaf.cer file instead of the ZtdRecovery.cer file.</p> <p>To do this, change your platform .fdf file from:</p> <pre><code>FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) {\n    SECTION RAW = ZeroTouchPkg/Certs/ZeroTouch/ZtdRecovery.cer\n}\n</code></pre> <p>to:</p> <pre><code>FILE FREEFORM = PCD(gZeroTouchPkgTokenSpaceGuid.PcdZeroTouchCertificateFile) {\n    SECTION RAW = DfciPkg/UnitTests/DfciTests/ZTD_Leaf.cer\n}\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#warning-do-not-ship-with-the-ztd_leafcer-certificate-in-your-firmware","title":"WARNING: Do not ship with the ZTD_Leaf.cer certificate in your firmware","text":"<p>Be sure your production systems are using the ZtdRecovery.cer file.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#running-the-first-test-case","title":"Running The First Test Case","text":"<p>Run the first test as shown replacing 11.11.11.211 with the actual IP address of the DUT. You should expect to see similar output with all four tests passing.</p> <pre><code>DfciTests&gt;RunDfciTest.bat TestCases\\DFCI_InitialState 11.11.11.211\n\nDfciTests&gt;python.exe -m robot.run -L TRACE -x DFCI_InitialState.xml -A Platforms\\SimpleFTDI\\Args.txt -v IP_OF_DUT:11.11.11.211 -v TEST_OUTPUT_BASE:C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 -d C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224 TestCases\\DFCI_InitialState\\run.robot\n==============================================================================\nRun :: DFCI Initial State test - Verifies that there are no enrolled identi...\n==============================================================================\nEnsure Mailboxes Are Clean                                            ..\n.L:\\Common\\MU\\DfciPkg\\UnitTests\\DfciTests\\TestCases\\DFCI_InitialState\\run.robot\nEnsure Mailboxes Are Clean                                            | PASS |\n------------------------------------------------------------------------------\nGet the starting DFCI Settings                                        | PASS |\n------------------------------------------------------------------------------\nObtain Target Parameters From Target                                  | PASS |\n------------------------------------------------------------------------------\nProcess Complete Testcase List                                        ..Initializing testcases\n..Running test\nProcess Complete Testcase List                                        | PASS |\n------------------------------------------------------------------------------\nRun :: DFCI Initial State test - Verifies that there are no enroll... | PASS |\n4 critical tests, 4 passed, 0 failed\n4 tests total, 4 passed, 0 failed\n==============================================================================\nOutput:  C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\output.xml\nXUnit:   C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\DFCI_InitialState.xml\nLog:     C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\log.html\nReport:  C:\\TestLogs\\robot\\DFCI_InitialState\\logs_20191113_121224\\report.html\n</code></pre>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#standard-testing","title":"Standard Testing","text":"<p>Starting with a DUT that is not enrolled in DFCI, run the tests in the following order:</p> <ol> <li>DFCI_InitialState</li> <li>DFCI_InTuneEnroll</li> <li>DFCI_InTuneRollCerts</li> <li>DFCI_InTunePermissions</li> <li>DFCI_InTuneSettings</li> <li>DFCI_InTuneBadUpdate</li> <li>DFCI_InTuneUnenroll</li> </ol> <p>Steps 3 through 6 can and should be repeated in any order.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#extended-testing","title":"Extended Testing","text":"<p>This tests also start with a DUT that is not enrolled in DFCI, and will leave the system not enrolled if it completes successfully.</p> <ul> <li>DFCI_CertChainingTest</li> </ul>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#recovering-from-errors","title":"Recovering from errors","text":"<p>Code issues can present issues with DFCI that may require deleting the Identity and Permission databases. Using privileged access of a DUT that unlocks the varstore, you can delete the two master variables of DFCI. These variables are:</p> <ol> <li>_SPP</li> <li>_IPCVN</li> </ol>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#usb-refresh-test","title":"USB Refresh Test","text":"<p>The test cases DFCI_InTuneEnroll and DFCI_InTuneUnenroll have a GenUsb.bat file. The GenUsb.bat file will generate a .dfi file that UEFI management menu can read.</p> <pre><code>GenUsb MFG_NAME PRODUCT_NAME SERIAL_NUMBER\n</code></pre> <p>If there is a space or other special characters, add double quotes as in:</p> <pre><code>GenUsb Fabrikam \"Fabrikam Spelunker Kit\" \"SN-47599011345\"\n</code></pre> <p>After producing your .dfi file, place it on a USB drive and take it to the system under test. Press the Install from USB button to apply the packets.</p>"},{"location":"dyn/mu_feature_dfci/DfciPkg/UnitTests/DfciTests/readme/#variable-lock-test","title":"Variable Lock Test","text":"<p>DfciPkg/UnitTest/DfciVarLockAudit contains a UEFI shell command to audit the state of the DFCI variables. This test should be run at multiple points during the development cycle, with the DfciVarLockAudit test run after enrollment and again after the system has been unenrolled. This verifies that the variables that secure the state of DFCI are not compromised. The automation to run DfciVarLock test automatically is not available at this time.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_feature_ipmi/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_feature_ipmi/RepoDetails/","title":"Project MU IPMI Feature","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_feature_ipmi.git Branch:         main Commit:         fc60b0d57f5f387027d24fa93860622e5180ebcf Commit Date:    2023-01-31 05:02:14 -0500</p> <p>The repo contains the MU implementation for the IPMI feature package based on TianoCore code. This code should be consumed as needed for IPMI feature support.</p>"},{"location":"dyn/mu_feature_ipmi/SECURITY/","title":"SECURITY","text":""},{"location":"dyn/mu_feature_ipmi/SECURITY/#security","title":"Security","text":"<p>Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft, Azure, DotNet, AspNet, Xamarin, and our GitHub organizations.</p> <p>If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability, please report it to us as described below.</p>"},{"location":"dyn/mu_feature_ipmi/SECURITY/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report.</p> <p>If you prefer to submit without logging in, send email to secure@microsoft.com.  If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page.</p> <p>You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc. </p> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p> <p>If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.</p>"},{"location":"dyn/mu_feature_ipmi/SECURITY/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"},{"location":"dyn/mu_feature_ipmi/SECURITY/#policy","title":"Policy","text":"<p>Microsoft follows the principle of Coordinated Vulnerability Disclosure.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/","title":"IpmiFeaturePkg","text":"<p>This package contains core code and features for leveraging IPMI in UEFI. For details on the design of the IPMI package see the IPMI feature documentation.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#configuring-the-ipmi-package","title":"Configuring the IPMI package","text":"<p>The IPMI feature package is designed to be customizable to fit the needs of the platform. This can be done through a combination of platform libraries and PCD settings.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#important-pcds","title":"Important PCDs","text":"<p>For the full list of PCDs, see the package DEC file.</p> <ul> <li>Generic IPMI</li> <li>PcdIpmiCheckSelfTestResults - Indicates the self-test command should be queried for IPMI initialization.</li> <li>PcdIpmiCommandTimeoutSeconds - Timeout for IPMI command response.</li> <li>PcdBmcTimeoutSeconds - Timeout for initial BMC initialization.</li> <li>IPMI Watchdog</li> <li>PcdFrb2EnabledFlag - Enables use of the FRB2 watchdog for UEFI boot.</li> <li>PcdFrb2TimeoutSeconds - FRB2 timeout in seconds.</li> <li>PcdFrb2TimeoutAction - Action taken on FRB2 timeout.</li> <li>PcdOsWatchdogEnabled - Enables the OS watchdog at exit boot services.</li> <li>PcdOsWatchdogTimeoutSeconds - The timeout for the OS watchdog in seconds.</li> <li>PcdOsWatchdogAction - Action taken on OS watchdog timeout.</li> <li>SEL Library</li> <li>PcdIpmiSelOemManufacturerId - The manufacturer ID used in OEM SEL events.</li> </ul>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#platform-libraries","title":"Platform Libraries","text":"<p>The primary location for platform customization of the generic IPMI code is in the IPMI Platform library. If the system requires special initialization logic, self-test handling, IO port configuration, etc, then it should be done by implementing this library.</p> <p>Additionally the platform may choice to implement their own IPMI transport library for a non-standard communication method wth the BMC.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Readme/#samples","title":"Samples","text":"<p>The samples directory in this package is intended to provide examples of common usage of the IPMI package components that are not suitable for generic implementation. Platforms may choose to use these as a starting point or reference for implementing similar functionality, but these implementations cannot be used as-is.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/","title":"IPMI Boot Options","text":"<p>The IPMI boot option commands allows the system to query the BMC for the desired boot device and configuration. This is described in sections 28.11 and 28.12 of the the IPMI Specification 2nd Generation v2.0. Much of functionality of these parameters are no longer relevant or are not used in practice.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/#ipmi-boot-option-library","title":"IPMI Boot Option Library","text":"<p>The IPMI feature package provides the IPMI Boot Option Library for easily querying the IPMI boot option information. Currently this is abstracted as only retrieving the desired boot device. The library will do the following to determine this device.</p> <ol> <li>Query the boot option parameter 5, checking that the parameter and boot flags are valid.</li> <li>Clear the boot flags if the persistance bit is not set.</li> <li>Send and acknowledgement to the BMC that the boot option has been handled by BIOS.</li> <li>Return the queried boot device.</li> </ol> <p>The caller is then responsible for ensuring the platform is configured to boot to the proper device for the returned value. Because the IPMI option is abstract, for example saying BootDefaultHardDrive, the caller should determine which specific device path this should correspond to. Because this library potentially clears the boot flags, this library should only be called once per boot.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Boot_Options/#implementing-oem-boot-options","title":"Implementing OEM Boot Options","text":"<p>The IPMI feature package only implements standard IPMI boot option parameters with some minor industry updates since the IPMI specification does not reflect more modern devices. Any additional OEM defined parameters can be implemented on top of the base or command libraries and can be used instead of or in conjunction with the standard boot option library.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/","title":"Ipmi Feature","text":"<p>This package implements core-functionality for IPMI as well as several services built on IPMI. See IPMI Specification 2nd Generation v2.0 for more information. This document details the design on the IPMI feature. For using and configuring this feature package, see the package readme. For specific functionality within this package see the other documents.</p> <ul> <li>IPMI Watchdog</li> <li>IPMI Boot Options</li> <li>IPMI System Event Log</li> </ul>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#purpose","title":"Purpose","text":"<p>The IPMI feature provides firmware functionality that implements behavior described in the IPMI specification. IPMI enables out-of-band and monitoring capabilities independent of the host system's CPU, firmware, and operating system by communicating with the Baseboard Management Controller (BMC).</p> <p>The IPMI feature is intended to be directly used by platforms without the need to customize the core code. Instead platforms should leverage the exposed PCDs and library options to either customize the core functionality or implement their own in the library plugins.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#structure","title":"Structure","text":"<p>The IPMI stack consists of several layers of functionality each with a set API for consumers to leverage.</p> <p>Transport Library - This consists of the KCS and SSIF IPMI transport libraries. These are responsible for implementing the necessary physical transport logic for the platform. This layer does not need to understand the structure of IPMI messages. The transport library definitions are in the transport library header file.</p> <p>Generic IPMI - Implements the generic IPMI in a protocol, PPI, or MM driver. This layer is responsible for taking a high level IPMI request and building the IPMI request and parsing the response. Generic IPMI will rely on the transport library to handle the hardware specifics. External consumers of the IPMI package should consider using the base library. The generic transport interface is defined in the IPMI interface header file but should be considered internal.</p> <p>IPMI Base Library - Supplies a library abstraction for the basic functionality provided by the Generic IPMI component. This is the API surface that should be used for platform components implementing non-standard IPMI messages. The library definitions are in the base library header file.</p> <p>IPMI Command Library - Implements wrappers for specific IPMI functions. This calls into the IPMI base library. This is provided as a convenient wrapper for standard IPMI messages. Supported commands are defined in the command library header file</p> <p>Functional IPMI Drivers - Implements functionality around IPMI. Consists of the drivers such as IpmiWatchdog which rely on the IPMI command library.</p> <p></p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#extending-the-ipmi-command-set","title":"Extending the IPMI Command Set","text":"<p>Platforms may implement custom or specialized IPMI commands and functionality that are not implemented in this repo. In this case, the platform should leverage the IPMI base library to abstract the interface into a single command which they can provide an opaque command and response buffer. Platforms may call directly into the protocols/PPIs if needed, but for consistency it is advised to use the base library.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Feature/#testing-the-ipmi-feature","title":"Testing the IPMI feature","text":"<p>Because IPMI relies on communication with a BMC, real testing often requires a physical device or complicated virtual environment. To facilitate unit tests and more accessible function tests, this package makes use of a mock IPMI library to test in user mode components or a environment without real IPMI support. This library can either be compiled into a host-based unit test for build time tests or can be used as the transport library for the generic ipmi modules to fake IPMI support in UEFI. When support is added for new IPMI features, support should also be added in the mock library to facilitate unit tests for the new feature.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_System_Event_Log/","title":"IPMI System Event Log (SEL)","text":"<p>The IPMI System Even Log (SEL) is a persistent logging interface detailed in section 31 of the IPMI specification. This package provides the IPMI SEL Library to allow for easy use of the SEL interface. It is advised that this library be used for creating or reading SEL events.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Docs/Ipmi_Watchdog/","title":"IPMI Watchdog Timers","text":"<p>The IPMI watchdog timers that are typically used are the FRB2 and OS timers. The FRB2 timer is used for UEFI boot and is typically configured during PEI and torn down at ready to boot in the BDS phase. The OS watchdog timer will be configured at exit boot services and will be handed off to the OS to maintain.</p> <p>The IPMI feature package provides two methods for configuring and controlling the watchdog timers. The watchdog lib and the Watchdog modules. The library provides the ability to generically configure, stop, and start a given watchdog timer while the module will do this automatically based on fixed or dynamic PCDs. Platforms that need strong control over the watchdog configuration, either for a particular timer or all may use the library directly. The library and module may be used in tandem, but it may not be desirable to use both the library and module in the same phase to avoid unexpected behavior or timing issues.</p> <p>The PEI implementation of the watchdog timer will configure the FRB2 timer, if enabled, at its entry during PEI. The DXE implementation will check the timer state on entry and set up a callback for ReadyToBoot to disable the FRB2 timer and ExitBootServices to enable the OS watchdog timer. Because the OS watchdog timer is based on dynamic PCDs, this configuration can be dynamically updated at boot time by any platform component so long as it's done before ExitBootServices.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/IpmiTransportLibSsif/Readme/","title":"SSIF Transport Library","text":"<p>This library implements the SMBus System Interface (SSIF) logic for communicating IPMI messages.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/IpmiTransportLibSsif/Readme/#prerequisites","title":"Prerequisites","text":"<p>For this transport library to operate, it assumes the platform will provide and implementation of the Simple SMBus library. This library is responsible for implementing the device specifics for the BMC and for accessing the I2C device.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Library/MockIpmi/Readme/","title":"Mock IPMI Library","text":"<p>The mock IPMI library is intended to be used to leverage the IPMI stack but without a real BMC providing the IPMI services. Currently, this means that the mock library will attempt to return a valid but often useless reply for most messages. This is useful for platform bring-up and testing new features in the IPMI feature package that may not have hardware support yet. The base library implementation of Mock IPMI is intended for use in host based unit tests of higher level functionality by allowing IPMI functionality without requiring the generic IPMI UEFI modules.</p> <p>To add new functionality to the mock IPMI library, handlers should be created and added to the MockHandlers array at the top of MockIpmi.c. The mock handlers will be provided in command data and the response data buffers. Failures should be reflected in the returned CompletionCode and the response size should always be set to the size of the returned structure.</p>"},{"location":"dyn/mu_feature_ipmi/IpmiFeaturePkg/Samples/Readme/","title":"IPMI Package Samples","text":"<p>This directory contains various sample implementations of modules and libraries that demonstrate common usage of the IPMI components, but may not be suitable for direct usage. Often this is because the ultimate functionality of the code is very platform specific and is not suitable for a generalize implementation. Instead, platforms consumers may wish to copy or use this code as reference for their own implementations.</p> <p>IPMI Status Reporter - This module is a sample for using the generic Status Code reporting mechanism in UEFI for logging events to the SEL.</p>"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_feature_ipmi/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_feature_mm_supv/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/","title":"Microsoft MM Supervisor","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_feature_mm_supv.git Branch:         main Commit:         0b792d32806285bb096f38f05b390beaae962c50 Commit Date:    2023-01-31 06:26:26 -0500</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#repository-philosophy","title":"Repository Philosophy","text":"<p>Like other Project MU feature repositories, the Project MU MM Supervisor feature repo does not strictly follow the EDKII releases, but instead has a continuous main branch which will periodically receive cherry-picks of needed changes from EDKII. For stable builds, release tags will be used instead to determine commit hashes at stable points in development. Release branches may be created as needed to facilitate a specific release with needed features, but this should be avoided.</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#consuming-the-mm-supervisor-feature-package","title":"Consuming the MM Supervisor Feature Package","text":"<p>Since this project does not follow the release fork model, the code should be consumed from a release hash and should be consumed as a extdep in the platform repo. To include, create a file named feature_mm_supv_ext_dep.yaml desired release tag hash. This could be in the root of the project or in a subdirectory as desired.</p> <pre><code>{\n\"scope\": \"global\",\n\"type\": \"git\",\n\"name\": \"FEATURE_MM_SUPV\",\n\"var_name\": \"FEATURE_MM_SUPV_PATH\",\n\"source\": \"https://github.com/microsoft/mu_feature_mm_supv.git\",\n\"version\": \"&lt;RELEASE HASH&gt;\",\n\"flags\": [\"set_build_var\"]\n}\n</code></pre> <p>Setting the the var_name and the set_build_var flags will allow the build scripts to reference the extdep location. To make sure that the package is discoverable for the build, the following line should also be added to the build MM supervisor GetPackagesPath list.</p> <pre><code>    shell_environment.GetBuildVars().GetValue(\"FEATURE_MM_SUPV_PATH\", \"\")\n</code></pre> <p>Note: If using pytool extensions older then version 0.17.0 you will need to append the root path to the build variable string.</p> <p>After this the package should be discoverable to can be used in the build like any other dependency.</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#code-of-conduct","title":"Code of Conduct","text":"<p>This project has adopted the Microsoft Open Source Code of Conduct https://opensource.microsoft.com/codeofconduct/</p> <p>For more information see the Code of Conduct FAQ https://opensource.microsoft.com/codeofconduct/faq/ or contact <code>opencode@microsoft.com &lt;mailto:opencode@microsoft.com&gt;</code>_. with any additional questions or comments.</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#contributions","title":"Contributions","text":"<p>Contributions are always welcome and encouraged! Please open any issues in the Project Mu GitHub tracker and read https://microsoft.github.io/mu/How/contributing/</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_feature_mm_supv/RepoDetails/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/","title":"Microsoft MM Supervisor Introduction","text":""},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#overview","title":"Overview","text":"<p>The Microsoft MM Supervisor brings new levels of security and usability to PC management mode. It is a new feature of UEFI that enables platform adaptive isolation protection under MM environment. The MM Supervisor intends to leverage standalone MM framework and CPU privilege level management to implement Kernel and User mode software environment for MM handler drivers. The objective is to enable platform MM isolation with binary release model for MM Supervisor and its loader.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#why-isolating-system-management-mode","title":"Why Isolating System Management Mode","text":"<p>Traditional UEFI system management mode work flow is described in Traditional SMM Framework Flow. This solution has various drawbacks listed below:</p> <ul> <li>Late loading in the boot phase, so that other malicious DXE code may cause damage before SMM framework was set up</li> <li>Excessive interaction with boot code, which involves entangled database with DXE core, exposing extra attack interfaces</li> <li>SMI handlers run under Kernel mode, thus highly privileged code execution requires SMI handler author proceed with extra precaution</li> </ul> <p>More detailed introduction to existed SMM framework setup flow is included in (MmSupervisorDesign/mm_supervisor_design.md)</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#existed-intermediate-solutions","title":"Existed Intermediate Solutions","text":"<p>Different silicon partners have their own solutions:</p> <ul> <li>Intel: ??? (Need some description here)</li> <li>AMD: SMM supervisor that will stick to traditional boot flow but change SMI entry point code to demote execution to CPL3 starting from gEfiDxeSmmReadyToLockProtocolGuid event and screen MSR, IO and memory access by attested platform policy.</li> <li>QC: ??? (Need some description here)</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-supervisor-mechanism","title":"MM Supervisor Mechanism","text":"<ul> <li>MM foundation initialized early in the boot process and has isolated protocol and configuration table database</li> <li>MM supervisor mechanism holds separate service database</li> <li>MM drivers and handlers execute under user mode (CPL3)</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#oem-enablement-summary","title":"OEM Enablement Summary","text":"<p>MM Isolation enablement is comprised of:</p> <ol> <li>MM Supervisor UEFI BIOS integration</li> <li>MM drivers implementation/conversion</li> <li>Platform specific isolation policy configuration</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-supervisor-uefi-bios-integration","title":"MM Supervisor UEFI BIOS Integration","text":"<p>The objective is to binary release MM Supervisor as core component. Thus ideally there should be platform dsc and fdf file change to include these entries into the UEFI code base for core capabilities.</p> <p>There are 4 essential drivers to be added to the device UEFI code base:</p> <ul> <li><code>StandaloneMmUnblockMem.efi</code></li> <li><code>PiSmmIpl.efi</code></li> <li><code>MmSupervisorCore.efi</code></li> <li><code>MmSupervisorRing3Broker.efi</code></li> </ul> <p>One requirement is that both of the drivers above and other MM drivers should reside in the same firmware volume. For current design, the MM Supervisor will not look for extra FVs once it has exited its entry point.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#mm-drivers-implementationconversion","title":"MM Drivers Implementation/Conversion","text":"<p>This section targets the SMM handler drivers of which module types are DXE_SMM_DRIVER. All gSmst table entries will have a one-to-one mapped field in gMmst. But there are still some limitations for currently existed SMM handler drivers.</p> <p>Once MM Supervisor is loaded, the data it can consume soly come from hob list, meaning SMM handlers drivers(type DXE_SMM_DRIVER) will not be able to consume the protocols, dependencies or event notification from DXE drivers unless relayed by a combination of one DXE driver communicate to one MM handler.</p> <p>Due to the above reason, there some functionalities that will not be provided in MM environment:</p> <ol> <li>Dynamic PCD consumption</li> <li>gBS services, i.e. memory allocation and free, get DXE memory map</li> <li>gDS services, i.e. install or check configuration tables</li> <li>For MM drivers that needs to access non-MMRAM region, an explicit MmUnblockMemoryRequest call needs to be invoke prior to its usage. Knowing the limitations listed below:<ul> <li>When installation of MM foundation occurs in DXE phase, the MmUnblockMemoryRequest will not be available from the beginning in DXE till gEfiMmBaseProtocolGuid is installed. It is suggested to advance the unblock request as early as PEI if necessary.</li> <li>When MM foundation is installed in PEI, TBD...</li> </ul> </li> <li><code>MmSupervisorRing3Broker</code> driver has to be the first user mode driver loaded, assuming all user mode driver relies on gMmst. Thus the libraries linked to this driver can neither have any dependency on MmServicesTableLib nor attempt to access the EFI_MM_SYSTEM_TABLE passed in from library constructors.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#platform-specific-isolation-policy-configuration","title":"Platform Specific Isolation Policy Configuration","text":"<p>This section describes how a platform can choose to add or remove protected MSRs, IO, memory region and instruction execution (if supported) based on platform needs.</p> <p>There is a minimum requirement for SMM isolation policy published by Microsoft where each platform has to block certain MSR, IO and memory region accesses to meet the criteria for Level 3 Secured Core PC environment. So a platform has to fullfil these requirements. (TODO: Link TBD)</p> <p>If platform has other resources would like to protect, i.e. proprietary MSR for special purpose, MMIO region for secure device, etc, platform can elect to add these entries to the corresponding section of policy file. Specific policy definition can be found here.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#uefi-implementation-details","title":"UEFI Implementation Details","text":"<ol> <li>Design: Proposed MM Supervisor boot flow and isolation mechanism</li> <li>Tradition: Introduction to traditional SMM implementation</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisor_Feature/#oem-integration-guide","title":"OEM Integration Guide","text":"<ol> <li>Integration: MM Supervisor Integration Guides</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/","title":"Proposed Flow of MM Supervisor","text":"<p>The proposed flow currently supports 2 platforms for development:</p> <ul> <li>OVMF Virtual Platform: Intel Q35 based virtual platform from Tianocore. It can be run on QEMU simulator</li> <li>AMD Renoir Reference Platform: AMD Renoir based CRB platform, requiring NDA with AMD</li> </ul> <p>Note: Please see Resources section for more links and tutorials</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#objective","title":"Objective","text":"<ul> <li>MM foundation initialized early in the boot process and has isolated protocol and configuration table database</li> <li>MM supervisor mechanism holds separate service database</li> <li>MM drivers and handlers execute under user mode (CPL3)</li> <li>Binary release model</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#standalone-mm-hob-peim-creates-necessary-hobs-serving-as-placeholder","title":"Standalone MM Hob (PEIM) Creates Necessary Hobs Serving as Placeholder","text":"<ol> <li>EfiSystemTable</li> <li>MM Core private data</li> <li>ACPI communication buffer address</li> <li>TCG NVS address from Tpm ACPI table</li> <li>Memory Map for DXE environment</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#in-dxe-at-mm-ipl-entry-point","title":"In DXE, at MM IPL entry point","text":"<ol> <li>Populates Hobs 1 and 2 Prior to Loading MM Supervisor<ul> <li>Memory Map as of now is still populated only in ready to lock</li> <li>Hobs 3 and 4 are populated in their separate drivers during their loading</li> <li>TODO: the ideal process would be all these hob population can be moved to null library and IPL can stay out of it</li> </ul> </li> <li>Finds the largest available MMRAM region and copy MM Supervisor to this region and load it</li> <li>After MM Supervisor loading, close SMRAM to prevent SMRAM access</li> <li>Before publishing Supervisor communication, IPL should test communication to Supervisor to query Supervisor version and verify the returned version and patch level is non-zero AND meets other system requirements. Known limitations for GCC toolchain:<ul> <li>Patch level information, which should be embedded into image version of built Pe/Coff header cannot be integrated when using GCC toolchain. User builds with GCC tools are welcome to reach out to MsCoreUefi@microsoft.com for technical discussion in that regards.</li> <li>Driver version embedded into subsystem version of Pe/Coff header is being parsed by objcopy when using GCC toolchain. This tool would parse input numeric strings with implicit base (i.e. strings beginning with 0s will be parsed as octal numbers). However, MSFT linker specifically only parse it as decimal numbers.</li> </ul> </li> <li>Publish protocol to be used by DXE drivers for brokage pipeline</li> <li>Send brokage command to MM Supervisor to load the rest of MM drivers (this is done so that all drivers can be transitioned to CPL3 under MM environment instead of DXE environment)</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#core-responsibility-by-mm-supervisor","title":"Core Responsibility By MM Supervisor","text":"<ol> <li>Provide memory service</li> <li>Provide protocol publication and notification</li> <li>Provide MMI handler register and unregister</li> <li>Provide gMmst table for usage</li> <li>Relocate MMI entry for x64 architecture</li> <li>Setup GDT, IDT, exception handlers for MMI environment</li> <li>Setup stack for each CPU in MMI environment</li> <li>Setup DXE to MM Supervisor brokage pipeline<ul> <li>This will be a MM Supervisor registered handler that run under CPL0 for DXE to demand special commands from MM Supervisor (i.e. dispatch MM drivers, query version or configuration information, fetch isolation policy)</li> <li>This will be provided as DXE_DRIVER type library API for consumption</li> </ul> </li> <li>Mark supervisor pages corresponds to data consumed by MM Supervisor as well as Supervisor code and lock MM control registers if applicable</li> <li>Return to DXE</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#mm-foundation-isolation","title":"MM foundation isolation","text":"<ol> <li>Page table:<ul> <li>Once MM foundation sets up MMI environment, the foundation data and code needs to be marked as supervisor pages.</li> <li>More data allocated internally will also be marked as supervisor pages.</li> <li>Memory services from subsequent drivers will be marked as user pages.</li> <li>At ready to lock event, ring 0 GDT and IDT and page table itself will be patched to read only</li> </ul> </li> <li>Privilege level:<ul> <li>MM foundation will execute at CPL0 to access all data and code if allowed by page table</li> <li>Before loading MM drivers, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP</li> <li>After MM driver returns, call far will return to the original return address from call gate set up</li> <li>For MMI. Before dispatching each MMI handlers, if prior to ready to lock, core will update stack pointer in TSS and return address from call gate. Return far with target SS:RSP and CS:RIP. Note: this will need to be in APHandler for APs and around MMI handler dispatching for BSP</li> <li>After MMI returns, call far will return to the original return address from call gate set up</li> </ul> </li> </ol> <ol> <li>Syscall (see the flow chart) to enforce all services needs to execute under CPL0 from CPL3 must go through syscall interface:<ul> <li>Core services provided through gMmst provided under CPL3 will be a syscall shim, it implements most gMmst service by invoking syscall and have core service replay the request.</li> <li>Certain privileged instructions such as IO read/write, MSR read/write, and INT, WBI, HLT will be evaluated through policy gate before proceeding. An example defined by AMD for v1 SMM isolation can be found in <code>SmmSupervisorPkg</code> here</li> <li>Telemetry records: when prohibited syscall occurs, core service will jump to preset variable service in Ring 3, write NV variable and long jump back to the point where Ring 3 is enforced.</li> </ul> </li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#individual-mmi-input-flow","title":"Individual MMI Input Flow","text":"<ol> <li>At the MMI entry point, each core will setup their MSR of STARs to point to core syscall center in MM core. And restore MSR back before rsm from MMI.</li> <li>Each core will still go through SmiRendezvous flow. BSP will go all the way to MMI handler dispatcher and transition to Ring 3, then run the handler code in Ring 3. And then come back to Ring 0 upon returning.</li> <li>AP will wait at idle state, till notified that there are schedules in the queue. Before loading the function pointers, AP will transition to Ring 3 and then execute procedures in Ring 3. And then come back to Ring 0 upon returning.</li> <li>Prior to dispatching individual MMI handlers, MM supervisor will copy incoming communicate buffers into MMRAM region, marked with proper memory attributes (user vs. kernel). The copied buffers will be dispatched to MMI handlers.</li> <li>Note that when ring level changes, the stack switch will occur as well. Thus when setting up stack, the Ring 3 stack needs to be allocated separately.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#mm-core-driver-interface","title":"MM Core &lt;-&gt; Driver Interface","text":"<ol> <li>Between MM drivers and MM Supervisor, a shim driver will be loaded first to publish a shim gMmst, which will implement some of the real gMmst function through syscall request.<ul> <li>This driver will also manage protocol data base in Ring 3, meaning the entire protocol publication, notification, location will be under Ring 3 and application level. And there will be no protocol published from MM core.</li> <li>The driver will also need to refresh the content of table when there is potential to change the values in the table (number of configuration table entries, etc)</li> </ul> </li> <li>Also between MM drivers and MM Supervisor, syscall version of BaseLib, CpuLib and IoLib for MM EFI drivers. This will provide a direct interface to request privileged information from MM core.</li> <li>Between DXE drivers and MM Supervisor, a brokage pipeline (special MM handler) will be set up for information querying and driver dispatching</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#launch-mm-in-pei","title":"Launch MM in PEI","text":"<ol> <li>At the entrypoint of MM PEI IPL, the PEIM will go over system prerequisites to make sure MM foundation is ready to settle. These requirements include designated MM communication buffers for both user and supervisor, MM control PPI to trigger MMI, MM access PPI to coalesce all available MMRAM regions and lock/close them once MM foundation is set.</li> <li>MM PEI IPL will iterate through all available MMRAMs and load the located MM core (supervisor in this case) into MMRAM.</li> <li>If the system operates PEI in 32-bit mode where as MM foundation needs to run in X64, MM PEI IPL will load a MM IPL X64 relay module, which runs similar to the CapsuleX64.inf from MdeModulePkg. MM PEI IPL will cache system context then switch the operation mode to X64 to execute X64 relay module.<ul> <li>Although X64 relay module is a PEIM module in UEFI environment, but it does not have PEI services like other PEIMs</li> <li>MM core is loaded and relocated in normal PEI environment. X64 relay routine will only execute the core entrypoint with supplied hob start pointer.</li> </ul> </li> <li>After MM core foundation is setup, the system will, fist return to 32-bit mode with cached context information if applicable, close and lock all available MMRAM regions.</li> <li>MM PEI IPL initiate test communication to Supervisor by querying Supervisor version before proceeding.</li> <li>MM PEI IPL then install MM communicate and MM supervisor communicate PPIs for usage in the rest of PEI phase.</li> <li>Once DXE environment is launched, a MM DXE IPL that depends on MM control protocol will test communication to MM supervisor by querying supervisor version.<ul> <li>Entities that publish MM control protocol might need to avoid double-initialization</li> </ul> </li> <li>Once test communication is successful, MM DXE IPL will publish MM communicate and MM supervisor communicate protocols for further usage in UEFI DXE or runtime.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/MmSupervisorDesign/mm_supervisor_design/#resources","title":"Resources","text":"<ul> <li>Project MU Repositories: https://github.com/topics/projectmu</li> <li>Standalone MM Specification: Vol. 4: Management Mode Core Interface, UEFI Platform Initialization (PI) Specification 1.7 A</li> <li>MU Q35 Platform: https://github.com/microsoft/mu_tiano_platforms</li> <li>QEMU Instructions: https://github.com/tianocore/edk2/blob/master/OvmfPkg/PlatformCI/ReadMe.md</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/","title":"MM Supervisor Platform Integration","text":"<p>The MM Supervisor source code is intended to be used as-is by platforms. In order to integrate the MM Supervisor into a platform firmware it is important to consider higher-level integration challenges specific to the platform in addition to the required code changes to integrate all of the pieces.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#high-level-considerations","title":"High-Level Considerations","text":"<ol> <li> <p>Standalone MM Changes - The supervisor will use Standalone MM as opposed to Traditional MM. SMM modules and libraries will need to be converted to be compatible with Standalone MM.</p> </li> <li> <p>Silicon Vendor Changes - The silicon vendor firmware may need changes for:</p> <ol> <li>Standalone MM compatibility</li> <li>Privilege constraints imposed by the supervisor</li> </ol> </li> <li> <p>Platform Data Requirements - The MM Supervisor requires a new set of industry standard defined data structures in addition to supervisor-specific data structures to be produced by the platform.</p> </li> <li> <p>Platform API Calls - Services that might need to be called by a platform.</p> </li> <li> <p>MM Supervisor Code Integration - How to best integrate the <code>MmSupervisorPkg</code> collateral into a platform firmware.</p> </li> <li> <p>Platform Security Goals - The MM Supervisor aims to improve security. It is important to understand the goals of the supervisor and how that aligns with the platform security goals.</p> </li> <li> <p>MM Driver Load Process - The platform might need to organize MM modules differently for the MM IPL than what was previously used for Traditional MM.</p> </li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#standalone-mm-changes","title":"Standalone MM Changes","text":"<p>Begin by reading the Standalone MM section of the Platform Initialization (PI) Specification to gain a basic understanding of Standalone MM.</p> <p>The following basic steps can be used to convert a Traditional MM library/module to Standalone MM:</p> <ul> <li>Change the driver entry point prototype from the Traditional MM API to the Standalone MM API.</li> <li>The system table should be of type <code>EFI_MM_SYSTEM_TABLE</code></li> <li> <p>The driver will now use <code>StandaloneMmDriverEntryPoint</code></p> </li> <li> <p>In target INF files, use <code>MM_STANDALONE</code> as <code>MODULE_TYPE</code></p> </li> <li>In target INF files, set <code>PI_SPECIFICATION</code> version to <code>0x00010032</code></li> <li>Update any <code>DXE_SMM_DRIVER</code> libraries that will now be ported for the Standalone MM environment, add support for the   <code>MM_STANDALONE</code> and <code>MM_CORE_STANDALONE</code> driver types</li> <li>For packages that contains libraries/modules shared with consumers that will be a mix of Traditional MM and   Standalone MM, consider the file path. In many cases, code sharing can be maximized for both cases by providing a   Traditional MM INF and a Standalone MM INF in the same directory. Where common code is placed in a .c file included   in both INF files and each INF has a corresponding .c file unique to its module type (e.g. different entry point   type). This also has the benefit that the INF file path remains constant so it does not break present consumers while   the new Standalone MM INF can be called <code>XxxStandaloneMm.inf</code>.</li> <li>Use <code>MemoryAllocationLib</code> functions to allocate and free memory as opposed to <code>gSmst</code> or <code>gMmst</code> directly. This can   improve portability between the two services tables</li> <li>Find an alternative solution for <code>gBS</code>, <code>gDS</code>, and other DXE environment accesses</li> <li>Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the   Standalone MM environment</li> <li>Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are   still met.</li> <li>Determine the TSEG size needed. After changing the fundamental SMM core, additional TSEG size may be required.</li> <li>MM handlers should start to use <code>MmCommBufferValid</code> interface to validate incoming communicate buffers, instead of   traditionally used <code>MmIsBufferOutsideMmValid</code>.</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#silicon-vendor-changes","title":"Silicon Vendor Changes","text":"<p>First, determine whether the silicon vendor code already supports Standalone MM. If it does not, the platform owner will either need to port the silicon vendor code directly (if practical) or work with the silicon vendor to enable Standalone MM support.</p> <p>In addition to the conversion guidelines in Standalone MM Changes, the silicon code should also consider the hardware access limitations that will be enforced by the MM Supervisor policy. Conversely, the MM Supervisor policy for the platform should consider the unique enforcements that should be applied for a given silicon architecture/design.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-data-requirements","title":"Platform Data Requirements","text":"<p>The platform needs to produce the data structures in this section. The structures are consumed by MM Supervisor code to acquire platform-specific details.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#hobs-required-by-mm-ipl","title":"HOBs Required by MM IPL","text":"<ol> <li><code>gMpInformationHobGuid</code> - Basic MP information.</li> <li>StandaloneMmPkg/Include/Guid/MpInformation.h</li> <li>Note that <code>PeiStandaloneMmHobProductionLib</code>    can be used to help produce this HOB.</li> <li><code>gEfiMmPeiMmramMemoryReserveGuid</code>/<code>gEfiSmmSmramMemoryGuid</code> - Describes MMRAM regions present.</li> <li>MdePkg/Include/Guid/SmramMemoryReserve.h</li> <li>Resource descriptor HOBs with MMIO regions identified - Required to allow MM access to MMIO.</li> <li>By default, the MM Supervisor will apply page table attributes based on the memory described by    <code>EFI_HOB_TYPE_RESOURCE_DESCRIPTOR</code> HOBs. In order for MMIO to be accessible from MM, the MMIO range must be    described in a resource descriptor HOB where the <code>EFI_RESOURCE_TYPE</code> field of the HOB is set to    <code>EFI_RESOURCE_MEMORY_MAPPED_IO</code> or <code>EFI_RESOURCE_FIRMWARE_DEVICE</code>.</li> <li>[Optional] <code>gMmProtectedRegionHobGuid</code> - Any protected MMIO regions such as IOMMU can be described in HOBs with    this GUID to prevent access from MM.</li> </ol> <p>Note that the PEI module <code>MmSupervisorPkg/Drivers/StandaloneMmHob</code> will produce <code>gMmCoreDataHobGuid</code> which is used to   hold <code>MM_CORE_PRIVATE_DATA</code>   and <code>gMmCoreMmProfileGuid</code> which is used to hold <code>MM_CORE_MM_PROFILE_DATA</code> as defined in <code>MmSupervisorPkg</code>.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#ppis-required-for-pei-mm-ipl","title":"PPIs Required for PEI MM IPL","text":"<ol> <li>MM Access PPI (<code>gEfiPeiMmAccessPpiGuid</code>)</li> <li>MM Control PPI (<code>gEfiPeiMmControlPpiGuid</code>)</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy","title":"MM Policy","text":"<p>The MM Supervisor policy is a data structure used to communicate the restrictions applied to certain hardware resources such as I/O ports, MSRs, CPU instructions, and CPU Save State. The policy should be reviewed for each platform in order as the hardware resources that might need to be restricted will vary across silicon families and platform-specific security goals.</p> <p>In order to verify the policy was discovered and read properly, the policy can be verified in debug output. Below is an example of debug policy output:</p> <pre><code>[InitializePolicy] Discovered policy file in FV at 0x7D4BB6D0.\nSMM_SUPV_SECURE_POLICY_DATA_V1_0:\nVersion Major:1\nVersion Minor:0\nSize:0x1E8\nMemoryPolicyOffset:0x0\nMemoryPolicyCount:0x0\nFlags:0\nCapabilities:0\nPolicyRootOffset:0x28\nPolicyRootCount:0x5\nPolicy Root:\n  Version: 1\n  PolicyRootSize: 18\n  Type: 2\n  Offset: A0\n  Count: 2\n  AccessAttr: DENY\nIO: [CF8-CFB] . W\nIO: [CFC-CFF] . W\nPolicy Root:\n  Version: 1\n  PolicyRootSize: 18\n  Type: 3\n  Offset: B0\n  Count: 20\n  AccessAttr: DENY\nMSR: [C0000080-C0000080] R W\nMSR: [C0000081-C0000084] R W\nMSR: [9E-9E] R W\nMSR: [1D9-1D9] R W\nMSR: [DA0-DA0] R W\nMSR: [6A0-6A0] R W\nMSR: [6A2-6A2] R W\nMSR: [6A4-6A8] R W\nMSR: [E4-E4] R W\nMSR: [600-600] R W\nMSR: [652-652] R W\nMSR: [653-653] R W\nMSR: [655-655] R W\nMSR: [656-656] R W\nMSR: [658-658] R W\nMSR: [700-700] R W\nMSR: [701-701] R W\nMSR: [706-706] R W\nMSR: [707-707] R W\nMSR: [710-710] R W\nMSR: [711-711] R W\nMSR: [716-716] R W\nMSR: [717-717] R W\nMSR: [720-720] R W\nMSR: [721-721] R W\nMSR: [726-726] R W\nMSR: [727-727] R W\nMSR: [730-730] R W\nMSR: [731-731] R W\nMSR: [736-736] R W\nMSR: [737-737] R W\nMSR: [570-570] R W\nPolicy Root:\n  Version: 1\n  PolicyRootSize: 18\n  Type: 4\n  Offset: 1B0\n  Count: 3\n  AccessAttr: ALLOW\nINSTRUCTION: [0] X\nINSTRUCTION: [1] X\nINSTRUCTION: [2] X\nPolicy Root:\n  Version: 1\n  PolicyRootSize: 18\n  Type: 5\n  Offset: 1C8\n  Count: 2\n  AccessAttr: ALLOW\nSAVESTATE: [0] 10 IoWrite\nSAVESTATE: [1] 1 Unconditional\nPolicy Root:\n  Version: 1\n  PolicyRootSize: 18\n  Type: 1\n  Offset: 1E8\n  Count: 0\n  AccessAttr: DENY\nSecurityPolicyCheck - Policy overlap check entry ...\nSecurityPolicyCheck - Policy overlap check exit ...\n</code></pre> <p>For more information about creating a policy and inserting the policy binary into firmware, see the MM Policy File instructions.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-api-calls","title":"Platform API Calls","text":"<p>These are APIs provided by <code>MmSupervisorPkg</code> that the platform might need to invoke if it needs to make use of the service provided.</p> <ol> <li><code>MmSupervisorUnblockMemoryLib</code> - By default, the MM Supervisor will block all memory resources outside of MMRAM. Regions that need to be accessed must be requested to be unblocked by the MM Supervisor.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-supervisor-code-integration","title":"MM Supervisor Code Integration","text":"<ol> <li>Ensure all submodules for the platform are based on the latest Project Mu version (e.g. \"202102\")</li> <li>Include this repo as a submodule for your platform repos and set the folder path as <code>Common/MU_MM_SUPV</code> (also add <code>Common/MU_MM_SUPV</code> to required repos and module packages in the platform build script): https://windowspartners.visualstudio.com/MsCoreUefi_Thanos/_git/msft_mmsupervisor</li> </ol> <p>Note: A list of the libraries and modules made available by this package is provided in the   Software Component Overview.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-dsc-statements","title":"Platform DSC statements","text":"<ol> <li>Add the DSC sections below.</li> </ol> <p>Note: There might be other silicon specific drivers/libraries a platform will need for these sections, i.e. SPI flash drivers, SW MMI dispatcher drivers, etc.</p> <pre><code>[PcdsFixedAtBuild]\ngEfiSecurityPkgTokenSpaceGuid.PcdUserPhysicalPresence               | FALSE\n  # MM environment only set up the exception handler for the upper 32 entries.\n# The platform should set this to a non-conflicting exception number, otherwise\n# it will be treated as one of the normal types of CPU faults.\ngEfiMdePkgTokenSpaceGuid.PcdStackCookieExceptionVector              | 0x0F\n\n[LibraryClasses.IA32]\nMmSupervisorUnblockMemoryLib|MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf\n\n[LibraryClasses.X64]\nMmSupervisorUnblockMemoryLib|MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf\n\n[LibraryClasses.X64.MM_CORE_STANDALONE]\nPcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf\n  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf\n  # Note: Make sure ACPI timer is properly programmed at load time\nTimerLib|PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf\n  ExtractGuidedSectionLib|MdePkg/Library/BaseExtractGuidedSectionLib/BaseExtractGuidedSectionLib.inf\n  FvLib|StandaloneMmPkg/Library/FvLib/FvLib.inf\n  HobLib|StandaloneMmPkg/Library/StandaloneMmCoreHobLib/StandaloneMmCoreHobLib.inf\n  MemoryAllocationLib|StandaloneMmPkg/Library/StandaloneMmCoreMemoryAllocationLib/StandaloneMmCoreMemoryAllocationLib.inf\n  MemLib|MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorCoreMemLib.inf\n  ReportStatusCodeLib|MdePkg/Library/BaseReportStatusCodeLibNull/BaseReportStatusCodeLibNull.inf\n  StandaloneMmCoreEntryPoint|StandaloneMmPkg/Library/StandaloneMmCoreEntryPoint/StandaloneMmCoreEntryPoint.inf\n  CpuExceptionHandlerLib|UefiCpuPkg/Library/CpuExceptionHandlerLib/SmmCpuExceptionHandlerLib.inf\n  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf\n  # Note: This API will be removed from core soon, leave the empty shell here\nSmmCpuPlatformHookLib|UefiCpuPkg/Library/SmmCpuPlatformHookLibNull/SmmCpuPlatformHookLibNull.inf\n  IhvMmSaveStateSupervisionLib|MmSupervisorPkg/Library/IhvMmSaveStateSupervisionLib/IhvMmSaveStateSupervisionLib.inf\n\n[LibraryClasses.X64.MM_STANDALONE]\nDebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf\n  TimerLib|PcAtChipsetPkg/Library/AcpiTimerLib/StandaloneAcpiTimerLib.inf\n  MmServicesTableLib|MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf\n  MemoryAllocationLib|StandaloneMmPkg/Library/StandaloneMmMemoryAllocationLib/StandaloneMmMemoryAllocationLib.inf\n  HobLib|MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf\n  ReportStatusCodeLib|MdeModulePkg/Library/SmmReportStatusCodeLib/StandaloneMmReportStatusCodeLib.inf\n  HwResetSystemLib|PcAtChipsetPkg/Library/ResetSystemLib/ResetSystemLib.inf\n  StandaloneMmDriverEntryPoint|MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf\n  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf\n  BaseCryptLib|CryptoPkg/Library/BaseCryptLib/SmmCryptLib.inf\n  OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf\n  IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf\n  AdvLoggerAccessLib|MdeModulePkg/Library/AdvLoggerAccessLibNull/AdvLoggerAccessLib.inf\n  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLibStandaloneMm.inf\n  LockBoxLib|MdeModulePkg/Library/SmmLockBoxLib/SmmLockBoxStandaloneMmLib.inf\n  MemLib|MmSupervisorPkg/Library/MmSupervisorMemLib/MmSupervisorMemLibSyscall.inf\n  Tcg2PhysicalPresenceLib|SecurityPkg/Library/SmmTcg2PhysicalPresenceLib/StandaloneMmTcg2PhysicalPresenceLib.inf\n  PlatformSecureLib|SecurityPkg/Library/PlatformSecureLibNull/PlatformSecureLibNull.inf\n\n  BaseLib|MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf\n  IoLib|MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf\n  SysCallLib|MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf\n\n[Components.IA32]\nMmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf\n  MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf\n!if $(PEI_MM_IPL_ENABLED) == TRUE\n  MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf\n!endif\n\n[Components.X64]\nMmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf\n!if $(PEI_MM_IPL_ENABLED) == TRUE\n  # Note: MmIplX64Relay is a 64-bit PEI module.\n#       - Any libraries linked to this module should not make 32-bit PEI assumptions\n#       - Any libraries linked to this module should not use PEI Services\nMmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf\n  MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf {\n&lt;LibraryClasses&gt;\n      NULL|StandaloneMmPkg/Library/VariableMmDependency/VariableMmDependency.inf\n  }\n!else\n  MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf\n!endif\n  MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf\n  MmSupervisorPkg/Core/MmSupervisorCore.inf {\n&lt;LibraryClasses&gt;\n      # Note that this should be whatever suits the target platform + MM standalone conversion for constructor input arguments\nSmmCpuFeaturesLib|$(PLATFORM_SI_PACKAGE)/Library/SmmCpuFeaturesLib/SmmCpuFeaturesLib.inf\n  }\nMmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf\n\n  MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf\n  UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf\n  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf {\n&lt;LibraryClasses&gt;\n      NULL|MdeModulePkg/Universal/Variable/UefiVariablePolicy/Library/VarCheckPolicyLib/VarCheckPolicyLibStandaloneMm.inf\n      NULL|MdeModulePkg/Library/VarCheckUefiLib/VarCheckUefiLib.inf\n  }\nMdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf\n  MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf\n  SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf\n  SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf {\n&lt;LibraryClasses&gt;\n      Tpm2DeviceLib|SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpmStandaloneMm.inf\n  }\n\n# Optional\nMsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf\n  MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf\n  MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf\n\n[BuildOptions.common.EDKII.MM_STANDALONE, BuildOptions.common.EDKII.MM_CORE_STANDALONE]\n#DLink flags to cut out project names from binaries\nMSFT:*_*_*_DLINK_FLAGS = /ALIGN:4096\n</code></pre> <ol> <li>Remove the DSC sections below.</li> </ol> <pre><code>[Components.X64]\n# MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf\n# MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf\n# UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf\n\n# MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf\n# MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf\n# UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf\n# MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf\n# UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf\n# MsCorePkg/Universal/StatusCodeHandler/Serial/Smm/SerialStatusCodeHandlerSmm.inf\n# SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf\n# MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf\n# MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf\n</code></pre> <ol> <li> <p>Given that current Standalone MM environment does not support dynamic PCDs, the SMM drivers currently consuming dynamic PCDs need to be configured to avoid this.</p> </li> <li> <p>Be aware that if the platform previously loaded the MM IPL in DXE, the MM initialization drivers such as the MM Control driver might assume the environment is not initialized and clear registers that were set up in the PEI phase. Modify the drivers as appropriate to avoid losing initialization performed in PEI.</p> </li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#platform-fdf-statements","title":"Platform FDF statements","text":"<ol> <li>Add the FDF sections below.</li> </ol> <p>Note: There might be other silicon specific drivers a platform will need for these sections</p> <pre><code>[FV.YOUR_PEI_FV]\nINF  MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf\n  INF  MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferPei.inf\n!if $(PEI_MM_IPL_ENABLED) == TRUE\n  INF  MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplPei.inf\n!endif\n\n[FV.YOUR_POST_MEM_PEI_FV]\n!if $(PEI_MM_IPL_ENABLED) == TRUE\n  INF  MmSupervisorPkg/Drivers/MmPeiLaunchers/MmIplX64Relay.inf\n  INF  MmSupervisorPkg/Core/MmSupervisorCore.inf\n  FILE FREEFORM = gMmSupervisorPolicyFileGuid {\nSECTION RAW = $(POLICY_BIN_PATH)\n}\n!endif\n\n[FV.YOUR_DXE_FV]\n!if $(PEI_MM_IPL_ENABLED) == TRUE\n  INF  MmSupervisorPkg/Drivers/MmPeiLaunchers/MmDxeSupport.inf\n!else\n  INF  MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf\n  INF  MmSupervisorPkg/Core/MmSupervisorCore.inf\n  FILE FREEFORM = gMmSupervisorPolicyFileGuid {\nSECTION RAW = $(POLICY_BIN_PATH)\n}\n!endif\n  INF  MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf\n  INF  MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf\n  INF  MmSupervisorPkg/Drivers/MmCommunicationBuffer/MmCommunicationBufferDxe.inf\n\n  INF  MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterStandaloneMm.inf\n  INF  MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceStandaloneMm.inf\n  INF  UefiCpuPkg/CpuIo2Smm/CpuIo2StandaloneMm.inf\n  INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableStandaloneMm.inf\n  INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteStandaloneMm.inf\n  INF  RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Acpi/Tcg2Acpi.inf\n  INF  SecurityPkg/Tcg/Tcg2StandaloneMm/Tcg2StandaloneMm.inf\n\n  # Optional\nINF  MsCorePkg/Universal/StatusCodeHandler/Serial/StandaloneMm/SerialStatusCodeHandlerStandaloneMm.inf\n  INF  MsWheaPkg/MsWheaReport/Smm/MsWheaReportStandaloneMm.inf\n  INF  MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf\n\n[Rule.Common.MM_CORE_STANDALONE]\nFILE MM_CORE_STANDALONE = $(NAMED_GUID) {\nPE32     PE32           $(INF_OUTPUT)/$(MODULE_NAME).efi\n    UI       STRING=\"$(MODULE_NAME)\" Optional\n    VERSION  STRING=\"$(INF_VERSION)\" Optional BUILD_NUM=$(BUILD_NUMBER)\n}\n\n[Rule.Common.MM_STANDALONE]\nFILE MM_STANDALONE = $(NAMED_GUID) {\nSMM_DEPEX    SMM_DEPEX Optional      $(INF_OUTPUT)/$(MODULE_NAME).depex\n    PE32     PE32                    $(INF_OUTPUT)/$(MODULE_NAME).efi\n    UI       STRING=\"$(MODULE_NAME)\" Optional\n    VERSION  STRING=\"$(INF_VERSION)\" Optional BUILD_NUM=$(BUILD_NUMBER)\n}\n</code></pre> <ol> <li>Remove the FDF sections below.</li> </ol> <pre><code>[FV.YOUR_DXE_FV]\n# INF  MdeModulePkg/Core/PiSmmCore/PiSmmIpl.inf\n# INF  MdeModulePkg/Core/PiSmmCore/PiSmmCore.inf\n# INF  UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf\n\n# INF  MdeModulePkg/Universal/ReportStatusCodeRouter/Smm/ReportStatusCodeRouterSmm.inf\n# INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableSmm.inf\n# INF  MdeModulePkg/Universal/Acpi/FirmwarePerformanceDataTableSmm/FirmwarePerformanceSmm.inf\n# INF  UefiCpuPkg/CpuIo2Smm/CpuIo2Smm.inf\n# INF  UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationSmm.inf\n# INF  MdeModulePkg/Universal/SmmCommunicationBufferDxe/SmmCommunicationBufferDxe.inf\n# INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmm.inf\n\n# INF  RuleOverride = DRIVER_ACPITABLE SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.inf\n</code></pre>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy-file","title":"MM Policy File","text":"<ol> <li>Create secure policy binary file using MmSupervisorPkg/SupervisorPolicyTools/SupervisorPolicyMaker.py per platform needs (an example can be found in SupervisorPolicyTools folder).</li> <li>Place the created secure policy as a FREEFORM binary in the FDF file within the same FV as the MmSupervisor image. The file should be GUIDed as <code>gMmSupervisorPolicyFileGuid</code> so it can be discovered by the MM Supervisor.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/PlatformIntegrationSteps/#mm-policy-xml-file-schema","title":"MM Policy XML File Schema","text":"<p>An example can be found in SupervisorPolicyTools folder.</p> <ol> <li>All XML files should use the <code>&lt;SmmIsolationPolicy&gt;</code> as the root tag.</li> <li> <p>Under the root, all supported protection categories should listed under <code>&lt;SmmCategory&gt;</code> nodes, with a <code>name</code> attribute denoting the specific category.</p> <ul> <li>Currently ony support 'MSR', 'IO', 'INSTRUCTION' and 'SAVESTATE'</li> <li>There should be only one <code>&lt;SmmCategory&gt;</code> node for each category in a single XML file.</li> </ul> </li> <li> <p>For each protection category group, a <code>&lt;PolicyAccessAttribute&gt;</code> must be included to indicate the corresponding policy entries belong to a deny list or allow list.</p> </li> <li> <p>In addition to policy attributes, multiple <code>&lt;PolicyEntry&gt;</code> nodes coud be included in a <code>&lt;SmmCategory&gt;</code> group. This will be an individual policy protection entry.</p> </li> <li> <p>For <code>MSR</code> protection group, each entry should be described with the following 3 children nodes:</p> </li> </ol> <pre><code>&lt;StartAddress Value=\"0xC0000080\"/&gt; &lt;!-- The starting base address of MSR --&gt;\n&lt;Size Value=\"0x2\"/&gt; &lt;!-- The range of MSRs to be protected. In this example, MSR 0xC0000080 and 0xC0000081 will be\nprotected. --&gt;\n&lt;SecurityAttributes Value=\"Read | Write\" /&gt; &lt;!-- Indicate the intended MSR access type to be protected. Only Read, Write\nor their combination are accepted. --&gt;\n</code></pre> <ul> <li>For <code>IO</code> protection group, each entry should be described with the following 3 children nodes:</li> </ul> <pre><code>&lt;StartAddress Value=\"0xCF8\"/&gt; &lt;!-- The IO port to be protected --&gt;\n&lt;Size Value=\"0x4\"/&gt; &lt;!-- The width of IO ports access to be protected. --&gt;\n&lt;SecurityAttributes Value=\"Read | Write | StrictWidth\" /&gt; &lt;!-- Indicate the intended IO access type to be protected.\nOnly Read, Write, StrictWidth or their combination are accepted. Note that when StrictWidth is indicated, only the access\nof StartAddress with specific Size width will be protected. Otherwise, it will be similar to MSR policy entry --&gt;\n</code></pre> <ul> <li>For <code>INSTRUCTION</code> protection group, each entry should be described with the following 3 children nodes:</li> </ul> <pre><code>&lt;Instruction Value=\"HLT\" /&gt; &lt;!-- The instruction name to be protected, only HLT, WBINVD and CLI are supported. --&gt;\n&lt;Size Value=\"0x4\"/&gt; &lt;!-- The width of IO ports access to be protected. --&gt;\n&lt;SecurityAttributes Value=\"Execute\" /&gt; &lt;!-- Only execute attribute is allowed here. --&gt;\n</code></pre> <ul> <li>For <code>SAVESTATE</code> protection group, each entry should be described with the following 3 children nodes:</li> </ul> <pre><code>&lt;SaveStateField Value=\"IO_TRAP\" /&gt; &lt;!-- The save state register name to be protected, only IO_TRAP and RAX are supported. --&gt;\n&lt;SecurityAttributes Value=\"Read\" /&gt; &lt;!-- Indicate the intended save state access type to be protected. Only Read and\nLimitedRead are accepted. Note that when LimitedRead is indicated, the AccessCondition node must be supplied. --&gt;\n&lt;AccessCondition Value=\"IoWrite\" /&gt; &lt;!-- Optional node to indicate what condition of LimitedRead can be accepted. Only\nIoWrite is accepted for RAX LimitedRead entry. --&gt;\n</code></pre>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/","title":"Software Components of the MM Supervisor","text":"<p>This section of documentation is focused on the software components of the MM Supervisor that are useful during platform integration.</p> <p>The MM Supervisor provides a software implementation that installs the MM foundation for X64. In order to load MM Supervisor properly, certain software prerequisites (libraries, drivers, hobs, etc.) needs to be met, most of which are included in this package.</p> <p>By including the proper software components, a platform can ensure the MM Supervisor features function as intended and the platform can meet Secured Core PC specification requirements. To enable an end-to-end Standalone MM based Secured Core solution, custom requirements may exist in adjacent UEFI firmware components.</p> <p>For more general background about the steps necessary to integrate the MM Supervisor, please review the Platform Integration Steps.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-pei-modules","title":"MM Standalone Mode PEI Modules","text":"PEI Module Location StandaloneMmHob MmSupervisorPkg/Drivers/StandaloneMmHob/StandaloneMmHob.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-pei-libraries","title":"MM PEI Libraries","text":"PEI Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibPei.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-dxe-drivers","title":"MM Standalone Mode DXE Drivers","text":"DXE Driver Location PiSmmIpl MmSupervisorPkg/Drivers/StandaloneMmIpl/PiSmmIpl.inf StandaloneMmUnblockMem MmSupervisorPkg/Drivers/StandaloneMmUnblockMem/StandaloneMmUnblockMem.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-dxe-libraries","title":"MM DXE Libraries","text":"DXE Library Location MmSupervisorUnblockMemoryLib MmSupervisorPkg/Library/MmSupervisorUnblockMemoryLib/MmSupervisorUnblockMemoryLibDxe.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-mm-core","title":"MM Standalone Mode MM Core","text":"MM Driver Location MmSupervisorCore MmSupervisorPkg/Core/MmSupervisorCore.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-mode-mm-drivers","title":"MM Standalone Mode MM Drivers","text":"MM Driver Location MmSupervisorRing3Broker MmSupervisorPkg/Drivers/MmSupervisorRing3Broker/MmSupervisorRing3Broker.inf MmSupervisorErrorReport MmSupervisorPkg/Drivers/MmSupervisorErrorReport/MmSupervisorErrorReport.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SoftwareComponentOverview/#mm-standalone-user-mode-libraries","title":"MM Standalone User Mode Libraries","text":"<p>These MM User Mode libraries are expected to be used as is and linked to other MM standalone drivers for standard functionality.</p> Library Location BaseIoLibIntrinsic MmSupervisorPkg/Library/BaseIoLibIntrinsicSysCall/BaseIoLibIntrinsic.inf BaseLib MmSupervisorPkg/Library/BaseLibSysCall/BaseLib.inf StandaloneMmCommunicationLib MmSupervisorPkg/Library/StandaloneMmCommunicationLib/StandaloneMmCommunicationLib.inf StandaloneMmDriverEntryPoint MmSupervisorPkg/Library/StandaloneMmDriverEntryPoint/StandaloneMmDriverEntryPoint.inf StandaloneMmHobLibSyscall MmSupervisorPkg/Library/StandaloneMmHobLibSyscall/StandaloneMmHobLibSyscall.inf StandaloneMmMemMapLib MmSupervisorPkg/Library/StandaloneMmMemMapLib/StandaloneMmMemMapLib.inf StandaloneMmServicesTableLib MmSupervisorPkg/Library/StandaloneMmServicesTableLib/StandaloneMmServicesTableLib.inf StandaloneMmSystemTableLib MmSupervisorPkg/Library/StandaloneMmSystemTableLib/StandaloneMmSystemTableLib.inf SysCallLib MmSupervisorPkg/Library/SysCallLib/SysCallLib.inf"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SwitchingToDenyByDefault/","title":"Switching MSR and IO MmPolicy from allow by default to deny by default","text":"<p>Individual platform MmPolicy can be edited in the corresponding \"YourPlatform\"MmPolicy.xml with an example in this repo at MmSupervisorPkg/SupervisorPolicyTools/MmIsolationPoliciesExample.xml. MSR and IO policy in this example uses a deny list to list ports that a platform cannot use.  This document describes how to go about switching to an allow list instead.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/PlatformIntegration/SwitchingToDenyByDefault/#transition-process","title":"Transition process","text":"<ol> <li> <p>Without changing any policies add the PCD gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsEnable to your platform .dsc file and set it to true.  Adding gMmSupervisorPkgTokenSpaceGuid.PcdMmSupervisorPrintPortsMaxSize to FixedPcd allows you to change the max dictionary size if necessary and is 50 by default.  This will print out all the MSR and IO ports currently being used in MM including their address and size which are required for making MM policies.</p> </li> <li> <p>Switch to an allow list by switching the PolicyAccessAttribute to \"Allow\". Create the allow list by following the list structure in your corresponding .xml file (refer to MmIsolationPoliciesExample.xml) and the address and size information from step 1.     Example:         Allow by default:              <pre><code>        &lt;!-- This policy denies the IO at port 0xADAA read and write access --&gt;\n&lt;PolicyEntry&gt;\n&lt;!-- Junk address and port--&gt;\n&lt;StartAddress Value=\"0xADAA\" /&gt; &lt;Size Value=\"0x2\" /&gt; &lt;SecurityAttributes Value=\"Read | Write\" /&gt;\n&lt;/PolicyEntry&gt;\n\nDeny by default:\n    &lt;!-- IO Policies required for level 20 start --&gt;\n&lt;SmmCategory name=\"IO\"&gt;\n&lt;!-- All IO policy entries listed here are allowed --&gt;\n&lt;PolicyAccessAttribute Value=\"Allow\"/&gt;\n\n&lt;!-- This policy allows the IO at port 0xADAA to have read and write access --&gt;\n&lt;PolicyEntry&gt;\n&lt;!-- Junk address and port--&gt;\n&lt;StartAddress Value=\"0xADAA\" /&gt; &lt;Size Value=\"0x2\" /&gt; &lt;SecurityAttributes Value=\"Read | Write\" /&gt;\n&lt;/PolicyEntry&gt;\n</code></pre> <li> <p>It's recommended to also look into each of the MSR and IO port addresses that you\u2019re adding to the allow list and leave a describing comment about them.  This can either be done by going through spec documentation describing the addresses and bits or by looking through the code itself and finding references to the addresses.</p> </li> <li> <p>For posterity you should then look for additional MSR and IO ports that you might want to add to the allow list as well.</p> <p>A couple of ways to do this (with examples from intel systems) would be:</p> <ul> <li> <p>Look for a file listing MSRs that you can comb over.  When doing step 3 you'll probably run across the file. An example for intel systems is 'CommonMsr.h'.</p> </li> <li> <p>Look around the location of defined MSR and IO ports that you're currently allowing.  There might be other relevant IO and MSR defintions that you\u2019d want to have on the allow list that currently are not being used.</p> </li> <li> <p>There might be an allow list for other mm used.  If so it's an excellent point of reference for relevant MSR and IO ports An example from intel systems isSmmIoMsrAccess.h.  A whitelist for intel Smm MSR and IO ports.</p> </li> </ul> </li> <li> <p>After compiling your list of MSR and IO ports make sure that you aren't violating the previous deny list or FASR requirements.  Some of these ports that you thought are relevant might have been explicitly denied by the previous deny list.  Make sure you don't put them on the allow list.</p> </li> <li> <p>To finish things off make sure that things boot correctly and if so you're done.</p> </li>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/","title":"Standalone MM","text":"<p>This document summarizes some of the benefits gained by adopting Standalone MM versus Traditional MM.</p> <p>For general background on Management Mode (MM), review the Platform Initialization (PI) specifications. In particular, Volume 4: Management Mode Core Interface. As noted in the PI specification, MM is a generic term used to describe a secure execution environment provided by the CPU and related silicon that is entered when the CPU detects a Management Mode Interrupt (MMI). x86 systems implement MM with System Management Mode (SMM) and ARM systems do so with TrustZone (TZ). This document exclusively focuses on the x86 architecture.</p> <p>Two MM \"modes\" are defined in the PI specification \u2013 (1) Traditional MM and (2) Standalone MM. Traditional MM is equivalent to the SMM software model historically used in PI-compliant firmware. Standalone MM is a relatively new mode that revises the historical model to improve security of the MM environment and prevent common mistakes made in Traditional MM implementations that led to numerous portability and security challenges over the years.</p> <p>A detailed comparison of the Traditional MM and Standalone MM load process is described in the PI Specification sections \"Initializing Management Mode in MM Traditional Mode\" and \"Initializing Management Mode in Standalone Mode\" respectively.</p> <p>It should be noted that both modes leverage the same hardware capabilities. No special hardware is required to transition a firmware to Standalone MM. Further, nearly all existing SMM code can be reused in Standalone MM with no change. Most mandatory changes either involve minimally changing small portions of code such as an entry point function signature or the module type or making changes that are not allowed in Standalone MM because they were violating security practices in Traditional MM. For example, compare the \"MM Traditional Driver Runtime\" section of the PI Specification with the \"MM Standalone Driver Runtime\" section.</p> <p>Instances of code in silicon code today violates the \"soft restrictions\" described in the traditional section.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#traditional-mm-versus-standalone-mm","title":"Traditional MM Versus Standalone MM","text":"<p>This section compares the main differences between Traditional MM and Standalone MM.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#mm-driver-initialization-and-runtime-phases","title":"MM Driver Initialization and Runtime Phases","text":"<p>Traditional MM typically launched in DXE and the DXE and Traditional MM environments closely interacted throughout driver dispatch. During MM dispatch, drivers execute in two phases \u2013 (1) initialization and (2) runtime.</p> Traditional MM Initialization Standalone MM Initialization Starts When the driver is loaded into MMRAM and the driver\u2019s entry point is called When the driver is loaded into MMRAM and the driver\u2019s entry point is called Ends The driver\u2019s entry point returns The driver\u2019s entry point returns Protocol Access UEFI - Boot services- DXE services- Runtime services- DXE protocolsMM- MM Services- MM protocolsNote: The PI specification states drivers should not call Exit() or ExitBootServices() during the initialization phase MM- MM Services- MM protocols Note: Drivers do not have access to interfaces outside the MM environment. Traditional MM Runtime Standalone MM Runtime Starts After the initialization phase ends Starts after the initialization phase ends Protocol Access MM- MM Services- MM protocolsNote: The PI specification states drivers should not call UEFI interfaces and services which were located during the initialization phase. MM- MM Services- MM protocolsNote: Drivers do not have access to interfaces outside the MM environment. <p>Given the initialization phase in Traditional MM occurred in DXE, in addition to the <code>DXE_SMM_DRIVER</code> driver type, <code>EFI_FV_FILETYPE_COMBINED_MM_DXE</code> driver types are also supported. Combination MM/DXE drivers are especially problematic for writing portable and secure code. They are launched twice, once by the DXE dispatcher as a normal DXE driver (outside MMRAM) that uses the <code>EFI_SECTION_DXE_DEPEX</code> section and again in Traditional MM (in MMRAM) where the <code>EFI_SECTION_MM_DEPEX</code> is used. In contrast, <code>MM_STANDALONE</code> drivers are launched once is Standalone MM only with access to the MM services and protocols.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#traditional-mm-and-standalone-mm-dispatch-overview","title":"Traditional MM and Standalone MM Dispatch Overview","text":"<p>Because the Standalone MM environment inherently has less coupling with DXE, it is much easier to launch Standalone MM code earlier in the boot flow which contributes to reducing the overall TCB. In addition, MM drivers cannot depend on implementation specific DXE protocols and interfaces increasing their portability. For example, this can force MM code design to be more reusable across silicon generations and client and server codebases.</p> <p></p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#problems-with-traditional-mm","title":"Problems with Traditional MM","text":"<p>Standalone MM can largely be considered a more disciplined approach to software execution in SMM. This discipline contributes to reduced likelihood of security issues, increased portability, and more flexibility in how to launch the MM environment. For a silicon vendor such as Intel and AMD, all of this improves the ability of partners to better integrate silicon reference code into their designs.</p> <p>Some key issues with Traditional MM are noted below.</p> <ol> <li>Late launch \u2013 Launching in DXE means another execution environment must be trusted after PEI to establish the MM environment.</li> <li>Excessive DXE coupling \u2013 Traditional MM is architecturally dependent on DXE.<ul> <li>MM driver writers often make mistakes and cache interface pointers not allowed in the initialization phase. This is a frequent source of security issues.</li> <li>MM drivers are dependent on DXE interfaces in their initialization phase. This makes it more difficult to execute these drivers in an environment where DXE is not present.</li> <li>Much as MM drivers have dependencies on the load order of the DXE environment, DXE drivers do on MM drivers.<ul> <li>For example, many DXE drivers have a dependency on the UEFI variable architectural protocol and/or the UEFI variable write architectural protocol. When MM is launched earlier in boot, such as PEI, the MM environment is already set up and ready making DXE dispatch more reliable.</li> </ul> </li> </ul> </li> <li>Delayed MM locking \u2013 Some system locks are delayed longer than necessary because the MM initialization phase is open throughout all of DXE.</li> <li>Broad memory access \u2013 Traditionally, SMM can access any memory buffer allocated prior to SmmReadyToLock. This presents security issues in which a freed buffer can be reassigned after the lock event and much more memory is exposed than necessary.<ul> <li>It is recommended to use Standalone MM in combination with explicit memory ranges to be unblocked for MM access. The MmUnblockMemoryLib API provides a mechanism for callers outside MM to permit explicit ranges to be accessible.</li> </ul> </li> </ol> <p>Launching the MM Foundation earlier brings other benefits such as the ability to use the read/write variable service in MM while in PEI. Because DXE is not involved, the MM Foundation can be entirely loaded and operational before launching payloads after PEI other than DXE.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#alignment-with-silicon-partner-initiatives","title":"Alignment With Silicon Partner Initiatives","text":"<p>Standalone MM launch in PEI naturally aligns with other silicon partner planned work such as:</p> <ul> <li>64-bit PEI \u2013 Thunking is not necessary between a 32-bit PEI and 64-bit MM environment.</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#enabling-options","title":"Enabling Options","text":"<p>Standalone MM provides flexibility in how to enable it. For example, if desired, a platform can simultaneously support both Traditional MM and Standalone MM modes with a build switch.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#launch-phase","title":"Launch Phase","text":"<p>Standalone MM can be launched in PEI which is preferred but it can also be launched in DXE at a similar point in the boot flow to Traditional MM to minimize deviation between the initialization point of the two modes.</p> <p>A high-level proposed Standalone MM IPL process in PEI is described below.</p> <ol> <li>Dispatch the Standalone MM PEI IPL in post-memory PEI.</li> <li>In the entry point of the Standalone MM PEI IPL, verify system pre-requisites are satisfied to set up the MM foundation in MMRAM.<ul> <li>Example: the MM Control PPI and MM Access PPI are installed and sufficiently large MMRAM regions are reported.</li> <li>Because in Standalone MM, the platform cannot provide information via DXE interfaces, it is expected a platform will have to provide data in HOBs that must be present when the Standalone MM PEI IPL is executed.<ul> <li>In general, this is considered a more ordered and structured approach to providing data into MM.</li> </ul> </li> </ul> </li> <li>Check if the system PEI is 32-bit. If so, cache the system execution context and then switch to X64 mode to load a X64 relay module (similar to CapsuleX64.inf).<ul> <li>The X64 relay module can execute the Standalone MM core entry point with a supplied HOB start address.</li> </ul> </li> <li>During the Standalone MM Foundation initialization, all Standalone MM drivers are loaded into MMRAM. No further drivers will be loaded from outside MMRAM during the boot.<ul> <li>To better organize this process and focus relevant module exposure to the corresponding dispatchers, all Standalone MM drivers can be consolidated in a single firmware volume.</li> </ul> </li> <li>After the Standalone MM Core Foundation is setup, the system will return to 32-bit mode restoring the cached context information, if applicable, and closing and locking all MMRAM regions.</li> <li>The Standalone MM PEI IPL installs the MM Communication PPI for PEIM usage in the remainder of the PEI phase.</li> <li>Once DXE is launched, the DXE MM Communication Protocol will be installed for DXE drivers to communicate with Standalone MM drivers.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#mm-module-dual-mode-support","title":"MM Module Dual Mode Support","text":"<p>All Traditional MM modules can continue to be supported with most of the code shared between the Traditional MM and Standalone MM instances.</p> <p>Typically, modules end up in the following state:</p> <ul> <li>A Traditional MM INF file</li> <li>A Standalone MM INF file</li> <li>A Common MM C file \u2013 where the actual module implementation is written</li> <li>A Traditional MM C file \u2013 usually with just the Traditional MM entry point function that calls into the common C code</li> <li>A Standalone MM C file \u2013 usually with just the Standalone MM entry point function that calls into the common C code</li> </ul> <p>Therefore, the Traditional MM module is not lost, and its implementation can simultaneously stay current with the Standalone MM driver.</p> <p>Even for a driver as complex as the UEFI variable driver, this pattern reveals the small touch necessary to support Standalone MM:</p> <ul> <li>INF files</li> <li>Traditional MM: edk2/VariableSmm.inf at master \u00b7 tianocore/edk2 (github.com)</li> <li>Standalone MM: edk2/VariableStandaloneMm.inf at master \u00b7 tianocore/edk2 (github.com)</li> <li>C entry point files</li> <li>Traditional MM: edk2/VariableStandaloneMm.c at master \u00b7 tianocore/edk2 (github.com)</li> <li>Standalone MM: edk2/VariableTraditionalMm.c at master \u00b7 tianocore/edk2 (github.com)</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#common-steps-to-port-traditional-mm-to-standalone-mm","title":"Common Steps to Port Traditional MM to Standalone MM","text":"<ul> <li>Change the driver entry point prototype from the Traditional MM API to the Standalone MM API.</li> <li>The driver will now use StandaloneMmDriverEntryPoint.</li> <li>The system table should be of type \"EFI_MM_SYSTEM_TABLE\".</li> <li>In target INF files, use \"MM_STANDALONE\" as \"MODULE_TYPE\".</li> <li>In target INF files, set \"PI_SPECIFICATION\" version to \"0x00010032\".</li> <li>Update any \"DXE_SMM_DRIVER\" libraries that will now be ported for the Standalone MM environment, add support for the \"MM_STANDALONE\" and \"MM_CORE_STANDALONE\" driver types.</li> <li>To minimize impact on packages like ClientOneSiliconPkg that are used by many different products, the file paths to the pre-existing module INF file remain unchanged. For example, PchSmiDispatcher is still called PchSmiDispatcher. However, in many cases, a new Standalone MM INF file accompanies the original SMM driver INF that has minor differences such as specifying the MODULE_TYPE as MM_STANDALONE and using a different module entry point API. In cases where backward compatibility is not a concern, such as a .C source file name (as opposed to the INF file name), it is generally preferred to update terminology to \"traditional MM\".</li> <li>Use MemoryAllocationLib functions to allocate and free memory as opposed to gSmst or gMmst directly. This can improve portability between the two services tables.</li> <li>Find an alternative solution for gBS, gDS, and other DXE environment accesses.</li> <li>Find an alternative solution for any PCDs that are not FixedAtBuild. The PCD protocol is not available within the Standalone MM environment.</li> <li>Check MM driver DEPEX statements and dispatch order after removing DXE protocols to ensure dispatch requirements are still met.</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/StandaloneMmOverview/standalone_mm_framework/#standalone-mm-at-microsoft","title":"Standalone MM at Microsoft","text":"<p>Microsoft has already implemented a POC on Tiger Lake that enables Standalone MM. We plan to ship code based on this Standalone MM implementation for Tiger Lake based products. It would greatly help reduce engineering effort within Microsoft if silicon partners would update silicon reference code to include Standalone MM support.</p> <p>Note: A Traditional MM option would be unnecessary for Microsoft if Standalone MM is fully supported.</p>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/","title":"Traditional SMM framework implementation (not Secured Core compliant)","text":""},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smm-framework-modules","title":"SMM framework modules","text":"<p>4 main modules consist of SMM framework (all in post-PEI phase):</p> <ul> <li>PiSmmIpl will search for available SMRAM regions and load PiSmmCore.</li> <li>PiSmmCore will load SMM handler drivers during boot, provide memory allocation and free service, manage protocol and SMM handler database, provide protocol and/or event notification services, and dispatch registered SMM handles from SMM Handler drivers</li> <li>PiSmmCpuDxeSmm will relocate SMM base address, configure SMI entry code, set up GDT, IDT, page table protection.</li> <li>Smm Handler drivers, the drivers OEM authored for highly privileged jobs, such as power management. These drivers will register handlers through PiSmmCore services and get dispatched during SMI events.</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smm-framework-boot-flow","title":"SMM framework boot flow","text":"<p>SMM framework boot flow is illustrated above. (The color of each subprocess activation block matches the first block in the corresponding flow)</p> <ol> <li>During the system boot, PiSmmIpl will be loaded by DXE core. This driver will:<ul> <li>Open and find the largest available SMRAM range</li> <li>Copy PiSmmCore into SMRAM and load it from SMRAM. NOTE that SMI entry is not setup yet, thus PiSmmCore entrypoint is not executed in SMI environment</li> <li>Share certain private data with PiSmmCore (mSmmCorePrivateData).</li> </ul> </li> <li>At the entrypoint of PiSmmCore:<ul> <li>PiSmmCore provides gSmst, a global table of service consumable from SMM handler drivers, including memory allocation, protocol publication, handler registration and waking up APs</li> <li>PiSmmCore register required SMI handler to itself, including gEfiEventDxeDispatchGuid, which is signaled on every round of DXE dispatching. SMM handler drivers are dispatched from this internal SMI handler, publishing protocols and signalling events consumable by other DXE and SMM drivers.</li> </ul> </li> <li>During the SMM handler driver dispatch, PiSmmCpuDxeSmm will be loaded to set up SMBASE and SMI entry. At the entrypoint of PiSmmCpuDxeSmm<ul> <li>Allocate buffer for SMM save state and SMI entry as described in git book by EDK2</li> <li>Allocate stacks for SMI environment</li> <li>Setup GDT for code segment management and IDT for exception handling</li> <li>Relocate SMBASE to allocated SmiEntry code block</li> </ul> </li> </ol>"},{"location":"dyn/mu_feature_mm_supv/MmSupervisorPkg/Docs/TraditionalSmmFramework/traditional_smm_framework/#smi-interrupt-flow","title":"SMI interrupt flow","text":"<ol> <li>Upon a SMI input, CPU will pause currently running software and start from SMM base address, which was relocated by PiSmmCpuDxeSmm. At initial entry point, system will start from legacy (16-bit) mode.</li> <li>SMI entry code block is responsible to bring the system up to 64-bit mode before handing over to <code>SmiRendezvous</code>, a routine to synchronize all cores on a processor inside PiSmmCpuDxeSmm. This process includes stack initialization, configure IDT, GDT and TSS to the ones initialized in PiSmmCpuDxeSmm entry point.</li> <li>SmiRendezvous will put all APs stand by for multi-processor job, and release BSP to SMM framework routine <code>SmmCoreEntry</code>, which will manage PiSmmCore SMI private data and dispatch all handlers registered by other SMM handler drivers.</li> <li>If this SMI happens immediately after gEfiDxeSmmReadyToLockProtocolGuid event, the system will apply page table attributes and prevent further paging modification from this point and on.</li> </ol>"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_feature_mm_supv/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_oem_sample/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/","title":"OemPkg","text":"<p>OemPkg contains the logic required to use Project Mu. Though this package should be bootable with some extra care from a developer, the code should be fully tailored to meet the needs of the product. Below is a short summary of each piece to the Project Mu puzzle to help jump-start the customization process.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#frontpage","title":"FrontPage","text":"<p>FrontPage is Project Mu's UEFI landing page. From here, the user can access items like system information, boot menu, and DFCI management settings. There's a significant amount of logic contained within.</p> <p>FrontPage.c is the actual implementation of the FrontPage. It includes all the logic required to call, update, and populate the FrontPage with system information. Adding or removing elements from the FrontPage can be done by editing mFormMap.</p> <p>FrontPageConfigAccess.c implements trivial versions of RouteConfig and ExtractConfig to satisfy dependencies.</p> <p>FrontPageStrings.uni contains all static strings displayed on the UEFI FrontPage.</p> <p>FrontPageUi.c handles updates to the FrontPage UI including updates to the current page and info/popup boxes.</p> <p>FrontPageVfr.Vfr A VFR (Visual Forms Representation) file defines the layout of a UI and, in this case, FrontPage. FrontPageVfr.h contains guid definitions used in VFR files.</p> <p>String.c contains the logic for fetching strings using HII (Human Interface Infrastructure) protocols. HII is detailed in the UEFI Spec v2.8 on page 1731.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#frontpagebuttonsvolumeup","title":"FrontpageButtonsVolumeUp","text":"<p>By default, booting to UEFI requires holding down the volume up (or equivalent) button on the device. It's unlikely that the volume up button will be appropriate or applicable to most devices, so it's recommended to alter the trigger for booting to UEFI. This module simulates holding down the volume up button on every boot so the UEFI FrontPage is loaded every boot.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#bootmenu","title":"BootMenu","text":"<p>The BootMenu on the UEFI FrontPage is under the Boot configuration tab. It defines the boot order for the device and advanced options which can potentially be managed through DFCI.</p> <p>BootMenu.c contains all logic required by the BootMenu including changing settings (assuming they are not locked through DFCI) and rebuilding the boot order.</p> <p>BootMenuStrings.uni contains all static strings displayed on the BootMenu.</p> <p>BootMenuVfr.Vfr defines the layout of the BootMenu UI. BootMenu.h contains guid definitions used in the VFR file.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#devicestatepei","title":"DeviceStatePei","text":"<p>This module sets the Device State bits in the PEI phase so they are available prior to display in the DXE phase. Possible Device States include Manufacturing Mode Enabled/Disabled, Unit Test Mode, Secure Boot Enabled/Disabled, etc.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#includes","title":"Include(s)","text":"<p>As is standard across EDK2, the Include/ directory contains header files for functionality under the Library/ directory (not to be confused with Include/Library/) and is available for inclusion in other modules.</p> <p>MsNVBootReason.h provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage.</p> <p>PasswordStoreVariable.h defines the GUID and variable names for a variable-backed PasswordStore.</p> <p>PasswordPolicyLib.h contains the interface for storing and hashing an administrator password.</p> <p>ButtonServices.h is the header for FrontpageButtonsVolumeUp.c</p> <p>MsFrontPageAuthTokenProtocol.h is required to access the authentication token generated when FrontPage is launched. This token is used in all FrontPage applications to retrieve data from the settings provider.</p> <p>FrontPageSettings.h contains some variables correlating with settings on FrontPage.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#library","title":"Library","text":"<p>As is standard across EDK2, the Library/ directory contains actual implementations of functionality provided/required by this module.</p> <p>BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume.</p> <p>DfciDeviceIdSupportLib provides access to platform data that becomes the DFCI Device ID which include the manufacturer name, product name, and serial number. Device IDs are used to target devices with DFCI settings management.</p> <p>DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here.</p> <p>DfciUiSupportLib allows DFCI to communicate with the user during DFCI initialization, enrollment, or to indicate a non secure environment is available.</p> <p>MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device.</p> <p>MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB).</p> <p>MsSecureBootModeSettingLib sets and gets the Secure Boot mode value during the DXE phase of execution.</p> <p>MsUefiVersionLib simply provides platform version information.</p> <p>PasswordPolicyLib contains the logic for storing and hashing an administrator password.</p> <p>PasswordPolicyLibNull is the NULL version of PasswordPolicyLib used when the actual functionality is unnecessary but some other component requires the library definition to successfully build.</p> <p>PasswordStoreLib manages storage location for the platform administrator password.</p> <p>PlatformKeyLibNull is the NULL implementation of PlatformKeyLib to satisfy dependencies.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#override","title":"Override","text":"<p>The Override/ directory contains overrides for EDK2 components. These overrides are sometimes required for things like bug fixes, functionality addition and removal. In this case, the only override is for BootManagerPolicyDxe to preserve some functionality of the original in case it is changed in the EDK2 upstream.</p>"},{"location":"dyn/mu_oem_sample/Docs/OemPkg/#others","title":"Others","text":"<p>.dec and .dsc files are required by the build process for any package in EDK2, hence the inclusion of OemPkg.dsc and OemPkg.dec. The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. The DEC file consists of sections delineated by section tags enclosed within square brackets which are used to generate AutoGen.c and AutoGen.h files for the EDK2 build infrastructure. For a more in-depth look at DSC and DEC files, check out the DSC specification and the DEC specification.</p>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/","title":"Project Mu Oem Sample Repository","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_oem_sample.git Branch:         release/202208 Commit:         50080f54aa83b21240bc3ae1d982294830a83b79 Commit Date:    2023-01-25 01:28:14 -0500</p> <p>This repository is considered sample code for any entity building devices using Project Mu.  It is likely that any device manufacturer will want to customize the device behavior by changing the modules in this package.</p> <ul> <li>Numerous libraries to support UEFI Boot Device Selection phase (BDS)</li> <li>Firmware Version information</li> <li>UI App / \"FrontPage\" application support as well as example</li> </ul>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#more-info","title":"More Info","text":"<p>FrontpageDsc and FrontpageFdf that can be included so you don't have to unravel all of the libraries and protocols that are required to get started with FrontPage. Includes contain comments for clarity, and there is a more extensive explanation for each library in the Docs/Frontpage_Includes.</p> <p>Please see the Project Mu docs for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#per-platform-libraries","title":"Per Platform Libraries","text":"<p>NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included in the DSC file. An example can be found in the NXP iMX8 platform.</p>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process. More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#pr-gate-builds","title":"PR-Gate Builds","text":"<pre><code>pip install --upgrade -r requirements.txt\nmu_build -c corebuild.mu.json\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Repo_Details/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/","title":"DSC Include File in Detail","text":"<p>This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#preliminaries","title":"Preliminaries","text":""},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-a-dsc-file","title":"What is a DSC File","text":"<p>The .dsc filetype is an EDK2 Platform Description file format. The DSC file must define all libraries, components and/or modules that will be processed by compiler tool chains, such as the GNU C compiler. To learn more about it, check the specification on the tianocore-docs github.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-an-inf-file","title":"What is an INF File","text":"<p>The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#how-do-i-include-a-dsc-file","title":"How do I Include a DSC File","text":"<p>This file will be included in the DSC file for the platform being built. The syntax for including a file is:</p> <pre><code>!include path/to/dsc/include/file\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-are-null-libs","title":"What are NULL Libs","text":"<p>A NULL lib is one which satisfies a dependency but doesn't implement the required functions. They're used when a package requires the definition of a library but the way in which the package is being used does not actually necessitate that library. Instead of reworking the package to remove dependencies on the unused library, a NULL version of that libraray can be created which fits the specification but returns the trivial result when called.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#what-is-dfci","title":"What is DFCI","text":"<p>From the feature document: The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#libraries-included","title":"Libraries included","text":"<p>NOTE: Three libraries (MsPlatformDevicesLib, DfciDeviceIdSupportLib, PlatformThemeLib) will need to be implemented per platform and included either here or in the main DSC file. An example can be found in the NXP iMX8 platform. in the Library/ directory.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#shell-libraries","title":"Shell libraries","text":"<p>From the frontpage, the shell can be loaded from frontpage using the boot menu. ShellLib provides the main functionality for shell commands and applications. ShellCommandLib provides the internal support for ShellLib. ShellCEntryLib enables a C-style main function with traditional argc and argv parameters. HandleParsingLib supports the parsing the handle and protocol database from the shell. BcfgCommandLib enables the usage of the bcfg command in the shell. Information about bcfg can be found in the UEFI Shell Specification v2.2 on page 96. NetLib provides basic network functionality.</p> <pre><code>ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf\nShellCommandLib|ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf\nShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf\nHandleParsingLib|ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf\nBcfgCommandLib|ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf\nNetLib|MdeModulePkg/Library/DxeNetLib/DxeNetLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#intrinsics-for-crypto-operations","title":"Intrinsics for crypto operations","text":"<p>IntrinsicLib is an intrinsic memory routines wrapper implementation for an OpenSSL -based cryptographic library.</p> <pre><code>IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#null-routines-to-support-dfci-ui-operations","title":"NULL routines to support DFCI UI operations","text":"<p>Info on DfciUiSupportLib can be found here</p> <pre><code>DfciUiSupportLib|DfciPkg/Library/DfciUiSupportLibNull/DfciUiSupportLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#crypto-support-functions-for-the-dfci-recovery-feature","title":"Crypto support functions for the DFCI recovery feature","text":"<p>Info on DfciRecoveryLib can be found here</p> <pre><code>DfciRecoveryLib|DfciPkg/Library/DfciRecoveryLib/DfciRecoveryLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#openssl-library","title":"OpenSSL Library","text":"<p>OpensslLib is an open-source implementation of the SSL and TLS protocols. This library is used by BaseCryptLib.</p> <pre><code>OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#stub-functions-that-should-contain-base-logic-for-querying-setting-and-verifying-user-passwords","title":"Stub functions that should contain base logic for querying, setting, and verifying user passwords","text":"<p>BaseCryptLib provides basic library functions for cryptographic primitives.</p> <pre><code>BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#supports-dfci-groups","title":"Supports DFCI Groups","text":"<p>DfciGroupLib allows settings managers to keep separate configurations depending upon the devices group membership. More on DfciGroupLib can be found here.</p> <p>XmlTreeQueryLib and XmlTreeLib introduce some xml support into UEFI. Info on the Xml Support Package can be found here.</p> <pre><code>DfciGroupLib|DfciPkg/Library/DfciGroupLibNull/DfciGroups.inf\nXmlTreeQueryLib|XmlSupportPkg/Library/XmlTreeQueryLib/XmlTreeQueryLib.inf\nXmlTreeLib|XmlSupportPkg/Library/XmlTreeLib/XmlTreeLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#backwards-compatibility-with-dfci-v1-functions","title":"Backwards compatibility with DFCI V1 functions","text":"<p>DfciV1SupportLib (or rather its NULL instance) translates V1 DFCI strings into V2 DFCI strings.</p> <p>FltUsedLib provides a global (fltused) that needs to be defined anywhere floating point operations are used.</p> <pre><code>DfciV1SupportLib|DfciPkg/Library/DfciV1SupportLibNull/DfciV1SupportLibNull.inf\nFltUsedLib|MdePkg/Library/FltUsedLib/FltUsedLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#library-instances-which-understand-the-msxml-settings-schema","title":"Library instances which understand the MsXml Settings Schema","text":"<p>DfciXmlSettingSchemaSupportLib supports the xml schema used to store/define settings in DFCI.</p> <p>DfciXmlPermissionSchemaSupportLib supports the xml format used to store permissions. More information on DFCI Permissions can be found here.</p> <p>DfciXmlDeviceIdSchemaSupportLib and DfciXmlIdentitySchemaSupportLib support the xml format used to store Device Identities.More info on the DFCI Identity Manager can be found here</p> <pre><code>DfciXmlSettingSchemaSupportLib|DfciPkg/Library/DfciXmlSettingSchemaSupportLib/DfciXmlSettingSchemaSupportLib.inf\nDfciXmlPermissionSchemaSupportLib|DfciPkg/Library/DfciXmlPermissionSchemaSupportLib/DfciXmlPermissionSchemaSupportLib.inf\nDfciXmlDeviceIdSchemaSupportLib|DfciPkg/Library/DfciXmlDeviceIdSchemaSupportLib/DfciXmlDeviceIdSchemaSupportLib.inf\nDfciXmlIdentitySchemaSupportLib|DfciPkg/Library/DfciXmlIdentitySchemaSupportLib/DfciXmlIdentitySchemaSupportLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#support-for-zero-touch","title":"Support for Zero Touch","text":"<p>The term Zero Touch is used in DFCI to describe managing device settings remotely. ZeroTouchSettingsLib is a library instance for ZeroTouch to support enabling, display, and deleting the Zero Touch Certificate.</p> <p>SafeIntLib is a simple integer mathematics library which guards against integer overflow.</p> <p>BmpSupportLib supports the use of bitmap files.</p> <pre><code>ZeroTouchSettingsLib|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf\nSafeIntLib|MdePkg/Library/BaseSafeIntLib/BaseSafeIntLib.inf\nBmpSupportLib|MdeModulePkg/Library/BaseBmpSupportLib/BaseBmpSupportLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#null-library-for-displaying-device-state","title":"NULL library for displaying device state","text":"<p>DisplayDeviceStateLib usually supplies a function to display all active device states. This NULL implementation satisfies dependencies on this function, but no non-null version of this lib exists in Project Mu.</p> <pre><code>DisplayDeviceStateLib|MsGraphicsPkg/Library/DisplayDeviceStateLibNull/DisplayDeviceStateLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#libraries-supporting-boot-graphics","title":"Libraries supporting boot graphics","text":"<p>BootGraphicsLib is used by BDS to draw and the main boot graphics to the screen. In the case of Microsoft Surface products, this is usually the Windows logo.</p> <p>BootGraphicsProviderLib enables the retrieval of the boot graphics used by BootGraphicsLib from a Firmware Volume.</p> <pre><code>BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf\nBootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#support-libary-for-ms_ui_theme","title":"Support libary for MS_UI_THEME","text":"<p>The MS_UI_THEME is the theme used by our FrontPage. MsUiThemeCopyLib is used by the graphics package to copy the stored theme into a buffer.</p> <pre><code>MsUiThemeCopyLib|MsGraphicsPkg/Library/MsUiThemeCopyLib/MsUiThemeCopyLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#version-support-library","title":"Version Support Library","text":"<p>MuUefiVersionLib is a simple library which returns the current UEFI version.</p> <pre><code>MuUefiVersionLib|OemPkg/Library/MuUefiVersionLib/MuUefiVersionLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#thermal-support","title":"Thermal Support","text":"<p>This NULL implementation of the ThermalServicesLib satisfies a dependency from DeviceBootManagerlib. Because there is no universal API for fetching thermal state, ThermalServicesLib requires a platform specific implementation to function.</p> <pre><code>ThermalServicesLib|PcBdsPkg/Library/ThermalServicesLibNull/ThermalServicesLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#platform-power-services","title":"Platform power services","text":"<p>Note that these are both NULL implementations.</p> <p>PowerServicesLib supports Platforms that don't have a battery. MsPlatformPowerCheckLib allows platform code to configure CPU power limits.</p> <pre><code>PowerServicesLib|PcBdsPkg/Library/PowerServicesLibNull/PowerServicesLibNull.inf\nMsPlatformPowerCheckLib|PcBdsPkg/Library/MsPlatformPowerCheckLibNull/MsPlatformPowerCheckLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#console-message-library","title":"Console Message Library","text":"<p>ConsoleMsgLib offers functionality to display platform specific debug messages. Platforms are responsible for implementing this interface (this is a NULL implementation)</p> <pre><code>ConsoleMsgLib|PcBdsPkg/Library/ConsoleMsgLibNull/ConsoleMsgLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#console-configuration","title":"Console Configuration","text":"<p>GraphicsConsoleHelperLib enables the setting of the graphics console resolution to known values (ex. native resolution, low resolution, etc.).</p> <pre><code>GraphicsConsoleHelperLib|PcBdsPkg/Library/GraphicsConsoleHelperLib/GraphicsConsoleHelper.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#device-state-support","title":"Device State Support","text":"<p>DeviceStateLib is a simple interface for getting and setting the device state (ex. Manufacturing Mode, Unit Test Mode, etc.). DisplayDeviceStateLib uses color bards to display device states during boot. For example, the following color bar displayed at the top of the screen implies Secure Boot is disabled</p> <p></p> <pre><code>DeviceStateLib|MsCorePkg/Library/DeviceStateLib/DeviceStateLib.inf\nDisplayDeviceStateLib|MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ColorBarDisplayDeviceStateLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#device-specific-boot-actions-supporting-platformbootmanagerlib","title":"Device specific boot actions supporting PlatformBootManagerLib","text":"<p>DeviceBootManagerLib provides extensions for BdsDxe which is responsible for producing the protocol gEfiBdsArchProtocolGuid which is used to transition between DXE and BDS phases.</p> <pre><code>DeviceBootManagerLib|PcBdsPkg/Library/DeviceBootManagerLib/DeviceBootManagerLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#rectangle-primitives-library","title":"Rectangle Primitives Library","text":"<p>UiRectangleLib enables the drawing of rectangles with different fills and borders.</p> <pre><code>UiRectangleLib|MsGraphicsPkg/Library/BaseUiRectangleLib/BaseUiRectangleLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#boot-management","title":"Boot Management","text":"<p>MsAltBootLib sets and gets the alternate boot variable used to specify when the user wants to boot from a USB or other device.</p> <p>MsBootOptionsLib extends BdsDxe to allow booting from specific storage devices or to the shell.</p> <pre><code>MsAltBootLib|OemPkg/Library/MsAltBootLib/MsAltBootLib.inf\nMsBootOptionsLib|PcBdsPkg/Library/MsBootOptionsLib/MsBootOptionsLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#color-support","title":"Color Support","text":"<p>MsColorTableLib is a simple library of colors</p> <pre><code>MsColorTableLib|MsGraphicsPkg/Library/MsColorTableLib/MsColorTableLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#networking-support","title":"Networking Support","text":"<p>MsNetworkDependencyLib is used by the boot manager to start the networking stack.</p> <pre><code>MsNetworkDependencyLib|PcBdsPkg/Library/MsNetworkDependencyLib/MsNetworkDependencyLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#library-to-access-reboot-reason","title":"Library to access reboot reason","text":"<p>MsNVBootReasonLib provides an interface for retrieving the reboot reason (ex. bootfail) from non-volatile variable storage.</p> <pre><code>MsNVBootReasonLib|OemPkg/Library/MsNVBootReasonLib/MsNVBootReasonLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#math-library","title":"Math Library","text":"<p>MathLib provides an architecture agnostic math library offering reasonable approximations for various functions in software.</p> <pre><code>MathLib|MsCorePkg/Library/MathLib/MathLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#system-boot-graphics-support","title":"System Boot Graphics Support","text":"<p>BootGraphicsLib is intended only to be used by BDS to draw the main boot graphics on the screen. (ex. the Microsoft logo).</p> <p>BootGraphicsProviderLib uses PCDs to retrieve BMP files from firmware volumes.</p> <pre><code>BootGraphicsLib|MsGraphicsPkg/Library/BootGraphicsLib/BootGraphicsLib.inf\nBootGraphicsProviderLib|OemPkg/Library/BootGraphicsProviderLib/BootGraphicsProviderLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#boot-manager-settings-access","title":"Boot Manager Settings Access","text":"<p>MsBootManagerSettingsLib provides get and set access for boot manager settings.</p> <pre><code>MsBootManagerSettingsLib|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#simple-window-manager-dialogs","title":"Simple Window Manager Dialogs","text":"<p>SwmDialogsLib enables the display of dialog boxes such as a password input box.</p> <pre><code>SwmDialogsLib|MsGraphicsPkg/Library/SwmDialogsLib/SwmDialogs.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#platform-specific-boot-policy","title":"Platform Specific Boot Policy","text":"<p>MsBootPolicyLib implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB).</p> <pre><code>MsBootPolicyLib|OemPkg/Library/MsBootPolicyLib/MsBootPolicyLib.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#ui-support","title":"UI Support","text":"<p>MsUiThemeLib Supplies the theme for this platform to the UEFI settings UI. UIToolKitLib initializes toolkit required for UI display.</p> <pre><code>MsUiThemeLib|MsGraphicsPkg/Library/MsUiThemeLib/Dxe/MsUiThemeLib.inf\nUIToolKitLib|MsGraphicsPkg/Library/SimpleUIToolKit/SimpleUIToolKit.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#security-support","title":"Security Support","text":"<p>ResetUtilityLib contains various helper functions for resetting the system. BaseBinSecurityLib is a NULL implementation of a library for initializing security cookies. SecurityLockAuditLib is another NULL implementation to satisfy compilation dependencies. The implemented version supplies necessary functions for logging hardware and software security locks.</p> <pre><code>ResetUtilityLib|MdeModulePkg/Library/ResetUtilityLib/ResetUtilityLib.inf\nBaseBinSecurityLib|MdePkg/Library/BaseBinSecurityLibNull/BaseBinSecurityLibNull.inf\nSecurityLockAuditLib|MdeModulePkg/Library/SecurityLockAuditLibNull/SecurityLockAuditLibNull.inf\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#pcds-included","title":"PCDs included","text":"<p>Set to TRUE so Console In (ConIn. ex. keyboard) is only connected once a console input is requested (ex. when a device is plugged).</p> <pre><code>gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|TRUE\n</code></pre> <p>Sets maximum printable number of characters to 16000</p> <pre><code>gEfiMdePkgTokenSpaceGuid.PcdUefiLibMaxPrintBufferSize|16000\n</code></pre> <p>Used to control the profiles available in the shell. 0x1f sets all profiles to available.</p> <pre><code>gEfiShellPkgTokenSpaceGuid.PcdShellProfileMask|0x1f     # All profiles\n</code></pre> <p>If TRUE, MsUiTheme is built in DXE. This should be TRUE for platforms that don't have a PPI (PEI module to PEI module Interface). Otherwise, the theme will be generated in PEI and it will be located on a HOB.</p> <pre><code>gMsGraphicsPkgTokenSpaceGuid.PcdUiThemeInDxe|TRUE\n</code></pre> <p>If TRUE, the Boot Manager will be in the boot order list.</p> <pre><code>gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerInBootOrder|TRUE\n</code></pre> <p>If TRUE, the BDS supports Platform Recovery</p> <pre><code>gEfiMdeModulePkgTokenSpaceGuid.PcdPlatformRecoverySupport|FALSE\n</code></pre> <p>Set to the guid associated with the Mu Frontpage.</p> <pre><code>gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ 0x8A, 0x70, 0x42, 0x40, 0x2D, 0x0F, 0x23, 0x48, 0xAC, 0x60, 0x0D, 0x77, 0xB3, 0x11, 0x18, 0x89 }\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_DSC_Include/#components","title":"Components","text":"<p>Spoofs button press to automatically boot to FrontPage.</p> <pre><code>OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf\n</code></pre> <p>Application that presents and manages FrontPage.</p> <pre><code>OemPkg/FrontPage/FrontPage.inf\n</code></pre> <p>Application that presents &amp; manages the Boot Menu Setup on Front Page.</p> <pre><code>OemPkg/BootMenu/BootMenu.inf\n</code></pre> <p>Enables MsBootPolicy. See the Platform Specific Boot Policy Library</p> <pre><code>PcBdsPkg/MsBootPolicy/MsBootPolicy.inf\n</code></pre> <p>A module which produces Boot Manager Policy protocol.</p> <pre><code>MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf\n</code></pre> <p>A regular expression library to support Remote/IT/Admin Settings such as DFCI.</p> <pre><code>MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf\n</code></pre> <p>Main component of DFCI which manages and enforces all DFCI settings</p> <pre><code>DfciPkg/SettingsManager/SettingsManagerDxe.inf {\n    # Platform should add all it settings libs here\n    &lt;LibraryClasses&gt;\n        NULL|ZeroTouchPkg/Library/ZeroTouchSettings/ZeroTouchSettings.inf\n        NULL|DfciPkg/Library/DfciPasswordProvider/DfciPasswordProvider.inf\n        NULL|DfciPkg/Library/DfciSettingsLib/DfciSettingsLib.inf\n        DfciSettingPermissionLib|DfciPkg/Library/DfciSettingPermissionLib/DfciSettingPermissionLib.inf\n        NULL|PcBdsPkg/Library/MsBootManagerSettingsDxeLib/MsBootManagerSettingsDxeLib.inf\n    &lt;PcdsFeatureFlag&gt;\n        gDfciPkgTokenSpaceGuid.PcdSettingsManagerInstallProvider|TRUE\n}\n</code></pre> <p>AuthManager provides authentication for DFCI.</p> <pre><code>DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf\n</code></pre> <p>Processes ingoing and outgoing DFCI settings requests</p> <pre><code>DfciPkg/DfciManager/DfciManager.inf\n</code></pre> <p>Manages windows and fonts to be drawn by the rendering engine</p> <pre><code>MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf\n</code></pre> <p>Produces EfiGraphicsOutputProtocol to draw graphics to the screen</p> <pre><code>MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf\n</code></pre> <p>Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one.</p> <pre><code>MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf\n</code></pre> <p>Driver for On Screen Keyboard.</p> <pre><code>MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf\n</code></pre> <p>Installs protocol to share the UI theme.</p> <pre><code>MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf\n</code></pre> <p>Produces gEdkiiFormDisplayEngineProtocolGuid protocol. Handles input, displays strings</p> <pre><code>MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf\n</code></pre> <p>Enables the Shell</p> <pre><code>ShellPkg/Application/Shell/Shell.inf {\n    &lt;LibraryClasses&gt;\n        NULL|ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf\n        NULL|ShellPkg/Library/UefiShellNetwork2CommandsLib/UefiShellNetwork2CommandsLib.inf\n    &lt;PcdsFixedAtBuild&gt;\n        gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE\n}\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/","title":"FDF Include File in Detail","text":"<p>This readme aims to describe FrontpageDsc.inc in detail, providing details and justification for the libraries and components included for Frontpage.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#preliminaries","title":"Preliminaries","text":""},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-an-fdf-file","title":"What is an FDF File","text":"<p>The .fdf filetype is an EDK2 Platform Description file format. The FDF file is used to describe the content and layout of binary images. It is used in conjunction with an EDK2 DSC file to generate bootable images, option ROM images, and update capsules for bootable images that comply with the UEFI specifications. To learn more about FDF files, look at the specification on the tianocore-docs github.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-an-inf-file","title":"What is an INF File","text":"<p>The .inf filetype is an EDK2 Platform Description file format. The INF file describes properties of a module, how it is coded, what it provides, what it depends on, architecture specific items, features, etc. regarding the module. To learn more about INF files, look at the specification on the tianocore-docs github.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#how-do-i-include-an-fdf-file","title":"How do I Include an FDF File","text":"<p>This file will be included in the DSC file for the platform being built. The syntax for including a file is:</p> <pre><code>!include path/to/fdf/inc/file\n</code></pre>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#what-is-dfci","title":"What is DFCI","text":"<p>From the feature document: The Device Firmware Configuration Interface (DFCI) brings new levels of security and usability to PC configuration management. It is a new feature of UEFI that enables secure programmatic configuration of hardware settings that are typically configured within a BIOS menu.</p>"},{"location":"dyn/mu_oem_sample/Docs/Frontpage_Includes/Frontpage_FDF_Include/#fdf-breakdown","title":"FDF Breakdown","text":"<p>This first line is a comment simply alerting the dev to include this file at some point under the [FV.FvMain] section of the platform FDF file.</p> <pre><code># Continuation of [FV.FvMain]\n</code></pre> <p>Finds and takes ownership of gEfiGraphicsOutputProtocolGuid so RenderingEngine can use it by uninstalling it on its current handle and reinstalling it on a new one.</p> <pre><code>INF MsGraphicsPkg/GopOverrideDxe/GopOverrideDxe.inf\n</code></pre> <p>AuthManager provides authentication for DFCI.</p> <pre><code>INF DfciPkg/IdentityAndAuthManager/IdentityAndAuthManagerDxe.inf\n</code></pre> <p>The main component of DFCI which manages and enforces all DFCI settings</p> <pre><code>INF DfciPkg/SettingsManager/SettingsManagerDxe.inf\n</code></pre> <p>Installs protocol to share the UI theme.</p> <pre><code>INF MsGraphicsPkg/MsUiTheme/Dxe/MsUiThemeProtocol.inf\n</code></pre> <p>Produces EfiGraphicsOutputProtocol to draw graphics to the screen</p> <pre><code>INF MsGraphicsPkg/RenderingEngineDxe/RenderingEngineDxe.inf\n</code></pre> <p>Produces gEdkiiFormDisplayEngineProtocolGuid protocol which handles input and displays strings</p> <pre><code>INF MsGraphicsPkg/DisplayEngineDxe/DisplayEngineDxe.inf\n</code></pre> <p>Application that presents &amp; manages the Boot Menu Setup on Front Page.</p> <pre><code>INF OemPkg/BootMenu/BootMenu.inf\n</code></pre> <p>Application that presents and manages FrontPage.</p> <pre><code>INF OemPkg/FrontPage/FrontPage.inf\n</code></pre> <p>Enables MsBootPolicy which implements the desired boot behavior when no UEFI boot options are present (or they failed) and a alternate boot has been requested (ex. booting from USB).</p> <pre><code>INF PcBdsPkg/MsBootPolicy/MsBootPolicy.inf\n</code></pre> <p>A module which produces Boot Manager Policy protocol.</p> <pre><code>INF MdeModulePkg/Universal/BootManagerPolicyDxe/BootManagerPolicyDxe.inf\n</code></pre> <p>A regular expression library to support Remote/IT/Admin Settings such as DFCI.</p> <pre><code>INF MdeModulePkg/Universal/RegularExpressionDxe/RegularExpressionDxe.inf\n</code></pre> <p>Processes ingoing and outgoing DFCI settings requests</p> <pre><code>INF DfciPkg/DfciManager/DfciManager.inf\n</code></pre> <p>Driver for On Screen Keyboard.</p> <pre><code>INF MsGraphicsPkg/OnScreenKeyboardDxe/OnScreenKeyboardDxe.inf\n</code></pre> <p>Spoofs button press to automatically boot to FrontPage.</p> <pre><code>INF OemPkg/FrontpageButtonsVolumeUp/FrontpageButtonsVolumeUp.inf\n</code></pre> <p>Manages windows and fonts to be drawn by the rendering engine</p> <pre><code>INF MsGraphicsPkg/SimpleWindowManagerDxe/SimpleWindowManagerDxe.inf\n</code></pre> <p>This final bit places the bmp files and shell.efi file within this firmware volume so they can be accessed by UEFI drivers.</p> <pre><code>  FILE APPLICATION=PCD(gPcBdsPkgTokenSpaceGuid.PcdShellFile) {\nSECTION PE32=$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/AARCH64/Shell.efi\n    SECTION UI= \"EdkShell\"\n}\nFILE FREEFORM = PCD(gOemPkgTokenSpaceGuid.PcdLogoFile) {\nSECTION RAW = OemPkg/FrontPage/Resources/BootLogo.bmp\n    SECTION UI = \"Logo\"\n}\nFILE FREEFORM = PCD(gOemPkgTokenSpaceGuid.PcdFrontPageLogoFile) {\nSECTION RAW = OemPkg/FrontPage/Resources/FrontpageLogo.bmp\n  }\nFILE FREEFORM = PCD(gOemPkgTokenSpaceGuid.PcdLowBatteryFile) {\nSECTION RAW = OemPkg/FrontPage/Resources/LBAT.bmp\n  }\nFILE FREEFORM = PCD(gOemPkgTokenSpaceGuid.PcdThermalFile) {\nSECTION RAW = OemPkg/FrontPage/Resources/THOT.bmp\n  }\n</code></pre>"},{"location":"dyn/mu_oem_sample/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_oem_sample/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_oem_sample/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_oem_sample/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_plus/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_plus/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_plus/RepoDetails/","title":"Project Mu Common Plus","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_plus.git Branch:         release/202208 Commit:         dd52b1b6a78d489e6e4088c78a754f304c799650 Commit Date:    2023-01-30 23:42:48 -0500</p> <p>This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. For full documentation.</p>"},{"location":"dyn/mu_plus/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_plus/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_plus/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_plus/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_plus/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/","title":"Advanced File Logger","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/#about","title":"About","text":"<p>The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services.</p> <p>An eligible file system is one with a Logs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem.</p> <p>To enable the Advanced File Logger, the following change is needed in the .dsc:</p> <pre><code>[Components.&lt;ArchOfDXE&gt;]\n  AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf\n</code></pre> <p>and the follow change is needed in the .fdf:</p> <pre><code>[Components.FV.&lt;YourFvDXE&gt;]\n  INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedFileLogger/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/","title":"Advanced Serial Logger","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/#about","title":"About","text":"<p>The Advanced Serial Logger starts, the memory log is flushed to the serial port. As more log is appended, the serial logger flushes it out to the serial port.</p> <p>To enable the Advanced Serial Logger, the following change is needed in the .dsc:</p> <pre><code>[Components.&lt;ArchOfDXE&gt;]\n  AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf\n</code></pre> <p>and the follow change is needed in the .fdf:</p> <pre><code>[Components.FV.&lt;YourFvDXE&gt;]\n  INF AdvLoggerPkg/AdvancedSerialLogger/AdvancedSerialLogger.inf\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/AdvancedSerialLogger/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/","title":"AdvLoggerPkg - DecodeUefiLog","text":"<p>DecodeUefiLog is used to get the Uefi debug log that is stored by UEFI in system memory.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#about","title":"About","text":"<p>Advanced Logger stores the debug log file in memory, with additional data for each line. At runtime, if the Advanced Logger is enabled, this in memory log is available through the UEFI Variable store. As the log in memory has additional metadata and alignment structure, DecodeUefiLog parses the on memory UefiLog to a text stream and writes the decoded log to a local file.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#usage","title":"Usage","text":"<p>Copy the two files, DecideUefiLog.py and UefiVariablesSupportLib.py, to the system that has the Advanced Logger enabled.</p> <p>The simplest case:</p> <pre><code>DecodeUefiLog -o NewLogFile.txt\n</code></pre> <p>Decode lines after a starting line number and send them to the file specified by -o:</p> <pre><code>  DecodeUefiLog -s 5000 -o NewLogFile.txt\n</code></pre> <p>Copy the raw in memory log to a binary file.</p> <pre><code>  DecodeUfieLog -r RawLog.bin\n</code></pre> <p>Decode a raw file into a text file:</p> <pre><code>  DecodeUefiLog -l RawLog.bin -o NewLogFIle.txt\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Application/DecodeUefiLog/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/","title":"AdvLoggerPkg - Advanced Logger Package","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#about","title":"About","text":"<p>The AdvancedLogger logs all debug messages into memory. At certain points, the log may be flushed to disk. The in memory log data is also available during runtime.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#configuration","title":"Configuration","text":"<p>The following configurations are supported:</p> Phase Usage DXE Only Uses DxeCore, DxeRuntime, and Dxe AdvancedLoggerLib libraries for logging from start of DXE CORE through Exit Boot Services.  Accepts the PEI Advanced Logger Hob if one is generated.  Produces the AdvancedLogger protocol. DXE+SMM Requires DXE modules above, and adds the Smm AdvancedLoggerLib library.  Collects SMM generated messages in the in memory log. PEI Uses PeiCore and Pei AdvancedLoggerLib libraries.  Creates the Advanced Logger Hob if PcdAdvancedLoggerPeiInRAM is set. SEC Uses the Sec Advanced Logger Library. SEC requires a fixed load address, so it piggy backs on the Temporary RAM PCD information.  Produces a Fixed Address temporary RAM log.  When memory is added, the Sec Advanced Logger library converts the Temporary RAM logging information to the PEI Advanced Logger Hob. PEI64 Uses Pei64 Advanced Logger Library. Requires the SEC fixed address temporary log information in order to log Pei64 bit DEBUG messages. MM Standalone MM - Loads during PEI phase. MMARM Standalone MM that loads prior to UEFI with a fixed memory block shared with UEFI. <p>PCD's used by Advanced Logger</p> PCD Function of the PCD PcdAdvancedLoggerForceEnable The default operation is to check if a Logs directory is present in the root of the filesystem.  If the UefiLogs directory is present, logging is enabled. When PcdAdvancedLoggerForceEnable is TRUE, and the device is not a USB device, a UefiLogs directory will be created and logging is enabled.  When logging is enabled, the proper log files will be created if not already preset. PcdAdvancedLoggerPeiInRAM For systems that have memory at PeiCore entry. The full in memory log buffer if PcdAdvancedLoggerPages is allocated in the Pei Core constructor and PcdAdvancedLoggerPreMemPages is ignored. PcdAdvancedLoggerFixedInRAM For systems that have a fixed memory buffer prior to UEFI. The full in memory log buffer is assumed. PcdAdvancedHdwLoggerDebugPrintErrorLevel The standard debug flags filter which log messages are produced.  This PCD allow a subset of log messages to be forwarded to the Hdw Port Lib. PcdAdvancedHdwLoggerDisable Specifies when to disable writing to the Hdw Port. PcdAdvancedLoggerPreMemPages Amount of temporary RAM used for the debug log. PcdAdvancedLoggerPages Amount of system RAM used for the debug log PcdAdvancedLoggerLocator When enabled, the AdvLogger creates a variable \"AdvLoggerLocator\" with the address of the LoggerInfo buffer"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#libraries","title":"Libraries","text":"<p>The following libraries are used with AdvancedLogger:</p> Library Function of the Library AdvancedLoggerAccessLib Used to access the memory log - used by FileLogger and Serial/Dxe/Logger AdvancedLoggerLib One per module type - used to provide access to the in memory log buffer AdvLoggerSmmAccessLib Used to intercept GetVariable in order to provide an OS utility the ability to read the log BaseDebugLibAdvancedLogger Basic Dxe etc DebugLib DebugAgent Used to intercept SEC initialization PeiDebugLibAdvancedLogger Basic Pei DebugLib AdvancedLoggerHdwPortLib Hook for a hardware port to capture debug messages as they are written to the log."},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#platform-notes","title":"Platform notes","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#ia32x64","title":"IA32/X64","text":"<p>The SEC version of the Advanced Logger uses the temporary RAM block. This block is fixed in size and location, and this temporary RAM block needs to be adjusted to make room for the Advanced Logger buffer. There may be cases where the processor cache size is too small to enable the Advanced Logger during SEC.</p> <p>The PEI versions of Advanced Logger work together to save space.  Rather than have the Debug Print libraries linked in all the PEIM's, only PEI_CORE has the Debug Print libraries. The PEI version of AdvancedLoggerLib uses the IDT to access a pointer to the PEI_CORE routines.</p> <p>The following changes are needed in the .dsc for IA32/X64.</p> <pre><code>[LibraryClasses.common]\n  DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf\n  AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf\n\n[LibraryClasses.IA32.SEC]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Sec/AdvancedLoggerLib.inf\n  DebugAgentLib|AdvLoggerPkg/Library/DebugAgent/Sec/AdvancedLoggerSecDebugAgent.inf\n\n[LibraryClasses.IA32.PEI_CORE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf\n\n[LibraryClasses.IA32.PEIM]\n  DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf\n\n[LibraryClasses.X64.PEIM]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei64/AdvancedLoggerLib.inf\n\n[LibraryClasses.X64]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf\n  AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf\n\n[LibraryClasses.X64.DXE_CORE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf\n\n[LibraryClasses.X64.DXE_SMM_DRIVER]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf\n\n[LibraryClasses.X64.SMM_CORE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Smm/AdvancedLoggerLib.inf\n\n[LibraryClasses.X64.DXE_RUNTIME_DRIVER]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf\n\n[PcdsFeatureFlag]\n## Build Example if your build environment differentiates customer builds from internal test builds\n!if $(SHIP_MODE) == FALSE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|TRUE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE\n!else\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerLocator|TRUE\n!endif\n</code></pre> <p>The following changes should be in the family .dsc where the processor specific changes are specified</p> <pre><code>[PcdsFixedAtBuild.common]\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages|24\n\n  #Advanced Logger configuration\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase         | 0xFA000000 # Must be TemporaryRamBase\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerCarBase      | 0xFA200000 # Address for CAR memory\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPreMemPages  | 256        # Size is 1MB\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages        | 1024       # Size is 4MB\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#arm-with-security-processor","title":"ARM with Security Processor","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#uefi","title":"UEFI","text":"<p>In this configuration, the Advanced Logger memory buffer is preallocated and setup from the BL31 (secure partition loader) at a known address. This simplifies SEC and PEI as memory has already been configured.</p> <p>Due to the memory block being at a known address, the SEC, PEI_CORE, and PEI modules link to the BaseArm version of AdvancedLoggerLib. While the BaseArm version includes the Debug Print libraries, it is assumed that there are few PEI components in the ARM with Security Processor configuration.</p> <pre><code>################################################################\n#\n# Advanced Logger Configurations\n#\n################################################################\n[LibraryClasses.common]\n  DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf\n  AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf\n  AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf\n  AdvancedLoggerAccessLib|AdvLoggerPkg/Library/AdvancedLoggerAccessLib/AdvancedLoggerAccessLib.inf\n\n[LibraryClasses.common.SEC]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf\n  AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf\n\n[LibraryClasses.common.PEI_CORE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/PeiCore/AdvancedLoggerLib.inf\n\n[LibraryClasses.common.PEIM]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Pei/AdvancedLoggerLib.inf\n  DebugLib|AdvLoggerPkg/Library/PeiDebugLibAdvancedLogger/PeiDebugLibAdvancedLogger.inf\n\n[LibraryClasses.common.DXE_DRIVER, LibraryClasses.common.UEFI_DRIVER, LibraryClasses.common.UEFI_APPLICATION]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Dxe/AdvancedLoggerLib.inf\n\n[LibraryClasses.common.DXE_CORE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/DxeCore/AdvancedLoggerLib.inf\n\n[LibraryClasses.common.DXE_RUNTIME_DRIVER]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/Runtime/AdvancedLoggerLib.inf\n\n[PcdsFeatureFlag]\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE\n\n  # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02).\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03\n</code></pre> <p>The following changes should be in the family .dsc where the processor specific changes are specified</p> <pre><code>[PcdsFixedAtBuild.common]\n  #Advanced Logger configuration\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase   | 0xFF622000 # Buffer address\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages  | 0x400      # Size is 4MB\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#mm-standalone-arm-with-security-processor","title":"MM Standalone Arm with security processor","text":"<p>In this configuration, the MM code needs to initialize the common buffer that was allocated from the BL31 (secure partition loader) in order to provide log messages prior to UEFI starting.</p> <pre><code>[LibraryClasses.common]\n  DebugLib|AdvLoggerPkg/Library/BaseDebugLibAdvancedLogger/BaseDebugLibAdvancedLogger.inf\n  AssertLib|AdvLoggerPkg/Library/AssertLib/AssertLib.inf\n  AdvancedLoggerHdwPortLib|AdvLoggerPkg/Library/AdvancedLoggerHdwPortLib/AdvancedLoggerHdwPortLib.inf\n\n[LibraryClasses.common.MM_CORE_STANDALONE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/MmCoreArm/AdvancedLoggerLib.inf\n\n[LibraryClasses.common.MM_STANDALONE]\n  AdvancedLoggerLib|AdvLoggerPkg/Library/AdvancedLoggerLib/BaseArm/AdvancedLoggerLib.inf\n  AdvLoggerAccessLib|AdvLoggerPkg/Library/AdvLoggerMmAccessLib/AdvLoggerMmAccessLib.inf\n\n[PcdsFeatureFlag]\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerForceEnable|FALSE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerLocator|TRUE\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerFixedInRAM|TRUE\n  # Set AdvLogger to flush at ReadyToBoot (0x01) and at ExitBootServices (0x02).\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedFileLoggerFlush|0x03\n\n[PcdsFixedAtBuild.common]\n  #Advanced Logger configuration\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerBase   | 0xFF622000 # Buffer address\n  gAdvLoggerPkgTokenSpaceGuid.PcdAdvancedLoggerPages  | 0x400      # Size is 4MB\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#advanced-file-logger","title":"Advanced File Logger","text":"<p>The Advanced File Logger monitors for file systems mounted during boot. When an eligible file system is detected, the log is flushed to the file system. The log is flushed if the system is reset during POST, and at Exit Boot Services.</p> <p>An eligible file system is one with a UefiLogs directory in the root of the file system. If no log files are present, the Advanced File Logger will create a log index file which contains the index of the last log file written, and nine log files each PcdAdvancedLoggerPages in size. These files are pre allocated at one time to reduce interference with other users of the filesystem.</p> <p>To enable the Advanced File Logger, the following change is needed in the .dsc:</p> <pre><code>[Components.&lt;YourFvDXE&gt;]\n  AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf\n</code></pre> <p>and the follow change is needed in the .fdf:</p> <pre><code>[Components.FV.&lt;YourFvDXE&gt;]\n  INF AdvLoggerPkg/AdvancedFileLogger/AdvancedFileLogger.inf\n</code></pre>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#hardware-logging-level","title":"Hardware Logging Level","text":"<p>The v3 data header supports a new field of hardware debugging level to support setting the serial print configurable during boot time.</p> <p>The default value will be initialized to the value of <code>PcdAdvancedLoggerHdwPortDebugPrintErrorLevel</code> in the PEI core, DXE core, or MM core, whichever comes first during the boot process.</p> <p>To override the initialized hardware print level, user needs to first get the advanced logger info region, this could be done, depending on the boot phase of consumer, through the <code>PcdAdvancedLoggerBase</code> in SEC phase and/or if <code>PcdAdvancedLoggerFixedInRAM</code> is set, or <code>gAdvancedLoggerHobGuid</code> HOB if setup in PEI phase.</p> <p>Note: This change will require all the firmware entities to update to v3 of advanced logger together. Torn state will result in hardware printing not functional.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/Docs/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/","title":"Verify Line Parser function for development","text":"<p>This test is to model the Line Parser in the AdvancedFileLogger.</p> <p>The internal message log is in units of DEBUG(()).  While most messages are a complete and end with a '\\n', there are some debug messages that are built with multiple DEBUG(()) operations.</p> <p>The line parser builds a debug line by copying one or more DEBUG(()) segments into a line, and prepends the time stamp.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#about","title":"About","text":"<p>These tests verify that the LineParser is functional.</p>"},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#lineparsertestapp","title":"LineParserTestApp","text":""},{"location":"dyn/mu_plus/AdvLoggerPkg/UnitTests/LineParser/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/","title":"HID support package","text":""},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#about","title":"About","text":"<p>The purpose of this package is to provide a generic Boot HID layer that can be used so that devices that implement the Boot Mouse and Boot Keyboard HID interfaces defined in the USB 1.1 spec can share a common HID processing layer.</p> <p>This avoids duplication of the HID parsing/processing code and provides a natural interface layer where various HID-supporting hardware can plug into the UEFI input stack.</p> <p></p> <p>Adding support for new hardware that wants to plug into HID Keyboard or Mouse simply requires implementing HidKeyboardProtocol or HidMouseProtocol and installing instances of those protocols on the controller handle for the hardware.</p> <p>This greatly simplifies the process of supporting hardware that is already designed to support Boot Mouse or Boot Keyboard HID spec, since such hardware is already producing reports in the same format that the HidKeyboardProtocol or HidMouseProtocol expects.</p>"},{"location":"dyn/mu_plus/HidPkg/Docs/Readme/#integration-guide","title":"Integration Guide","text":"<p>To use the HidPkg, include the following drivers in your build:</p> <p>FDF:</p> <pre><code>#HID Support\nINF HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf\nINF HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf\n</code></pre> <p>DSC:</p> <pre><code>#HID Support\n  HidPkg/HidKeyboardDxe/HidKeyboardDxe.inf\n  HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe.inf\n</code></pre> <p>Then, include low-level drivers that produce the HID protocols. This package includes two sample drivers for USB keyboard and Mouse that can be used in place of the standard USB keyboard and Mouse drivers. A platform may add additional drivers to support proprietary hardware such as keyboards/track pads/ touchscreens that support the HID protocol definitions in this package.</p> <p>To include the sample USB HID drivers, remove the MdeModulePkg versions and replace them with the sample drivers from this package.</p> <p>FDF:</p> <pre><code>-INF MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf\n-INF MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf\n+INF HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf\n+INF HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf\n</code></pre> <p>DSC:</p> <pre><code>-  MdeModulePkg/Bus/Usb/UsbKbDxe/UsbKbDxe.inf\n-  MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf\n+  HidPkg/UsbKbHidDxe/UsbKbHidDxe.inf\n+  HidPkg/UsbMouseHidDxe/UsbMouseHidDxe.inf\n</code></pre>"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/","title":"Description","text":"<p>This driver produces an instances of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX for keyboard support in UEFI</p> <p>It registers a callback with devices exposing the HID_KEYBOARD_PROTOCOL to receive Keyboard HID reports, which are used to satisfy the contract of SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX.</p>"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#provides","title":"Provides","text":"<p>SIMPLE_TEXT_INPUT/SIMPLE_TEXT_INPUT_EX instance for consumption by UEFI console.</p>"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#dependencies","title":"Dependencies","text":"<p>HID_KEYBOARD_PROTOCOL to register for and receive HID Keyboard Reports.</p>"},{"location":"dyn/mu_plus/HidPkg/HidKeyboardDxe/HidKeyboardDxe/#application","title":"Application","text":"<p>Used to enable PreBoot Keyboard Support.</p>"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/","title":"HID Mouse Absolute Pointer DXE","text":""},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#description","title":"Description","text":"<p>This driver produces an instance of EFI_ABSOLUTE_POINTER_PROTOCOL for mouse support in UEFI</p> <p>It registers a callback with the devices exposing HID_POINTER_PROTOCOL to receive Mouse HID reports, which are used to satisfy the contract of EFI_ABSOLUTE_POINTER_PROTOCOL.</p>"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#provides","title":"Provides","text":"<p>EFI_ABSOLUTE_POINTER_PROTOCOL instance for consumption by UEFI console.</p>"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#dependencies","title":"Dependencies","text":"<p>HID_POINTER_PROTOCOL to register for and receive HID Mouse Reports.</p>"},{"location":"dyn/mu_plus/HidPkg/HidMouseAbsolutePointerDxe/HidMouseAbsolutePointerDxe/#application","title":"Application","text":"<p>Used to enable PreBoot Mouse Support.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/","title":"Manufacturer Firmware Configuration Interface (MFCI)","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#overview","title":"Overview","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#in-a-sentence","title":"In a Sentence","text":"<p>Manufacturer Firmware Configuration Interface (MFCI) is a UEFI BIOS feature that provides a secure mechanism for an authorized agent, such as an OEM or ODM, to modify firmware security properties of a specific device, typically for the purposes of remanufacturing or refurbishment.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#background","title":"Background","text":"<p>Manufacturing and remanufacturing (refurbishment) of devices requires configuration of settings related to safety (batteries, thermals), compliance (radio calibration, anti-theft), licensing (OA3, serial numbers), &amp; security.  These sensitive settings are typically secured by the OEM / ODM at end of manufacturing to ensure that they are not modified with malicious intent. During initial manufacturing, a device is typically not secured until the final provisioning station, after calibration and other secure data have been provisioned.  After a device is secured, product demand may deviate from forecasts and a device may need to be reprovisioned for a different region, requiring modification of secured settings.  Remanufacturing of devices requires executing tools and workflows that bypass this security, allowing modification of these sensitive settings, and performing potentially destructive diagnostics.  The Windows 10X Compatibility Requirements prohibit unauthorized execution of these dangerous tools. The MFCI feature provides a secure path to enable remanufacturing while maintaining the Windows 10X security promise.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#building-an-end-to-end-mfci-solution","title":"Building an End-to-End MFCI Solution","text":"<p>An MFCI-based solution requires:</p> <ol> <li>Devices with MFCI integrated into their UEFI BIOS</li> <li>An authority that produces signed MFCI policy blobs, for example, Microsoft's cloud MFCI service from Hardware Dev Center</li> <li>A manufacturer process that connects the MFCI-enabled device to an MFCI policy service</li> </ol> <p>The Project Mu MfciPkg provides the reference code to enable device-side UEFI BIOS, and includes examples of signing authorities &amp; processes needed to implement a solution.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#a-remanufacturing-example","title":"A Remanufacturing Example","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#conceptual-workflow","title":"Conceptual Workflow","text":"<ol> <li>Determine the desired 64-bit MFCI policy to be applied to the device based upon the type of remanufacturing to be performed (see MFCI Structures for more information)</li> <li>Read targeting information stored in OS-visible UEFI variables from the device</li> <li>Combine the 64-bit MFCI policy and targeting information to construct an unsigned MFCI blob</li> <li>Digitally sign the MFCI blob using the specified digital signing format and trusted signing keys</li> <li>Write the signed MFCI Policy blob to the \"next\" policy blob mailbox (a UEFI variable) on the target device</li> <li>Reboot the target device to trigger an installation attempt    Prior to OS launch, UEFI attempts to verify the digital signature and targeting information<ul> <li>If verification fails, the policy is deleted from the \"next\" policy blob mailbox, and the device proceeds with boot to the OS</li> <li>If verification succeeds, MFCI policy is applied:<ol> <li>Callbacks are notified to perform any 1-time actions</li> <li>Designated action bit ranges are cleared from the policy</li> <li>If the policy contains persistent states, it is moved to the \"current\" policy blob mailbox, otherwise it is     deleted from the \"next\" policy blob mailbox</li> <li>The device reboots for the new policy to take effect</li> <li>The device's UEFI code should now modify its behavior based upon the persistent state bits or device changes     resulting from the 1-time actions</li> </ol> </li> </ul> </li> <li>If a persistent MFCI Policy was installed, it is removed by deleting the \"current\" policy blob mailbox</li> </ol>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#example-workflow-using-microsoft-tools-services","title":"Example Workflow Using Microsoft Tools &amp; Services","text":"<ol> <li>Boot device to FFU mode</li> <li>Use Microsoft-supplied tool ImageUtility.exe to read the targeting variables from the device</li> <li>Use Microsoft Hardware Dev Center (web portal or REST APIs) to generate the signed policy<ol> <li>Authenticate from an authorized account</li> <li>Supply the targeting and policy parameters</li> <li>Receive the signed MFCI Policy blob for your device</li> </ol> </li> <li>Use the Microsoft-supplied tool ImageUtility.exe to set the signed policy blob to a mailbox</li> <li>Reboot, and the new policy should take effect</li> <li>OEM performs customer service or re-manufacturing as needed. Note that if the device make, model, serial number, or related UEFI variables change or are deleted, the policy may no longer be valid on subsequent boots.</li> <li>After re-manufacturing, remove the policy using MS-supplied tool ImageUtility.exe to delete the policy</li> </ol>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Feature/#deep-dives","title":"Deep Dives","text":"<ul> <li>MFCI Structures</li> <li>UEFI Integration Guide</li> <li>End to End Testing Guide</li> </ul>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/","title":"MFCI UEFI Integration Guide","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#mfcipkg-provides","title":"MfciPkg Provides","text":"<ul> <li>a structure for encoding a manufacturer policy that is bound to a specific device and usage instance (they are 1-time use)</li> <li>a definition of the structure's digital signature format, authentication &amp; authorization</li> <li>a test certificate and private key for development &amp; testing</li> <li>a production Microsoft certificate and Enhanced Key Usage for authorizing Microsoft's cloud MFCI service</li> <li>a manufacturing-line-facing UEFI interface, based upon UEFI variables, that supports creation, installation, and     removal of policies</li> <li>a UEFI-implementor-facing UEFI interface that reports the in-effect policy and notifications of policy changes</li> <li>a reference UEFI implementation that handles the authentication, target validation, and structure parsing, translating signed policy blobs into actionable 64-bit policies</li> <li>examples of policy change handlers for Secure Boot Clear and TPM Clear</li> <li>tests including data and scripts that simulate the manufacturer unlock process</li> </ul>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#uefi-integration-overview","title":"UEFI Integration Overview","text":"<ol> <li>Include MfciPkg and its dependencies in your platform</li> <li>Author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values.  These variables MUST be set prior the EndOfDxe event.</li> <li>Where applicable to your platform, leverage MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes</li> </ol>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-mfcipkg-and-dependencies","title":"Including MfciPkg and dependencies","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#fdf","title":"FDF","text":"<p>Add the following to your EDK2 Flash Descriptor File (FDF)</p> <pre><code>INF  MfciPkg/MfciDxe/MfciDxe.inf\n</code></pre> <pre><code>INF  MfciPkg/MfciPei/MfciPei.inf\n</code></pre>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#dsc","title":"DSC","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-modules","title":"Including Modules","text":"<p>MfciPkg provides a <code>.dsc.inc</code> that can be <code>!include</code> in your platform DSC. An example follows:</p> <pre><code>!include MfciPkg/MfciPkg.dsc.inc\n</code></pre> <p>Additionally, an instance of MfciRetrievePolicyLib will need to be specified. The default instance of MfciRetrievePolicyLibNull must be overridden. Two other instances are available in the MfciPkg, or a custom version can be authored.</p> <pre><code>  MfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaHob/MfciRetrievePolicyLibViaHob.inf\nMfciRetrievePolicyLib|MfciPkg/Library/MfciRetrievePolicyLibViaVariable/MfciRetrievePolicyLibViaVariable.inf\n</code></pre>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#including-pkcs-certificates","title":"Including Pkcs Certificates","text":"<p>Mfci Policy Blobs need to be digitally signed for the system to consume their data. The public portion of the Public/Private key needs to be included into for the MfciPkg to be able to verify policy blobs. This is done through the PCDs PcdMfciPkcs7CertBufferXdr.</p> <p>To help convert the Mfci Pkcs certificate into a PCD, the BinToPcd.py in MU_BASECORE can be used. Using BinToPcd.py will ensure that the public key is properly formatted into RFC 4506 External Data Representation Standard.</p> <pre><code>MU_BASECORE/BaseTools/Scripts/BinToPcd.py -i &lt;PublicKey.cer&gt; -o &lt;Output.inc&gt; -p gMfciPkgTokenSpaceGuid.PcdMfciPkcs7CertBufferXdr -x\n</code></pre> <p>Additionally, PcdMfciPkcs7RequiredLeafEKU needs to be filled out with the Extended Key Usage information. The leaf EKU is used as an additional check during policy blob validation. Failure to include the correct EKU leaf will result in the policy blob being rejected.</p> <p>The below examples are from the Unit Test portion of this package. The Unit Test implementation can be followed to see how to convert a certificate into a binary pcd, and how to add the Extended Key Usage string into the PCD.</p> <pre><code>  DEFINE  MFCI_POLICY_EKU_TEST   = \"1.3.6.1.4.1.311.45.255.255\"\n\n# the unit test uses the test certificate that will also be used for testing end-to-end scenarios\n!include MfciPkg/Private/Certs/CA-test.dsc.inc\ngMfciPkgTokenSpaceGuid.PcdMfciPkcs7RequiredLeafEKU  |$(MFCI_POLICY_EKU_TEST)   # use the test version\n</code></pre> <p>When using <code>!include MfciPkg/MfciPkg.dsc.inc</code>, please ensure the platform pcds for  <code>PcdMfciPkcs7RequiredLeafEKU</code> and <code>PcdMfciPkcs7RequiredLeafEKU</code> are included after the <code>MfciPkg.dsc.inc</code></p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#mfcipkg-dependencies","title":"MfciPkg Dependencies","text":"<ul> <li>Variable Policy</li> <li>Variable policy is used to protect MFCI's security data (UEFI variables) from malicious tampering</li> <li>EDK2's SecureBootVariableLib, specifically:</li> <li><code>DeleteSecureBootVariables()</code></li> <li>EDK2's BaseCryptLib, specifically:</li> <li><code>Pkcs7GetAttachedContent()</code></li> <li><code>Pkcs7Verify()</code></li> <li><code>VerifyEKUsInPkcs7Signature()</code></li> </ul>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#populating-device-targeting-variables","title":"Populating Device Targeting Variables","text":"<p>An integrator must author code that sets the MFCI Per-Device Targeting Variable Names with the manufacturer, product, serial number, and optional OEM targeting values.  These variables MUST be set prior the EndOfDxe event.</p> <p>See the header file for type information on these variables, they must exactly match the contents of policies for targeting to successfully match them.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#take-action-based-upon-mfci-policy-changes","title":"Take action based upon MFCI Policy &amp; changes","text":"<p>The final piece of code integration is to enumerate the list of behaviors and actions to be supported, and activate their code by calling either MFCI's PEI and/or DXE interfaces to synchronously query the in-effect MFCI policy, or register callbacks for notification of MFCI policy changes.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#state-machine","title":"State Machine","text":"<p>MfciPkg's public interface defines UEFI variable mailboxes for installing and removing policy blobs, see MFCI Per-Device Targeting Variable Names</p> <p>A machine with no policy blob installed is deemed to have have a configuration policy value of 0x0 and is said to be running in the default customer mode, typically the most secure state with all security enabled.</p> <p>There are 2 groups of mailboxes prefixed with <code>Current...</code> and <code>Next...</code>.  The <code>Current...</code> mailboxes represent the policy in effect for the current boot.  The <code>Next...</code> mailboxes are used for queuing installation of a new policy.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Integration_Guide/#boot-timeline-example","title":"Boot Timeline Example","text":"<ol> <li>PEI<ol> <li>PEI is considered too early in the boot root of trust to perform policy blob validation. A pre-validated, cached     copy of configuration policy is available to PEI modules via the PEI     interface. Policy will not change in the PEI phase, so a policy change notification is not part of the PEI     interface. If a policy change occurs later in boot, the platform is guaranteed to reboot prior to the BDS phase.</li> </ol> </li> <li>DXE prior to StartOfBds<ol> <li>Drivers that need security policy augmentation should both get the current pre-verified policy and register for notification of policy changes</li> <li>OEM-supplied code populates UEFI variables that communicate the Make, Model, &amp; SN targeting information to MFCI policy driver</li> </ol> </li> <li>StartOfBds event<ol> <li>The MFCI Policy Driver will...<ol> <li>Check for the presence of a policy.  If present...<ol> <li>Verify its signature, delete the policy on failure</li> <li>Verify its structure, delete the policy on failure</li> <li>If the resulting policy is different from the current policy, notify registered handlers, make the new policy active, reboot</li> </ol> </li> <li>If a next policy is not present, and a pre-verified policy was used for this boot, roll nonces, delete the pre-verified policy, &amp; notify registered handlers</li> </ol> </li> </ol> </li> </ol>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/","title":"MFCI Structures","text":""},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#policy","title":"Policy","text":"<p>MFCI provides 64 bits of configuration policy, 32 bits to be defined by Microsoft, 32 bits reserved for OEM definition. Each 32-bit range is split into two 16-bit ranges, one for state that persists across reboots for the duration a policy is installed, and one for 1-time actions that are triggered once at policy installation. Example actions include Microsoft-defined Secure Boot clear and TPM clear. An example state might be \"OEM Manufacturing Mode foo\", which enables modification of secure configuration.  </p> <p>Structure Definition</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#policy-blob","title":"Policy Blob","text":"<p>An MFCI policy blob is a structure that contains the aforementioned 64-bit configuration policy, along with device targeting information including OEM, model, serial number, 2 OEM-defined fields, &amp; a security nonce.  </p> <p>To prevent tampering and provide authentication &amp; authorization, MFCI policy blobs are digitally signed using the attached, embedded PKCS7 format (not the detached format as is used elsewhere in UEFI). Authentication of MFCI blobs leverages both a trust anchor public certificate that must be present in the blob's signing chain, and an Enhanced Key Usage (EKU) that must be present on the leaf certificate signer. By default, MfciPkg trusts a provided test certificate chain when <code>SHIP_MODE==FALSE</code>, otherwise the certificate and EKU specified by the Microsoft MFCI cloud signing service.</p> <p>At runtime, a UEFI implementor may consider the policy blobs to be opaque, as MfciPkg's private parsing lib handles the task of authenticating, verifying targeting, and parsing the blobs down to the 64-bit policies.</p> <p>For the purpose of testing, a python library and commandline wrappers are provided to facilitate creation of unsigned MFCI policies. After the policies are created, they will still need to be signed.</p> <ul> <li>https://github.com/tianocore/edk2-pytool-library/blob/master/docs/features/windows_firmware_policy.md</li> <li>https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_firmware_policy_tool.md</li> </ul>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#targeting-information","title":"Targeting Information","text":"<p>Policies are targeted at specific devices via Make (OEM), Model, Serial Number, Nonce, and 2 optional, OEM-defined fields.  The Nonce is a randomly-generated 64-bit integer, and the remaining fields are unescaped, WIDE NULL-terminated UTF-16LE strings.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#digital-signature","title":"Digital Signature","text":"<p>The PKCS7 digital signature format familiar to the UEFI ecosystem is used with 2 key differences. First, a full PKCS7 is used, not the SignedData subset used by authenticated variables.  Second, the P7 is embedded, not detached.  The policy targeting and flavor information are embedded in a PKCS 7 Data inside the full PKCS 7 Signed object.</p>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#signing-key","title":"Signing Key","text":"<p>To digitally sign a policy blob, a public/private key combination is required.  The scripts used to generate test signing keys are included in this repo for reference. Please note that the EKU needs to include OID <code>1.3.6.1.5.5.7.3.3</code> as well as the user designed leaf EKU that is used as an additional test.  This second EKU must be set in pcd <code>PcdMfciPkcs7RequiredLeafEKU</code>.</p> <ul> <li>Windows Power Shell Script</li> <li>Windows Batch Script</li> </ul>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#example-signing","title":"Example signing","text":"<p>Signtool is available in Windows Kits and can be used to sign the policy blob.</p> <p>After the policy blob is created, sign tool can be called, as in the below example. The signed policy blob has a .p7 extension, and this is the file that should be place into the MfciNext variable.</p> <pre><code>    c:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\bin\\\\10.0.17763.0\\\\x64\\\\signtool.exe\nsign \n/fd SHA256 \n/p7 .\n/p7co 1.2.840.113549.1.7.1\n/p7ce Embedded\n/f &lt;pfx file of leaf key&gt;.pfx\n/v /debug \n/p &lt;password used to secure the leaf key pfx file&gt;\n&lt;input policy&gt;.bin\n</code></pre>"},{"location":"dyn/mu_plus/MfciPkg/Docs/Mfci_Structures/#signed-packet-example","title":"Signed Packet Example","text":"<p>Output of running certutil.exe  on a signed MFCI Policy packet (signed). <code>certutil.exe -asn</code></p> <pre><code>0000: 30 82 0e 6c                               ; SEQUENCE (e6c Bytes)\n0004:    06 09                                  ; OBJECT_ID (9 Bytes)\n0006:    |  2a 86 48 86 f7 0d 01 07  02\n         |     ; 1.2.840.113549.1.7.2 PKCS 7 Signed\n000f:    a0 82 0e 5d                            ; OPTIONAL[0] (e5d Bytes)\n0013:       30 82 0e 59                         ; SEQUENCE (e59 Bytes)\n0017:          02 01                            ; INTEGER (1 Bytes)\n0019:          |  01\n001a:          31 0f                            ; SET (f Bytes)\n001c:          |  30 0d                         ; SEQUENCE (d Bytes)\n001e:          |     06 09                      ; OBJECT_ID (9 Bytes)\n0020:          |     |  60 86 48 01 65 03 04 02  01\n               |     |     ; 2.16.840.1.101.3.4.2.1 sha256 (sha256NoSign)\n0029:          |     05 00                      ; NULL (0 Bytes)\n002b:          30 82 02 17                      ; SEQUENCE (217 Bytes)\n002f:          |  06 09                         ; OBJECT_ID (9 Bytes)\n0031:          |  |  2a 86 48 86 f7 0d 01 07  01\n               |  |     ; 1.2.840.113549.1.7.1 PKCS 7 Data\n003a:          |  a0 82 02 08                   ; OPTIONAL[0] (208 Bytes)\n003e:          |     04 82 02 04                ; OCTET_STRING (204 Bytes)\n</code></pre> <p>[policy payload starts here]</p> <pre><code>0042:          |        02 00 01 00 00 00 08 f8  e6 5a 84 83 b9 4e a2 3a  ; .........Z...N.:\n0052:          |        0c cc 10 93 e3 dd 00 00  00 00 00 00 00 00 07 00  ; ................\n0062:          |        00 00 10 ef 00 00 00 00  0e 00 00 00 28 00 00 00  ; ............(...\n0072:          |        00 00 10 ef 58 00 00 00  66 00 00 00 76 00 00 00  ; ....X...f...v...\n0082:          |        00 00 10 ef 8e 00 00 00  9c 00 00 00 b6 00 00 00  ; ................\n0092:          |        00 00 10 ef e0 00 00 00  ee 00 00 00 fc 00 00 00  ; ................\n00a2:          |        00 00 10 ef 0e 01 00 00  1c 01 00 00 2a 01 00 00  ; ............*...\n00b2:          |        00 00 10 ef 2e 01 00 00  3c 01 00 00 48 01 00 00  ; ........&lt;...H...\n00c2:          |        00 00 10 ef 52 01 00 00  5c 01 00 00 6a 01 00 00  ; ....R...\\...j...\n00d2:          |        0c 00 54 00 61 00 72 00  67 00 65 00 74 00 18 00  ; ..T.a.r.g.e.t...\n00e2:          |        4d 00 61 00 6e 00 75 00  66 00 61 00 63 00 74 00  ; M.a.n.u.f.a.c.t.\n00f2:          |        75 00 72 00 65 00 72 00  00 00 2c 00 43 00 6f 00  ; u.r.e.r...,.C.o.\n0102:          |        6e 00 74 00 6f 00 73 00  6f 00 20 00 43 00 6f 00  ; n.t.o.s.o. .C.o.\n0112:          |        6d 00 70 00 75 00 74 00  65 00 72 00 73 00 2c 00  ; m.p.u.t.e.r.s.,.\n0122:          |        20 00 4c 00 4c 00 43 00  0c 00 54 00 61 00 72 00  ;  .L.L.C...T.a.r.\n0132:          |        67 00 65 00 74 00 0e 00  50 00 72 00 6f 00 64 00  ; g.e.t...P.r.o.d.\n0142:          |        75 00 63 00 74 00 00 00  14 00 4c 00 61 00 70 00  ; u.c.t.....L.a.p.\n0152:          |        74 00 6f 00 70 00 20 00  46 00 6f 00 6f 00 0c 00  ; t.o.p. .F.o.o...\n0162:          |        54 00 61 00 72 00 67 00  65 00 74 00 18 00 53 00  ; T.a.r.g.e.t...S.\n0172:          |        65 00 72 00 69 00 61 00  6c 00 4e 00 75 00 6d 00  ; e.r.i.a.l.N.u.m.\n0182:          |        62 00 65 00 72 00 00 00  26 00 46 00 30 00 30 00  ; b.e.r...&amp;.F.0.0.\n0192:          |        31 00 33 00 2d 00 30 00  30 00 30 00 32 00 34 00  ; 1.3.-.0.0.0.2.4.\n01a2:          |        33 00 35 00 34 00 36 00  2d 00 58 00 30 00 32 00  ; 3.5.4.6.-.X.0.2.\n01b2:          |        0c 00 54 00 61 00 72 00  67 00 65 00 74 00 0c 00  ; ..T.a.r.g.e.t...\n01c2:          |        4f 00 45 00 4d 00 5f 00  30 00 31 00 00 00 0e 00  ; O.E.M._.0.1.....\n01d2:          |        4f 00 44 00 4d 00 20 00  46 00 6f 00 6f 00 0c 00  ; O.D.M. .F.o.o...\n01e2:          |        54 00 61 00 72 00 67 00  65 00 74 00 0c 00 4f 00  ; T.a.r.g.e.t...O.\n01f2:          |        45 00 4d 00 5f 00 30 00  32 00 00 00 00 00 0c 00  ; E.M._.0.2.......\n0202:          |        54 00 61 00 72 00 67 00  65 00 74 00 0a 00 4e 00  ; T.a.r.g.e.t...N.\n0212:          |        6f 00 6e 00 63 00 65 00  05 00 ef cd ab 89 67 45  ; o.n.c.e.......gE\n0222:          |        23 01 08 00 55 00 45 00  46 00 49 00 0c 00 50 00  ; #...U.E.F.I...P.\n0232:          |        6f 00 6c 00 69 00 63 00  79 00 05 00 03 00 00 00  ; o.l.i.c.y.......\n0242:          |        00 00 00 00                                       ; ....\n</code></pre> <p>[policy payload ends here]</p> <p>[digital signature continues but is not shown here]</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/","title":"MFCI Device ID Support Library: NULL interface","text":""},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/#about","title":"About","text":"<p>Platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in <code>MfciVariables.h</code>.  Alternatively, then can implement this library. MfciDxe will invoke this library if it cannot find variables just before EndOfDxe.</p> <p>Refer to <code>MfciPkg/Include/MfciVariables.h</code>, \"Targeting Variable Names\" for additional details on the strings to return.</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/","title":"MFCI Device ID Support Library: SMBIOS instance example","text":""},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#background","title":"Background","text":"<p>MFCI-compatible platforms MUST publish MFCI targeting information prior to EndOfDxe. They may do so by either setting all of the Per-Device Targeting Variables declared in <code>MfciVariables.h</code>.  Alternatively, then can implement an instance of MFCI Device ID Support Library.</p> <p>Refer to <code>MfciDeviceIdSupportLib.h</code> for this library's interface.</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#about","title":"About","text":"<p>This example instance of MfciDeviceIdSupportLib leverages <code>EFI_SMBIOS_PROTOCOL</code> to implement the library interface. This library is invoked by MfciDxe in an event that triggers immediately prior to EndOfDxe, and expects all SMBIOS values leveraged to be populated with correct MFCI targeting values at that time.  A platform might accomplish this by populating SMBIOS values in another driver's entry point, constructor, or in an event upon arrival of <code>EFI_SMBIOS_PROTOCOL</code>.</p> <p>To leverage this library, add the following to your platform DSC:</p> <pre><code>[LibraryClasses]\nMfciDeviceIdSupportLib|MfciPkg/Library/MfciDeviceIdSupportLibSmbios/MfciDeviceIdSupportLibSmbios.inf\n</code></pre>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciDeviceIdSupportLibSmbios/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/","title":"MfciRetrievePolicyLib: NULL edition","text":""},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/#about","title":"About","text":"<p>Platforms are not generally expected to implement this library, as MFCI carries known implementations, thus it's header is under MfciPkg/Private/... This library abstracts where MfciDxe retrieves the cached, current policy. On platforms with a PEI phase, it may retrieve the policy from a HOB. On platforms that lack a PEI phase, it may retrieve the policy from a UEFI variable.</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/","title":"MfciRetrievePolicyLib: HOB edition","text":""},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/#about","title":"About","text":"<p>This library implements retrieving the current, cached policy from a HOB.</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaHob/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/","title":"MfciRetrievePolicyLib: UEFI variable edition","text":""},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/#about","title":"About","text":"<p>This library implements retrieving the current, cached policy from a UEFI variable.</p>"},{"location":"dyn/mu_plus/MfciPkg/Library/MfciRetrievePolicyLibViaVariable/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/","title":"ACPI RGRT","text":""},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#about","title":"About","text":"<p>The Regulatory Graphics Resource Table is an entry into the ACPI table. It provides a way to publish a PNG with the regulatory information of a given product. This could include FCC id, UL, Model number, or CMIIT ID just to name a few. This driver publishes that entry in the ACPI table to be picked up by the OS later to display for regulatory reasons.</p>"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#the-table-definition","title":"The table definition","text":"<p>The format of the table is defined by a pending addition to the ACPI spec here:</p> <p></p> <p>and consists of a standard ACPI header along with an RGRT payload. At time of writing, the only image format supported by RGRT is PNG.</p>"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#using-in-your-project","title":"Using in your project","text":"<p>Using this is as simple as including the INF in both your DSC and FDF. You will also need to define the PCD you use in the FDF file in your DEC file.</p> <p>DSC:</p> <pre><code>[Components]\n  MsCorePkg/AcpiRGRT/AcpiRgrt.inf\n</code></pre> <p>FDF:</p> <pre><code>[FV.FVDXE]\n\n# Regulatory Graphic Driver\nINF MsCorePkg/AcpiRGRT/AcpiRgrt.inf\n\nFILE FREEFORM = PCD(gMsCorePkgTokenSpaceGuid.PcdRegulatoryGraphicFileGuid) {\n    SECTION RAW = $(GRAPHICS_RESOURCES)/RGRT.png\n}\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/AcpiRGRT/feature_acpi_rgrt/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/","title":"CapsuleRuntimeDxe","text":"<p>Supports the UpdateCapsule and QueryCapsuleCapabilities runtime services. This driver does not apply capsules.</p> <p>This driver uses a DXE protocol (gCapsuleServiceProtocolGuid) to provide these services. Once ExitBootServices has been signaled, the driver will always return EFI_UNSUPPORTED for both calls.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/#why-a-protocol","title":"Why A Protocol","text":"<p>This is done for binary size reduction and library simplification.</p> <p>Because this isn't a \"true\" runtime driver (it effectively becomes a NOP at runtime), libraries that would be leveraged by this runtime service would need to support runtime. This choice poses a challenge because this driver isn't a \"true\" runtime driver so many of the libraries need to support runtime dxe in name only. This nuance can cause problems if an attempt is made to use these libraries in a runtime driver.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleRuntimeDxe/ReadMe/#protocol-producer","title":"Protocol Producer","text":"<p>Currently CapsuleServiceProtocolDxe is the primary producer of the gCapsuleServiceProtocolGuid protocol - there is additional documentation there, including a flow chart of the capsule update process.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServicePei/ReadMe/","title":"CapsuleServicePei","text":"<p>Produces the capsule PPI which currently only fully implements the <code>CheckCapsuleUpdate</code> functionality.</p> <p>Everything else returns success or unsupported, as it is related to capsule coalescing.</p> <p>This is needed as there is often infrastructure which detects FlashUpdate as a boot mode and attempts to find this PPI to check to make sure we actually have a capsule. So, we produce a simple PPI to satisfy that requirement.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/","title":"Capsule Service Protocol DXE","text":"<p>This driver produces a protocol (gCapsuleServiceProtocolGuid) which can be used by the CapsuleRuntimeService. There is a readme which details why a protocol was used in that folder (see <code>CapsuleRuntimeDxe</code>).</p> <p>This protocol does not apply capsules. It combines CapsuleLib, PersistLib, and CapsuleRuntimeDxe.</p> <p>It is significantly less configurable and is focused on reducing attack surface.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#constraints-introduced-in-comparison-to-the-traditional-capsule-runtime-mechanism","title":"Constraints Introduced in Comparison to the Traditional Capsule Runtime mechanism","text":"<ul> <li>MRC does not preserve memory. We do a warm reset but make no guarantee that memory is preserved.</li> <li>Capsules will not be applied at runtime.</li> <li>All capsules will do a reset before applying.</li> <li>Option roms are not supported.</li> <li>Embedded Drivers inside of Capsules are not supported.</li> </ul>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#implementation","title":"Implementation","text":""},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#flow-chart","title":"Flow chart","text":"<p>Here is a flow chart that should explain the overall flow of the capsule system.</p> <p></p> <p>The new system stores capsules on the EFI partition of the main disk. While it shares many similarities to Capsule on Disk, it is significantly more opinionated and has few modes of operation/configuration. It has a few additional security features as well.</p> <p>Capsules are staged by the OS by calling the Runtime service <code>UpdateCapsule</code>. The capsule header is given a quick sanity check, hashed, given a unique ID, and saved to the EFI partition. Once saved, a variable is created to keep track of the capsules which have been saved and are processed in a first in, first out manner.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#libraries","title":"Libraries","text":"<p>Two other pieces of capsule infrastructure are leveraged by this driver: IsCapsuleSupportedLib and CapsulePersistenceLib. These libraries are used to validate a capsule as well as manage the storage of capsules. This driver also uses QueueLib to keep track of capsules that have been persisted. Each library has a readme containing further information located in their respective folders.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#further-notes","title":"Further Notes","text":"<p>The first time a capsule is persisted, we clear the <code>Capsules</code> folder on the disk to remove stale files.</p> <p>The only way to stage a capsule is by calling the Runtime service. Currently there are no plans to support capsules that are placed manually in the <code>Capsules</code> folder.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CapsuleServiceProtocolDxe/ReadMe/#next-boot-path","title":"Next Boot Path","text":"<p>Before the system is reset, the variable <code>PreviousCapsuleCount</code> is set to zero. This variable signals that capsules are present. It is zero as it is a marker of the number of capsules on the last boot. If we set it to the current number of capsules, we would detect it as no progress being made, and would abort.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/","title":"CheckHardwareConnected","text":""},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#about","title":"About","text":"<p>This driver determines at boot if the specified pci devices found in the DeviceSpecificBusInfoLib library are properly connected</p>"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#usage","title":"Usage","text":"<p>To employ this driver, simply build it and supply the DeviceSpecificBusInfoLib which implements the DeviceSpecificBusInfoLib.h interface.</p> <p>The info for each PCI device will be contained within the DEVICE_PCI_INFO struct which contains fields:</p> <p>DeviceName: A friendly name for the device. This Ascii name will be contained within the AdditionalInfo2 field of the MU_TELEMETRY_CPER_SECTION_DATA telemetry struct.</p> <p>IsFatal: A boolean which if true states that the pci device being absent crashes the device upon OS boot</p> <p>SegmentNumber, BusNumber, DeviceNumber, FunctionNumber : Info required to locate the PCI device</p> <p>MinimumLinkSpeed The minimum link speed expected for the PCI device</p> <p>The library interface consists of two functions:</p> <p>GetPciCheckDevices() : Populates an array of pointers to DEVICE_PCI_INFO structs. The pointer to the unallocated array is passed in as an argument and should be allocated within the function. The DEVICE_PCI_INFO structs should be global variables in the library and the array should contain their addresses. Function returns the number of DEVICE_PCI_INFO struct pointers within the allocated array.</p> <p>ProcessPciDeviceResults() : Accepts an array of PCI device check results in the form of a pointer to a type of DEVICE_PCI_CHECK_RESULT and performs custom actions based upon the results.</p> <p>If there are specific cases when you do not want to check for certain PCI devices (such as when a device has been purposefully disabled), simply exclude the DEVICE_PCI_INFO associated with that device when allocating and returning the array.</p>"},{"location":"dyn/mu_plus/MsCorePkg/CheckHardwareConnected/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/","title":"GuidedSectionExtract","text":""},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/#about","title":"About","text":"<p>A version of GuidedSectionExtract without decompression.</p> <p>By moving decompression to DXE, a PEI FV that is tight on space, may have a little more room if decompression code is moved to DXE, and swapped for an uncompressed DxeIplPeim.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Core/GuidedSectionExtractPeim/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/","title":"Debug File Logger II","text":"<p>NOTE:  Superseded by the AdvLoggerPkg.</p> <p>This is Debug File Logger II.</p> <p>Debug File Logger was tried a few times with varying degrees of success. It was thought that the not quite right USB stack was the issue with the Debug File Logger. When the Debug File Logger was enabled to write logs in the ESP (EFI System Partition) on the NVMe drive, there would be systems that would no longer boot.</p> <p>Over time, we have found that there were issues in the Windows FAT file system driver across hibernate where the OS assumed no change to the file system metadata (The FAT and Directory Entries) causing irreparable damage to the ESP.</p>"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#top-design-points","title":"Top design points","text":"<ol> <li> <p>The debug log files are pre-allocated the first time they are needed on a particular device.</p> </li> <li> <p>Every SimpleFileSystem device that is connected during POST is eligible to be a log device.</p> </li> <li> <p>A USB device must have a directory in the root named 'Logs' to be considered a log device.</p> </li> <li> <p>The NVMe device(s) will get a hidden directory named 'Logs' the first time is is mounted.    The time to create the initial logs is about 2 seconds.    The time to register the logs during subsequent time through POST is about 2ms.</p> </li> <li> <p>The logs can be obtained in the OS or by booting to the Shell.  In the OS, mount the ESP    using:</p> <p>mountvol P: /S</p> <p>The drive letter can be any available drive letter.</p> </li> <li> <p>Logs will be recorded at:</p> <ul> <li>When a registered device is connected</li> <li>When just prior to ExitBootServices to any previously registered devices</li> <li>When the system is reset (from TPL &lt;= TPL_CALLBACK) to any previously registered devices</li> </ul> </li> </ol> <p>If you want to collect logs on a USB device, you can insert the non-bootable USB drive with the Logs directory installed, then power on the system and hold VOL/- to attempt booting from USB. This will mount the USB filesystem, the Logs directory will be acknowledged, and the log written. The system will continue to boot and should append the rest of the log at ExitBootServices.</p>"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#future-items","title":"Future items","text":"<p>Should there be more suggestions for future items, post them at Microsoft Mu Issues</p> <p>Some features under considerations:</p> <ol> <li> <p>Refactor DebugLib again to insure logs are collected during the whole boot.</p> </li> <li> <p>Add a new feature to DebugLib to capture the full UEFI log, but only send selected entries    to the serial port (to handle devices with a slow serial port).</p> </li> <li> <p>Always connect the NVMe drive at console connect.    For 99.9% of the cases, the system is going to boot the NVMe drive, so connecting it early    would not significantly change the boot time, but would allow logs to be collected in more    cases.</p> </li> <li> <p>When the log cannot be written (too high of TPL for the FileSystem to work), have a method    to store the last 100 lines or so of the log somewhere (system dependent) that can be    collected on the next boot.</p> </li> <li> <p>Timestamp the head of the log to assist in sorting logs.</p> </li> </ol>"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#installation-instructions","title":"Installation Instructions","text":"<p>Replace the current Pei/DebugFileLoggerPei.inf and /Dxe/DebugFileLogger.inf with the new versions. Delete the DebugFileLoggerLib as it is no longer necessary.</p> <ol> <li> <p>Remove these lines of the old Debug File Logger:</p> <pre><code>  DebugFileLoggerLib|XxxxxPkg/Library/DebugFileLoggerLib/DebugFileLoggerLib.inf\n  XxxxxPkg/DebugFileLogger/Pei/DebugFileLoggerPei.inf {\n  &lt;LibraryClasses&gt;\n    DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf\n  }\n  XxxxxPkg/DebugFileLogger/Dxe/DebugFileLogger.inf\n</code></pre> </li> <li> <p>Replace the old Debug file logger files with these new Debug File Logger II entries:</p> <pre><code>  MsCorePkg/DebugFileLoggerII/Pei/DebugFileLoggerPei.inf {\n  &lt;LibraryClasses&gt;\n    DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf\n  }\n\n  MsCorePkg/DebugFileLoggerII/Dxe/DebugFileLogger.inf {\n    &lt;LibraryClasses&gt;\n      DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf\n  }\n</code></pre> </li> <li> <p>There is no check for Manufacturing mode.    The idea is for the File Logger to be robust enough to be on in all builds.</p> </li> </ol>"},{"location":"dyn/mu_plus/MsCorePkg/DebugFileLoggerII/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/","title":"MS Core Package","text":""},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#about","title":"About","text":"<p>This package has shared drivers and libraries that are silicon and platform independent.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#modules","title":"Modules","text":"Modules Link to Documentation AcpiRGRT: Regulatory Graphics Resource Table CheckHardwareConnected: Require Devices Connected DebugFileLoggerII: Uefi Log to File GuidedSectionExtractPeim: Pei version without decompression IncompatiblePciDevices Incompatible Pci Devices No Option Roms Allowed NoOptionRomsAllowed MuCryptoDxe MuCryptoDxe MuVarPolicyFoundationDxe MuVarPolicyFoundationDxe"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#libraries","title":"Libraries","text":"Libraries Link to Documentation DebugPortPei DebugPortPei DebugPortProtocolInstallLib DebugPortProtocolInstallLib DeviceBootManagerLibNull DeviceBootManagerLibNull DeviceSpecificBusInfoLibNull DeviceSpecificBusInfoLibNull DxeDebugLibRouter DxeDebugLibRouter JsonLiteParser JsonLiteParser MathLib MathLib MemoryTypeInformationChangeLib MemoryTypeInformationChangeLib PasswordStoreLibNull PasswordStoreLibNull PeiDebugLib PeiDebugLib PlatformBootManagerLib PlatformBootManagerLib TpmSgNvIndexLib TpmSgNvIndexLib ExceptionPersistenceLib ExceptionPersistenceLib MemoryProtectionExceptionHandlerLib MemoryProtectionExceptionHandlerLib"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#testing","title":"Testing","text":"<p>There are UEFI shell application based unit tests for some libraries. These tests attempt to verify basic functionality of public interfaces. Check the UntTests folder at the root of the package.</p> Library Tests Link to Documentation Json Test: Json Test MathLib UnitTests: MathLib UnitTests"},{"location":"dyn/mu_plus/MsCorePkg/Docs/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/","title":"Incompatible Pci Devices","text":""},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/#about","title":"About","text":"<p>There are times when a PCI devices misbehaves.  This library class allows you to specify what to do when you need to support a PCI device that doesn't follow the spec, or if the platform wants to disable a feature.</p> <p>The only Incompatible Pci device behavior currently supported is to disable processing of the Option Rom. It is expected for supported PCI devices to have their rom built into the system firmware.</p>"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/NoOptionRomsAllowed/ReadMe/","title":"Incompatible Pci Devices - No Option Roms Allowed","text":""},{"location":"dyn/mu_plus/MsCorePkg/IncompatiblePciDevices/NoOptionRomsAllowed/ReadMe/#about","title":"About","text":"<p>Some system plaforms do not want PCI devices to run their option ROMS.  In this case, the platform provides the PCI Option Rom in the system firmware image, and this driver prevents the PCI drivers from loading the option rom from the device.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/","title":"Debug Port Pei","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/#about","title":"About","text":"<p>This library is meant to be linked against a module within a DSC already linked against a version of DebugLib. This PPI is meant to be used by the rest of the PEI modules as a source for DebugLib functions.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortPei/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/","title":"DebugPortProtocolInstallLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/#about","title":"About","text":"<p>Provides the gEfiDebugPortProtocolGuid to support Generic Debug prints across platforms.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DebugPortProtocolInstallLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/","title":"DeviceBootManagerLibNull","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/#about","title":"About","text":"<p>DeviceBootManagerLib contains the device or family of devices actions which can be customized by IBV/OEM. Each of the BdsDxe callback actions are passed from PlatformBootManagerLib to DeviceBootManagerLib for device specific action. This is the NULL version of the library for CI builds.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceBootManagerLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/","title":"DeviceSpecificBusInfoLibNull","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/#about","title":"About","text":"<p>Provides a NULL implementation of DeviceSpecificBusInfoLibNull for use by CI builds.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DeviceSpecificBusInfoLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeCapsulePersistenceLib/ReadMe/","title":"Capsule Persistence Lib for PEI and DXE","text":"<p>This is an implementation of CapsulePersistenceLib which is used to persist capsules using the EFI partition.</p> <p>It provides methods for:</p> <ul> <li>Persisting a capsule across reset</li> <li>Retrieving all currently persisted capsules and deleting them</li> <li>Retrieving a specific persisted capsule</li> <li>Deleting a specific persisted capsule</li> </ul> <p>This library can be used without any sort of queue, by using a retrieve all method but, ideally, it should be paired with <code>QueueLib</code>.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/","title":"Debugging with DxeDebugLibRouter","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#about","title":"About","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#dxedebuglibrouter","title":"DxeDebugLibRouter","text":"<p>The DxeDebugLibRouter is an implementation of DebugLib that routes the DebugPrint and DebugAssert messages depending on what the platform is capable of and what has been set-up.</p> <p>In the example below we show how to use DxeDebugLibRouter to route debug messages through either the serial interface or the report status code interface, depending on what protocols and libraries are being used.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#statuscodehandler","title":"StatusCodeHandler","text":"<p>If you wish to make use of the Report Status Code debugging feature you will need to set up a status code handler and install the gMsSerialStatusCodeHandlerDxeProtocolGuid tag GUID. The MsCorePkg version of StatusCodeHandler is setup to do this.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#debugportprotocolinstalllib","title":"DebugPortProtocolInstallLib","text":"<p>The DebugPortProtocolInstallLib is a shim library whose only purpose is to install a protocol that points to the currently linked DebugLib being used by the module. You can see how this is used in the DSC example shown below.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#reportstatuscoderouter","title":"ReportStatusCodeRouter","text":"<p>This library handles the routing of ReportStatusCode if the DxeDebugLibRouter is set-up to use the ReportStatusCode debug path. We have only implemented the serial output for report status code, but there are many ways you can implement a RSC observer including</p> <ul> <li>Serial Port Listener</li> <li>Save Debug To File System</li> <li>Save Debug To Memory</li> <li>...</li> </ul>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#how-to-use","title":"How To Use","text":"<p>To make full use of the DxeDebugLibRouter each Dxe Driver will need to use the DebugPort implementation of DebugLib to route their messages through the DxeDebugLibRouter. The Flowchart below shows how this would work.</p> <p>To set up DxeCore to work as the router you will need to set up the DSC as below:</p> <pre><code>[LibraryClasses.X64]\nDebugLib|MdePkg/Library/UefiDebugLibDebugPortProtocol/UefiDebugLibDebugPortProtocol.inf\n\n[Components.X64]\nMdeModulePkg/Core/Dxe/DxeMain.inf {\n    &lt;LibraryClasses&gt;\n      NULL|MsCorePkg/Library/DebugPortProtocolInstallLib/DebugPortProtocolInstallLib.inf\n      DebugLib|MsCorePkg/Library/DxeDebugLibRouter/DxeDebugLibRouter.inf\n  }\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#debug-flow","title":"Debug Flow","text":"<ol> <li> <p>The NULL library responsible for publishing the DebugPort protocol is linked against DxeMain.    This allows the DebugLib used by Dxe drivers to locate the DebugLib used by Dxe Main</p> </li> <li> <p>Dxe Driver makes a DebugPrint which is routed to the DebugLib linked to DxeMain</p> </li> <li> <p>DebugLib routes the DebugPrint through either Serial or Report Status Code depending on what    is installed at the time</p> </li> <li> <p>This step can happen at any time. When the StatusCodeHandler is dispatched it installs a tag    GUID letting the DebugLib know that Report Status Code is now available</p> </li> </ol> <p></p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeDebugLibRouter/Feature_DebugRouting_Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeIsCapsuleSupportedLib/ReadMe/","title":"DXE Is Capsule Supported Lib","text":"<p>This library performs a sanity check to determine if a capsule is supported by the UEFI firmware. It does not perform any sort of signature or hash. In the case of nested capsules, there is stubbed out functionality to check if the ESRT table contains an entry related to the nested capsule.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeIsCapsuleSupportedLib/ReadMe/#why-dxe_driver-only","title":"Why DXE_DRIVER Only","text":"<p>This is called from the DXE_RUNTIME_DRIVER indirectly via the <code>CapsuleServiceProtocol</code>. Because this is a DXE protocol and the Capsule Runtime service doesn't call the protocol after ExitBootServices, this is safe.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/DxeQueueUefiVariableLib/ReadMe/","title":"DXE Queue UEFI Variable Lib","text":"<p>This is an implementation of QueueLib backed by the UEFI variable store.</p> <p>Because the queue has manipulation functions, this does not support PEI as the variable services in PEI are usually read only.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/","title":"ExceptionPersistenceLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#about","title":"About","text":"<p>ExceptionPersistenceLib implements functionality for getting, setting, and clearing exception info to/from platform-specific early store. All functions return an EFI_ERROR if the function was unsuccessful. The validity of the data stored in CMOS is verified through the use of a two-byte checksum. Sets/Gets/Clears will first evaluate the checksum and return an EFI_ERROR if it is invalid. Sets/Gets/Clears will also write and read a test value to CMOS to make sure the library is working as expected which also should catch instances where the library was linked improperly.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#usage","title":"Usage","text":"<p>ExceptionPersistenceLib is a BASE library and can be included under [LibraryClasses].</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/ExceptionPersistenceLibCmos/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/","title":"JsonLiteParser","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/#about","title":"About","text":"<p>This is a limited function Json parser used by the DfciPkg InTune Http requests.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/JsonLiteParser/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/","title":"MathLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/#about","title":"About","text":"<p>MathLib provide add, subtract, multiply and divide routines that return an error when there is an underflow or overflow.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MathLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/","title":"MemoryProtectionExceptionHandlerLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/#about","title":"About","text":"<p>If memory protections are on, MemoryProtectionExceptionHandlerLib registers an exception handler which uses platform early store to log the page fault.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/Readme/#usage","title":"Usage","text":"<p>To use this library, make MemoryProtectionExceptionHandlerLib a null library for a module such as CpuDxe:</p> <pre><code>UefiCpuPkg\\CpuDxe\\CpuDxe.inf {\n&lt;LibraryClasses&gt;\nNULL|MsCorePkg/Library/MemoryProtectionExceptionHandlerLib/MemoryProtectionExceptionHandlerLib.inf\n}\n</code></pre> <p>CpuDxe is preferable because the page fault exception handler is only registered after gEfiCpuArchProtocolGuid has been installed.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/","title":"MemoryTypeInformationChangeLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/#about","title":"About","text":"<p>Reports the memory type information change as a telemetry event.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MemoryTypeInformationChangeLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/","title":"Using MuSecureBootKeySelectorLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#about","title":"About","text":"<p>This document describes the overview of Secure Boot related changes from SecurityPkg and how <code>MuSecureBootKeySelectorLib</code> and <code>SecureBootKeyStoreLib</code> are introduced to leverage the changes to support multiple key chains needed by OEMs.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#involved-definitions","title":"Involved Definitions","text":"Definitions Definition Paths Implementation Paths UefiSecureBoot.h SecurityPkg/Include/UefiSecureBoot.h N/A SecureBootVariableLib.h SecurityPkg/Include/Library/SecureBootVariableLib.h SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf PlatformPKProtectionLib.h SecurityPkg/Include/Library/PlatformPKProtectionLib.h SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf (Required If Platforms Uses Variable Policy to Protect PK) MuSecureBootKeySelectorLib.h MsCorePkg/Include/Library/MuSecureBootKeySelectorLib.h MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf SecureBootKeyStoreLib.h MsCorePkg/Include/Library/SecureBootKeyStoreLib.h Platform Supplied"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#update-for-secure-boot-variable-operation-in-securitypkg","title":"Update for Secure Boot Variable Operation in SecurityPkg","text":"<p>With the improvement from <code>SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf</code>, this library begins to support the Secure Boot related variables (db, dbt, dbx, KEK, PK, etc.) deletion and enrollment without much external dependencies: <code>gEfiVariableWriteArchProtocolGuid</code> is required; if platform supports variable policy, <code>gEdkiiVariablePolicyProtocolGuid</code> is also required.</p> <p>The <code>Delete**</code> interfaces as well as the <code>EnrollFromInput</code> could be leveraged to delete or write individual secure boot variable with time based authenticated payload. <code>IsSecureBootEnabled</code> is also added to query the secure boot state quickly.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-deletesecurebootvariables","title":"Interface <code>DeleteSecureBootVariables</code>","text":"<p>In addition, the newly introduced interface from <code>SecureBootVariableLib</code>, <code>DeleteSecureBootVariables</code>, streamline all secure boot variable deletion in one function to facilitate the usage for platforms.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-setsecurebootvariablestodefault","title":"Interface <code>SetSecureBootVariablesToDefault</code>","text":"<p>Another newly introduced interface from <code>SecureBootVariableLib</code>, <code>SetSecureBootVariablesToDefault</code>, streamline all secure boot variable enrollment in one function to facilitate the usage for platforms. This function takes the platform supplied <code>SECURE_BOOT_PAYLOAD_INFO</code> structure (defined in <code>SecurityPkg/Include/UefiSecureBoot.h</code>) that contains pointers to target secure boot variables (db, dbt, dbx, KEK, PK, etc.), creates time based authenticated payload, disable PK variable protection if needed, and write the variables. Specifically, the content from <code>SECURE_BOOT_PAYLOAD_INFO</code> must be formatted to <code>EFI_SIGNATURE_LIST</code> structures.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#interface-securebootcreatedatafrominput","title":"Interface <code>SecureBootCreateDataFromInput</code>","text":"<p>This interface is a helper function to convert DER formatted certificates to <code>EFI_SIGNATURE_LIST</code>. Callers can collect all applicable DER formatted certificates' addresses and sizes in <code>SECURE_BOOT_CERTIFICATE_INFO</code> arrays. The collected array can be passed into this interface to create a single, concatenated <code>EFI_SIGNATURE_LIST</code> in one call.</p> <p>This function is especially useful for platforms that currently carry these certificates in DER format to populate <code>SECURE_BOOT_PAYLOAD_INFO</code> structure.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#creation-of-musecurebootkeyselectorlib","title":"Creation of MuSecureBootKeySelectorLib","text":"<p>The introduction of this library instance is to support platforms that needs to install mutiple chains of secure boot keys under various circumstances. i.e. Platform would like to support only 1st party signed applications vs. 1st party and 3rd party signed application.</p> <p>This library provides a set of <code>SECURE_BOOT_PAYLOAD_INFO</code>, each entry formatted to <code>EFI_SIGNATURE_LIST</code> structure. This set of keys will be used with <code>MuSecureBootKeySelectorLib</code> to select which key set to be applied to the system. Along with the signature list pointers, each key could provide a unicode string to denote its name, which might be used in other modules for informational purpose.</p> <p>The provided key sets should persist in the lifetime of its consuming module. The caller should not free the key store buffer after usage.</p> <p>Note: If the platforms currently deliver any associated certificates in DER format, one should use <code>SecureBootCreateDataFromInput</code> function to convert them into <code>EFI_SIGNATURE_LIST</code> format.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#usage-of-musecurebootkeyselectorlib","title":"Usage of MuSecureBootKeySelectorLib","text":"<p>This library provides an interface to query or set the current status of secure boot variables in accordance to the key sets provided in <code>MuSecureBootKeySelectorLib</code>.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-integration","title":"Platform Integration","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-code","title":"Platform Code","text":"<p>Platforms held the responsibility in authoring a library instance of <code>SecureBootKeyStoreLib</code> to provide certificates or signature lists for secure boot operation usage.</p> <p>Optional: if platforms do not use variable policy to protect <code>PK</code>, one should also author an instance of <code>PlatformPKProtectionLib</code> to disarm the protection when PK is about to be updated.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/MuSecureBootKeySelectorLib/ReadMe/#platform-dsc-change","title":"Platform DSC Change","text":"<p>Add the following items in the platform DSC file:</p> <pre><code>  SecureBootVariableLib|SecurityPkg/Library/SecureBootVariableLib/SecureBootVariableLib.inf\n  # Optional\nPlatformPKProtectionLib|SecurityPkg/Library/PlatformPKProtectionLibVarPolicy/PlatformPKProtectionLibVarPolicy.inf\n  MuSecureBootKeySelectorLib|MsCorePkg/Library/MuSecureBootKeySelectorLib/MuSecureBootKeySelectorLib.inf\n  # Platform Code\nSecureBootKeyStoreLib|PlatformPkg/Library/SecureBootKeyStoreLibPlat/SecureBootKeyStoreLibPlat.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/","title":"PasswordStoreLibNull","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/#about","title":"About","text":"<p>Provides a NULL implementation of PasswordStoreLibNull for use by CI builds.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PasswordStoreLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/","title":"PeiDebugLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/#about","title":"About","text":"<p>Debug Library to be used with DebugPortPEI library Routes all DebugPrint and DebugAssert calls through PPI.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PeiDebugLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/","title":"PlatformBootManagerLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/#about","title":"About","text":"<p>This file include all the common platform action which can be customized by IBV/OEM. Each of the BDS actions are passed to DeviceBootManagerLib for device specific action.</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/PlatformBootManagerLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/","title":"TpmSgNvIndexLib","text":""},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/#about","title":"About","text":"<p>Library to create SystemGuard NV Index consumed by OS</p>"},{"location":"dyn/mu_plus/MsCorePkg/Library/TpmSgNvIndexLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/MacAddressEmulationDxe/Readme/","title":"MacAddressEmulationDxe","text":"<p>This driver provides UEFI support for MAC Address Emulation.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MacAddressEmulationDxe/Readme/#feature-of-this-driver","title":"Feature of this driver","text":"<p>Support for updating the station address (i.e. the MAC address) for UEFI SNP instances that are used for PXE boot.  This ensures that the MAC address is emulated in preboot.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MacAddressEmulationDxe/Readme/#usage","title":"Usage","text":"<p>To use this feature, platforms must do the following:</p> <ol> <li> <p>Provide an implementation of MacAddressEmulationPlatformLib.</p> </li> <li> <p>Update the platform DSC/FDF to build and include the driver</p> </li> <li> <p>Update the platform FDF to include the driver in the ROM</p> </li> </ol>"},{"location":"dyn/mu_plus/MsCorePkg/MacAddressEmulationDxe/Readme/#notes-on-platform-implementation","title":"Notes on platform implementation","text":"<ul> <li><code>GetMacEmulationAddress</code> and <code>PlatformMacEmulationEnable</code> are called during driver entrypoint.</li> <li><code>PlatformMacEmulationSnpCheck</code> is called during a callback at TPL_NOTIFY, so any code here must be aware of this    restriction. It is not recommended to lower the TPL during this function if the network stack has already been    started as some packets may be transmitted before the mac is programmed to the emulated address.</li> </ul>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/","title":"MuCryptoDxe","text":""},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#about","title":"About","text":"<p>MuCryptoDxe is a DXE_DRIVER you can include in your platform to have a protocol that can call Crypto functions without having to statically linked against the crypto library in many places</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#supported-architectures","title":"Supported Architectures","text":"<p>This package is not architecturally dependent.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#methods-supported","title":"Methods supported","text":"<p>There are two protocols exposed in this GUID</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#mu_pkcs5_password_hash_protocol","title":"MU_PKCS5_PASSWORD_HASH_PROTOCOL","text":""},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#hashpassword","title":"HashPassword","text":"<p>Hashes a password by passing through to the BaseCryptLib. Returns EFI_STATUS</p> <pre><code>NOTE: DigestSize will be used to determine the hash algorithm and must correspond to a known hash digest size. Use standards.\n\n@retval     EFI_SUCCESS             Congratulations! Your hash is in the output buffer.\n@retval     EFI_INVALID_PARAMETER   One of the pointers was NULL or one of the sizes was too large.\n@retval     EFI_INVALID_PARAMETER   The hash algorithm could not be determined from the digest size.\n@retval     EFI_ABORTED             An error occurred in the OpenSSL subroutines.\n\n**Inputs**:\n\nIN CONST MU_PKCS5_PASSWORD_HASH_PROTOCOL\nIN UINTN                                      PasswordSize\nIN CONST  CHAR8                              *Password\nIN UINTN                                      SaltSize\nIN CONST  UINT8                              *Salt\nIN UINTN                                      IterationCount\nIN UINTN                                      DigestSize\nIN UINTN                                      OutputSize\nOUT UINT8                                    *Output\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#mu_pkcs7_protocol","title":"MU_PKCS7_PROTOCOL","text":""},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#verify","title":"Verify","text":"<p>Verifies the validity of a PKCS#7 signed data as described in \"PKCS #7: Cryptographic Message Syntax Standard\". The input signed data could be wrapped in a ContentInfo structure.</p> <p>If P7Data, TrustedCert or InData is NULL, then return EFI_INVALID_PARAMETER. If P7Length, CertLength or DataLength overflow, then return EFI_INVALID_PARAMETER. If this interface is not supported, then return EFI_UNSUPPORTED.</p> <pre><code>    @retval  EFI_SUCCESS  The specified PKCS#7 signed data is valid.\n@retval  EFI_SECURITY_VIOLATION Invalid PKCS#7 signed data.\n@retval  EFI_UNSUPPORTED This interface is not supported.\n\n**Inputs:**\n\nIN  CONST MU_PKCS7_PROTOCOL\nIN  CONST UINT8                   *P7Data,\nIN  UINTN                          P7DataLength,\nIN  CONST UINT8                   *TrustedCert,\nIN  UINTN                          TrustedCertLength,\nIN  CONST UINT8                   *Data,\nIN  UINTN                          DataLength (in bytes)\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#verifyeku","title":"VerifyEKU","text":"<p>This function receives a PKCS7 formatted signature, and then verifies that the specified Enhanced or Extended Key Usages (EKU's) are present in the end-entity leaf signing certificate.</p> <p>Note that this function does not validate the certificate chain.</p> <p>Applications for custom EKU's are quite flexible. For example, a policy EKU may be present in an Issuing Certificate Authority (CA), and any sub-ordinate certificate issued might also contain this EKU, thus constraining the sub-ordinate certificate. Other applications might allow a certificate embedded in a device to specify that other Object Identifiers (OIDs) are present which contains binary data specifying custom capabilities that the device is able to do.</p> <pre><code>    @retval EFI_SUCCESS            - The required EKUs were found in the signature.\n@retval EFI_INVALID_PARAMETER  - A parameter was invalid.\n@retval EFI_NOT_FOUND          - One or more EKU's were not found in the signature.\n\n**Inputs:**\n\nIN CONST MU_PKCS7_PROTOCOL\nIN CONST UINT8                *Pkcs7Signature,\nIN CONST UINT32                SignatureSize,  (in bytes)\nIN CONST CHAR8                *RequiredEKUs[], null-terminated strings listing OIDs of required EKUs\nIN CONST UINT32                RequiredEKUsSize,\nIN BOOLEAN                     RequireAllPresent\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#including-in-your-platform","title":"Including in your platform","text":""},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#sample-dsc-change","title":"Sample DSC change","text":"<pre><code>    [Components.&lt;arch&gt;]\n    ...\n    ...\n    MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#sample-fdf-change","title":"Sample FDF change","text":"<pre><code>    [FV.&lt;a DXE firmware volume&gt;]\n    ...\n    ...\n    INF MsCorePkg/MuCryptoDxe/MuCryptoDxe.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsCorePkg/MuCryptoDxe/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/","title":"MuVarPolicyFoundationDxe Driver and Policies","text":""},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#overview","title":"Overview","text":"<p>This driver works in conjunction with the Variable Policy engine to create two policy-based concepts that can be leveraged by other drivers in the system and to produce an EDK2 Variable Locking Protocol. The two concepts are: Dxe Phase Indicators and Write Once State Variables.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#dxe-phase-indicators","title":"DXE Phase Indicators","text":"<p>To support the DXE Phase Indicators, a new policy is installed that creates the <code>gMuVarPolicyDxePhaseGuid</code> variable namespace. By policy, all variables in this namespace are required to be the size of a <code>PHASE_INDICATOR</code> (which is a <code>UINT8</code>) and must be volatile and readable in both BootServices and Runtime. All variables in this namespace will also be made read-only immediately upon creation (as such, they are also Write-Once, but have a special purpose). Because these variables are required to be volatile, it will not be possible to create more after ExitBootServices.</p> <p>This driver will also register callbacks for EndOfDxe, ReadyToBoot, and ExitBootServices. At the time of the corresponding event, a new <code>PHASE_INDICATOR</code> variable will be created for the callback that has just been triggered. The purpose of these variables is two-fold:</p> <ul> <li>They can be queried by any driver or library that needs to know what phases of boot have   already occurred.   This is especially convenient for libraries that might be linked against any type of driver or   application, but may not have been able to register callbacks for all the events because they   don't know their execution order or time.</li> <li>They can be used as the delegated \"Variable State\" variables in other Variable Policy lock   policies.   As such, you could describe a variable that locks \"at ReadyToBoot\" or \"EndOfDxe\".</li> </ul> <p>Note that the <code>PHASE_INDICATOR</code> variables are intentionally named as short abbreviations, such as \"EOD\" and \"RTB\". This is to minimize the size of the policy entries for lock-on-state policies.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#important-note-on-timing","title":"Important Note on Timing","text":"<p>The EndOfDxe and ReadyToBoot state variables will be created at the end of the Notify list for the respective event. As such, any variable that locks on those events will still be writeable in Notify callbacks for the event. However, the ExitBootServices state variable (due to architectural requirements) will be created at a non-deterministic time in the Notify list. Therefore, it is unpredictable whether any variable which locks \"on ExitBootServices\" would still be writeable in any given callback.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#write-once-state-variables","title":"Write-Once State Variables","text":"<p>The Write-Once State Variables are actually quite similar to the DXE Phase Variables in terms of policy, but are kept distinct because of the different intentions for their use. This driver will also register a policy that creates the <code>gMuVarPolicyWriteOnceStateVarGuid</code> namespace. This policy will also limit these variables to being: volatile, BootServices and Runtime, read-only on create, and a fixed size -- <code>sizeof(POLICY_LOCK_VAR)</code>, which is also a <code>UINT8</code>, given that that is the size of the Value field of the current <code>VARIABLE_LOCK_ON_VAR_STATE_POLICY</code> structure.</p> <p>The primary difference is that the DXE Phase Variables have a very clear purpose and meaning. While the <code>gMuVarPolicyWriteOnceStateVarGuid</code> namespace is designed to be general-purpose and used to easily describe delegated variables for <code>VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE</code>-type policies without requiring every driver to define two policies in order to employ this common pattern.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#example","title":"Example","text":"<p>Driver XYZ wants to define a policy to allow a boot application (that executes after the policy creation interface may be closed) to modify a collection of variables until the boot application chooses to lock them. One way to accomplish this is the create a policy that delegates the lock control of the target variables to the state of variable A. However, now the variable A is the linchpin for the protections of the target variables and should have some protections of its own. This might require another policy.</p> <p>Instead, the driver could create a policy that delegates lock control of the target variables to a variable in the <code>gMuVarPolicyWriteOnceStateVarGuid</code>. This would not require a second policy, as a general-purpose policy is already in place. Now the boot application only needs to create variable A in the <code>gMuVarPolicyWriteOnceStateVarGuid</code> namespace (with the value designated in the policy created by driver XYZ) in order to lock the target variables.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#important-note-on-naming","title":"Important Note on Naming","text":"<p>Since the <code>gMuVarPolicyWriteOnceStateVarGuid</code> namespace is a single variable namespace, naming collisions are possible. Because of the write-once nature of the policy, it is not a concern that an existing lock may be overwritten, but there still may be policy confusion if there are two policies that delegate to the exact same name. It is up to the platform architect to ensure that naming collisions like this do not occur.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#edk2-variable-locking-protocol","title":"EDK2 Variable Locking Protocol","text":"<p>Finally, this driver installs an EDK2 Variable Locking Protocol instance. This implementation locks a variable by creating a policy entry and registering it via the Variable Policy Protocol. The policy entry is of type VARIABLE_POLICY_TYPE_LOCK_ON_VAR_STATE and locks the variable based on state of the Phase Indicator variable \"EOD\" (meaning End Of Dxe) in <code>gMuVarPolicyDxePhaseGuid</code> namespace.</p>"},{"location":"dyn/mu_plus/MsCorePkg/MuVarPolicyFoundationDxe/Feature_MuVarPolicyFoundationDxe_Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/","title":"Verify Json Lite library functionality","text":"<p>The Json Lite Library parses json strings in to tuples and encodes tuples into a json string.</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#about","title":"About","text":"<p>These tests verify that the Json Lite Library functions properly.</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#jsontestapp","title":"JsonTestApp","text":"<p>This application consumes the UnitTestLib and implements various test cases for the verification of the Json Lite Library.</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/JsonTest/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/","title":"Math Lib Unit Tests","text":""},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/#about","title":"About","text":"<p>The Math Lib Unit Tests test the boundary conditions to insure proper results of catching underflows and overflows during calculations.</p>"},{"location":"dyn/mu_plus/MsCorePkg/UnitTests/MathLibUnitTest/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsCorePkg/Universal/StatusCodeHandler/ReadMe/","title":"Status Code Handler","text":""},{"location":"dyn/mu_plus/MsCorePkg/Universal/StatusCodeHandler/ReadMe/#about","title":"About","text":"<p>Provides output of the Report Status Codes to a debugging device.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/","title":"BmpDisplay test application","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/#about","title":"About","text":"<p>While UEFI uses and displays BMP format files, there are some BMP specification that UEFI follows that not all drawing programs honor. Running this tool to display a BMP in the Uefi Shell will check to make sure your BMP file are displayable in UEFI.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Application/BmpDisplay/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/","title":"DisplayEngineDxe Driver","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/#about","title":"About","text":"<p>This DisplayEngine driver supports the SetupBrowser display engine interface, and this version uses the Simple Window Manager to implement the backend of the IFR operations. Currently, not all IFR's are implemented.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/DisplayEngineDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/","title":"MS Graphics Package","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/#about","title":"About","text":"<p>This package has shared drivers and libraries that extend the UEFI graphics with a simple windowing system.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Docs/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/","title":"Gop Override Dxe Driver","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/#about","title":"About","text":"<p>This driver provides a less optimal method of providing the MsGopOverrideProtocol for the Rendering Engine.  See What Does the GopOverrideDxe Do</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/GopOverrideDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/","title":"Base Ui Progress Circle Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/#about","title":"About","text":"<p>Implements Ui Progress Circle or Donut. You can specify 100% or drawing whatever segments you specify.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiProgressCircleLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/","title":"Base UI Rectanble Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/#about","title":"About","text":"<p>This library provides the ability to draw rectangles on the display. They can be solid, checkered, or striped.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BaseUiRectangleLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/","title":"Boot Graphics Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/#about","title":"About","text":"<p>This BootGraphicsLib  is only intended to be used by BDS to draw the main boot graphics to the screen.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/","title":"Boot Graphics Null Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/#about","title":"About","text":"<p>This library is used in the CI build configuration.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/","title":"Boot Graphics Provider NULL Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/#about","title":"About","text":"<p>This library is used by CI builds to test compile users of the BootGraphicsLib.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/BootGraphicsProviderLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/","title":"Color Bar Display Device State Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/#about","title":"About","text":"<p>There are a number of states that are critical when manufacturing a system. Some of these are the fuses that must be set that protect the device. These fuses are not set on some machines for test purposes, etc.</p> <p>To quickly notice that these customer critical settings are correct, this library display color bars on the display if there state is not in the secure state.</p> <p>This allows an end user to quickly notice that secure boot is off.</p> <p>This allows an end of line tester to verify that the fuses are in the correct state for customer delivery.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/ColorBarDisplayDeviceStateLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/","title":"Display Device State Null Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/#about","title":"About","text":"<p>The Display Device State NULL library is in the CI build when a real DisplayDeviceState library is not accessible.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/DisplayDeviceStateLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/","title":"FrameBufferMemDrawLib","text":"<p>FrameBufferMemDrawLib is a wrapper around FrameBufferBltLib. This offers some nice benefits as the FrameBufferBltLib offers a nice abstractions of manipulating the frame buffer while it's in memory. This is most useful in situations where the full display protocol might not be up yet. FrameBufferMemDrawLib tries to simplify using the FrameBufferBltLib by gathering the information about the display, the pixel format, and getting the handles needed to manipulate the frame buffer. This is done through a constructor and a destructor.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#methods-offered","title":"Methods offered","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#memdrawonframebuffer","title":"MemDrawOnFrameBuffer","text":"<p>This is meant to take a buffer that is formatted with 32bit pixels in the standard RGB+reserved format. It takes in the top left corner of the position on the screen where the buffer should be drawn. It also takes in the number of rows and columns of the buffer.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/FrameBufferMemDrawLib/Readme/#memfillonframebuffer","title":"MemFillOnFrameBuffer","text":"<p>This fills in a region with a solid color. This color is the standard 32 bit format referenced in the previous method. This functions takes in the top left corner of the position on the screen where the color should be filled. It also takes in the number of rows and columns that the color should fill out to.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/","title":"MS Color Table Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/#about","title":"About","text":"<p>This package defines the absolute RGB values for each color that is used by users of the Simple Window Manager. Each UI element is assigned a color.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsColorTableLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/","title":"Ms Early Graphics NULL Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/#about","title":"About","text":"<p>This library is used in the CI build configuration.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsEarlyGraphicsLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/","title":"Ms Ui Theme Copy Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/#about","title":"About","text":"<p>MsUiThemeCopyLib is used to unpack the fonts from the packed FV into execution time structures.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeCopyLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/","title":"Ms Ui Theme Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/#about","title":"About","text":"<p>The MsUiThemeLib publishes the MuUiTheme (Ppi/Protocol).</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/MsUiThemeLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/","title":"Qr Encoder Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/#about","title":"About","text":"<p>This package builds a QR code bit map object from binary data. The encoder supports all 40 versions, all 4 error correction levels (L, Q, M, H), but only three character encoding modes (Numeric, AlphNumeric, and Byte).</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/QrEncoderLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/","title":"Sample Platform Theme Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#about","title":"About","text":"<p>The Sample Platform Theme Library is used to specify the fonts and display size information to the Simple Window Manager.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#how-to-choose-scale-and-font-sizes","title":"How to choose scale and font sizes","text":"<p>The starting point is a 3000 W x 2000 H display as a 100% size.</p> <p>Start with your display size.</p> <p>Scale =  (The width in pixels of the your display) / 3000.</p> <p>Change the #define SCALE value to your whole number scale value.</p> <p>Using Scale, multiply each font size in the sample by your Scale value and select a font point close to your Scale value.. Keep in mind that each font must be a unique fonts. The same font file cannot be used for multiple fonts.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SamplePlatformThemeLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/","title":"Simple UI ToolKit Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/#about","title":"About","text":"<p>The Simple UI Toolkit library allows code to create interfaces dynamically. The two sample users of the Simple UI Toolkit is the Display Engine and SwmDialogs Library.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SimpleUIToolKit/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/","title":"Swm Dialogs Library","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#about","title":"About","text":"<p>The Simple Window Manager Dialog Library has a couple of dialogs that can be use by UEFI application. These dialogs use the Simple Window Manager.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#dialog-types","title":"Dialog types","text":"<ol> <li>Simple Message Box</li> <li>Password Prompt</li> <li>Selection Prompt</li> <li>SwmDialogsVerifyThumbprintPrompt special for DFCI</li> </ol>"},{"location":"dyn/mu_plus/MsGraphicsPkg/Library/SwmDialogsLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/","title":"MS Early Graphics Drivers","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/#about","title":"About","text":"<p>The MsEarlyGraphics drivers load the fonts used for the Simple Window Manager, and is used to display Preboot information on the graphics console, when the display if first initialized (for example, in PEI) by drawing directly to the frame buffer.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsEarlyGraphics/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/","title":"MS UI Theme Drivers","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/#about","title":"About","text":"<p>The MsUiTheme drivers load the fonts used by the platform. Each platform must supply the font information required based on the display information.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/MsUiTheme/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/","title":"OnScreenKeyboardDxe","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/#about","title":"About","text":"<p>This driver implements an OnScreen keyboard driver. This driver relies heavily on the SimpleWindowManager, The SimpleUI Toolkit, and the RenderingEngine to implement a floating on screen keyboard that can be rotated on the display.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/OnScreenKeyboardDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/","title":"PrintScreenLogger","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#about","title":"About","text":"<p>PrintScreenLogger is a DXE_DRIVER you can include in your platform to obtain Screen Captures during the preboot environment by pressing the Ctrl-PrtScn key combination. This action will creates a 24bbp (Bits Per Pixel) .BMP file of the screen's contents and write it to a enabled USB drive.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#supported-architectures","title":"Supported Architectures","text":"<p>This package is not architecturally dependent. This package is dependent upon the Gop pixel format, and only supports these two pixel formats:</p> <ol> <li>PixelRedGreenBlueReserved8BitPerColor</li> <li>PixelBlueGreenRedReserved8BitPerColor</li> </ol>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#printscreenlogger-operation","title":"PrintScreenLogger operation","text":"<p>During initialization, the Print Screen Logger registers for notification of the Ctrl-PrtScn key combination is pressed.</p> <p>When a Print Screen callback occurs:</p> <ol> <li>Looks for a mounted USB drive that contains a file in the root directory called    PrintScreenEnable.txt.  This limits PrintScreenLogger to only write to    enabled USB devices.</li> <li>Looks for the next available filename in the form PrtScreen####.bmp,    starting with 0000.</li> <li>Creates the new PrtScreen####.bmp file.</li> <li>Call GraphicsOutput-&gt;Blt to obtain the complete screen.</li> <li>Converts the BLT buffer to a 24bbp BMP structure.</li> <li>Writes the BMP structure to the new PrtScreen####.bmp file.</li> </ol>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#including-in-your-platform","title":"Including in your platform","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#sample-dsc-change","title":"Sample DSC change","text":"<pre><code>    [Components.&lt;arch&gt;]\n    ...\n    ...\n    MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#sample-fdf-change","title":"Sample FDF change","text":"<pre><code>    [FV.&lt;a DXE firmware volume&gt;]\n    ...\n    ...\n    INF MsGraphicsPkg/PrintScreenLogger/PrintScreenLogger.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsGraphicsPkg/PrintScreenLogger/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/","title":"Rendering Engine Driver","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/#about","title":"About","text":"<p>The Rendering Engine is responsible for maintaining the supported windows, displaying popups, and restopring windows when popups are dismissed. The Rendering Engins is the only consumer of the MsGopOverrideProtocol and is the publisher of the \"real\" Efi Graphics Output protocol.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/RenderingEngineDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/","title":"Simple Window Manager","text":""},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/#about","title":"About","text":"<p>The Simple Window Manager manages window placement and pop up dialogs. The Simple Window Manager uses the Rendering Engine to display objects in their display region.</p>"},{"location":"dyn/mu_plus/MsGraphicsPkg/SimpleWindowManagerDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/","title":"MS WHEA Package","text":""},{"location":"dyn/mu_plus/MsWheaPkg/readme/#about","title":"About","text":"<p>This package contains drivers and infrastructure for reporting errors and telemetry through the CPER (Common Platform Error Record) HwErrRecord interface, specifically targeting systems that also leverage WHEA (Windows Hardware Error Architecture).</p> <p>The MsWhea drivers provide the same functionality at different stages of UEFI by binding to the REPORT_STATUS_CODE interface. Together, they store hardware errors and corrected faults into non-volatile memory that is later picked up by Windows. In Windows, this can be emitted as telemetry which is then used to identify errors and patterns for devices (as of time of writing any event besides EFI_GENERIC_ERROR_INFO will be sent).</p> <p>Project MU has updated design which defines a specific section type under <code>gMuTelemetrySectionTypeGuid</code> to be used in CPER header for WHEA telemetry. All reported data will be formatted to this section. Please refer to <code>MuTelemetryCperSection.h</code> for field definitions.</p> <p>This package also contains optional solutions for persisting error records in the pre-memory space. In early boot stages, drivers need to emit events as critical in order for them to be logged.</p> <p>Detailed information about CPER can be found in Appendix N of the UEFI spec.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#how-to-include-this-driver","title":"How to include this driver","text":"<p>This driver must be included via DSC by including the EarlyStorageLib: MsWheaEarlyStorageLib|MsWheaPkg/Library/MsWheaEarlyStorageLib/MsWheaEarlyStorageLib.inf Then the PEI stage driver will be included in the DSC Components.IA32 or PEI section: MsWheaPkg/MsWheaReport/Pei/MsWheaReportPei.inf Then the DXE stage driver will be included in the Components.X64 or DXE section: MsWheaPkg/MsWheaReport/Dxe/MsWheaReportDxe.inf Finally the SMM stage driver will be included in the Components.X64 or DXE_SMM_DRIVER section: MsWheaPkg/MsWheaReport/Smm/MsWheaReportSmm.inf</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#important-notes","title":"Important Notes","text":"<p>The PCD value of gMsWheaPkgTokenSpaceGuid.PcdDeviceIdentifierGuid must be overriden by each platform as this is later used in the CPER as the Platform ID (byte offset 32 in the record).</p> <p>In the DXE phase, errors will be picked up by MsWhea for you. In early phases of boot, the errors must be explicitly logged. To do so, first add the library into your INF: MsWheaPkg/MsWheaPkg.dec</p> <p>These headers must be included:</p> <ul> <li>MsWheaErrorStatus.h</li> <li>MuTelemetryCperSection.h</li> <li>Library/BaseLib.h</li> </ul> <p>Once you're ready to log your error, you can fill the MU_TELEMETRY_CPER_SECTION_DATA and report the StatusCode. The failure type is of type EFI_STATUS_CODE_VALUE. Note that MsWhea drivers will only listen to report status code calls with <code>(EFI_ERROR_MINOR | EFI_ERROR_CODE)</code> or <code>(EFI_ERROR_MAJOR | EFI_ERROR_CODE)</code> at EFI_STATUS_CODE_TYPE.</p> <pre><code>ReportStatusCode( MS_WHEA_ERROR_STATUS_TYPE_FATAL,\n{{ FAILURE_TYPE }});\n</code></pre> <p>for error under EFI_GENERIC_ERROR_FATAL severity. Or:</p> <pre><code>ReportStatusCode( MS_WHEA_ERROR_STATUS_TYPE_INFO,\n{{ FAILURE_TYPE }});\n</code></pre> <p>will report errors under EFI_GENERIC_ERROR_INFO severity.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#testing","title":"Testing","text":"<p>There is a UEFI shell application based unit test for WHEA reports.  This test attempts to verify basic functionality of public interfaces.  Check the UnitTests folder at the root of the package.</p> <p>There is also a feature flag that can inject reports on each boot during various uefi stages. This flag should be off in production.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#helper-lib","title":"Helper Lib","text":"<p>A helper lib to help integrate the MsWhea package has been provided. It is entirely optional and can be easily dropped in. It provides a few macros that are detailed here.</p> <ul> <li>LOG_INFO_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData )</li> <li>LOG_INFO_EVENT ( ClassId )</li> <li>LOG_CRITICAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData )</li> <li>LOG_CRITICAL_EVENT ( ClassId )</li> <li>LOG_FATAL_TELEMETRY ( ClassId, LibraryId, IhvId, ExtraData1, ExtraData )</li> <li>LOG_FATAL_EVENT ( ClassId )</li> </ul> <p>Currently FATAL and CRITICAL map to the same level in the WHEA log but has been implemented to provide future functionality. The parameters are as follows.</p> <ul> <li>ClassId - An EFI_STATUS_CODE_VALUE representing the event that has occurred. This should be unique enough to identify a             module or region of code.</li> <li>LibraryId - An optional EFI_GUID that should identify the library emitting this event</li> <li>IhvId - An optional EFI_GUID that should identify the Ihv that is most applicable to this. This will often be NULL</li> <li>ExtraData1 - A UINT64 that can be used to provide contextual or runtime data. It will be persisted and can be useful for                 debugging purposes.</li> <li>ExtraData2 - Another UINT64 that is also used for contextual and runtime data similar to ExtraData1.</li> </ul> <p>By default, gEfiCallerIdGuid is used as the module ID when using the macros. If you need complete control over the WHEA entry, you can use the LogTelemetry function to log a telemetry event. This is the function that the Macros use. More information on this function is in the public header for MuTelemetryHelperLib.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#including-the-helper-lib","title":"Including the Helper Lib","text":"<p>The helper lib can easily be included by including it in your DSC.</p> <pre><code>[LibraryClasses]\n  MuTelemetryHelperLib|MsWheaPkg/Library/MuTelemetryHelperLib/MuTelemetryHelperLib.inf\n</code></pre> <p>Since it is a BASE library, it is available for all architectures.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/","title":"HwhMenu","text":""},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#about","title":"About","text":"<p>A UEFI front page application which displays various fields of hardware error records to the user. The application attempts to parse fields to provide more useful information and prints the raw data if it cannot.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#main-file","title":"Main File","text":""},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#hwhmenuc","title":"HwhMenu.c","text":"<p>The main application file.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#loading-logs","title":"Loading Logs","text":"<p>The HwErrRecs are loaded when the Hardware Health tab is first opened using GetVariable(). The records are verified using CheckHwErrRecHeaderLib within MsWheaPkg before being added to a linked list structure. The linked list is not being deleted because it will simply be reclaimed when the OS boots or another allocation call is made which needs that memory. The config struct used by the vfr holds a single UINT8 which if equal to LOGS_TRUE means there are errors to display. If it is equal to LOGS_FALSE, the page will be suppressed and a string saying that there are no logs present will be displayed at the top.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#paging-between-logs-and-updating-the-form","title":"Paging between logs and updating the form","text":"<p>There is a simple paging interface between records. Whenever Next or Previous is pressed by the user, the page attempts to perform the desired action. If it is successful, UpdateForm() is called which simply inserts nothing into the label section of the VFR. What this does is make the form think it has been updated and tricks it into refreshing, thus allowing all error specific strings which have been edited to be displayed to the user.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#parsing-the-logs","title":"Parsing the logs","text":"<p>Each field which we display is parsed using the structs defined in Cper.h. Parsing most fields is straightforward, but parsing section data requires a bit more work. When preparing section data for the user, a call is made to ParserRegistryLib using the Section Type guid within the section header of the hardware error record. The parser registry holds a table which associates guids with function pointers, and any entity which employs its own section guid should register a section data parser with the library. During parsing, if the section type matches one in the register, the function pointer is called with the parameters specified in ParserRegistryLib.h (SECTIONFUNCTIONPTR). The parser parses the data and populates an array of strings with their desired display. HwhMenu.c holds a 2D array of EFI_STRING_IDs which are the lines/columns where section data can be placed. The populated string array is written to these strings until there is no more data to display or there are no more strings to put the data. The user can place '\\n' within their strings to separate a line into columns. See the GenericSectionParserLib for a parsing example.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#adding-to-the-section-parser","title":"Adding to the Section Parser","text":"<p>If you, the platform developer, recognize a section guid and know how to parse the bytes, you can provide a function to do so by calling ParserLibRegisterSectionParser() with the guid you're able to parse and a function pointer to parse it. This can be done within a new driver or by simply extending an existing driver. The HWH menu will pass to your function (if the guid matches) a pointer to the section data and a pointer to an array of strings to fill out with your completed parse.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#secondary-files","title":"Secondary files","text":""},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#creatoridparserc-and-platformidparserc","title":"CreatorIDParser.c and PlatformIDParser.c","text":"<p>Called from within the HwhMenu.c file to parse the Creator and Platform IDs.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#hwhmenuvfrh","title":"HwhMenuVfr.h","text":"<p>Holds configuration information and guid opcodes used in the VFR file</p>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#including-the-hwh-menu","title":"Including the HWH Menu","text":"<p>To include, paste the following in the platform DSC flie:</p> <pre><code>[LibraryClasses]\n    ParserRegistryLib     |MsWheaPkg/Library/ParserRegistryLib/ParserRegistryLib.inf\n    CheckHwErrRecHeaderLib|MsWheaPkg/Library/CheckHwErrRecHeaderLib/CheckHwErrRecHeaderLib.inf\n[Components.X64]\n    MsWheaPkg/HwhMenu/HwhMenu.inf\n</code></pre> <p>and the following in the platform FDF file</p> <pre><code>[FV.FVDXE]\n    INF  MsWheaPkg/HwhMenu/HwhMenu.inf\n</code></pre>"},{"location":"dyn/mu_plus/MsWheaPkg/HwhMenu/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/","title":"ParserRegistryLib","text":""},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/#about","title":"About","text":"<p>Holds a table which associates guids with function pointers used for parsing section data. If an entity wishes to parse a section type in a specific way, they simply need to call the register function using a the section type guid and function pointer. When HwhMenu.c tries to parse section data, it will look through all guids and return a function pointer if one matches. The functions being registered must adhere to the SECTIONFUNCTIONPTR type located in ParserRegistryLib.h.</p>"},{"location":"dyn/mu_plus/MsWheaPkg/Library/ParserRegistryLib/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/","title":"MS Network DependencyLib and NetworkDelayLib","text":""},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#about","title":"About","text":"<p>These libraries implement a method to disable the network stack unless there is a reason to use the network.  Not starting the network improves boot performance and causes fewer issues during manufacturing.</p>"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#how-to-use-these-libraries","title":"How to use these libraries","text":"<p>Add the NetworkDelayLib as a NULL library reference.  All this library does is introduce a [Depex] on a NetworkDelay protocol.</p> <pre><code>  MdeModulePkg/Universal/Network/SnpDxe/SnpDxe.inf {\n    &lt;LibraryClasses&gt;\n      NULL|PcBdsPkg/Library/MsNetworkDelayLib/MsNetworkDelayLib.inf\n  }\n</code></pre> <p>The NetworkDependencyLib implements a StartNetwork() interface that will publish the NetworkDelay protocol.</p> <p>The future goal of this functionality is to have the EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() function be overridden and insert a call to DeviceDependencyLib.StartNetwork() when a request is made to start the network class.</p> <p>You nay see other references to NetworkDependencyLib as the conversion to using EFI_BOOT_MANAGER_POLICY.ConnectDeviceClass() is not complete.</p>"},{"location":"dyn/mu_plus/PcBdsPkg/Library/MsNetworkDependencyLib/readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/","title":"UEFI Testing Package","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#about","title":"About","text":"<p>This package adds tests.  </p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#system-functional-tests","title":"System Functional tests","text":"<p>Tests that invoke system functions and query system state for verification.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#memmapandmattestapp","title":"MemmapAndMatTestApp","text":"<p>This test compares the UEFI memory map and Memory Attributes Table against known requirements.  The MAT has strict requirements to allow OS usage and page protections.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#morlocktestapp","title":"MorLockTestApp","text":"<p>This test verifies the UEFI variable store handling of MorLock v1 and v2 behavior.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smmpagingprotections","title":"SmmPagingProtections","text":"<p>This test verifies the SMM paging attributes by invoking operations that should cause cpu exceptions if the memory protections are in place.  The SMM cpu exception handler needs to be configured to force reset on trap to allow automated testing. See <code>UefiCpuPkg/Include/Protocol/SmmExceptionTestProtocol.h</code>, <code>gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionRebootInsteadOfHaltDefault</code>, and <code>gUefiCpuPkgTokenSpaceGuid.PcdSmmExceptionTestModeSupport</code>.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#system-audit-tests","title":"System Audit tests","text":"<p>UEFI applications that collect data from the system and then that data can be used to compare against known good values.  </p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#uefivarlockaudit","title":"UefiVarLockAudit","text":"<p>Audit collection tool that gathers information about UEFI variables.  This allows auditing the variables within a system, checking attributes, and confirming read/write status.  This information is put into an XML file that allows for easy comparison and programmatic auditing.  </p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#uefi","title":"UEFI","text":"<p>UEFI shell application that gets the current variable information from the UEFI shell and creates an XML file.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#windows-uefi","title":"Windows (UEFI)","text":"<p>Python  script that can be run from the Windows OS.  It takes the UEFI created XML file as input and then queries all listed variables and updates the XML with access and status codes.  This gives additional verification for variables that may employ late locking or other protections from OS access.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#tpmeventlogaudit","title":"TpmEventLogAudit","text":"<p>Audit tool to collect the TPM Event Log from the system in standard format.  It can then be programmatically compared against a known event log for the given system.  Easy this that can be tested are the number of events in some PCRs, confirm that all PCRs should be capped, etc.  </p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smmpagingaudit","title":"SMMPagingAudit","text":"<p>Audit tool creates a human readable description of the SMM page tables and memory environment.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#app","title":"App","text":"<p>UEFI shell application collects information from SMM and writes it to files.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#smm","title":"SMM","text":"<p>SMM Library linked into SMM driver used to collect information about SMM environment.  Activated by the shell app collects IDT, GDT, page tables, and loaded images.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#windows-smm","title":"Windows (SMM)","text":"<p>Python scripts that process the files generated by the UEFI app and output a report for verification and analysis.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/","title":"DMAR Table Audit","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/UEFI/#about","title":"About","text":"<p><code>DMAProtectionUnitTestApp.c</code></p> <p>Shell based UEFI unit test based off of the UnitTestFrameworkPkg that test for:</p> <ol> <li>IOMMU status register shows IOMMU enabled</li> <li>All excluded regions are set as EfiReservedMemoryType(VTd)/EfiACPIMemoryNVS(IVRS)</li> <li>Bus mastering enabled (BME) is disabled on ExitBootServices. Because we can no longer write to file after ExitBootServices     a variable is used to store the test state and the machine.</li> </ol> <p>Note: this unit test requires a restart to finish its testing. If you plan to use this unit test in automation make sure to set up your startup.nsh script properly.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/","title":"DMAR Table Audit","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/DMAProtectionAudit/Windows/Readme/#about","title":"About","text":"<p><code>DMARTableAudit.py</code></p> <p>Unit test that checks:</p> <ol> <li>DMA remapping bit is enabled</li> <li>No ANDD structures are included in DMAR table</li> <li>RMRRs are limited to only the RMRRs specified in provided XML file (if no XML provided then verify no RMRRs exist)</li> </ol> <p>Software Requirements</p> <ol> <li>Python3</li> <li>Pywin32<ul> <li><code>pip install Pywin32</code></li> </ul> </li> <li>Project Mu python library<ul> <li><code>pip install mu-python-library</code></li> </ul> </li> </ol>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/","title":"Paging Audit","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smmpagingaudit","title":"SmmPagingAudit","text":"<p>SMM is a privileged mode of the ia32/x64 cpu architecture.  In this environment nearly all system state can be inspected including that of the operating system, kernel, and hypervisor.  Due to it's capabilities SMM has become an area of interest for those searching to exploit the system. To help minimize the interest and impact of an exploit in SMM the SMI handlers should operate in a least privileged model.  To do this standard paging can be leveraged to limit the SMI handlers access.  Tianocore has a feature to enable paging within SMM and this tool helps confirm the configuration being used.  This tool requires three parts to get a complete view.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm","title":"SMM","text":"<p>The SMM driver must be included in your build and dispatched to SMM before the End Of Dxe.  It is recommended that this driver should only be used on debug builds as it reports the entire SMM memory environment to the caller.  The shell app will communicate to the SMM driver and request critical memory information including IDT, GDT, page tables, and loaded images.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm-version-app","title":"SMM Version App","text":"<p>The UEFI shell application collects system information from the DXE environment and then communicates to the SMM driver/handler to collect necessary info from SMM.  It then writes this data to files and then that content is used by the windows scripts.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingaudit","title":"DxePagingAudit","text":"<p>The Dxe version of paging audit driver/shell app intends to inspect all 4 levels of page tables and their corresponding Read/Write/Execute/Present attributes. The driver/shell app will collect necessary memory information from platform environment, then iterate through each page entries and log them on to available SimpleFileSystem. The collected *.dat files can be parsed using Windows\\PagingReportGenerator.py.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-driver","title":"DXE Driver","text":"<p>The DXE Driver registers an event to be notified on Mu Pre Exit Boot Services (to change this, replace gMuEventPreExitBootServicesGuid with a different event GUID), which will then trigger the paging information collection.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-version-app","title":"DXE Version App","text":"<p>The DXE version of UEFI shell application collects necessary system and memory information from DXE when invoked from Shell environment.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#windows","title":"Windows","text":"<p>The Windows script will look at the *.DAT files, parse their content, check for errors and then insert the formatted data into the Html report file.  This report file is then double-clickable by the end user/developer to review the posture of the SMM environment.  The Results tab applies our suggested rules for SMM to show if the environment passes or fails. If it fails the filters on the data tab can be configured to show where the problem exists.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#usage-enabling-on-edk2-based-system","title":"Usage / Enabling on EDK2 based system","text":"<p>First, for the SMM driver and app you need to add them to your DSC file for your project so they get compiled.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#smm-paging-audit","title":"SMM Paging Audit","text":"<pre><code>[PcdsFixedAtBuild.X64]\n  # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR\n  gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE\n\n[Components.X64]\n  UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf\n  UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditTestApp.inf\n</code></pre> <p>Next, you must add the SMM driver to a firmware volume in your FDF that can dispatch SMM modules.</p> <pre><code>INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/SmmPagingAuditDriver.inf\n</code></pre> <p>Third, after compiling your new firmware you must:</p> <ol> <li>Flash that image on the system.</li> <li>Copy the SmmPagingAuditTestApp.efi to a USB key</li> </ol> <p>Then, boot your system running the new firmware to the shell and run the app. The tool will create a set of *.dat files on the same USB key.</p> <p>On a Windows PC, run the Python script on the data found on your USB key.</p> <p>Finally, double-click the HTML output file and check your results.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxe-paging-audit","title":"DXE Paging Audit","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingauditdxe","title":"DxePagingAuditDxe","text":"<ol> <li> <p>Add the following entry to platform dsc file;</p> <pre><code>[PcdsFixedAtBuild.X64]\n  # Optional: Virtual platforms that do not support SMRRs can add below change to skip the auditing related to SMRR\n  gUefiTestingPkgTokenSpaceGuid.PcdPlatformSmrrUnsupported|TRUE\n\n[Components.X64]\n    UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf\n</code></pre> </li> <li> <p>Add the driver to a firmware volume in your FDF that can dispatch it;</p> <pre><code>INF UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditDriver.inf\n</code></pre> </li> <li> <p>After compiling your new firmware you must flash that image on the system.</p> </li> <li> <p>Boot your system running the new firmware to the OS then reboot to UEFI shell with a USB plugged in. If the USB disk is     <code>FS0:\\\\</code>, the files should be in <code>FS1:\\\\</code>. Copy them to the flash drive:</p> <pre><code>copy FS1:\\*.dat FS0:\\\n</code></pre> </li> <li> <p>On a Windows PC, run Windows\\PagingReportGenerator.py script with the data found on your USB key. Please use the following command for detailed script instruction:</p> <pre><code>PagingReportGenerator.py -h\n</code></pre> </li> <li> <p>Double-click the HTML output file and check your results.</p> </li> </ol>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#dxepagingaudittestapp","title":"DxePagingAuditTestApp","text":"<ol> <li> <p>Add the following entry to platform dsc file:</p> <pre><code>[Components.X64]\n    UefiTestingPkg/AuditTests/PagingAudit/UEFI/DxePagingAuditTestApp.inf\n</code></pre> </li> <li> <p>Compile the newly added application and copy DxePagingAuditTestApp.efi to a USB key.</p> </li> <li> <p>Boot your system to the shell with the USB plugged in. If the USB disk is <code>FS0:\\</code>, the files should be in <code>FS1:\\\\</code>. Copy them to the flash drive:</p> <pre><code>FS0:\\\nDxePagingAuditTestApp.efi\ncopy FS1:\\*.dat FS0:\\\n</code></pre> </li> <li> <p>Follow step 5 - 6 from DxePagingAuditDxe section.</p> </li> </ol>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/PagingAudit/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/","title":"Variable Lock Audit Test","text":"<p>The Variable Lock Audit tests is a tool to ensure that variables have the correct policy.</p> <p>The test is only a helper. That is, running the Audit test generates a report. Developers need to understand the report, and ensure that all the variable have the correct policy. The reviewed report is saved as a master known good report.</p> <p>Later, after ingesting new code and update the firmware, you can run the audit test and compare the new report with the previously stored master known good report.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#two-versions-of-the-variable-audit-test","title":"Two versions of the Variable Audit Test","text":"<p>There are two versions of the Variable Audit Test. One is a shell application to check all the variables visible during Boot Services. The second version of the Variable Audit Test checks all the variables visible in the OS using the list of variables generated bu the UEFI version of the test.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#building-the-uefi-version-of-the-tool","title":"Building the UEFI version of the tool","text":"<p>Just add the following to your platform package .dsc file:</p> <pre><code>   UefiTestingPkg/AuditTests/UefiVarLockAudit/UEFI/UefiVarLockAuditTestApp.inf\n</code></pre>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#running-the-varlockaudit-test","title":"Running the VarLockAudit Test","text":"<p>Copy UefiVarLockAuditTestApp.efi, UefiVarAudit.py, and UefiVariablesSupportLib.py to a USB device. First, you need to run the UEFI Version of the test by booting to the UEFI Shell. Log into the USB device (ie FS0:). Run UefiVarLockAuditTestApp.efi to generate the UefiVarLockAudit_manifest.xml file:</p> <pre><code>FS0:&gt; UefiVarLockAuditTestApp\n</code></pre> <p>Boot the system into Windows. Open an Administrator Cmd window. Change the drive to the USB device, and to the directory to where UefiVarLockAudit_manifest.xml, UefiVarAudit.py, and UefiVariablesSupportLib.py are stored. Run:</p> <pre><code>D:\\python UefiVarAudit.py -InputXml UefiVarLockAudit_manifest.xml -OutputXml VarLockAuditResults.xml\n</code></pre>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#analyzing-the-varlockauditresultsxml","title":"Analyzing the VarLockAuditResults.xml","text":"<p>Here is an example of a Boot Services variable:</p> <pre><code>  &lt;Variable Guid=\"4C19049F-4137-4DD3-9C10-8B97A83FFDFA\" Name=\"MemoryTypeInformation\"&gt;\n&lt;Attributes&gt;0x3 NV BS&lt;/Attributes&gt;\n&lt;Size&gt;48&lt;/Size&gt;\n&lt;Data&gt;09000000580000000A000000200000000000000029000000060000004601000005000000B70000000F00000000000000&lt;/Data&gt;\n&lt;ReadyToBoot&gt;\n&lt;ReadStatus&gt;0x0 Success&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x0 Success&lt;/WriteStatus&gt;\n&lt;/ReadyToBoot&gt;\n&lt;FromOs&gt;\n&lt;ReadStatus&gt;0xCB [WinError 203] The system could not find the environment option that was entered.&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x13 [WinError 19] The media is write protected.&lt;/WriteStatus&gt;\n&lt;/FromOs&gt;\n&lt;/Variable&gt;\n</code></pre> <p>It shows the results of reading and writing to the variable at two places.  One is after ReadyToBoot, and is provided by the UEFI version of the VarLockAudit test.  The other is in the OS.  In this example, the variable does not have the RT (Runtime) attributes, and Windows cannot read this variable. It also cannot write to the variable since is is present.</p> <p>Here is an example of a variable with the Runtime attribute:</p> <pre><code>  &lt;Variable Guid=\"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name=\"BootOrder\"&gt;\n&lt;Attributes&gt;0x7 NV BS RT&lt;/Attributes&gt;\n&lt;Size&gt;10&lt;/Size&gt;\n&lt;Data&gt;05000000010002000300&lt;/Data&gt;\n&lt;ReadyToBoot&gt;\n&lt;ReadStatus&gt;0x0 Success&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x0 Success&lt;/WriteStatus&gt;\n&lt;/ReadyToBoot&gt;\n&lt;FromOs&gt;\n&lt;ReadStatus&gt;0x0&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x0&lt;/WriteStatus&gt;\n&lt;/FromOs&gt;\n&lt;/Variable&gt;\n````\n\nThe BootOrder variable is readable and writable in the OS.\n\nHere is an example of a write protected RT variable:\n\n```xml\n&lt;Variable Guid=\"8BE4DF61-93CA-11D2-AA0D-00E098032B8C\" Name=\"ConOutDev\"&gt;\n&lt;Attributes&gt;0x6 BS RT&lt;/Attributes&gt;\n&lt;Size&gt;30&lt;/Size&gt;\n&lt;Data&gt;02010C00D041030A0000000001010600000202030800001401807FFF0400&lt;/Data&gt;\n&lt;ReadyToBoot&gt;\n&lt;ReadStatus&gt;0x0 Success&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x0 Success&lt;/WriteStatus&gt;\n&lt;/ReadyToBoot&gt;\n&lt;FromOs&gt;\n&lt;ReadStatus&gt;0x0&lt;/ReadStatus&gt;\n&lt;WriteStatus&gt;0x13 [WinError 19] The media is write protected.&lt;/WriteStatus&gt;\n&lt;/FromOs&gt;\n&lt;/Variable&gt;\n</code></pre>"},{"location":"dyn/mu_plus/UefiTestingPkg/AuditTests/UefiVarLockAudit/Readme/#subsequent-runs-of-the-variable-audit-test","title":"Subsequent runs of the Variable Audit test","text":"<p>Once you have validated the results file, you can save it as a Good Master. You could simply run the tests on every firmware and compare the newly generated VarLockAuditResults.xml with the Good Master you saved. You only need to analyze the differences.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/","title":"Memory Protection Tests","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MemoryProtectionTest/Readme/#about-this-test","title":"About This Test","text":"<p>This is set of tests to ensure that heap guard, stack guard, null pointer detection, and nx protections are working properly.</p> <p>It consists of:</p> <ul> <li>An SMM driver</li> <li>A Shell-based test app</li> </ul> <p>The Shell-based app may be built at any time and run from Shell. The app can use the SMM driver to preform SMM tests if the SMM driver is installed.</p> <p>It is not the intention of this test to include the driver in production systems. They should only be used for purpose-built test images.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MpManagement/Readme/","title":"MP Management Tests","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MpManagement/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/MpManagement/Readme/#about-this-test","title":"About This Test","text":"<p>This is set of functionality and unit tests to ensure that individual cores can be powered on/off and suspended/resumed as expected.</p> <p>It consists of:</p> <ul> <li>An DXE driver</li> <li>A Shell-based test app</li> </ul> <p>The Shell-based app may be built at any time and run from Shell. The app can use the DXE driver installed protocol to preform AP power state exercise if the DXE driver is properly installed.</p> <p>It is not the intention of this test to include the driver in production systems. They should only be used for purpose-built test images.</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/","title":"SMM Paging Protections Test","text":""},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. All rights reserved. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/UefiTestingPkg/FunctionalSystemTests/SmmPagingProtectionsTest/Readme/#about-this-test","title":"About This Test","text":"<p>This is a [currently] small test to prove that certain SMM paging protections have been applied.</p> <p>It consists of:</p> <ul> <li>An SMM driver</li> <li>A DXE driver</li> <li>A Shell-based test app</li> </ul> <p>In order to use this test, the SMM and DXE drivers must be built and included in your FW image to be dispatched at boot time. The Shell-based app may be built at any time and run from Shell. The app will ask the DXE driver to pass a message to the SMM driver to invoke a particular test.</p> <p>It is not the intention of this test to include the two drivers in production systems. They should only be used for purpose-built test images.</p>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/","title":"Xml Support Package","text":""},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#about","title":"About","text":"<p>This package adds some limited XML support to the UEFI environment.  Xml brings value in that there are numerous, robust, readily available parsing solutions in nearly every environment, language, and operating system. The UEFI support is limited in that it only supports ASCII strings and does not support XSD, schema, namespaces, or other extensions to XML.</p>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#xmltreelib","title":"XmlTreeLib","text":"<p>The XmlTreeLib is the cornerstone of this package.  It provides functions for:</p> <ul> <li>Reading and parsing XML strings into an XML node/tree structure</li> <li>Creating or altering xml nodes within a tree</li> <li>Writing xml nodes/trees to ASCII string</li> <li>Escaping and Un-Escaping strings</li> </ul>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#xmltreequerylib","title":"XmlTreeQueryLib","text":"<p>The XmlTreeQueryLib provides very basic and simple query functions allowing code to interact with the XmlTree to do things like:</p> <ul> <li>Find the first child element node with a name equal to the parameter</li> <li>Find the first attribute node of a given element with a name equal to the parameter</li> </ul>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#unittestresultreportlib","title":"UnitTestResultReportLib","text":"<p>A UnitTestResultReportLib that formats the results in XML using the JUnit defined schema.  This instance allows the UEFI Unit Test Framework to integrate results with existing tools and other frameworks.  </p>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#testing","title":"Testing","text":"<p>There are UEFI shell and host based unit tests for each library.  These tests attempt to verify basic functionality of publicly defined functions.  Check the Test/UnitTest folder at the root of the package for more details.</p>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#developer-notes","title":"Developer Notes","text":"<ul> <li>These libraries have known limitations and have not been fully vetted for un-trusted input. If used in such a situation it is suggested to validate the input before leveraging the XML libraries.  With that said the ability to use xml in UEFI has been invaluable for building features and tests that interact with code running in other environments.</li> <li>The parser has been tuned to fail fast and when invalid XML encountered just return NULL.</li> </ul>"},{"location":"dyn/mu_plus/XmlSupportPkg/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_plus/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_plus/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_plus/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_plus/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_silicon_arm_tiano/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/","title":"Project Mu Silicon Arm Tiano Repository","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_silicon_arm_tiano.git Branch:         release/202208 Commit:         bcb56e64e1d433b6b14423f5efa298e732d8c66b Commit Date:    2023-01-30 22:32:41 -0500</p> <p>This repository contains Project Mu code based on TianoCore edk2 code for ARM silicon features and ARM based platforms.</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_silicon_arm_tiano/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmPlatformPkg/Drivers/HestMmErrorSources/Readme/","title":"HEST &amp; SDEI","text":"<p>Hardware Error Source Table HEST [1] and Software Delegated Exception Interface SDEI [2] ACPI tables are used to accomplish firmware first error handling.This patch series introduces a framework to build and install the HEST ACPI table dynamically.</p> <p>The following figure illustrates the possible usage of the dynamic generation of HEST ACPI table.</p> <p><code>ascii art                                     NS | S +--------------------------------------+--------------------------------------+ |                                      |                                      | |+-------------------------------------+---------------------+                | ||               +---------------------+--------------------+|                | ||               |                     |                    ||                | || +-----------+ |+------------------+ | +-----------------+|| +-------------+| || |HestTable  | ||  HestErrorSource | | | HestErrorSource ||| | DMC-620     || || |  DXE      | ||        DXE       | | |  StandaloneMM   ||| |Standalone MM|| || +-----------+ |+------------------+ | +-----------------+|| +-------------+| ||               |GHESv2               |                    ||                | ||               +---------------------+--------------------+|                | ||          +--------------------+     |                     |                | ||          |PlatformErrorHandler|     |                     |                | ||          |        DXE         |     |                     |                | ||          +--------------------+     |                     |                | ||FF FWK                               |                     |                | |+-------------------------------------+---------------------+                | |                                      |                                      | +--------------------------------------+--------------------------------------+                                        |                    Figure: Dynamic Hest Table Generation.</code></p> <p>All the hardware error sources are added to HEST table as GHESv2[3] error source descriptors. The framework comprises of following DXE and MM drivers:</p> <ul> <li> <p>HestTableDxe:   Builds HEST table header and allows appending error source descriptors to the   HEST table. Also provides protocol interface to install the built HEST table.</p> </li> <li> <p>HestErrorSourceDxe &amp; HestErrorSourceStandaloneMM:   These two drivers together retrieve all possible error source descriptors of   type GHESv2 from the MM drivers implementing HEST Error Source Descriptor   protocol. Once all the descriptors are collected HestErrorSourceDxe appends   it to HEST table using HestTableDxe driver.</p> </li> <li> <p>PlatformErrorHandlerDxe:   Builds and installs SDEI ACPI table. This driver does not initialize(load)   until HestErrorSourceDxe driver has finished appending all possible GHESv2   error source descriptors to the HEST table. Once that is complete using the   HestTableDxe driver it installs the HEST table.</p> </li> </ul> <p>This patch series provides reference implementation for DMC-620 Dynamic Memory Controller[4] that has RAS feature enabled. This is platform code implemented as Standalone MM driver in edk2-platforms.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmPlatformPkg/Drivers/HestMmErrorSources/Readme/#references","title":"References","text":"<p>[1]: ACPI 6.3, Table 18-382, Hardware Error Source Table [2] : SDEI Platform Design Document, revision b, 10 Appendix C, ACPI table definitions for SDEI [3] : ACPI Reference Specification 6.3, Table 18-393 GHESv2 Structure [4] : DMC620 Dynamic Memory Controller, revision r1p0 [5] : UEFI Reference Specification 2.8, Appendix N - Common Platform Error       Record [6] : UEFI Reference Specification 2.8, Section N.2.5 Memory Error Section</p> <p>Link to github branch with the patches in this series - https://github.com/omkkul01/edk2/tree/ras_firmware_first_edk2</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/","title":"ArmVirtPkg - Platform CI","text":"<p>This Readme.md describes the Azure DevOps based Platform CI for ArmVirtPkg and how to use the same Pytools based build infrastructure locally.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#supported-configuration-details","title":"Supported Configuration Details","text":"<p>This solution for building and running ArmVirtPkg has only been validated with Ubuntu 18.04 and the GCC5 toolchain. Two different firmware builds are supported and are described below.</p> Configuration name Architecture DSC File Additional Flags AARCH64 AARCH64 ArmVirtQemu.dsc None ARM ARM ArmVirtQemu.dsc None"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#edk2-developer-environment","title":"EDK2 Developer environment","text":"<ul> <li>Python 3.8.x - Download &amp; Install</li> <li>GIT - Download &amp; Install</li> <li>QEMU - Download, Install, and add to your path</li> <li>Edk2 Source</li> <li>Additional packages found necessary for Ubuntu 18.04</li> <li>apt-get install gcc g++ make uuid-dev</li> </ul> <p>Note: edksetup, Submodule initialization and manual installation of NASM, iASL, or the required cross-compiler toolchains are not required, this is handled by the Pytools build system.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#building-with-pytools-for-armvirtpkg","title":"Building with Pytools for ArmVirtPkg","text":"<ol> <li> <p>[Optional] Create a Python Virtual Environment - generally once per workspace</p> <pre><code>python -m venv &lt;name of virtual environment&gt;\n</code></pre> </li> <li> <p>[Optional] Activate Virtual Environment - each time new shell opened</p> <ul> <li>Windows</li> </ul> <pre><code>&lt;name of virtual environment&gt;/Scripts/activate.bat\n</code></pre> <ul> <li>Linux</li> </ul> <pre><code>source &lt;name of virtual environment&gt;/bin/activate\n</code></pre> </li> <li> <p>Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes</p> <pre><code>pip install --upgrade -r pip-requirements.txt\n</code></pre> </li> <li> <p>Initialize &amp; Update Submodules - only when submodules updated</p> <pre><code>stuart_setup -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n</code></pre> </li> <li> <p>Initialize &amp; Update Dependencies - only as needed when ext_deps change</p> <pre><code>stuart_update -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n</code></pre> </li> <li> <p>Compile the basetools if necessary - only when basetools C source files change</p> <pre><code>python BaseTools/Edk2ToolsBuild.py -t &lt;ToolChainTag&gt;\n</code></pre> </li> <li> <p>Compile Firmware</p> <pre><code>stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n</code></pre> <ul> <li>use <code>stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py -h</code> option to see additional options like <code>--clean</code></li> </ul> </li> <li> <p>Running Emulator</p> <ul> <li>You can add <code>--FlashRom</code> to the end of your build command and the emulator will run after the build is complete.</li> <li>or use the <code>--FlashOnly</code> feature to just run the emulator.</li> </ul> <pre><code>stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt; --FlashOnly\n</code></pre> </li> </ol>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#notes","title":"Notes","text":"<ol> <li>Including the expected build architecture and toolchain to the stuart_update command is critical.    This is because there are extra scopes and tools that will be resolved during the update step that    need to match your build step.</li> <li>Configuring ACTIVE_PLATFORM and TARGET_ARCH in Conf/target.txt is not required. This    environment is set by PlatformBuild.py based upon the <code>[-a &lt;TARGET_ARCH&gt;]</code> parameter.</li> <li>QEMU must be on your path.  On Windows this is a manual process and not part of the QEMU installer.</li> </ol> <p>NOTE: Logging the execution output will be in the normal stuart log as well as to your console.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#custom-build-options","title":"Custom Build Options","text":"<p>MAKE_STARTUP_NSH=TRUE will output a startup.nsh file to the location mapped as fs0. This is used in CI in combination with the <code>--FlashOnly</code> feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh.</p> <p>QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this.</p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#passing-build-defines","title":"Passing Build Defines","text":"<p>To pass build defines through stuart_build, prepend <code>BLD_*_</code>to the define name and pass it on the command-line. <code>stuart_build</code> currently requires values to be assigned, so add an <code>=1</code> suffix for bare defines. For example, to enable the TPM2 support, instead of the traditional \"-D TPM2_ENABLE=TRUE\", the stuart_build command-line would be:</p> <p><code>stuart_build -c ArmVirtPkg/PlatformCI/PlatformBuild.py BLD_*_TPM2_ENABLE=TRUE</code></p>"},{"location":"dyn/mu_silicon_arm_tiano/ArmVirtPkg/PlatformCI/ReadMe/#references","title":"References","text":"<ul> <li>Installing and using Pytools</li> <li>More on python virtual environments</li> </ul>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/","title":"Dynamic Tables Framework","text":"<p>Dynamic Tables Framework provides mechanisms to reduce the amount of effort required in porting firmware to new platforms. The aim is to provide an implementation capable of generating the firmware tables from an external source.  This is potentially a management node, either local or remote, or, where suitable, a file that might be generated from the system construction.  This initial release does not fully implement that - the configuration is held in local UEFI modules.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#feature-summary","title":"Feature Summary","text":"<p>The dynamic tables framework is designed to generate standardised firmware tables that describe the hardware information at run-time. A goal of standardised firmware is to have a common firmware for a platform capable of booting both Windows and Linux operating systems.</p> <p>Traditionally the firmware tables are handcrafted using ACPI Source Language (ASL), Table Definition Language (TDL) and C-code. This approach can be error prone and involves time consuming debugging. In addition, it may be desirable to configure platform hardware at runtime such as: configuring the number of cores available for use by the OS, or turning SoC features ON or OFF.</p> <p>The dynamic tables framework simplifies this by providing a set of standard table generators, that are implemented as libraries. These generators query a platform specific component, the 'Configuration Manager', to collate the information required for generating the tables at run-time.</p> <p>The framework also provides the ability to implement custom/OEM generators; thereby facilitating support for custom tables. The custom generators can also utilize the existing standard generators and override any functionality if needed.</p> <p>The framework currently implements a set of standard ACPI table generators for ARM architecture, that can generate Server Base Boot Requirement (SBBR) compliant tables. Although, the set of standard generators implement the functionality required for ARM architecture; the framework is extensible, and support for other architectures can be added easily.</p> <p>The framework currently supports the following table generators for ARM: * DBG2 - Debug Port Table 2 * DSDT - Differentiated system description table. This is essentially          a RAW table generator. * FADT - Fixed ACPI Description Table * GTDT - Generic Timer Description Table * IORT - IO Remapping Table * MADT - Multiple APIC Description Table * MCFG - PCI Express memory mapped configuration space base address          Description Table * SPCR - Serial Port Console Redirection Table * SSDT - Secondary System Description Table. This is essentially          a RAW table generator.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#dynamic-aml","title":"Dynamic AML","text":"<p>ACPI Definition block (e.g. DSDT or SSDT) tables are used to describe system devices along with other control and power management information. These tables are written using ACPI Source Language (ASL). The ASL code is compiled using an ASL compiler (e.g. Intel iASL compiler) to generate ACPI Machine Language (AML) bytecode.</p> <p>Since, definition blocks are represented using AML grammar, run-time generation of definition blocks is complex. Dynamic AML is a feature of Dynamic Tables framework that provides a solution for dynamic generation of ACPI Definition block tables.</p> <p>Dynamic AML introduces the following techniques: * AML Fixup * AML Codegen * AML Fixup + Codegen</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#aml-fixup","title":"AML Fixup","text":"<p>AML fixup is a technique that involves compiling an ASL template file to generate AML bytecode. This template AML bytecode can be parsed at run-time and a fixup code can update the required fields in the AML template.</p> <p>To simplify AML Fixup, the Dynamic Tables Framework provides an AmlLib library with a rich set of APIs that can be used to fixup the AML code.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#aml-codegen","title":"AML Codegen","text":"<p>AML Codegen employs generating small segments of AML code. The AmlLib library provides AML Codegen APIs that generate the AML code segments.</p> <pre><code>Example: The following table depicts the AML Codegen APIs and the\ncorresponding ASL code that would be generated.\n\n| AML Codegen API                | ASL Code                       |\n|--------------------------------|--------------------------------|\n|  AmlCodeGenDefinitionBlock (   |  DefinitionBlock (             |\n|    ..,                         |    ...                         |\n|    &amp;RootNode);                 |  ) {                           |\n|  AmlCodeGenScope (             |    Scope (_SB) {               |\n|    \"\\_SB\",                     |                                |\n|    RootNode,                   |                                |\n|    &amp;ScopeNode);                |                                |\n|  AmlCodeGenDevice (            |    Device (CPU0) {             |\n|    \"CPU0\",                     |                                |\n|    ScopeNode,                  |                                |\n|    &amp;CpuNode);                  |                                |\n|  AmlCodeGenNameString (        |      Name (_HID, \"ACPI0007\")   |\n|    \"_HID\",                     |                                |\n|    \"ACPI0007\",                 |                                |\n|    CpuNode,                    |                                |\n|    &amp;HidNode);                  |                                |\n|  AmlCodeGenNameInteger (       |      Name (_UID, Zero)         |\n|    \"_UID\",                     |                                |\n|    0,                          |                                |\n|    CpuNode,                    |                                |\n|    &amp;UidNode);                  |                                |\n|                                |      } // Device               |\n|                                |    } // Scope                  |\n|                                |  } // DefinitionBlock          |\n</code></pre>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#aml-fixup-codegen","title":"AML Fixup + Codegen","text":"<p>A combination of AML Fixup and AML Codegen could be used for generating Definition Blocks. For example the AML Fixup could be used to fixup certain parts of the AML template while the AML Codegen APIs could be used to inserted small fragments of AML code in the AML template.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#amllib-library","title":"AmlLib Library","text":"<p>Since, AML bytecode represents complex AML grammar, an AmlLib library is introduced to assist parsing and traversing of the AML bytecode at run-time.</p> <p>The AmlLib library parses a definition block and represents it as an AML tree. This tree representation is based on the AML grammar defined by the ACPI 6.3 specification, section - 20 'ACPI Machine Language (AML) Specification'.</p> <p>AML objects, methods and data are represented as tree nodes. Since the AML data is represented as tree nodes, it is possible to traverse the tree, locate a node and modify the node data. The tree can then be serialized to a buffer (that represents the definition block). This definition block containing the fixed up AML code can then be installed as an ACPI table (DSDT/SSDT).</p> <p>AmlLib provides a rich API to operate on AML data. For example it provides APIs to update a device's name, the value of a \"_UID\" object, and the memory and interrupt number stored in a \"_CRS\" node.</p> <p>Although the AmlLib performs checks to a reasonable extent while modifying a definition block, these checks may not cover all aspects due to the complexity of the ASL/AML language. It is therefore recommended to review any operation performed, and validate the generated output.</p> <pre><code>Example: The serialized AML code could be validated by\n- Saving the generated AML to a file and comparing with\na reference output.\nor\n- Disassemble the generated AML using the iASL compiler\nand verifying the output.\n</code></pre>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#roadmap","title":"Roadmap","text":"<p>The current implementation of the Configuration Manager populates the platform information statically as a C structure. Further enhancements to introduce runtime loading of platform information from a platform information file is planned.</p> <p>Also support for generating SMBIOS tables is planned and will be added subsequently.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#supported-platforms","title":"Supported Platforms","text":"<ol> <li>Juno</li> <li>FVP Models</li> </ol>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#build-instructions","title":"Build Instructions","text":"<ol> <li> <p>Set path for the iASL compiler with support for generating a C header    file as output.</p> </li> <li> <p>Set PACKAGES_PATH to point to the locations of the following repositories:</p> </li> </ol> <p>Example:</p> <p>set PACKAGES_PATH=%CD%\\edk2;%CD%\\edk2-platforms;</p> <p>or</p> <p>export PACKAGES_PATH=$PWD/edk2:$PWD/edk2-platforms</p> <ol> <li>To enable Dynamic tables framework the 'DYNAMIC_TABLES_FRAMEWORK' option must be defined. This can be passed as a command line parameter to the edk2 build system.</li> </ol> <p>Example:</p> <p>build -a AARCH64 -p Platform\\ARM\\JunoPkg\\ArmJuno.dsc    -t GCC5 -D DYNAMIC_TABLES_FRAMEWORK</p> <p>or</p> <p>build -a AARCH64 -p Platform\\ARM\\VExpressPkg\\ArmVExpress-FVP-AArch64.dsc    -t GCC5 -D DYNAMIC_TABLES_FRAMEWORK</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#prerequisites","title":"Prerequisites","text":"<p>Ensure that the latest ACPICA iASL compiler is used for building Dynamic Tables Framework. Dynamic Tables Framework has been tested using the following iASL compiler version: Version 20200717, dated 17 July, 2020.</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#running-ci-builds-locally","title":"Running CI builds locally","text":"<p>The TianoCore EDKII project has introduced Core CI infrastructure using TianoCore EDKII Tools PIP modules:</p> <ul> <li> <p>edk2-pytool-library</p> </li> <li> <p>edk2-pytool-extensions</p> </li> </ul> <p>The instructions to setup the CI environment are in 'edk2\\.pytool\\Readme.md'</p>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#building-dynamictablespkg-with-pytools","title":"Building DynamicTablesPkg with Pytools","text":"<ol> <li> <p>[Optional] Create a Python Virtual Environment - generally once per workspace</p> <pre><code>    python -m venv &lt;name of virtual environment&gt;\n\n    e.g. python -m venv edk2-ci\n</code></pre> </li> <li> <p>[Optional] Activate Virtual Environment - each time new shell/command window is opened</p> <p><pre><code>    &lt;name of virtual environment&gt;/Scripts/activate\n\n    e.g. On a windows host PC run:\n         edk2-ci\\Scripts\\activate.bat\n</code></pre> 3. Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes</p> <pre><code>    pip install --upgrade -r pip-requirements.txt\n</code></pre> </li> <li> <p>Initialize &amp; Update Submodules - only when submodules updated</p> <pre><code>    stuart_setup -c .pytool/CISettings.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n\n    e.g. stuart_setup -c .pytool/CISettings.py TOOL_CHAIN_TAG=GCC5\n</code></pre> </li> <li> <p>Initialize &amp; Update Dependencies - only as needed when ext_deps change</p> <pre><code>    stuart_update -c .pytool/CISettings.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n\n    e.g. stuart_update -c .pytool/CISettings.py TOOL_CHAIN_TAG=GCC5\n</code></pre> </li> <li> <p>Compile the basetools if necessary - only when basetools C source files change</p> <pre><code>    python BaseTools/Edk2ToolsBuild.py -t &lt;ToolChainTag&gt;\n</code></pre> </li> <li> <p>Compile DynamicTablesPkg</p> <pre><code>    stuart_build-c .pytool/CISettings.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; -a &lt;TARGET_ARCH&gt;\n\n    e.g. stuart_ci_build -c .pytool/CISettings.py TOOL_CHAIN_TAG=GCC5 -p DynamicTablesPkg -a AARCH64 --verbose\n</code></pre> <ul> <li>use <code>stuart_build -c .pytool/CISettings.py -h</code> option to see help on additional options.</li> </ul> </li> </ol>"},{"location":"dyn/mu_silicon_arm_tiano/DynamicTablesPkg/Readme/#documentation","title":"Documentation","text":"<p>Refer to the following presentation from UEFI Plugfest Seattle 2018:</p> <p>Dynamic Tables Framework: A Step Towards Automatic Generation of Advanced Configuration and Power Interface (ACPI) &amp; System Management BIOS (SMBIOS) Tables</p>"},{"location":"dyn/mu_silicon_arm_tiano/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_silicon_arm_tiano/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_silicon_arm_tiano/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_silicon_arm_tiano/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_silicon_intel_tiano/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/","title":"Project Mu Silicon Intel Tiano Repository","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_silicon_intel_tiano.git Branch:         release/202208 Commit:         9b3a6dcd6f753085a8550b72ed70d21b16c127fd Commit Date:    2023-01-30 22:24:05 -0500</p> <p>This repository contains Project Mu code based on TianoCore edk2 code for Intel silicon features and Intel based platforms.</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_silicon_intel_tiano/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Readme/","title":"IntelFsp2Pkg","text":"<p>This package provides the component to create an FSP binary.</p> <p>Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2Pkg</p> <p>A whitepaper to describe the IntelFsp2Pkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Creating_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/","title":"Name","text":"<p>ConfigEditor.py is a python script with a GUI interface that can support changing configuration settings directly from the interface without having to modify the source.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#description","title":"Description","text":"<p>This is a GUI interface that can be used by users who would like to change configuration settings directly from the interface without having to modify the SBL source. This tool depends on Python GUI tool kit Tkinter. It runs on both Windows and Linux. The user needs to load the YAML file along with DLT file for a specific board into the ConfigEditor, change the desired configuration values. Finally, generate a new configuration delta file or a config binary blob for the newly changed values to take effect. These will be the inputs to the merge tool or the stitch tool so that new config changes can be merged and stitched into the final configuration blob.</p> <p>It supports the following options:</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#1-open-config-yaml-file","title":"1. Open Config YAML file","text":"<p>This option loads the YAML file for a FSP UPD into the ConfigEditor to change the desired configuration values.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#example","title":"Example:","text":"<pre><code>![Example ConfigEditor 1](https://slimbootloader.github.io/_images/CfgEditOpen.png)\n\n![Example ConfigEditor 2](https://slimbootloader.github.io/_images/CfgEditDefYaml.png)\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#2-open-config-bsf-file","title":"2. Open Config BSF file","text":"<p>This option loads the BSF file for a FSP UPD into the ConfigEditor to change the desired configuration values. It works as a similar fashion with Binary Configuration Tool (BCT)</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#3-show-binary-information","title":"3. Show Binary Information","text":"<p>This option loads configuration data from FD file and displays it in the ConfigEditor.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#4-save-config-data-to-binary","title":"4. Save Config Data to Binary","text":"<p>This option generates a config binary blob for the newly changed values to take effect.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#5-load-config-data-from-binary","title":"5. Load Config Data from Binary","text":"<p>This option reloads changed configuration from BIN file into the ConfigEditor.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#6-load-config-changes-from-delta-file","title":"6. Load Config Changes from Delta File","text":"<p>This option loads the changed configuration values from Delta file into the ConfigEditor.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#7-save-config-changes-to-delta-file","title":"7. Save Config Changes to Delta File","text":"<p>This option generates a new configuration delta file for the newly changed values to take effect.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#8-save-full-config-data-to-delta-file","title":"8. Save Full Config Data to Delta File","text":"<p>This option saves all the changed configuration values into a Delta file.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#9-search-feature","title":"9. Search feature","text":"<p>This feature helps the user to easily find any configuration item they are looking for in ConfigEditor. A text search box is available on the Top Right Corner of ConfigEditor. To use this feature the user should type the name or a key word of the item they want to search in the text box and then click on the \"Search\" button. This will display all the items which contains that particular word searched by the user.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/ConfigEditorUserManual/#running-configuration-editor","title":"Running Configuration Editor:","text":"<p>python ConfigEditor.py</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/","title":"Name","text":"<p>FspDscBsf2Yaml.py The python script that generates YAML file for the Boot Settings from an EDK II Platform Description (DSC) file or from a Boot Settings File (BSF). It is created to help transitioning FSP Updateable Product Data (UPD) file format to new standardized YAML format so that it can be configured through open source tools.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#synopsis","title":"Synopsis","text":"<pre><code>FspDscBsf2Yaml DscFile|BsfFile  YamlFile\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#description","title":"Description","text":"<p>FspDscBsf2Yaml.py is a script that generates configuration options from an EDK II Platform Description (DSC) file or a Boot Settings File (BSF) file.</p> <p>It generates a YAML file that can be used by the Config Editor to provide a graphical user interface for manipulating settings in the UPD regions.</p> <p>The following sections explain the usage of this script.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#1-fspdscbsf2yamlpy-dscfile-yamlfile","title":"1. FspDscBsf2Yaml.py DscFile YamlFile","text":"<p>The DscFile option is an input DSC file.</p> <p>The YamlFile option is an output YAML file.</p> <p>The script takes the FSP DSC file consisting BSF syntax and generates a YAML output file describing the boot settings.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/FspDscBsf2YamlUserManual/#2-fspdscbsf2yamlpy-bsffile-yamlfile","title":"2. FspDscBsf2Yaml.py BsfFile YamlFile","text":"<p>The BsfFile option is an input BSF file.</p> <p>The YamlFile option is an output YAML file.</p> <p>The script generates a YAML output file from a BSF file. The BSF file can be generated using GenCfgOpt tool.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/","title":"Name","text":"<p>GenCfgOpt.py The python script that generates UPD text (.txt) files for the compiler, header files for the UPD regions, and generates a Boot Settings File (BSF), all from an EDK II Platform Description (DSC) file.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#synopsis","title":"Synopsis","text":"<pre><code>GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros]\nGenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros]\nGenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros]\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#description","title":"Description","text":"<p>GenCfgOpt.py is a script that generates configuration options from an EDK II Platform Description (DSC) file. It has three functions.</p> <ol> <li>It produces a .txt file that is used by the compiler that summarizes      the UPD section in the DSC file.</li> <li>It generates header files for the UPD regions.</li> <li>It generates a Boot Settings File (BSF) that can be used by the      Binary Configuration Tool (BCT) to provide a graphical user      interface for manipulating settings in the UPD regions.</li> </ol> <p>The GenCfgOpt.py script generates important files that are vital parts of your build process. The UPDTXT and HEADER use cases must be done before the 'build' command; the GENBSF use case may be done at any time.</p> <p>The following sections explain the three use cases.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#1-gencfgoptpy-updtxt","title":"1. GenCfgOpt.py UPDTXT","text":"<p>The UPDTXT option creates a text file with all the UPD entries, offsets, size in bytes, and values. GenCfgOpt reads this information from the [PcdsDynamicVpd.Upd] section of the project's DSC file. The DSC file allows you to specify offsets and sizes for each entry, opening up the possibility of introducing gaps between entries. GenCfgOpt fills in these gaps with UPD entries that have the generic names UnusedUpdSpaceN where N begins with 0 and increments. The command signature for UPDTXT is:</p> <pre><code>GenCfgOpt UPDTXT PlatformDscFile BuildFvDir [TxtOutFile] [-D Macros]\n</code></pre> <p>PlatformDscFile must be the location of the DSC file for the platform you're building. BuildFvDir is the location where the binary will be stored. The optional TxtOutFile is a name and location for the output of GenCfgOpt. The default name and location is the <code>&lt;UPD_TOOL_GUID&gt;.txt</code> in the directory specified by BuildFvDir. The macro <code>UPD_TOOL_GUID</code> must be defined in the DSC file or in the optional Macros arguments. Each optional macro argument must follow the form <code>?D &lt;MACRO_NAME&gt;=&lt;VALUE&gt;</code>.</p> <p>GenCfgOpt checks to see if the UPD txt file has already been created and will only re-create it if the DSC was modified after it was created.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#2-gencfgoptpy-header","title":"2. GenCfgOpt.py HEADER","text":"<p>The HEADER option creates header files in the build folder. Both header files define the <code>_UPD_DATA_REGION</code> data structures in FspUpd.h, FsptUpd.h, FspmUpd.h and FspsUpd.h. In these header files any undefined elements of structures will be added as ReservedUpdSpaceN beginning with N=0. The command signature for HEADER is</p> <p><code>GenCfgOpt HEADER PlatformDscFile BuildFvDir [InputHFile] [-D Macros]</code></p> <p>PlatformDscFile and BuildFvDir are described in the previous section. The optional InputHFile is a header file that may contain data definitions that are used by variables in the UPD regions. This header file must contain the special keywords <code>!EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN</code> and <code>!EXPORT EXTERNAL_BOOTLOADER_STRUCT_END</code> in comments. Everything between these two keywords will be included in the generated header file. The mechanism to specify whether a variable appears as ReservedUpdSpaceN in the FspUpd.h header file is in special commands that appear in the comments of the DSC file. The special commands begin with <code>!HDR</code>, for header. The following table summarizes the two command options.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#header","title":"HEADER","text":"<p>Use the HEADER command to hide specific variables in the public header file. In your project DSC file, use <code>!HDR HEADER:{OFF}</code> at the beginning of the section you wish to hide and <code>!HDR HEADER:{ON}</code> at the end.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#struct","title":"STRUCT","text":"<p>The STRUCT command allows you to specify a specific data type for a variable. You can specify a pointer to a data struct, for example. You define the data structure in the InputHFile between <code>!EXPORT EXTERNAL_BOOTLOADER_STRUCT_BEGIN</code> and <code>!EXPORT EXTERNAL_BOOTLOADER_STRUCT_END</code>.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example","title":"Example:","text":"<p><code>!HDR STRUCT:{MY_DATA_STRUCT*}</code></p> <p>You then define <code>MY_DATA_STRUCT</code> in InputHFile.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#embed","title":"EMBED","text":"<p>The EMBED command allows you to put one or more UPD data into a specify data structure. You can utilize it as a group of UPD for example. You must specify a start and an end for the specify data structure.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_1","title":"Example:","text":"<pre><code>  !HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:START}\n  gTokenSpaceGuid.Upd1  | 0x0020 | 0x01 | 0x00\n  gTokenSpaceGuid.Upd2  | 0x0021 | 0x01 | 0x00\n  !HDR EMBED:{MY_DATA_STRUCT:MyDataStructure:END}\n  gTokenSpaceGuid.UpdN  | 0x0022 | 0x01 | 0x00\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#result","title":"Result:","text":"<pre><code>  typedef struct {\n    /** Offset 0x0020\n    **/\n    UINT8                     Upd1;\n    /** Offset 0x0021\n    **/\n    UINT8                     Upd2;\n    /** Offset 0x0022\n    **/\n    UINT8                     UpdN;\n  } MY_DATA_STRUCT;\n\n  typedef struct _UPD_DATA_REGION {\n    ...\n    /** Offset 0x0020\n    **/\n    MY_DATA_STRUCT    MyDataStruct;\n    ...\n  } UPD_DATA_REGION;\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#3-gencfgopt-py-genbsf","title":"3. GenCfgOpt .py GENBSF","text":"<p>The GENBSF option generates a BSF from the UPD entries in a package's DSC file. It does this by parsing special commands found in the comments of the DSC file. They roughly match the keywords that define the different sections of the BSF.</p> <p>The command signature for GENBSF is</p> <p><code>GenCfgOpt GENBSF PlatformDscFile BuildFvDir BsfOutFile [-D Macros]</code></p> <p>In this case, the BsfOutFile parameter is required; it should be the relative path to where the BSF should be stored.</p> <p>Every BSF command in the DSC file begins with !BSF or @Bsf. The following table summarizes the options that come after !BSF or @Bsf:</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#bsf-commands-description","title":"BSF Commands Description","text":""},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#pages","title":"PAGES","text":"<p>PAGES maps abbreviations to friendly-text descriptions of the pages in a BSF.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_2","title":"Example:","text":"<p><code>!BSF PAGES:{PG1:?Page 1?, PG2:?Page 2?}</code> or</p> <p><code>@Bsf PAGES:{PG1:?Page 1?, PG2:?Page 2?}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#page","title":"PAGE","text":"<p>This marks the beginning of a page. Use the abbreviation specified in PAGES command.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_3","title":"Example:","text":"<p><code>!BSF PAGE:{PG1}</code> or</p> <p><code>@Bsf PAGE:{PG1}</code></p> <p>All the entries that come after this command are assumed to be on that page, until the next PAGE command</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#find","title":"FIND","text":"<p>FIND maps to the BSF Find command. It will be placed in the StructDef region of the BSF and should come at the beginning of the UPD sections of the DSC, immediately before the signatures that mark the beginning of these sections. The content should be the plain-text equivalent of the signature. The signature is usually 8 characters.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_4","title":"Example:","text":"<p><code>!BSF FIND:{PROJSIG1}</code> or</p> <p><code>@Bsf FIND:{PROJSIG1}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#block","title":"BLOCK","text":"<p>The BLOCK command maps to the BeginInfoBlock section of the BSF. There are two elements: a version number and a plain-text description.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_5","title":"Example:","text":"<p><code>!BSF BLOCK:{NAME:\"My platform name\", VER:\"0.1\"}</code> or</p> <p><code>@Bsf BLOCK:{NAME:\"My platform name\", VER:\"0.1\"}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#name_1","title":"NAME","text":"<p>NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_6","title":"Example:","text":"<p><code>!BSF NAME:{Variable 0}</code> or</p> <p><code>@Bsf NAME:{Variable 0}</code></p> <p>If the !BSF NAME  or @Bsf NAME command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#type","title":"TYPE","text":"<p>The TYPE command is used either by itself or with the NAME command. It is usually used by itself when defining an EditNum field for the BSF. You specify the type of data in the second parameter and the range of valid values in the third.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_7","title":"Example:","text":"<p><code>!BSF TYPE:{EditNum, HEX, (0x00,0xFF)}</code> or</p> <p><code>@Bsf TYPE:{EditNum, HEX, (0x00,0xFF)}</code></p> <p>TYPE appears on the same line as the NAME command when using a combo-box.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_8","title":"Example:","text":"<p><code>!BSF NAME:{Variable 1} TYPE:{Combo}</code> or <code>@Bsf NAME:{Variable 1} TYPE:{Combo}</code></p> <p>There is a special None type that puts the variable in the StructDef region of the BSF, but doesn't put it in any Page section. This makes the variable visible to BCT, but not to the end user.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#help","title":"HELP","text":"<p>The HELP command defines what will appear in the help text for each control in BCT.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_9","title":"Example:","text":"<p><code>!BSF HELP:{Enable/disable LAN controller.}</code> or</p> <p><code>@Bsf HELP:{Enable/disable LAN controller.}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#option","title":"OPTION","text":"<p>The OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_10","title":"Example:","text":"<p><code>!BSF OPTION:{0:IDE, 1:AHCI, 2:RAID}</code></p> <p><code>!BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB}</code></p> <p>or</p> <p><code>@Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID}</code></p> <p><code>@Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#field","title":"FIELD","text":"<p>The FIELD command can be used to define a section of a consolidated PCD such that the PCD will be displayed in several fields via BCT interface instead of one long entry.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_11","title":"Example:","text":"<p><code>!BSF FIELD:{PcdDRAMSpeed:1}</code> or</p> <p><code>@Bsf FIELD:{PcdDRAMSpeed:1}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#order","title":"ORDER","text":"<p>The ORDER command can be used to adjust the display order for the BSF items. By default the order value for a BSF item is assigned to be the UPD item <code>(Offset * 256)</code>. It can be overridden by declaring ORDER command using format ORDER: <code>{HexMajor.HexMinor}</code>. In this case the order value will be <code>(HexMajor*256+HexMinor)</code>. The item order value will be used as the sort key during the BSF item display.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_12","title":"Example:","text":"<p><code>!BSF ORDER:{0x0040.01}</code> or</p> <p><code>@Bsf ORDER:{0x0040.01}</code></p> <p>For OPTION and HELP commands, it allows to split the contents into multiple lines by adding multiple OPTION and HELP command lines. The lines except for the very first line need to start with + in the content to tell the tool to append this string to the previous one.</p> <p>For example, the statement</p> <p><code>!BSF OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB}</code></p> <p>is equivalent to:</p> <p><code>!BSF OPTION:{0x00:0 MB, 0x01:32 MB,}</code></p> <p><code>!BSF OPTION:{+ 0x02:64 MB}</code></p> <p>or</p> <p><code>@Bsf OPTION:{0x00:0 MB, 0x01:32 MB, 0x02:64 MB}</code></p> <p>is equivalent to:</p> <p><code>@Bsf OPTION:{0x00:0 MB, 0x01:32 MB,}</code></p> <p><code>@Bsf OPTION:{+ 0x02:64 MB}</code></p> <p>The NAME, OPTION, TYPE, and HELP commands can all appear on the same line following the !BSF or @Bsf keyword or they may appear on separate lines to improve readability.</p> <p>There are four alternative ways to replace current BSF commands.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#1-prompt","title":"1. <code># @Prompt</code>","text":"<p>An alternative way replacing NAME gives a plain-text for a variable. This is the text label that will appear next to the control in BCT.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_13","title":"Example:","text":"<p><code># @Prompt Variable 0</code></p> <p>The above example can replace the two methods as below.</p> <p><code>!BSF NAME:{Variable 0}</code> or</p> <p><code>@Bsf NAME:{Variable 0}</code></p> <p>If the <code># @Prompt</code> command does not appear before an entry in the UPD region of the DSC file, then that entry will not appear in the BSF.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#2","title":"2. <code>##</code>","text":"<p>An alternative way replacing HELP command defines what will appear in the help text for each control in BCT.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_14","title":"Example:","text":"<p><code>## Enable/disable LAN controller.</code></p> <p>The above example can replace the two methods as below.</p> <p><code>!BSF HELP:{Enable/disable LAN controller.}</code> or</p> <p><code>@Bsf HELP:{Enable/disable LAN controller.}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#3-validlist","title":"3. <code># @ValidList</code>","text":"<p>An alternative way replacing OPTION command allows you to custom-define combo boxes and map integer or hex values to friendly-text options.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/GenCfgOptUserManual/#example_15","title":"Example:","text":"<p>``` # @ValidList 0x80000003 | 0, 1, 2 | IDE, AHCI, RAID                    Error Code | Options | Descriptions <pre><code>The above example can replace the two methods as below.\n\n```!BSF OPTION:{0:IDE, 1:AHCI, 2:RAID}``` or\n\n```@Bsf OPTION:{0:IDE, 1:AHCI, 2:RAID}```\n\n### 4. ```# @ValidRange```\nAn alternative way replace **EditNum** field for the BSF.\n\n#####Example:\n```# @ValidRange 0x80000001 | 0x0 ? 0xFF\n                    Error Code | Range\n</code></pre></p> <p>The above example can replace the two methods as below.</p> <p><code>!BSF TYPE:{EditNum, HEX, (0x00,0xFF)}</code> or</p> <p><code>@Bsf TYPE:{EditNum, HEX, (0x00,0xFF)}</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/","title":"Name","text":"<p>PatchFv.py - The python script that patches the firmware volumes (FV) with in the flash device (FD) file post FSP build.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#synopsis","title":"Synopsis","text":"<pre><code>PatchFv FvBuildDir [FvFileBaseNames:]FdFileBaseNameToPatch [\"Offset, Value\"]+\n  | [\"Offset, Value, @Comment\"]+\n  | [\"Offset, Value, $Command\"]+\n  | [\"Offset, Value, $Command, @Comment\"]+\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#description","title":"Description","text":"<p>The PatchFv.py tool allows the developer to fix up FD images to follow the Intel FSP Architecture specification.  It also makes the FD image relocatable. The tool is written in Python and uses Python 2.7 or later to run. Consider using the tool in a build script.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fvbuilddir-argument-1","title":"FvBuildDir (Argument 1)","text":"<p>This is the first argument that PatchFv.py requires.  It is the build directory for all firmware volumes created during the FSP build. The path must be either an absolute path or a relevant path, relevant to the top level of the FSP tree.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage","title":"Example usage:","text":"<pre><code> Build\\YouPlatformFspPkg\\%BD_TARGET%_%VS_VERSION%%VS_X86%\\FV\n</code></pre> <p>The example used contains Windows batch script %VARIABLES%.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fvfilebasenames-argument-2-optional-part-1","title":"FvFileBaseNames (Argument 2: Optional Part 1)","text":"<p>The firmware volume file base names (FvFileBaseNames) are the independent Fv?s that are to be patched within the FD. (0 or more in the form FVFILEBASENAME:) The colon : is used for delimiting the single argument and must be appended to the end of each (FvFileBaseNames).</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage_1","title":"Example usage:","text":"<pre><code>STAGE1:STAGE2:MANIFEST:YOURPLATFORM\n</code></pre> <p>In the example STAGE1 is STAGE1.Fv in YOURPLATFORM.fd.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#fdfilenametopatch-argument-2-mandatory-part-2","title":"FdFileNameToPatch (Argument 2: Mandatory Part 2)","text":"<p>Firmware device file name to patch (FdFileNameToPatch) is the base name of the FD file that is to be patched. (1 only, in the form YOURPLATFORM)</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example-usage_2","title":"Example usage:","text":"<pre><code>STAGE1:STAGE2:MANIFEST:YOURPLATFORM\n</code></pre> <p>In the example YOURPLATFORM is from YOURPLATFORM.fd</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#offset-value-command-comment-argument-3","title":"\"Offset, Value[, Command][, Comment]\" (Argument 3)","text":"<p>The Offset can be a positive or negative number and represents where the Value to be patched is located within the FD. The Value is what will be written at the given Offset in the FD. Constants may be used for both offsets and values.  Also, this argument handles expressions for both offsets and values using these operators:</p> <pre><code> = - * &amp; | ~ ( ) [ ] { } &lt; &gt;\n</code></pre> <p>The entire argument includes the quote marks like in the example argument below:</p> <pre><code>0xFFFFFFC0, SomeCore:__EntryPoint - [0x000000F0],@SomeCore Entry\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#constants","title":"Constants:","text":"<p>Hexadecimal (use 0x as prefix) | Decimal</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#examples","title":"Examples:","text":"Positive Hex Negative Hex Positive Decimal Negative Decimal 0x000000BC 0xFFFFFFA2 188 -94 <pre><code>ModuleName:FunctionName | ModuleName:GlobalVariableName\nModuleGuid:Offset\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#operators","title":"Operators:","text":"<pre><code>  + Addition\n  - Subtraction\n  * Multiplication\n  &amp; Logical and\n  | Logical or\n  ~ Complement\n  ( ) Evaluation control\n  [ ] Get a DWord value at the specified offset expression from [expr]\n  { } Convert an offset {expr} into an absolute address (FSP_BASE + expr)\n  &lt; &gt; Convert absolute address &lt;expr&gt; into an image offset (expr &amp; FSP_SIZE)\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#special-commands","title":"Special Commands:","text":"<p>Special commands must use the $ symbol as a prefix to the command itself. There is only one command available at this time.</p> <pre><code>$COPY ? Copy a binary block from source to destination.\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#example","title":"Example:","text":"<pre><code>0x94, [PlatformInit:__gPcd_BinPatch_FvRecOffset] + 0x94, [0x98], $COPY, @Sync up 2nd FSP Header\n</code></pre>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/PatchFvUserManual/#comments","title":"Comments:","text":"<p>Comments are allowed in the Offset, Value [, Comment] argument. Comments must use the @ symbol as a prefix. The comment will output to the build window upon successful completion of patching along with the offset and value data.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/","title":"SplitFspBin.py is a python script to support some operations on Intel FSP 1.x/2.x image.","text":"<p>It supports:</p> <ul> <li> <p>Split Intel FSP 2.x image into individual FSP-T/M/S/O component</p> </li> <li> <p>Rebase Intel FSP 1.x/2.x components to different base addresses</p> </li> <li> <p>Generate Intel FSP 1.x/2.x C header file</p> </li> <li> <p>Display Intel FSP 1.x/2.x information header for each FSP component</p> </li> </ul>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#split-intel-fsp-2x-image","title":"Split Intel FSP 2.x image","text":"<p>FSP 1.x image is not supported by split command. To split individual FSP component in Intel FSP 2.x image, the following command can be used:</p> <p>python SplitFspBin.py split [-h] -f FSPBINARY [-o OUTPUTDIR] [-n NAMETEMPLATE]</p> <p>For example:</p> <p><code>python SplitFspBin.py split -f FSP.bin</code></p> <p>It will create FSP_T.bin, FSP_M.bin and FSP_S.bin in current directory.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#rebase-intel-fsp-1x2x-components","title":"Rebase Intel FSP 1.x/2.x components","text":"<p>To rebase one or multiple FSP components in Intel FSP 1.x/2.x image, the following command can be used:</p> <p>python SplitFspBin.py rebase [-h] -f FSPBINARY -c {t,m,s,o} [{t,m,s,o} ...] -b FSPBASE [FSPBASE ...] [-o OUTPUTDIR] [-n OUTPUTFILE]</p> <p>For example:</p> <p><code>python SplitFspBin.py rebase -f FSP.bin -c t -b 0xFFF00000 -n FSP_new.bin</code></p> <p>It will rebase FSP-T component inside FSP.bin to new base 0xFFF00000 and save the    rebased Intel FSP 2.x image into file FSP_new.bin.    For FSP 1.x image there is only one component in binary so above command also    works for FSP 1.x image.</p> <p><code>python SplitFspBin.py rebase -f FSP.bin -c t m -b 0xFFF00000 0xFEF80000 -n FSP_new.bin</code></p> <p>It will rebase FSP-T and FSP-M components inside FSP.bin to new base 0xFFF00000    and 0xFEF80000 respectively, and save the rebased Intel FSP 2.x image into file    FSP_new.bin file.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#generate-intel-fsp-1x2x-c-header-file","title":"Generate Intel FSP 1.x/2.x C header file","text":"<p>To generate Intel FSP 1.x/2.x C header file, the following command can be used:</p> <p>Python SplitFspBin.py genhdr [-h] -f FSPBINARY [-o OUTPUTDIR] [-n HFILENAME]</p> <p>For example:</p> <p><code>python SplitFspBin.py genhdr -f FSP.bin -n FSP.h</code></p> <p>It will create the C header file FSP.h containing the image ID, revision, offset    and size for each individual FSP component.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2Pkg/Tools/UserManuals/SplitFspBinUserManual/#display-intel-fsp-1x2x-information-header","title":"Display Intel FSP 1.x/2.x information header","text":"<p>To display Intel FSP 1.x/2.x information headers, the following command can be used:</p> <p>Python SplitFspBin.py info [-h] -f FSPBINARY</p> <p>For example:</p> <p><code>python SplitFspBin.py info -f FSP.bin</code></p> <p>It will print out the FSP information header for each FSP component.</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelFsp2WrapperPkg/Readme/","title":"IntelFsp2WrapperPkg","text":"<p>This package provides the component to use an FSP binary.</p> <p>Source Repository: https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg</p> <p>A whitepaper to describe the IntelFsp2WrapperPkg: https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Using_the_Intel_Firmware_Support_Package_with_the_EFI_Developer_Kit_II_%28FSP2.0%29.pdf</p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsulePdb/Readme/","title":"How to generate Microcode FMP from Microcode PDB file","text":"<p>1) Copy directory <code>UefiCpuPkg/Feature/Capsule/MicrocodeUpdatePdb</code> to <code>&lt;Your Platform Package&gt;/MicrocodeUpdatePdb</code>.</p> <p>2) Uncomment and update <code>FILE DATA</code> statement in <code>&lt;Your Platform Package&gt;/MicrocodeUpdatePdb/MicrocodeCapsulePdb.fdf</code> with path to a Microcode PDB file.  The PDB file can placed in <code>&lt;Your Platform Package&gt;/MicrocodeUpdatePdb</code> or any other path.</p> <p><code>FILE DATA = &lt;your Microcode PDB file path&gt;</code></p> <p>Uncomment and update <code>PLATFORM_NAME</code>, <code>FLASH_DEFINITION</code>, <code>OUTPUT_DIRECTORY</code> section in <code>&lt;Your Platform Package&gt;/MicrocodeUpdatePdb/MicrocodeCapsulePdb.dsc</code> with . <pre><code>PLATFORM_NAME                  = &lt;Your Platform Package&gt;\nFLASH_DEFINITION               = &lt;Your Platform Package&gt;/MicrocodeCapsulePdb/MicrocodeCapsulePdb.fdf\nOUTPUT_DIRECTORY               = Build/&lt;Your Platform Package&gt;\n</code></pre> <p>3) Use EDK II build tools to generate the Microcode FMP Capsule</p> <p><code>build -p &lt;Your Platform Package&gt;/MicrocodeCapsulePdb/MicrocodeCapsulePdb.dsc</code></p> <p>4) The Microcode FMP Capsule is generated at <code>$(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/IntelSiliconPkg/Feature/Capsule/MicrocodeCapsuleTxt/Readme/","title":"How to generate Microcode FMP from Microcode TXT file","text":"<p>1) Copy directory <code>UefiCpuPkg/Feature/Capsule/MicrocodeUpdateTxt</code> to <code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt</code></p> <p>2) Copy microcode TXT file to<code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/Microcode</code></p> <p>3) Uncomment and update statement in <code>[Sources]</code> section of <code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/Microcode/Microcode.inf</code> with name of Microcode TXT file copied in previous step.</p> <pre><code>[Sources]\n&lt;Your Microcode TXT file&gt;\n</code></pre> <p>Uncomment and update <code>FILE DATA</code> statement in <code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.fdf</code> with path to a Microcode MCB file.  The MCB file is placed in <code>$(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/IA32/&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/Microcode/Microcode/OUTPUT/</code>.</p> <p><code>FILE DATA = &lt;your Microcode MCB file path&gt;</code></p> <p>Uncomment and update <code>PLATFORM_NAME</code>, <code>FLASH_DEFINITION</code>, <code>OUTPUT_DIRECTORY</code> section in <code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc</code> with . <pre><code>PLATFORM_NAME                  = &lt;Your Platform Package&gt;\nFLASH_DEFINITION               = &lt;Your Platform Package&gt;/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.fdf\nOUTPUT_DIRECTORY               = Build/&lt;Your Platform Package&gt;\n</code></pre> <p>Uncomment and update statement in <code>Components</code> section of <code>&lt;Your Platform Package&gt;/MicrocodeUpdateTxt/MicrocodeCapsuleTxt.dsc</code> with path to a Microcode INF file.</p> <pre><code>[Components]\n&lt;Your Microcode INF file&gt;\n</code></pre> <p>4) Use EDK II build tools to generate the Microcode FMP Capsule</p> <p><code>build -p &lt;Your Platform Package&gt;/MicrocodeCapsuleTxt/MicrocodeCapsuleTxt.dsc</code></p> <p>5) The generated Microcode FMP Capsule is found at <code>$(WORKSPACE)/$(OUTPUT_DIRECTORY)/$(TARGET)_$(TOOL_CHAIN_TAG)/FV/MicrocodeCapsule.Cap</code></p>"},{"location":"dyn/mu_silicon_intel_tiano/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_silicon_intel_tiano/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_silicon_intel_tiano/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_silicon_intel_tiano/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_tiano_platforms/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/","title":"Mu Tiano Platforms Repository","text":"Git Details <p>Repository Url: https://github.com/microsoft/mu_tiano_platforms.git   Branch:         main   Commit:         2e786051685b9db84d7c0898e15a333576acb925   Commit Date:    2023-01-31 01:24:18 -0500  </p> <p>Mu Tiano Platform is a public repository of Project Mu based firmware for the QEMU processor emulator. It contains a QemuQ35Pkg that is customized to enable many of the features of Project Mu. It also contains the original upstream OvmfPkg from edk2 which supports IA32/X64 virtual firmware for QEMU.</p> <p>This repository is to provide a readily available, free, and feature rich platform to use as an example for feature enablement and validation, demonstrating how a single firmware codebase can be shared across multiple products and architectures, promoting serviceable, maintainable, up-to-date and secure firmware. Eventually there may be numerous feature branches that demonstrate how to enable advanced capabilities.  By providing an end-to-end example, these features can be easily tested and evaluated before being integrated into other platforms.</p>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#upstream-alignment","title":"Upstream Alignment","text":"<p>This repo has a filtered version of edk2 as an upstream, which can be found in the <code>upstream/main</code> branch. The Azure Pipeline definition, which performs the upstream syncing process, can be found in <code>upstream/sync</code>. When edk2 is tagged, a new branch with the corresponding tag will be created (example: <code>upstream/202005</code>). Since it is a filtered branch, the exact commit that edk2 is tagged at won't be represented but it will be the closest applicable commit before edk2 was tagged.</p> <p>In addition, the current release branch of this repo will be rebased on those upstream release commits and a new release branch will be created and set as default. For example <code>upstream/202005</code> will have a development branch of <code>release/202005</code>. The expectation is that only the latest release branch is in active development.</p> <p>Long Term Support/Security Patches</p> <p>This repository and all code within it is not part of an officially supported customer facing product and therefore long term servicing will not be supported.  Security issues will also not be backported.</p>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#platform-firmware-support","title":"Platform Firmware Support","text":"<p>Buildable platforms can be found under the <code>Platforms</code> folder inside the root of this repo. Details about the platform and how to build/use each platform can be found in their respective directories.</p> <ul> <li>Q35 Platform</li> <li>Ovmf upstream Platform</li> </ul> <p>For general details about Project Mu please see the Project Mu docs (https://github.com/Microsoft/mu).</p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Project Mu contributions will be licensed as BSD-2-Clause-Patent and will contain the SPDX-License-Identifier.</p> <pre><code>Copyright (C) Microsoft Corporation  \nSPDX-License-Identifier: BSD-2-Clause-Patent\n</code></pre>"},{"location":"dyn/mu_tiano_platforms/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> <p>================================================================================</p> <p>Some files are subject to the following license, the MIT license. Those files are located in:</p> <ul> <li>Platform/OvmfPkg/Include/IndustryStandard/Xen/</li> <li>Platform/OvmfPkg/XenBusDxe/</li> </ul> <p>SPDX-License-Identifier: MIT</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"dyn/mu_tiano_platforms/SECURITY/","title":"SECURITY","text":""},{"location":"dyn/mu_tiano_platforms/SECURITY/#security","title":"Security","text":"<p>Microsoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include Microsoft,  Azure, DotNet, AspNet,  Xamarin, and our GitHub organizations.</p> <p>If you believe you have found a security vulnerability in any Microsoft-owned repository that meets Microsoft's definition of a security vulnerability, please report it to us as described below.</p>"},{"location":"dyn/mu_tiano_platforms/SECURITY/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, please report them to the Microsoft Security Response Center (MSRC) at https://msrc.microsoft.com/create-report.</p> <p>If you prefer to submit without logging in, send email to secure@microsoft.com.  If possible, encrypt your message with our PGP key; please download it from the Microsoft Security Response Center PGP Key page.</p> <p>You should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at microsoft.com/msrc.</p> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, use after free, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p> <p>If you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our Microsoft Bug Bounty Program page for more details about our active programs.</p>"},{"location":"dyn/mu_tiano_platforms/SECURITY/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"},{"location":"dyn/mu_tiano_platforms/SECURITY/#policy","title":"Policy","text":"<p>Microsoft follows the principle of Coordinated Vulnerability Disclosure.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/","title":"QemuQ35Pkg","text":"<p>QemuQ35Pkg...</p> <ul> <li>Is a derivative of Temp.</li> <li>Will not support Legacy BIOS or CSM.</li> <li>WIll not support S3 sleep functionality.</li> <li>Has a 32-bit PEI phase and a 64-bit DXE phase.</li> <li>Seeks to enable a tightly constrained virtual platform based on the QEMU Q35 machine type.</li> </ul> <p>By solely focusing on the Q35 chipset, this package can be optimized such that it is allowed to break compatibility with other QEMU supported chipsets. The Q35 chipset can be paired with an IA32 or X64 processor to enable a machine that can emulate PC class hardware with industry standard features like SMM and PCI-E.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#q35-platform","title":"Q35 Platform","text":"<p>Q35 is a machine type that QEMU emulates. Below is a diagram from Qemu.org about the Q35 chipset which emulates a ICH9 (I/O controller hub).</p> <p></p> <p>The advantages of the ICH9 over the I440FX (which is what QEMU often emulates) is that it has PCI-E instead of just PCI as well as having an integrated AHCI controller and no ISA bus.</p> <p>Visit the feature wiki detailing QEMU Q35 for more information: https://wiki.qemu.org/Features/Q35</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#compiling-and-running-qemu","title":"Compiling and Running QEMU","text":"<p>QemuQ35Pkg uses the Project Mu repositories and Edk2 PyTools for its build operations. Specific details can be found here Development/building.md</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#firmware-features","title":"Firmware Features","text":"<p>QemuQ35Pkg is a great environment to demonstrate Project Mu features without any restricted or costly physical hardware. Current QEMU Q35 platform supports the following features provided by Project Mu:</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-front-page","title":"Mu Front Page","text":"<p>Enable the Project Mu OEM sample \"front page\". This is a touch friendly, graphical, UEFI HII based UI application that allows basic platform and boot device configuration.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#device-firmware-configuration-interface","title":"Device Firmware Configuration Interface","text":"<p>The DFCI feature enables cloud management services (MDM services like Microsoft Intune) to manage some PC bios settings securely.  DFCI is a foundational feature that provides a shared identity and ownership model between the device firmware and the cloud.  Once a device is enrolled this shared identity can be used to securely communicate across untrusted mediums (network or usb).</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-telemetry-whea-hwerrorrecord","title":"Mu Telemetry / WHEA / HwErrorRecord","text":"<p>The Mu Telemetry feature is an extension of the PI spec defined report status code.  The feature is designed to collect critical (platform defined) status codes, record them into a HwErrRecord, and then transfer them through the Microsoft WHEA pipeline.  From there an OEM can use Microsoft provided reports to check on in market device health.  *Some work still pending completion.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#platform-runtime-mechanism-prm","title":"Platform Runtime Mechanism (PRM)","text":"<p>Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. This feature adds the PRM infrastructure to the firmware that enables loading PRM modules which in turn are exposed to the OS for invocation. To accomplish this, a set of open source sample PRM modules are used to demonstrate the feature and show how additional modules can be added.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#codeql","title":"CodeQL","text":"<p>CodeQL is open source and free for open-source projects. It is maintained by GitHub and naturally has excellent integration with GitHub projects. CodeQL uses a semantic code analysis engine to discover vulnerabilities in a number of programming languages (both compiled and interpreted).</p> <p>Project Mu (and TianoCore) use CodeQL C/C++ queries to find common programming errors and security vulnerabilities in firmware code. This platform leverages the CodeQL build plugin from Mu Basecore that makes it very easy to run CodeQL against this platform. You simply use provide the <code>--codeql</code> argument in your normal <code>stuart_update</code> and <code>stuart_build</code> commands.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#q35-supported-color-bar","title":"Q35 Supported Color Bar","text":"<p>Color bars are used to quickly convey the Device state, based upon the DeviceStateLib. Color bars are displayed by the ColorBarDisplayDeviceStateLib.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#mu-customized-components","title":"Mu Customized Components","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#modules","title":"Modules","text":"Modules Link to Documentation QemuVideoDxe QEMU Cirrus Video Controller"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/QemuQ35_ReadMe/#libraries","title":"Libraries","text":"Libraries Link to Documentation MsPlatformDevicesLib MsPlatformDevicesLib PlatformDebugLibIoPort PlatformDebugLibIoPort PlatformThemeLib PlatformThemeLib"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/","title":"Building","text":"<p>Steps to setup your environment, compile, and run the QemuQ35Pkg.</p> <p>This solution for building and running QemuQ35Pkg has only been validated with Windows 10 with VS2022 and Ubuntu 18.04 with GCC5 toolchain.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#developer-environment","title":"Developer environment","text":"<p>This is a Project Mu platform and thus the default environment requirements can be found here at the Project Mu Prerequisites page.</p> <p>In addition if you want to run your locally compiled firmware you need</p> <ul> <li>QEMU - Download, Install, and add to your path</li> </ul> <p>This build uses edk2-pytools for functionality.  Documentation can be found here. On most Linux distros this requires an extra step for mono and nuget support. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_extdep.md#a-note-on-nuget-on-linux</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#building-with-pytools","title":"Building with Pytools","text":"<ol> <li> <p>[Optional] Create a Python Virtual Environment - generally once per workspace</p> <pre><code>python -m venv &lt;name of virtual environment&gt;\n</code></pre> </li> <li> <p>[Optional] Activate Virtual Environment - each time new shell opened</p> <ul> <li>Linux</li> </ul> <pre><code>source &lt;name of virtual environment&gt;/bin/activate\n</code></pre> <ul> <li>Windows</li> </ul> <pre><code>&lt;name of virtual environment&gt;/Scripts/activate.bat\n</code></pre> </li> <li> <p>Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes</p> <pre><code>pip install --upgrade -r pip-requirements.txt\n</code></pre> </li> <li> <p>Initialize &amp; Update Submodules - only when submodules updated</p> <pre><code>stuart_setup -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> <ul> <li><code>TOOL_CHAIN_TAG</code> being the toolchain you want to build with, currently <code>VS2019</code>, <code>VS2022</code>, and <code>GCC5</code> are   supported values</li> </ul> </li> <li> <p>Initialize &amp; Update Dependencies - only as needed when ext_deps change</p> <pre><code>stuart_update -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> </li> <li> <p>Compile Firmware</p> <pre><code>stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> <ul> <li>use <code>stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py -h</code> option to see additional options like <code>--clean</code></li> </ul> </li> <li> <p>Running Emulator</p> <ul> <li>You can add <code>--FlashRom</code> to the end of your build command and the emulator will run after the build is complete.</li> <li>or use the <code>--FlashOnly</code> feature to just run the emulator.</li> </ul> <pre><code>stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; --FlashOnly\n</code></pre> </li> <li> <p>Alternative Options</p> <ul> <li>All the commands specified here can use a shortcut, which is to invoke the Build file directly. For example:</li> </ul> <pre><code>py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --FlashOnly\n</code></pre> <ul> <li>Setup and update can be done by passing it in</li> </ul> <pre><code>py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --setup\n</code></pre> <pre><code>py Platforms/QemuQ35Pkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --update\n</code></pre> <ul> <li>Under the hood, it just does the invocation of Stuart for you.</li> </ul> </li> </ol>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#notes","title":"Notes","text":"<ol> <li>QEMU must be on your path.  On Windows this is a manual process and not part of the QEMU installer.</li> <li>QEMU output will be in Build/BUILDLOG_QemuQ35Pkg.txt as well as Build/QemuQ35Pkg/QEMULOG_QemuQ35Pkg.txt</li> </ol> <p>NOTE: Logging the execution output will be in the normal stuart log as well as to your console (if you have the correct logging level set, by default it doesn't output to console).</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#custom-build-options","title":"Custom Build Options","text":"<p>SHUTDOWN_AFTER_RUN=TRUE will output a startup.nsh file to the location mapped as fs0 with <code>reset -s</code> as the final line. This is used in CI in combination with the <code>--FlashOnly</code> feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh.</p> <p>QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this.</p> <p>GDB_SERVER=\\&lt;TCP Port&gt; Enables the GDB port in the QEMU instance at the provided TCP port.</p> <p>SERIAL_PORT=\\&lt;Serial Port&gt; Enables the specified serial port to be used as console.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#passing-build-defines","title":"Passing Build Defines","text":"<p>To pass build defines through stuart_build, prepend <code>BLD_*_</code> to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add a <code>=1</code> suffix for bare defines. For example, to enable the E1000 network support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be:</p> <p><code>stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py BLD_*_E1000_ENABLE=1</code></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/building/#references","title":"References","text":"<ul> <li>Installing and using Pytools</li> <li>More on python virtual environments</li> </ul>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/","title":"Debugging QEMU","text":"<p>QEMU has the ability to expose a GDB port for debugging. This can be leveraged several ways. To start enable the GDB server, add the following parameter when launched QEMU through the QEMU runner.</p> <pre><code>GDB_SERVER=&lt;port number&gt;\n</code></pre> <p>Example ports can be: 1234, 5000, 5001, etc.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#windbg-integration","title":"Windbg Integration","text":"<p>Windbg supports source debugging QEMU through an EXDI interface with the GDB port. Details can be found on the github readme. This supplies a EXDI server binary, a configuration file, and a script to start Windbg bound to the EXDI interface.</p> <p>Once Windbg is connected, following the instruction in the readme, the symbols and source can be loaded. This is most easily done using the UEFI debugger extension. This can also be done manually by scanning memory for images using the image scan command. For example:</p> <pre><code>kd&gt; r rip\nrip=000000007d1fc64b\nkd&gt; .imgscan /l /r 0x07d000000 0x07e000000\n</code></pre> <p>This will scan for image headers between the specified addresses and load their symbols. More information on this command can be found in the Windbg help window.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#debugging-windows-on-qemu","title":"Debugging Windows on QEMU","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#boot-to-os","title":"Boot to OS","text":"<p>In order to kernel debug the OS, once need to boot to OS first.</p> <ol> <li> <p>Download original OS image in the format of VHDX or QCOW2. If the image has never been booted before, one can boot this image using Hyper-V once to get through the OOBE process, if any. Related reads:</p> <ul> <li>Enable Hyper-V on Windows 10</li> <li>Create a Virtual Machine with Hyper-V</li> </ul> </li> <li> <p>Although QEMU supports both VHDX and QCOW2 images. For the sake of fail proof, it is recommended to use QCOW2 format image, which can be converted from VHDX image with:</p> <p><code>qemu-img convert -f vhdx -p -c -O qcow2 foo.vhdx foo.qcow2</code></p> </li> <li> <p>With the above QCOW2 image, set up the <code>PATH_TO_OS</code> parameter when launching QemuRunner.py:</p> <p><code>PATH_TO_OS=&lt;absolute path to your OS image&gt; SERIAL_PORT=&lt;port number&gt;</code></p> <ul> <li>More details on the <code>&lt;port number&gt;</code> in the corresponding section</li> </ul> </li> </ol>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#debug-windows-with-windbg-on-qemu","title":"Debug Windows with WinDbg on QEMU","text":"<p>Unlike EXDI debugger introduced above, this method will enlighten the target OS and debug the Windows more \"traditionally\", where Windows can communicate to the attached debugger with proper transports.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#configurations-on-target-qemu","title":"Configurations on Target QEMU","text":"<p>After booting to the desktop or command prompt of target Windows by following above steps, issue below commands:</p> <pre><code>bcdedit /dbgsettings serial debugport:1 baudrate:115200\nbcdedit /set {default} debug on\n# One can potentially enable boot debugger as well\nbcdedit /set {default} bootdebug on\n</code></pre>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#configurations-on-host-that-runs-qemu","title":"Configurations on Host that runs QEMU","text":"<p>Once the QEMU boots to the point where the target is accepting debugger commands, launch the WinDbg using:</p> <p><code>windbg.exe -k com:ipport=&lt;port number&gt;,port=127.0.0.1 -v</code></p> <p>where the <code>&lt;port number&gt;</code> is the number you set when launching QEMU</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Development/debugging/#serial-console-for-uefi","title":"Serial Console for UEFI","text":"<p>Launch terminal application such as Putty or Tera Term to connect to <code>&lt;port number&gt;</code> you set when launching QEMU at <code>127.0.0.1</code> through raw TCP/IP protocol.</p> <p>Note:</p> <ul> <li>One needs to release this console in order for the KD to attach.</li> <li>Some terminal software would enable \"local line editing\" for raw connection, this needs to be turned off to prevent garbage keystrokes.</li> </ul>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_codeql/","title":"CodeQL","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_codeql/#overview","title":"Overview","text":"<p>CodeQL is open source and free for open-source projects. It is maintained by GitHub and naturally has excellent integration with GitHub projects. CodeQL uses a semantic code analysis engine to discover vulnerabilities in a number of programming languages (both compiled and interpreted).</p> <p>General CodeQL Information</p> <p>Project Mu (and TianoCore) use CodeQL C/C++ queries to find common programming errors and security vulnerabilities in firmware code. This platform leverages the CodeQL build plugin from Mu Basecore that makes it very easy to run CodeQL against this platform. You simply use provide the <code>--codeql</code> argument in your normal <code>stuart_update</code> and <code>stuart_build</code> commands.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_codeql/#codeql-command-line-interface-cli","title":"CodeQL Command-Line Interface (CLI)","text":"<p>Because of CodeQL's integration with GitHub, it is often run in projects hosted on GitHub via an officially supported GitHub Action (codeql-action).</p> <p>However, a CodeQL CLI application is also available that provides a command-line interface to CodeQL. This facilitates a local developer workflow by using the CLI application to perform two main tasks:</p> <ol> <li>Generate a CodeQL database</li> <li>Analyze the CodeQL database</li> </ol> <p>There's ample documentation written on creating CodeQL databases and analyzing CodeQL databases.</p> <p>Our unique firmware build environment poses several challenges and further integrating the CLI with the stuart tool set can be daunting for those unfamiliar with stuart's internals.</p> <p>Therefore, Project Mu and, by extension, this platform, use a set of CodeQL plugins from Mu Basecore to simplify CodeQL usage.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_codeql/#codeql-plugins","title":"CodeQL Plugins","text":"<p>The CodeQL plugins are described in the plugin readme. This readme does not repeat information and instead focuses on explaining the context of the plugins within this platform.</p> <p>Put simply, the plugins allow a single command-line argument (<code>--codeql</code>) to be provided to the normal <code>stuart</code> commands already used in this platform to run CodeQL.</p> <p>For example:</p> <ul> <li><code>stuart_update --codeql</code> - Downloads the appropriate CodeQL CLI for your operating system.</li> <li><code>stuart_build --codeql</code> - Generates a CodeQL database using that CodeQL during the build. In post-build, the   database is automatically analyzed and a SARIF file is generated.</li> </ul> <p>Be aware that these commands will take a long time. The CodeQL CLI is several hundred megabytes in size and hooking CodeQL into the build (1) forces a clean build (2) adds additional CodeQL database logic, both of which increase the overall time of the build.</p> <p>Note: The CodeQL queries run during analysis by default are those in MuCodeQlQueries.qls.</p> <p>The CodeQL plugin readme describes how to change the queries run and change how the plugin interprets the results. It also describes how to view SARIF results conveniently in an IDE such as Visual Studio Code.</p> <p>Also by default, this platform shows CodeQL result from those queries but does not fail the build if there are any errors.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_codeql/#codeql-database-and-result-locations","title":"CodeQL Database and Result Locations","text":"<p>Although the database and result directory locations are documented in the plugin readme, they are repeated here for convenience.</p> <p>The CodeQL database is written to a directory unique to the package and target being built:</p> <p><code>Build/codeql-db-&lt;package&gt;-&lt;target&gt;-&lt;instance&gt;</code></p> <p>For example: <code>Build/codeql-db-qemuq35pkg-debug-0</code></p> <p>The plugin does not delete or overwrite existing databases, the instance value is simply increased. This is because databases are large, take a long time to generate, and are important for reproducing analysis results. The user is responsible for deleting database directories when they are no longer needed.</p> <p>Similarly, analysis results are written to a directory unique to the package and target. For analysis, results are stored in individual files so those files are stored in a single directory.</p> <p>For example, all analysis results for the above package and target will be stored in:   <code>codeql-analysis-qemuq35pkg-debug</code></p> <p>CodeQL results are stored in SARIF (Static Analysis Results Interchange Format) (CodeQL SARIF documentation) files. Each SARIF file corresponding to a database will be stored in a file with an instance matching the database instance.</p> <p>For example, the analysis result file for the above database would be stored in this file:   <code>codeql-analysis-qemuq35pkg-debug/codeql-db-qemuq35pkg-debug-0.sarif</code></p> <p>The SARIF Viewer extension for VS Code can open the .sarif file generated by this plugin and allow you to click links directly to the problem area in source files.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_colorbar/","title":"ColorBar Display Device States","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_colorbar/#overview","title":"Overview","text":"<p>Color Bars are used to show current device state for quick reference of the system firmware. The Color Bars supported by Q35 are listed below.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_colorbar/#color-bar-legend","title":"Color Bar Legend","text":"Color Description Location where Device State is set Red Secure Boot Disabled MU_OEM_SAMPLE\\OemPkg\\DeviceStatePei\\DeviceStatePei.c Yellow and Grey Caution Unit Test Mode (Unit Tests Compiled into Firmware) Platforms\\QemuQ35Pkg\\QemuQ35Pkg.dsc"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/","title":"UEFI Configuration Platform Guide","text":"<p>The UEFI configuration is a Project MU feature intended to streamline the injection of configuration with better scalability.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#configuration-logistics","title":"Configuration Logistics","text":"<p>This sections describes the design logistics on how the platforms should integrate configuration framework into the features they desire to configure.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#overview","title":"Overview","text":"<p>A platform could author as many as hundreds of features to be configured/changed for various purposes. For example, silicon drivers could configure the number of USB ports to overdrive the current, the index of PCIe ports to be powered, etc. These flexibilities could be used for hardware validation for silicon features and/or exposed to end users/admins to configure the system to comply with various marketing/regulatory needs.</p> <p>However, the silicon validation features are not (always) identical to the configuration knobs exposed to the end users. For example, the chipset could contain 4 USB controllers and all of them are configurable through silicon validation phase. But on a given platform, only the first 2 controllers can be configured by the end user because only these 2 controllers have physical outlets. This is where the differences between policy and configuration start to emerge.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#policy-data","title":"Policy Data","text":"<p>Policy, in this context, refers to the PolicyServicePkg in MU_BASECORE. This framework creates volatile GUIDed database during boot time and supports notification at data creation time. This data structure is defined by the feature module and should be published during early boot time with initial values desirable for the platform to boot properly. This data should also be consumed by the feature module to configure the hardware or other entities as needed.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#configuration-data","title":"Configuration Data","text":"<p>Configuration, in contrast, is defined by the platform with their discretion. This means that the end design of configuration knobs is not 1:1 mapped into the corresponding policy data. Thus the platform could selectively expose a few configuration knobs from policy data structure and allow the end user/admin to configure through configuration framework. Or alternatively, coalesce a group of policy switches into a single configuration knob.</p> <p>In this case, the platform module is responsible for consuming the injected configuration data (in the format of UFEI variables) then translating and applying the change on top of existing policy data so the feature module can consume the modified policy data according to configuration data.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#configuration-data-delivery","title":"Configuration Data Delivery","text":"<p>A more detailed description of how configuration data is delivered to UEFI variable storage is described in the feature repo here.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#feature-integration-guidance","title":"Feature Integration Guidance","text":"<p>This section describes the workflow, from the platform feature owner's perspective, on how to integrate the configuration framework into a single feature. To simplify the language, this flow uses the GFX configuration knob as an example to explain the expected workflow.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#authormodify-the-final-consumer-module-around-policy-package","title":"Author/Modify the Final Consumer Module Around Policy Package","text":"<p>For a feature that needs to be configured through this framework, the end module should be updated to consume the data described in PolicyServicePkg.</p> <p>In the example of GFX module, QemuQ35Pkg/QemuVideoDxe/QemuVideoDxe.inf is updated to check against the published policy data (<code>GFX_POLICY_DATA</code>) to enable/disable the applicable VGA controller during the driver binding event.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#author-the-initial-policy-publisher","title":"Author the Initial Policy Publisher","text":"<p>As mentioned above, given the GFX module is updated to consume the policy data, a module is needed to publish the initial values for the feature module to proceed properly. Per platform discretion, this module could either be a silicon module if a general default policy data is applicable, or a platform module when the platform would like to apply customizations to the inital policy value.</p> <p>In the example of GFX module, this initial value is handled by QemuQ35Pkg/ConfigDataGfx/ConfigDataGfx.inf, which publishes a policy blob under GUID <code>gPolicyDataGFXGuid</code> to enable all GFX controllers by default.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_config/#author-the-platform-configuration-consumer","title":"Author the Platform Configuration Consumer","text":"<p>Once the initial policy data is published, the platform driver should check the configuration data, as defined by platform configuratuin definition files (i.e. XML) to translate the data and apply them on top of the GFX policy data.</p> <p>In the example of GFX module, this translation and data application is also handled by QemuQ35Pkg/ConfigDataGfx/ConfigDataGfx.inf.</p> <p>Note that with the support of GUIDed policy database and notification, the platform configuration consumer does not always need to be the same driver as the policy publisher, but can instead be a module with a Depex on the published policy data GUID (in this case, <code>gPolicyDataGFXGuid</code>).</p> <p>This way, when QemuQ35Pkg/QemuVideoDxe/QemuVideoDxe.inf enters the driver binding event, it will check against the updated policy database and enable/disable the VGA controller accordingly.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_dfci/","title":"Device Firmware Configuration Interface (DFCI)","text":"<p>Todo</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_frontpage/","title":"Front Page","text":"<p>Todo</p> <p></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_memoryprotection_Q35/","title":"Memory Protection on Q35","text":"<p>For in-depth information on Memory Protection in Project Mu, see feature_memory_protection.md</p> <p>Memory protection is ON by default on Q35. To disable memory protection add <code>BLD_*_MEMORY_PROTECTION=FALSE</code> to your <code>stuart_build</code> command. Example:</p> <p><code>stuart_build -c .\\Platforms\\QemuQ35Pkg\\PlatformBuild.py BLD_*_MEMORY_PROTECTION=FALSE --FlashRom</code></p> <p>Because <code>MEMORY_PROTECTION</code> is a build flag, the platform will need to be rebuilt for a change to the value to take effect (meaning <code>--FlashOnly</code> will not work).</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/","title":"Platform Runtime Mechanism (PRM)","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#overview","title":"Overview","text":"<p>Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. Generally, SMM code that does not depend upon SMM execution privileges is a candidate for conversion to PRM. The PRM conversion process involves porting code from SMM modules into code modules that execute at CPL0 and are directly invoked by host OS kernel components. These code modules are called PRM Modules. Functions within a PRM Module exposed to the OS for runtime execution are called PRM Handlers.</p> <p>End-to-end PRM support on a system requires firmware and OS support. The firmware must provide an initial set of PRM modules for the OS to use along with an ACPI tabled called PRMT that describes those modules. The OS uses this information to invoke PRM functionality when requested by a kernel component. PRM has two high-level invocation paths either directly from an OS driver (direct call) or by interacting with an ACPI OpRegion (ACPI call).</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-goal-in-qemuq35pkg","title":"PRM Goal in QemuQ35Pkg","text":"<p>The goals of the PRM feature within <code>QemuQ35Pkg</code> are:</p> <ol> <li>To serve as an open source example of how to integrate PRM into a platform firmware.</li> <li>To serve as a test vehicle for generic PRM infrastructure and new PRM handlers testable in a virtual system.</li> <li>To provide an easily accessible virtual environment in open source that lends to PRM feature experimentation.</li> </ol> <p>For more information about the PRM feature and to access the platform agnostic PRM code/documentation visit edk2-staging/PlatformRuntimeMechanism.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-platform-agnostic-feature-code","title":"PRM Platform Agnostic Feature Code","text":"<p>The official edk2 support for PRM is being developed in edk2-staging/PlatformRuntimeMechanism.</p> <p>All of the content in that branch is agnostic to any particular platform and should be considered the single source for PRM firmware infrastructure in an edk2 based firmware.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-modules-overview","title":"PRM Modules Overview","text":"<p>PRM is adopted in a particular platform by including platform-agnostic components from <code>PrmPkg</code> and then supplementing that with the PRM Modules that perform some platform-specific work.</p> <p>The following are key platform agnostic modules.</p> <ul> <li> <p><code>PrmLoaderDxe</code> - Discovers PRM Modules loaded into memory by the platform (e.g. an FV with PRM Modules is installed)   and places those modules and the PRM Handlers within those modules into the PRMT ACPI table so the PRM configuration   for the platform is described to the operating system.</p> </li> <li> <p><code>PrmConfigDxe</code> - Configures PRM Module settings during the boot services environment.</p> </li> </ul> <p>Some modules need special configuration and others do not. For example, if a module needs MMIO ranges to be converted   it would describe those MMIO ranges during boot services so they are converted in the virtual memory address change   event. Another example would be a module that allocates a static data buffer and then populates it with some data   like that from a Setup menu item or a RAW section in a FV so it's accessible to a PRM Handler later.</p> <p>Often each PRM Module links a configuration library against this module to perform the configuration work needed for   the module. The PRM Module could also choose to create a dedicated DXE configuration driver if that's preferred.</p> <p>For example, here's the configuration libraries currently linked against <code>PrmConfigDxe</code> in <code>QemuQ35Pkg</code>:</p> <pre><code>PrmPkg/PrmConfigDxe/PrmConfigDxe.inf {\n  &lt;LibraryClasses&gt;\n    NULL|PrmPkg/Samples/PrmSampleAcpiParameterBufferModule/Library/DxeAcpiParameterBufferModuleConfigLib/DxeAcpiParameterBufferModuleConfigLib.inf\n    NULL|PrmPkg/Samples/PrmSampleContextBufferModule/Library/DxeContextBufferModuleConfigLib/DxeContextBufferModuleConfigLib.inf\n    NULL|PrmPkg/Samples/PrmSampleHardwareAccessModule/Library/DxeHardwareAccessModuleConfigLib/DxeHardwareAccessModuleConfigLib.inf\n}\n</code></pre> <ul> <li> <p><code>PrmSsdtInstallDxe</code> - Installs the PRM SSDT. The SSDT in <code>PrmPkg</code> is a reference SSDT and a platform owner should   inspect the SSDT to determine whether any changes are required. If the platform will not trigger PRM Handlers from   ACPI code at all (only use direct call), this driver can be excluded from the platform firmware.</p> </li> <li> <p><code>PrmInfo</code> - An optional UEFI application that reports information about the PRM configuration currently loaded in   the system. The application can be used to confirm PRM Modules are discovered correctly and to exercise PRM Handlers   in a lightweight manner (some activities like updating parameter buffers cannot be performed).</p> </li> </ul> <p>In order to incorporate some PRM Modules into the boot flow, the sample PRM Modules provided by <code>PrmPkg</code> are loaded by <code>QemuQ35Pkg</code>.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_prm/#prm-libraries-overview","title":"PRM Libraries Overview","text":"<p>Some aspects of the generic PRM Modules in <code>PrmPkg</code> are customizable with libraries. It is not expected a platform needs to provide custom libraries but it is possible if needed. Those libraries are briefly noted below.</p> <ul> <li> <p><code>PrmContextBufferLib</code> - Provides a general abstraction for PRM context buffer management.</p> </li> <li> <p><code>PrmModuleDiscoveryLib</code> - Provides functionality to discover PRM modules loaded in the system boot.</p> </li> <li> <p><code>PrmPeCoffLib</code> - Provides functionality to support additional PE/COFF functionality needed to use Platform Runtime   Mechanism (PRM) modules.</p> </li> </ul>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/","title":"QemuRunner_plug_in","text":"<p>The QEMU runner plugin supports easy execution of the QEMU emulator running the locally compiled QemuQ35Pkg firmware.  This runner also supports easy local and server execution of UEFI shell based tests. It can automatically collect compiled UEFI shell based unit tests, mount a VHD or map a folder as a drive, and then parse the results once QEMU has finished.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#configuration","title":"Configuration","text":"<p>The plugin has numerous configuration options to support the Q35 Platform.  These can be set when calling <code>stuart_build</code> or <code>platform_build</code> by adding <code>&lt;name&gt;=&lt;value&gt;</code> to the command line.</p> <p>Example setting up unit test to run automatically</p> <pre><code>stuart_build -c Platforms/QemuQ35Pkg/PlatformBuild.py SHUTDOWN_AFTER_RUN=TRUE RUN_TESTS=TRUE\n</code></pre>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#qemu_headless","title":"QEMU_HEADLESS","text":"<p>Boolean string value to indicate if QEMU should be configured to run headless/no graphics. By default graphics will be used but in some server/remote scenarios headless is required.</p> <p>TRUE:   configure QEMU to run headless or with no graphics FALSE:  configure QEMU for local graphics (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#test_regex","title":"TEST_REGEX","text":"<p>Comma separated regular expressions to configure the plugin on how to identify a UEFI shell based unit test. If one is provided and the user is on a Windows OS, all tests found with the regular expressions will be added to the virtual drive</p> <p>Example: <code>TEST_REGEX=MyTestOne.efi,*UefiShellApp.efi</code></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#run_tests","title":"RUN_TESTS","text":"<p>Boolean string value to indicate the plugin should write all shell-based unit tests located with <code>TEST_REGEX</code> to <code>startup.nsh</code>.This startup.nsh is a special file that executes when the UEFI shell loads. See UEFI shell specification for more details. Unless <code>SHUTDOWN_AFTER_RUN=FALSE</code> is also passed, QEMU will shutdown after executing to parse and display the XML based results.</p> <p>TRUE:   find, execute, and evaluate UEFI shell unit tests FALSE:  do not (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#shutdown_after_run","title":"SHUTDOWN_AFTER_RUN","text":"<p>Boolean string value to indicate that QEMU should be shutdown once it has finished running. The system is finished running when it has booted to shell or all unit tests specified by <code>TEST_REGEX</code> and added to the <code>startup.nsh</code> script with <code>RUN_TESTS=TRUE</code> have finished execution.</p> <p>TRUE:   The system will automaticaly shutdown after booting to shell or running all unit tests FALSE:  The system will not automatically shutdown (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_qemurunner/#empty_drive","title":"EMPTY_DRIVE","text":"<p>Boolean string value to control plugin creation of virtual drive folder and emptying the folder before copying contents. When running automated tests multiple times they may write some state to the virtual drive which may change their execution. Sometimes that is desired and this option allows the plugin to copy new files to the virtual drive but not delete files.</p> <p>TRUE:   delete all drive contents before copying new content FALSE:  don't delete all drive content before copying new content (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Docs/Features/feature_whea/","title":"Mu Telemetry / WHEA","text":"<p>Todo</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/","title":"MS QEMU Devices Library","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/#about","title":"About","text":"<p>This abstraction layer sets up devices paths for QEMU Q35 platform console input/output that can be used by Project Mu based BDS. QEMU (Cirrus Logic 5446) video controller is configured to preferred graphics output for current implementation.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/MsPlatformDevicesLibQemuQ35/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/","title":"QEMU Debug Library","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/#about","title":"About","text":"<p>This library is derived from DebugLib in Temp. It corrected several typos from the original library and added support for DEBUG_BUFFER function.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformDebugLibIoPort/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/","title":"Platform Theme Library","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/#about","title":"About","text":"<p>This platform specific abstraction layer allows the platforms to set the font type and font size for various rendering components as appropriate.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/Library/PlatformThemeLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/","title":"Qemu Video Dxe","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/#about","title":"About","text":"<p>This driver is derived from sample GOP driver QemuVideoDxe in Temp. It replaces the standard GOP interfaces GUID with MsGopOverrideProtocolGuid from Project Mu to allow further graphics control through Mu interfaces. It also removes support for BOCHS due to out of project scope.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuQ35Pkg/QemuVideoDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright (C) Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/","title":"QemuSbsaPkg","text":"<p>QemuSbsaPkg...</p> <ul> <li>Is another derivative of OvmfPkg based on EDK2 QEMU-SBSA ARM machine type.</li> <li>Will not support Legacy BIOS or CSM.</li> <li>WIll not support S3 sleep functionality.</li> <li>Has 64-bit for both PEI and DXE phase.</li> <li>Seeks to enable a tightly constrained virtual platform based on the QEMU ARM CPUs.</li> </ul> <p>By solely focusing on the ARM chipset, this package can be optimized such that it is allowed to break compatibility with other QEMU supported chipsets. The ARM chipset can be paired with an AARCH64 processor to enable a machine that can emulate ARM based hardware with industry standard features like TrustZone and PCI-E. Although leveraging SBSA machine type provided by QEMU, the features enabled/included in this package will not be server class platform centric.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#qemu-sbsa-platform","title":"QEMU-SBSA Platform","text":"<p>SBSA is an ARM based machine type that QEMU emulates.</p> <p>The advantages of the SBSA over the virtual ARM platform (which is what QEMU often emulates) is that it has better ARM based platform level support (ACPI, etc.) as well as having an integrated AHCI controller.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#compiling-and-running-qemu","title":"Compiling and Running QEMU","text":"<p>QemuSbsaPkg uses the Project Mu repositories and Edk2 PyTools for its build operations. Specific details can be found here Development/building.md</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#firmware-features","title":"Firmware Features","text":"<p>QemuSbsaPkg is a great environment to demonstrate Project Mu features without any restricted or costly physical hardware. Current QEMU SBSA platform supports the following features provided by Project Mu:</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#mu-front-page","title":"Mu Front Page","text":"<p>Enable the Project Mu OEM sample \"front page\". This is a touch friendly, graphical, UEFI HII based UI application that allows basic platform and boot device configuration.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#device-firmware-configuration-interface","title":"Device Firmware Configuration Interface","text":"<p>The DFCI feature enables cloud management services (MDM services like Microsoft Intune) to manage some PC bios settings securely.  DFCI is a foundational feature that provides a shared identity and ownership model between the device firmware and the cloud.  Once a device is enrolled this shared identity can be used to securely communicate across untrusted mediums (network or usb).</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#mu-telemetry-whea-hwerrorrecord","title":"Mu Telemetry / WHEA / HwErrorRecord","text":"<p>The Mu Telemetry feature is an extension of the PI spec defined report status code.  The feature is designed to collect critical (platform defined) status codes, record them into a HwErrRecord, and then transfer them through the Microsoft WHEA pipeline.  From there an OEM can use Microsoft provided reports to check on in market device health.  *Some work still pending completion.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#platform-runtime-mechanism-prm","title":"Platform Runtime Mechanism (PRM)","text":"<p>Platform Runtime Mechanism (PRM) introduces the capability of moving certain classes of SMM code out of SMM and into a code module that executes within OS context. This feature adds the PRM infrastructure to the firmware that enables loading PRM modules which in turn are exposed to the OS for invocation. To accomplish this, a set of open source sample PRM modules are used to demonstrate the feature and show how additional modules can be added.</p> <p>Details</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#mu-customized-components","title":"Mu Customized Components","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#modules","title":"Modules","text":"Modules Link to Documentation QemuVideoDxe QEMU Cirrus Video Controller"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/QemuSbsa_ReadMe/#libraries","title":"Libraries","text":"Libraries Link to Documentation MsPlatformDevicesLib MsPlatformDevicesLib PlatformDebugLibIoPort PlatformDebugLibIoPort PlatformThemeLib PlatformThemeLib"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/","title":"Building","text":"<p>Steps to setup your environment, compile, and run the QemuSbsaPkg.</p> <p>This solution for building and running QemuSbsaPkg has only been validated with Windows 10 with VS2019 and Ubuntu 18.04 with GCC5 toolchain.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#developer-environment","title":"Developer environment","text":"<p>This is a Project Mu platform and thus the default environment requirements can be found here at the Project Mu Prerequisites page.</p> <p>In addition if you want to run your locally compiled firmware you need</p> <ul> <li>QEMU - Download, Install, and add to your path</li> </ul> <p>This build uses edk2-pytools for functionality.  Documentation can be found here. On most Linux distros this requires an extra step for mono and nuget support. https://github.com/tianocore/edk2-pytool-extensions/blob/master/docs/usability/using_extdep.md#a-note-on-nuget-on-linux</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#building-with-pytools","title":"Building with Pytools","text":"<ol> <li> <p>[Optional] Create a Python Virtual Environment - generally once per workspace</p> <pre><code>python -m venv &lt;name of virtual environment&gt;\n</code></pre> </li> <li> <p>[Optional] Activate Virtual Environment - each time new shell opened</p> <ul> <li>Linux</li> </ul> <pre><code>source &lt;name of virtual environment&gt;/bin/activate\n</code></pre> <ul> <li>Windows</li> </ul> <pre><code>&lt;name of virtual environment&gt;/Scripts/activate.bat\n</code></pre> </li> <li> <p>Install Pytools - generally once per virtual env or whenever pip-requirements.txt changes</p> <pre><code>pip install --upgrade -r pip-requirements.txt\n</code></pre> </li> <li> <p>Initialize &amp; Update Submodules - only when submodules updated</p> <pre><code>stuart_setup -c Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> <ul> <li><code>TOOL_CHAIN_TAG</code> being the toolchain you want to build with, currently <code>VS2017</code>, <code>VS2019</code>, and <code>GCC5</code> are   supported values</li> </ul> </li> <li> <p>Initialize &amp; Update Dependencies - only as needed when ext_deps change</p> <pre><code>stuart_update -c Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> </li> <li> <p>Compile Firmware</p> <pre><code>stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;\n</code></pre> <ul> <li>use <code>stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py -h</code> option to see additional options like <code>--clean</code></li> </ul> </li> <li> <p>Running Emulator</p> <ul> <li>You can add <code>--FlashRom</code> to the end of your build command and the emulator will run after the build is complete.</li> <li>or use the <code>--FlashOnly</code> feature to just run the emulator.</li> </ul> <pre><code>stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt; --FlashOnly\n</code></pre> </li> <li> <p>Alternative Options</p> <ul> <li>All the commands specified here can use a shortcut, which is to invoke the Build file directly. For example:</li> </ul> <pre><code>py Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --FlashOnly\n</code></pre> <ul> <li>Setup and update can be done by passing it in</li> </ul> <pre><code>py Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --setup\n</code></pre> <pre><code>py Platforms/QemuSbsaPkg/PlatformBuild.py TOOL_CHAIN_TAG=&lt;TOOL_CHAIN_TAG&gt;  --update\n</code></pre> <ul> <li>Under the hood, it just does the invocation of Stuart for you.</li> </ul> </li> </ol>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#notes","title":"Notes","text":"<ol> <li>QEMU must be on your path.  On Windows this is a manual process and not part of the QEMU installer.</li> <li>QEMU output will be in Build/BUILDLOG_QemuSbsaPkg.txt as well as Build/QemuSbsaPkg/QEMULOG_QemuSbsaPkg.txt</li> </ol> <p>NOTE: Logging the execution output will be in the normal stuart log as well as to your console (if you have the correct logging level set, by default it doesn't output to console).</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#custom-build-options","title":"Custom Build Options","text":"<p>SHUTDOWN_AFTER_RUN=TRUE will output a startup.nsh file to the location mapped as fs0 with <code>reset -s</code> as the final line. This is used in CI in combination with the <code>--FlashOnly</code> feature to run QEMU to the UEFI shell and then execute the contents of startup.nsh.</p> <p>QEMU_HEADLESS=TRUE Since CI servers run headless QEMU must be told to run with no display otherwise an error occurs. Locally you don't need to set this.</p> <p>GDB_SERVER=\\&lt;TCP Port&gt; Enables the GDB port in the QEMU instance at the provided TCP port.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#passing-build-defines","title":"Passing Build Defines","text":"<p>To pass build defines through stuart_build, prepend <code>BLD_*_</code> to the define name and pass it on the command-line. stuart_build currently requires values to be assigned, so add a <code>=1</code> suffix for bare defines. For example, to enable the E1000 network support, instead of the traditional \"-D E1000_ENABLE\", the stuart_build command-line would be:</p> <p><code>stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py BLD_*_E1000_ENABLE=1</code></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/building/#references","title":"References","text":"<ul> <li>Installing and using Pytools</li> <li>More on python virtual environments</li> </ul>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/debugging/","title":"Debugging QEMU","text":"<p>QEMU has the ability to expose a GDB port for debugging. This can be leveraged several ways. To start enable the GDB server, add the following parameter when launched QEMU through the QEMU runner.</p> <pre><code>GDB_SERVER=&lt;port number&gt;\n</code></pre> <p>Example ports can be: 1234, 5000, 5001, etc.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Development/debugging/#windbg-integration","title":"Windbg Integration","text":"<p>Windbg supports source debugging QEMU through an EXDI interface with the GDB port. Details can be found on the github readme. This supplies a EXDI server binary, a configuration file, and a script to start Windbg bound to the EXDI interface.</p> <p>Once Windbg is connected, following the instruction in the readme, the symbols and source can be loaded by scanning memory for images using the image scan command. For example:</p> <pre><code>kd&gt; r pc\npc=000000007d1fc64b\nkd&gt; .imgscan /l /r 0x07d000000 0x07e000000\n</code></pre> <p>This will scan for image headers between the specified addresses and load their symbols. More information on this command can be found in the Windbg help window.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_dfci/","title":"Device Firmware Configuration Interface (DFCI)","text":"<p>Todo</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_frontpage/","title":"Front Page","text":"<p>Todo</p> <p></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/","title":"QemuRunner_plug_in","text":"<p>The QEMU runner plugin supports easy execution of the QEMU emulator running the locally compiled QemuSbsaPkg firmware.  This runner also supports easy local and server execution of UEFI shell based tests. It can automatically collect compiled UEFI shell based unit tests, mount a VHD or map a folder as a drive, and then parse the results once QEMU has finished.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#configuration","title":"Configuration","text":"<p>The plugin has numerous configuration options to support the SBSA Platform.  These can be set when calling <code>stuart_build</code> or <code>platform_build</code> by adding <code>&lt;name&gt;=&lt;value&gt;</code> to the command line.</p> <p>Example setting up unit test to run automatically</p> <pre><code>stuart_build -c Platforms/QemuSbsaPkg/PlatformBuild.py SHUTDOWN_AFTER_RUN=TRUE RUN_TESTS=TRUE\n</code></pre>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#qemu_headless","title":"QEMU_HEADLESS","text":"<p>Boolean string value to indicate if QEMU should be configured to run headless/no graphics. By default graphics will be used but in some server/remote scenarios headless is required.</p> <p>TRUE:   configure QEMU to run headless or with no graphics FALSE:  configure QEMU for local graphics (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#test_regex","title":"TEST_REGEX","text":"<p>Comma separated regular expressions to configure the plugin on how to identify a UEFI shell based unit test. If one is provided and the user is on a Windows OS, all tests found with the regular expressions will be added to the virtual drive</p> <p>Example: <code>TEST_REGEX=MyTestOne.efi,*UefiShellApp.efi</code></p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#run_tests","title":"RUN_TESTS","text":"<p>Boolean string value to indicate the plugin should write all shell-based unit tests located with <code>TEST_REGEX</code> to <code>startup.nsh</code>.This startup.nsh is a special file that executes when the UEFI shell loads. See UEFI shell specification for more details. Unless <code>SHUTDOWN_AFTER_RUN=FALSE</code> is also passed, QEMU will shutdown after executing to parse and display the XML based results.</p> <p>TRUE:   find, execute, and evaluate UEFI shell unit tests FALSE:  do not (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#shutdown_after_run","title":"SHUTDOWN_AFTER_RUN","text":"<p>Boolean string value to indicate that QEMU should be shutdown once it has finished running. The system is finished running when it has booted to shell or all unit tests specified by <code>TEST_REGEX</code> and added to the <code>startup.nsh</code> script with <code>RUN_TESTS=TRUE</code> have finished execution.</p> <p>TRUE:   The system will automaticaly shutdown after booting to shell or running all unit tests FALSE:  The system will not automatically shutdown (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_qemurunner/#empty_drive","title":"EMPTY_DRIVE","text":"<p>Boolean string value to control plugin creation of virtual drive folder and emptying the folder before copying contents. When running automated tests multiple times they may write some state to the virtual drive which may change their execution. Sometimes that is desired and this option allows the plugin to copy new files to the virtual drive but not delete files.</p> <p>TRUE:   delete all drive contents before copying new content FALSE:  don't delete all drive content before copying new content (default)</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Docs/Features/feature_whea/","title":"Mu Telemetry / WHEA","text":"<p>Todo</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Library/MsPlatformDevicesLibQemuSbsa/ReadMe/","title":"MS QEMU Devices Library","text":""},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Library/MsPlatformDevicesLibQemuSbsa/ReadMe/#about","title":"About","text":"<p>This abstraction layer sets up devices paths for QEMU SBSA platform console input/output that can be used by Project Mu based BDS. QEMU (BOCHS) video controller is configured to preferred graphics output for current implementation.</p>"},{"location":"dyn/mu_tiano_platforms/Platforms/QemuSbsaPkg/Library/MsPlatformDevicesLibQemuSbsa/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/","title":"UEFI Debugger Extension","text":"<p>This folder contains the source for the UEFI debugger extension. This provides functionality within windbg for debugging the UEFI environment. Using the UEFI extension requires that Windbgx has access to the symbol files for the target UEFI code.</p> <p>The most recent compiled version of this binary can be found as a build artifact in the debug extension workflow.</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/#compiling","title":"Compiling","text":"<p>Windbg debugger extensions need to be compiled with the Microsoft build tools. The easiest way to do this is to use the Developer Command Prompt that comes with the Visual Studio tools installation. In the command prompt, navigate to the folder and run \"msbuild\".</p> <pre><code>msbuild -property:Configuration=Release -property:Platform=x64\n</code></pre> <p>The project can also be loaded and built in Visual Studio using the solution file. This project requires the Windows SDK and the Windows Driver Kit.</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/#installing-the-extension","title":"Installing the Extension","text":"<p>Debugger extensions can be loaded into windbg several ways. First, by manually loading once already in windbg. This can be done with the .load command. Though this will not persist across windbg sessions.</p> <pre><code>.load &lt;path to uefiext.dll&gt;\n</code></pre> <p>The second is to place the DLL in the windbg application folder, or another place in windbg's extpath which can be enumerating using the .extpath command. This will make the extension available to all future windbg sessions.</p> <pre><code>e.g. C:\\Users\\&lt;user&gt;\\AppData\\Local\\dbg\\UI\n</code></pre> <p>For more information about loading debugger extensions see the Microsoft documentation page.</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/#using-the-extension","title":"Using the Extension","text":"<p>Once the extension is loaded into windbg, you can use it by running any of its commands. To see its commands, use the help command to get started.</p> <pre><code>!uefiext.help\n</code></pre> <p>One particularly useful instruction will be the <code>!uefiext.findall</code> instruction to load the needed modules.</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/#design","title":"Design","text":"<p>Windbg debug extensions allow for programmatic decoding and outputting of data from to debugger. The UEFI debug extension is designed to help finding, parsing, and changing data in the UEFI environment more accessible from the debugger.</p> <p>Because UEFI has various environments, SEC, DXE, MM, the extension has a concept of the current running environment. This can be manually set using <code>!uefiext.setenv</code>. This environment should be used to change the operation of various routines based on the current context. For example, enumerating the hobs or loaded modules is done differently in DXE then it is in MM. At the time of writing this, most functions are only implemented in DXE, but this environment should always be checked before accessing environment specific information.</p>"},{"location":"dyn/mu_tiano_platforms/UefiDbgExt/readme/#creating-new-commands","title":"Creating new commands","text":"<p>New commands can be exported by added them to the exports in uefiext.def. New commands should also be added to the help command in uefiext.cpp. For reference on how to write debugger extension code, see the Microsoft API Docs.</p>"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/","title":"BranchReadme [Name of Branch]","text":"<p>Describe the goal of your project.</p> <p>What are you trying to showcase?</p> <p>Branched from: {Release you forked from - ie 202005}</p> <p>Branched on: {Date you branched}</p> <p>Author: {Email}</p>"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#whats-unique-about-this-branch","title":"What's unique about this branch","text":"<p>Fill in with more detail about the technical differences between this branch and the release branch you forked from.</p>"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#roadmap","title":"Roadmap","text":"<p>Fill in your expected roadmap, what do you hope to accomplish? What still needs to be done?</p>"},{"location":"dyn/mu_tiano_platforms/docs/BranchReadme_template/#expected-lifetime-of-your-branch","title":"Expected lifetime of your branch","text":"<p>The goal of feature branches in <code>mu_tiano_platforms</code> is to showcase a feature and allow for development of that feature. Branches shouldn't linger on unnecessarily. They exist as proofs of concept and should try to become ready to be merged into a release branch or be archived as a useful learning exercise.</p>"},{"location":"dyn/mu_tiano_platforms/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_tiano_platforms/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_tiano_platforms/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_tiano_platforms/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/","title":"Contributing to Project Mu","text":"<p>Welcome, and thank you for your interest in contributing to Project Mu!</p> <p>There are many ways in which you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved.</p> <p>If this is your first time working with Project Mu, please keep in mind that many project details are maintained in the Project Mu Documentation.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#asking-questions","title":"Asking Questions","text":"<p>Have a question? Rather than opening an issue, please post your question under the <code>Q&amp;A</code> category in the <code>Discussions</code> section of the relevant Project Mu GitHub repo.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>Every Project Mu repo has an <code>Issues</code> section. Bug reports, feature requests, and documentation requests can all be submitted in the issues section.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#identify-where-to-report","title":"Identify Where to Report","text":"<p>Project Mu is distributed across multiple repositories. Use features such as issues and discussions in the repository most relevant to the topic.</p> <p>Although we prefer items to be filed in the most relevant repo, if you're unsure which repo is most relevant, the item can be filed in the Project Mu Documentation Repo and we will review the request and move it to the relevant repo if necessary.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#look-for-an-existing-issue","title":"Look For an Existing Issue","text":"<p>Before you create a new issue, please do a search in the issues section of the relevant repo to see if the issue or feature request has already been filed.</p> <p>If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a \"+1\" comment:</p> <ul> <li>\ud83d\udc4d - upvote</li> <li>\ud83d\udc4e - downvote</li> </ul> <p>If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#follow-your-issue","title":"Follow Your Issue","text":"<p>Please continue to follow your request after it is submitted to assist with any additional information that might be requested.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#pull-request-best-practices","title":"Pull Request Best Practices","text":"<p>Pull requests for UEFI code can become large and difficult to review due to the large number of build and configuration files. To aid maintainers in reviewing your code, we suggest adhering to the following guidelines:</p> <ol> <li>Do keep code reviews single purpose; don't add more than one feature at a time.</li> <li>Do fix bugs independently of adding features.</li> <li>Do provide documentation and unit tests.</li> <li>Do introduce code in digestible amounts.</li> <li>If the contribution logically be broken up into separate pull requests that independently build and function      successfully, do use multiple pull requests.</li> </ol>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#code-categories","title":"Code Categories","text":"<p>To keep code digestible, you may consider breaking large pull requests into three categories of commits within the pull request.</p> <ol> <li>Interfaces: .h, .inf, .dec, documentation</li> <li>Implementation: .c, unit tests, unit test build file; unit tests should build and run at this point</li> <li>Integration/Build: .dec, .dsc, .fdf, (.yml) configuration files, integration tests; code added to platform and    affects downstream consumers</li> </ol> <p>By breaking the pull request into these three categories, the pull request reviewers can digest each piece independently.</p> <p>If your commits are still very large after adhering to these categories, consider further breaking the pull request down by library/driver; break each component into its own commit.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#implementation-limits","title":"Implementation Limits","text":"<p>Implementation is ultimately composed of functions as logical units of code.</p> <p>To help maintainers review the code and improve long-term maintainability, limit functions to 60 lines of code. If your function exceeds 60 lines of code, it likely has also exceeded a single responsibility and should be broken up.</p> <p>Files are easier to review and maintain if they contain functions that serves similar purpose. Limit files to around 1,000 lines of code (excluding comments). If your file exceeds 1,000 lines of code, it may have functions that should be split into separate files.</p> <p>By following these guidelines, your pull requests will be reviewed faster, and you'll avoid being asked to refactor the code to follow the guidelines.</p> <p>Feel free to create a draft pull request and ask for suggestions on how to split the pull request if you are unsure.</p>"},{"location":"dyn/mu_tiano_plus/CONTRIBUTING/#thank-you","title":"Thank You","text":"<p>Thank you for your interest in Project Mu and taking the time to contribute!</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/","title":"Project Mu Tiano Plus","text":"Git Details <p>Repository Url: https://github.com/Microsoft/mu_tiano_plus.git Branch:         release/202208 Commit:         72482c789ed06e80454bd8f5b674d0c8182b04b1 Commit Date:    2023-01-31 12:29:40 -0800</p> <p>This repo contains Project Mu common code that should only take Basecore as a dependency and be applicable to almost any FW project. The modules in this repo were taken with minimal modification from TianoCore. For full documentation, please see the Project Mu Docs site.</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#more-info","title":"More Info","text":"<p>Please see the Project Mu docs (https://github.com/Microsoft/mu) for more information.  </p> <p>This project has adopted the Microsoft Open Source Code of Conduct.</p> <p>For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#issues","title":"Issues","text":"<p>Please open any issues in the Project Mu GitHub tracker. More Details</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#contributing-code-or-docs","title":"Contributing Code or Docs","text":"<p>Please follow the general Project Mu Pull Request process.  More Details</p> <ul> <li>Code Requirements</li> <li>Doc Requirements</li> </ul>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#builds","title":"Builds","text":"<p>Please follow the steps in the Project Mu docs to build for CI and local testing. More Details</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#copyright-license","title":"Copyright &amp; License","text":"<p>Copyright (C) Microsoft Corporation SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/RepoDetails/#upstream-license-tianocore","title":"Upstream License (TianoCore)","text":"<p>Copyright \u00a9 2019, TianoCore and contributors.  All rights reserved.</p> <p>SPDX-License-Identifier: BSD-2-Clause-Patent</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> </ol> <p>Subject to the terms and conditions of this license, each copyright holder and contributor hereby grants to those receiving rights under this license a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except for failure to satisfy the conditions of this license) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer this software, where such license applies only to those patent claims, already acquired or hereafter acquired, licensable by such copyright holder or contributor that are necessarily infringed by:</p> <p>(a) their Contribution(s) (the licensed copyrights of copyright holders and     non-copyrightable additions of contributors, in source or binary form)     alone; or</p> <p>(b) combination of their Contribution(s) with the work of authorship to which     such Contribution(s) was added by such copyright holder or contributor, if,     at the time the Contribution is added, such addition causes such combination     to be necessarily infringed. The patent license shall not apply to any other     combinations which include the Contribution.</p> <p>Except as expressly stated above, no rights or licenses from any copyright holder or contributor is granted under this license, whether expressly, by implication, estoppel or otherwise.</p> <p>DISCLAIMER</p> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/","title":"Lauterbach T32 Scripts","text":""},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/#dxe-phase-debug","title":"DXE Phase Debug","text":"<p>Update the memsize variable in EfiLoadDxe.cmm for the actual amount of memory available in your system.  Allow your system to boot to the point that the DXE core is initialized (so that the System Table and Debug Information table is present in memory) and execute this script (using the toolbar button or 'do EfiLoadDxe' from the command area).  It will scan memory for the debug info table and load modules in it.</p>"},{"location":"dyn/mu_tiano_plus/EmbeddedPkg/Scripts/LauterbachT32/Readme/#secpei-phase-debug","title":"SEC/PEI Phase Debug","text":"<p>There is no way to autodetect where these images reside so you must pass an address for the memory-mapped Firmware Volume containing these images.  To do this, enter 'do EfiLoadFv \\&lt;addr&gt;' where \\&lt;addr&gt; is the base address for the firmware volume containing the SEC or PEI code.  To be more efficient you may want to create a script that calls this, like MyBoardLoadSec.cmm which contains the call to EfiLoadFv.  You can them map this script to a T32 menu or toolbar button for quick access.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/","title":"Capsule Update Policy DXE","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/#about","title":"About","text":"<p>This DXE driver produces the Capsule Update Policy Protocol (<code>EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL</code>). The policy functions wrap around the corresponding functions provided in the <code>CapsuleUpdatePolicyLib</code> linked against the driver.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/CapsuleUpdatePolicyDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/","title":"Firmware Management Protocol (FMP) Device Package","text":"<p>FmpDevicePkg provides the common resources necessary to manage the firmware on a given device. The UEFI Specification defines several elements used in the firmware management process that are implemented or depended upon in FmpDevicePkg such as:</p> <ol> <li><code>EFI_FIRMWARE_MANAGEMENT_PROTOCOL</code></li> <li>Firmware Management Protocol dependency expression support</li> <li>FMP capsule format</li> <li>EFI System Resource Table (ESRT)</li> </ol>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#package-organization","title":"Package Organization","text":"<p>This section briefly describes the package modules and libraries.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#modules","title":"Modules","text":"<ol> <li>CapsuleUpdatePolicyDxe readme</li> <li>Purpose: \\    Produces the Capsule Update Policy Protocol using the services of the Capsule Update Policy Library.</li> <li>FmpDxe readme</li> <li>Purpose: \\    Produces an instance of the Firmware Management Protocol (<code>EFI_FIRMWARE_MANAGEMENT_PROTOCOL</code>) that is used    to support updates to a firmware image stored on a firmware device</li> </ol>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#libraries","title":"Libraries","text":"<ol> <li>CapsuleUpdatePolicyLib</li> <li> <p>Purpose: \\    Provides platform policy services used during a capsule update.</p> <ol> <li>CapsuleUpdatePolicyLibNull readme</li> <li>CapsuleUpdatePolicyLibOnProtocol readme</li> <li>FmpDependencyCheckLib</li> <li> <p>Purpose: \\    Provides services to check that capsule dependencies are met during firmware update.</p> </li> <li> <p>FmpDependencyCheckLib readme</p> </li> <li>FmpDependencyCheckLibNull readme</li> <li>FmpDependencyDeviceLib</li> <li> <p>Purpose: \\    Provides firmware device specific services to support saving dependency expressions to a firmware device and    getting dependency expressions from a firmware device.</p> </li> <li> <p>FmpDependencyDeviceLibNull readme</p> </li> <li>FmpDependencyLib</li> <li> <p>Purpose: \\    Provides functions used to manage dependencies between firmware components during the update of device firmware    images.</p> </li> <li> <p>FmpDependencyLib readme</p> </li> <li>FmpDeviceLib</li> <li> <p>Purpose: \\    Provides firmware device specific services to support firmware updates on a given device.</p> </li> <li> <p>FmpDeviceLibNull readme</p> </li> <li>FmpPayloadHeaderLib</li> <li> <p>Purpose: \\    Provides services to retrieve values from a capsule FMP Payload Header.</p> </li> <li> <p>FmpPayloadHeaderLibV1 readme</p> </li> </ol> </li> </ol>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Docs/FmpDevicePkg_ReadMe/#further-reading","title":"Further Reading","text":"<p>Several documents describe important elements involved in understanding <code>FmpDevicePkg</code>. Consult the following resource for more information on a particular topic.</p> <ol> <li> <p><code>FmpDevicePkg</code> Overview</p> <ol> <li>The ReadMe documents referenced above that reside in the package.</li> <li>Tianocore wiki: FmpDevicePkg</li> </ol> </li> <li> <p>UEFI Specification Definitions for Firmware Updating and Reporting</p> <ol> <li>Section 23 of the UEFI Specification 2.8B</li> </ol> </li> <li> <p>Technical Overview of the EDK II Capsule Update and Recovery Flow</p> <ol> <li>A Tour Beyond BIOS - Capsule Update and Recovery in EDK II</li> </ol> </li> <li> <p>Windows UEFI Firmware Update Resources</p> <ol> <li>Windows UEFI Firmware Update Platform</li> <li>Validating Windows UEFI Firmware Update Platform Functionality</li> </ol> </li> <li> <p>NIST Guidelines for Authenticated Firmware Update</p> <ol> <li>SP800-147</li> <li>SP800-147B</li> <li>SP800-193</li> </ol> </li> </ol>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/","title":"Firmware Management Protocol (FMP) DXE","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#about","title":"About","text":"<p>This driver produces an instance of the Firmware Management Protocol (<code>EFI_FIRMWARE_MANAGEMENT_PROTOCOL</code>) that is used to support updates to a firmware image stored on a firmware device. Platform-specific information and customization is configured through libraries and PCDs.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#getting-started","title":"Getting Started","text":"<p>This driver integrates several customization points that need to be considered during firmware update. This section provides brief background on key elements to consider when adapting this driver for a platform firmware.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#capsule-authentication","title":"Capsule Authentication","text":"<p>The firmware update capsule must be signed and this driver will verify the integrity of the capsule contents. The actual capsule data is preceded by an <code>EFI_FIRMWARE_IMAGE_AUTHENTICATION</code> structure. This structure contains a monotonic count and a <code>WIN_CERTIFICATE_UEFI_GUID</code> member that contains a signature that covers both the monotonic count and the capsule payload data. These two elements ensure replay protection across update operations and authentication. The certificate type used must be <code>EFI_CERT_TYPE_PKCS7_GUID</code>.</p> <p>An EDK II implementation of signature verification is available in the following <code>FmpAuthenticationLib</code> instance: SecurityPkg/Library/FmpAuthenticationLibPkcs7.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#capsule-versioning","title":"Capsule Versioning","text":"<p>The capsule version should only be allowed to increment in value across updates to prevent rollback attacks. The <code>EFI_FIRMWARE_IMAGE_DESCRIPTOR</code> structure contains <code>Version</code> and <code>LowestSupportedImageVersion</code> fields that are used to check for compliance during firmware update. <code>Version</code> must be greater than or equal to <code>LowestSupportedImageVersion</code> in the current firmware and the greater than <code>Version</code> of the current firmware.</p> <p>An EDK II library implementation (<code>EdkiiSystemCapsuleLib</code>) that performs version checking is available at: SignedCapsulePkg/Library/EdkiiSystemCapsuleLib.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#device-specific-functionality-during-update","title":"Device-Specific Functionality During Update","text":"<p>A capsule can target firmware update to a diverse set of devices on a system. Each device might bring unique logic and requirements to the firmware update process. Therefore, a library class called <code>FmpDeviceLib</code> exists that allows for instances written specific to a particular device.</p> <p>For more information about <code>FmpDeviceLib</code>, review: FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe.md</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#dependency-considerations","title":"Dependency Considerations","text":"<p>The UEFI Specification 2.8 version introduced support for expressing dependencies between components involved in a capsule update. For instance, FWx requires FWy to be at least version 2.0 to install. This information is primarily conveyed to <code>FmpDxe</code> through the <code>FmpDependencyCheckLib</code> and <code>FmpDependencyLib</code> library classes.</p> <p>More information about the overall infrastructure is available in: Section 23.2 of the UEFI Specification 2.8B Tianocore wiki: Fmp Capsule Dependency Introduction</p> <p>More details regarding the libraries in <code>FmpDevicePkg</code> are available in the respective ReadMe files: [FmpDevicePkg/Library/FmpDependencyCheckLib]FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe.md [FmpDevicePkg/Library/FmpDependencyLib]FmpDevicePkg/Library/FmpDependencyLib/ReadMe.md</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#update-policy","title":"Update Policy","text":"<p>A library class (<code>CapsuleUpdatePolicyLib</code>) is used to make platform-specific policy decisions available to the firmware update process. This includes information such as whether the system power/thermal state permits firmware to be updated. A few functions also exist to modify expected behavior such as ignoring the <code>LowestSupportedImageVersion</code> check or not locking the firmware device for update when the FMP lock event is signaled. It is important to note that the latter functions should only be used in very rare special cases such as during manufacturing flows.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#design-changes","title":"Design Changes","text":"<ul> <li>Date: 06/15/2020</li> <li>Description/Rationale: Extending on the more granular LastAttemptStatus support added in FmpDeviceSetImage (), FmpDeviceCheckImage () also has a LastAttemptStatus parameter added. An image check is always performed by a set image operation. A more granular status code from the check image path greatly improves overall error isolation when applying an image.</li> <li>Changes: This change allows the FmpDeviceLib implementation to return a last attempt status code in the range LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MIN_ERROR_CODE to LAST_ATTEMPT_STATUS_LIBRARY_ERROR_MAX_ERROR_CODE. Furthermore, an internal wrapper for CheckTheImage () in FmpDxe was added called CheckTheImageInternal (). This function can return a last attempt status code for an error in the driver prior to invoking FmpDeviceCheckImage (). These driver error codes will be in the range of LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE_MIN to LAST_ATTEMPT_STATUS_DRIVER_ERROR_MAX_ERROR_CODE.</li> <li>Impact/Mitigation: The change break the build for all FmpDeviceLib instances due to the API change. Each FmpDeviceLib should change to the new API definition and implement support to return unique values for LastAttemptStatus when appropriate.</li> </ul> <ul> <li>Date: 10/07/2019</li> <li>Description/Rationale: Capsule update is the process where each OEM has a lot of interest. Especially when there is capsule update failure, it is helpful to gather more information of the failure. With existing implementations, the SetImage routine from FmpDxe driver, which performs most heavy lifting during capsule update, will only populate LastAttemptStatus with limited pre-defined error codes which could be consumed/inspected by the OS when it recovers and boots. Thus our proposal is to update the SetImage routine and leverage the LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range newly defined in UEFI Spec 2.8 Section 23.4, so that the error code will provide better granularity when viewing capsule update failure from OS device manager.</li> <li>Changes: A few error codes (128 total) are reserved from LAST_ATTEMPT_STATUS_ERROR_UNSUCCESSFUL_VENDOR_RANGE range for FmpDxe driver usage, which ranges from thermal and power API failure to capsule payload header check failure. Furthermore, an output pointer of the LastAttemptStatus is added as an input argument for FmpDeviceSetImage function in FmpDeviceLib to allow platform to provide their own platform specific error codes. (SPI write failure, SVN checking failure, and more).</li> <li>Impact/Mitigation: The italic text above will cause a breaking change for all the FmpDeviceLib instances due to API being modified. This is to provide better visibility to OEMs to decode capsule update failures more efficiently. Each FmpDeviceLib should change to the new API definition and populate proper LastAttemptStatus values when applicable.</li> </ul>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/FmpDxe/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/","title":"Capsule Update Policy NULL Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#about","title":"About","text":"<p>This is a NULL instance of the <code>CapsuleUpdatePolicy</code> library class. This instance is provided for building when an actual library instance is not needed or the values returned by this instance are sufficient for a platform.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>CheckSystemEnvironment ()</code> - Determines if the system environment state supports a capsule update.</li> </ul> <p>The NULL implementation will always return <code>EFI_SUCCESS</code>.</p> <ul> <li><code>CheckSystemPower ()</code> - Determine if the system power state supports a capsule update.</li> </ul> <p>The NULL implementation will always return <code>EFI_SUCCESS</code>.</p> <ul> <li><code>CheckSystemThermal ()</code> - Determines if the system thermal state supports a capsule update.</li> </ul> <p>The NULL implementation will always return <code>EFI_SUCCESS</code>.</p> <ul> <li><code>IsLockFmpDeviceAtLockEventGuidRequired ()</code> - Determines if the Lowest Supported Version checks should be performed.</li> </ul> <p>The NULL implementation will always return <code>TRUE</code>.</p> <ul> <li><code>IsLowestSupportedVersionCheckRequired ()</code> - Determines if the FMP device should be locked when the event specified   by <code>PcdFmpDeviceLockEventGuid</code> is signaled.</li> </ul> <p>The NULL implementation will always return <code>TRUE</code>.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/","title":"Capsule Update Policy On Protocol Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#about","title":"About","text":"<p>This library class instance of <code>CapsuleUpdatePolicyLib</code> implements the library API using the values returned from an installed instance of <code>EDKII_CAPSULE_UPDATE_POLICY_PROTOCOL</code>. If the protocol is not found, the library will default to conservative responses.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>CheckSystemEnvironment ()</code> - Determines if the system environment state supports a capsule update.</li> <li><code>CheckSystemPower ()</code> - Determine if the system power state supports a capsule update.</li> <li><code>CheckSystemThermal ()</code> - Determines if the system thermal state supports a capsule update.</li> <li><code>IsLockFmpDeviceAtLockEventGuidRequired ()</code> - Determines if the Lowest Supported Version checks should be performed.</li> <li><code>IsLowestSupportedVersionCheckRequired ()</code> - Determines if the FMP device should be locked when the event specified   by <code>PcdFmpDeviceLockEventGuid</code> is signaled.</li> </ul>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/CapsuleUpdatePolicyLibOnProtocol/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/","title":"FMP Dependency Check Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#about","title":"About","text":"<p>This library provides services to check that capsule dependencies are met during firmware update.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>CheckFmpDependency ()</code> - Checks a given set of firmware image information such as the image type ID and version   against a given dependency expression and returns whether the dependency expression is satisfied.</li> </ul>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/","title":"FMP Dependency Check NULL Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#about","title":"About","text":"<p>This is a NULL instance of the <code>FmpDependencyCheckLib</code> library class. This instance is provided for building when an actual library instance is not needed. A version of the library that contains actual dependency checking implementation is also available in this package, see <code>FmpDependencyCheckLib</code>.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>CheckFmpDependency ()</code> - Checks a given set of firmware image information such as the image type ID and version   against a given dependency expression and returns whether the dependency expression is satisfied.</li> </ul> <p>The NULL implementation will always return <code>TRUE</code> indicating the all dependencies are satisfied.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyCheckLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/","title":"FMP Dependency Device NULL Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#about","title":"About","text":"<p>This is a NULL instance of the <code>FmpDependencyDeviceLib</code> library class. This instance is provided for building when an actual library instance is not needed.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>GetFmpDependency ()</code> - Gets the dependency expression for the device represented by the library class instance.</li> </ul> <p>The NULL implementation always returns <code>NULL</code> a dependency expression was not retrieved.</p> <ul> <li><code>SaveFmpDependency ()</code> - Saves the dependency expression to the device represented by the library class instance.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code> indicating a dependency expression cannot be saved.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyDeviceLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/","title":"FMP Dependency Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#about","title":"About","text":"<p>This library provides functions used to manage dependencies between firmware components during the update of device firmware images.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>EvaluateDependency ()</code> - Evaluates a given dependency expression against a given set of FMP versions.</li> <li><code>GetImageDependency ()</code> - Gets the dependency expression from a given firmware image.</li> <li><code>ValidateDependency ()</code> - Validates a given dependency expression.</li> </ul>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDependencyLib/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/","title":"FMP Device NULL Library Instance","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#about","title":"About","text":"<p>This is a NULL instance of the <code>FmpDeviceLib</code> library class. This instance is provided for building when an actual library instance is not needed. Any device firmware that is actually updated using <code>FmpDevicePkg</code> should always implement a device-specific instance of <code>FmpDeviceLib</code>.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#api-overview","title":"API Overview","text":"<p>This library provides an interface for component involved in controlling the firmware update process (such as <code>FmpDxe</code>) to retrieve information specific to the device whose firmware is being updated. The current library API along with brief descriptions follow below. For more detailed information, check the individual function description comment that precedes each function in the library header file.</p> <ul> <li><code>FmpDeviceCheckImageWithStatus ()</code> - Checks if a given firmware image is valid for the device.</li> </ul> <p>The NULL implementation always returns <code>EFI_SUCCESS</code>.</p> <ul> <li><code>FmpDeviceGetAttributes ()</code> - Returns values used to indicate what firmware image attributes are supported and    valid such as whether the image is updatable, a reset is required after update, authentication is required, and    whether the image is a UEFI image.</li> </ul> <p>The NULL implementation always returns <code>EFI_SUCCESS</code>.</p> <ul> <li><code>FmpDeviceGetHardwareInstance ()</code> - Returns an instance of the firmware image currently stored on the device.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceGetImageTypeIdGuidPtr ()</code> - Returns a GUID that indicates the image type.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceGetLowestSupportedVersion ()</code> - Returns the lowest supported version from the currently stored firmware   image for the device. The new firmware image version must be greater than or equal to this value.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceGetSize ()</code> - Returns the size, in bytes, of the firmware image currently stored on the device.</li> </ul> <p>The NULL implementation always returns <code>EFI_SUCCESS</code> unless <code>Size</code> is NULL in which case <code>EFI_INVALID_PARAMETER</code>   is returned.</p> <ul> <li><code>FmpDeviceGetVersion ()</code> - Returns the <code>Version</code> of the firmware image currently stored on the device.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceGetVersionString ()</code> - Returns the Null-terminated Unicode string of the current firmware image version.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code> unless <code>VersionString</code> is NULL in which case   <code>EFI_INVALID_PARAMETER</code> is returned.</p> <ul> <li><code>FmpDeviceLock ()</code> - Locks the firmware device, thereby preventing any future firmware updates (before a reset).</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceSetContext ()</code> - Sets the device context when the device is managed by a UEFI Driver Model driver.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p> <ul> <li><code>FmpDeviceSetImageWithStatus ()</code> - Updates a firmware image with a new firmware image.</li> </ul> <p>The NULL implementation always returns <code>EFI_UNSUPPORTED</code>.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpDeviceLibNull/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/","title":"FMP Payload Header Library","text":""},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#about","title":"About","text":"<p>This library provides services to retrieve values from Version 1 of a capsule's FMP Payload Header. The FMP Payload Header structure is not defined in the library class. Instead, services are provided to retrieve information from the FMP Payload Header. If information is added to the FMP Payload Header, then new services may be added to this library class to retrieve the new information.</p>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#api-overview","title":"API Overview","text":"<ul> <li><code>GetFmpPayloadHeaderSize ()</code> - Returns the FMP Payload Header size in bytes.</li> <li><code>GetFmpPayloadHeaderVersion ()</code> - Returns the version described in the FMP Payload Header.</li> <li><code>GetFmpPayloadHeaderLowestSupportedVersion ()</code> - Returns the lowest supported version described in the FMP Payload   Header.</li> </ul>"},{"location":"dyn/mu_tiano_plus/FmpDevicePkg/Library/FmpPayloadHeaderLibV1/ReadMe/#copyright","title":"Copyright","text":"<p>Copyright \u00a9 Microsoft Corporation. SPDX-License-Identifier: BSD-2-Clause-Patent</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/","title":"Platform Runtime Mechanism","text":"<p>Platform Runtime Mechanism (PRM) introduces the capability of moving platform-specific code out of SMM and into a code module that executes within the OS context. Moving this firmware to the OS context provides better transparency and mitigates the negative system impact currently accompanied with SMM solutions. Futhermore, the PRM code is packaged into modules with well-defined entry points, each representing a specific PRM functionality.</p> <p>For more details on PRM, refer to the Platform Runtime Mechanism Specification on uefi.org.</p> <p>The <code>PrmPkg</code> maintained in this branch provides a single cohesive set of generic PRM functionality that is intended to be leveraged by platform firmware with minimal overhead to integrate PRM functionality in the firmware.</p> <p>By default, the build makes use of a new ACPI OperationRegion type specifically introduced for PRM called <code>PlatformRtMechanism</code>. Support for this OperationRegion is planned for the next release of the ACPI specification. However, support for <code>PlatformRtMechanism</code> is already included in the iASL Compiler/Disassembler for early prototyping (i.e. this package). If you would like the default build to work and/or to use PRM handlers that are invoked through ACPI, iASL compiler 20200528 or greater must be used. If you are only interested in compiling the code and/or using direct call style PRM handlers, you can simply remove <code>PrmSsdtInstallDxe</code> from <code>PrmPkg.dsc</code>.</p> <p>The changes in the ACPI Specification include two elements:</p> <ol> <li><code>BIT20</code> in Platform-Wide _OSC Capabilities DWORD2 will be used by an OS to indicate support for PRM</li> <li>A new Operation Region Address Space Identifier Value is defined as <code>0xB</code> for <code>PlatformRtMechanism</code></li> </ol>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#how-to-build-prmpkg","title":"How to Build PrmPkg","text":"<p>As noted earlier, resources in <code>PrmPkg</code> are intended to be referenced by a platform firmware so it can adopt support for PRM. In that case, the platform firmware should add the <code>PrmConfigDxe</code> and <code>PrmLoaderDxe</code> drivers to its DSC and FDF files so they are built in the platform firmware build and dispatched during its runtime. All that is left is to add individual PRM modules to the DSC and FDF. These can be built from source or included as binaries into the platform firmware flash map.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prmpkg-standalone-build","title":"PrmPkg Standalone Build","text":"<p>To build <code>PrmPkg</code> as a standalone package:</p> <ol> <li> <p>If new to EDK II, follow the directions in Getting Started with EDK II</p> </li> <li> <p>Clone the master branch on the edk2 repository locally \\    <code>git clone https://github.com/tianocore/edk2.git</code></p> </li> <li> <p>Change to the edk2 workspace directory \\    <code>cd edk2</code></p> </li> <li> <p>Run edksetup to set local environment variables needed for build</p> </li> <li>Windows:<ul> <li><code>edksetup.bat</code></li> </ul> </li> <li> <p>Linux:</p> <ul> <li>If you have not already built BaseTools:</li> <li><code>make -C BaseTools</code></li> <li><code>. edksetup.sh</code></li> </ul> </li> <li> <p>Build PrmPkg \\</p> </li> </ol> <p>The PrmPkg can be built targetting the IA32/X64 and AArch64 architectures.</p> <ul> <li>IA32/X64</li> </ul> <p><code>build -p PrmPkg/PrmPkg.dsc -a IA32 -a X64</code></p> <p>Note: Due to the way PRM modules are compiled with exports, only building on Visual Studio compiler tool    chains has been tested.</p> <p>Note: \\ This package has been used without modification in several environments including client, server, and virtual systems.</p> <p>You can add your own PRM modules into the build and check them with the <code>PrmInfo</code> UEFI application described later in this document and dump the PRMT table in the OS to check if your PRM module is represented as expected.</p> <ul> <li>AArch64     <code>build -p PrmPkg/PrmPkg.dsc -a AARCH64 -t GCC5</code></li> </ul> <p>Note: Only builds with the GCC5 toolchain have been tested. Note: For builds with the GCC5 toolchain, the PrmModuleExportDescriptor and any other handler entry points    symbols, tobe listed in the PRMT, must be explicitly preserved by enumerating these in the AARCH64 linker flags.    The --require-defined linker flag must be used for each symbol to be preserved.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-platform-guid","title":"PRM Platform GUID","text":"<p>IMPORTANT PRM has a concept of a \"Platform GUID\" which associates a specific platform with a set of PRM modules built for that platform. This GUID is used to ensure system compatibility for a given collection of PRM modules.</p> <p>Therefore, each PRM module must only target a single platform and each platform must have a unique GUID. Even if a PRM module is unchanged between two different platforms now, there is no guarantee that will remain the case so always assign a unique Platform GUID for each platform.</p> <p>The PRM Platform GUID is primarily used during PRM module runtime updates in the OS to ensure that the Platform GUID in the system's ACPI table (PRMT) matches the Platform GUID of the module requested for update. Even if runtime updates are not a planned feature for a given platform, still assign a unique Platform GUID for binary module identification (the Platform GUID is in the module's export descriptor) and to ensure such updates can be seamlessly supported in the future if needed.</p> <p>In the <code>PrmPkg</code> implementation, the Platform GUID is automatically derived from the PLATFORM_GUID in the DSC file of the package being built.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#build-output","title":"Build Output","text":"<p>Like a typical EDK II package, the PrmPkg binary build output can be found in the Build directory in the edk2 workspace. The organization in that directory follows the same layout as other EDK II packages.</p> <p>For example, that path to PRM module sample binaries for a DEBUG VS2017 X64 build is: \\ <code>edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples</code></p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#overview","title":"Overview","text":"<p>At a high-level, PRM can be viewed from three levels of granularity:</p> <ol> <li><code>PRM interface</code> - Encompassing the entirety of firmware functionalities and data provided to OS runtime. Most    information is provided through ACPI tables to be agnostic to a UEFI implementation.</li> <li><code>PRM module</code> - An independently updatable package of PRM handlers. The PRM interface will be composed of multiple    PRM modules. This requirement allows for the separation of OEM and IHV PRM code, each of which can be serviced    independently.</li> <li><code>PRM handler</code> - The implementation/callback of a single PRM functionality as identified by a GUID.</li> </ol>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#firmware-design","title":"Firmware Design","text":"<p>The firmware has three key generic drivers to support PRM:</p> <ol> <li>A <code>PRM Loader driver</code> - Functionality is split across three phases:</li> <li>Discover - Find all PRM modules in the firmware image made available by the platform firmware author.<ul> <li>This phase includes verifying authenticity/integrity of the image, the image executable type, the export     table is present and the PRM Export Module Descriptor is present and valid.</li> </ul> </li> <li>Process - Convert PRM handler GUID to name mappings in the PRM Module Export Descriptor to PRM handler Name       to physical address mappings required to construct the PRM ACPI table.</li> <li> <p>Publish - Publish the PRM ACPI table using the information from the Process phase.</p> </li> <li> <p>A <code>PRM Configuration driver</code> - A generic driver responsible for processing PRM module configuration information    consumed through a <code>PRM_CONFIG_PROTOCOL</code> per PRM module instance. Therefore, the <code>PRM_CONFIG_PROTOCOL</code> serves    as the dynamic interface for this driver to process PRM module resources and prepare the module's data to be    configured properly for OS runtime.</p> </li> <li> <p>A <code>PRM Module</code> - Not a single driver but a user written PE/COFF image that follows the PRM module authoring process.    A PRM module groups together cohesive sets of PRM functionality into functions referred to as \"PRM handlers\".</p> </li> </ol>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prmpkg-code-organization","title":"PrmPkg Code Organization","text":"<p>The package follows a standard EDK II style package format. The list below contains some notable areas to explore in the package:</p> <ul> <li>ACPI Table Definitions</li> <li>Common Interface Definitions</li> <li>PRM Config Driver</li> <li>PRM Loader Driver</li> <li>Sample PRM Modules</li> </ul> <p>While the package does provide sample PRM modules to be used as a reference, actual PRM modules should not be maintained in PrmPkg. It is intended to only contain PRM infrastructure code and a few samples of how to use that infrastructure. The PrmPkg is meant to be used as-is by firmware that supports PRM. Any shortcomings that prevent the package from being used as-is should be addressed directly in PrmPkg.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-information-uefi-application","title":"PRM Information UEFI Application","text":"<p>A UEFI application is provided in this package called <code>PrmInfo</code> that allows a user to display and test PRM modules on their system.</p> <p>Link to application source code.</p> <p>This application is intended to be helpful during PRM enabling by allowing the user to:</p> <ol> <li>Confirm that their firmware port of the PRM infrastructure implemented in this package is functioning correctly.</li> <li>Quickly get information about what PRM modules and handlers that are present on a given system.</li> <li>Quickly test PRM handlers without booting into a full operating system.</li> <li>Develop and exercise PRM handlers prior to the availability of an operating system that is PRM aware.</li> </ol> <p>Execute the application help command for detailed usage instructions and examples of how to use the application: \\   <code>PrmInfo -?</code></p> <p>Example Usage:</p> <p></p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module","title":"PRM Module","text":"<p>Note: You can find simple examples of PRM modules in the Samples directory of this package. Samples/Readme.md has more information.</p> <p>By default, the EDK II implementation of UEFI does not allow images with the subsystem type <code>IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</code> to be built with exports.</p> <pre><code>ERROR - Linker #1294 from LINK : fatal exports and import libraries are not supported with /SUBSYSTEM:EFI_RUNTIME_DRIVER\n</code></pre> <p>This can adjusted in the MSVC\u00a0linker options.</p> <p>The subsystem type is changed in the firmware build to allow the export table to be added but the subsystem type\u00a0in the final image is still <code>0xC</code> (<code>EFI Runtime Driver</code>). This is important to allow the DXE dispatcher to use its standard image verification and loading algorithms to load the image into permanent memory during the DXE execution phase.</p> <p>All firmware-loaded PRM modules are loaded into a memory buffer of type <code>EfiRuntimeServicesCode</code>. This means the operating system must preserve all PRM handler code and the buffer will be reflected in the UEFI memory map. The execution for invoking PRM handlers is the same as that required for UEFI Runtime Services, notably 4KiB or more of available stack space must be provided and the stack must be 16-byte aligned.</p> <p>Note:\u00a0Long term it is possible to similarly load the modules into a <code>EfiRuntimeServicesCode</code> buffer and perform relocation fixups with a new EFI module type for PRM if desired. It was simply not done since it is not essential for this POC.</p> <p>Where possible, PRM module information is stored and generated using industry compiler tool chains. This is a key motivation behind using PE/COFF export tables to expose PRM module information and using a single PRM module binary definition consistent between firmware and OS load.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module-exports","title":"PRM Module Exports","text":"<p>A PRM module must contain at least two exports: A PRM Module Export Descriptor and at least one PRM handler. Here's an example of an export table from a PRM module that has a single PRM handler:</p> <pre><code>  0000000000005000: 00 00 00 00 FF FF FF FF 00 00 00 00 3C 50 00 00  ............&lt;P..\n  0000000000005010: 01 00 00 00 02 00 00 00 02 00 00 00 28 50 00 00  ............(P..\n  0000000000005020: 30 50 00 00 38 50 00 00 78 13 00 00 20 40 00 00  0P..8P..x... @..\n  0000000000005030: 5D 50 00 00 7C 50 00 00 00 00 01 00 50 72 6D 53  ]P..|P......PrmS\n  0000000000005040: 61 6D 70 6C 65 43 6F 6E 74 65 78 74 42 75 66 66  ampleContextBuff\n  0000000000005050: 65 72 4D 6F 64 75 6C 65 2E 64 6C 6C 00 44 75 6D  erModule.dll.Dum\n  0000000000005060: 70 53 74 61 74 69 63 44 61 74 61 42 75 66 66 65  pStaticDataBuffe\n  0000000000005070: 72 50 72 6D 48 61 6E 64 6C 65 72 00 50 72 6D 4D  rPrmHandler.PrmM\n  0000000000005080: 6F 64 75 6C 65 45 78 70 6F 72 74 44 65 73 63 72  oduleExportDescr\n  0000000000005090: 69 70 74 6F 72 00                                iptor.\n\n    00000000 characteristics\n    FFFFFFFF time date stamp\n        0.00 version\n           1 ordinal base\n           2 number of functions\n           2 number of names\n\n    ordinal hint RVA      name\n\n          1    0 00001378 DumpStaticDataBufferPrmHandler\n          2    1 00004020 PrmModuleExportDescriptor\n</code></pre>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-image-format","title":"PRM Image Format","text":"<p>PRM modules are ultimately PE/COFF images. However, when packaged in firmware the PE/COFF image is placed into a Firmware File System (FFS) file. This is transparent to the operating system but done to better align with the typical packaging of PE32(+) images managed in the firmware binary image. In the dump of the PRM FV binary image\u00a0shown earlier, the\u00a0FFS sections placed by EDK II build tools\u00a0(\"DXE dependency\", \"User interface\", \"Version\") that reside alongside the PE/COFF binary\u00a0are shown. A PRM module can be placed into a firmware image as a pre-built PE/COFF binary or built during the firmware build process. In either case, the PE/COFF section is contained in a FFS file as shown in that image.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-module-implementation","title":"PRM Module Implementation","text":"<p>To simplify building the PRM Module Export Descriptor, a PRM module implementation can use the following macros to mark functions as PRM handlers. In this example, a PRM module registers three functions by name as PRM handlers with the associated GUIDs.</p> <pre><code>//\n// Register the PRM export information for this PRM Module\n//\nPRM_MODULE_EXPORT (\nPRM_HANDLER_EXPORT_ENTRY (PRM_HANDLER_1_GUID, PrmHandler1),\nPRM_HANDLER_EXPORT_ENTRY (PRM_HANDLER_2_GUID, PrmHandler2),\nPRM_HANDLER_EXPORT_ENTRY (PRM_HANDLER_N_GUID, PrmHandlerN)\n);\n</code></pre> <p><code>PRM_MODULE_EXPORT</code> take a variable-length argument list of <code>PRM_HANDLER_EXPORT_ENTRY</code> entries that each describe an individual PRM handler being exported for the module. Ultimately, this information is used to define the structure necessary to statically allocate the PRM Module Export Descriptor Structure (and its PRM Handler Export Descriptor substructures) in the image.</p> <p>Another required export for PRM modules is automatically provided in <code>PrmModule.h</code>, a header file that pulls together all the includes needed to author a PRM module. This export is <code>PRM_MODULE_UPDATE_LOCK_EXPORT</code>. By including, <code>PrmModule.h</code>, a PRM module has the <code>PRM_MODULE_UPDATE_LOCK_DESCRIPTOR</code> automatically exported.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Readme/#prm-handler-constraints","title":"PRM Handler Constraints","text":"<p>At this time, PRM handlers are restricted to a maximum identifier length of 128 characters. This is checked when using the <code>PRM_HANDLER_EXPORT</code> macro by using a static assert that reports a violation at build-time.</p> <p>PRM handlers are not allowed to use UEFI Runtime Services and should not rely upon any UEFI constructs. For the purposes of this POC, this is currently not explicitly enforced but should be in the final changes.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/","title":"Platform Runtime Mechanism Sample Modules","text":"<p>The PRM module samples provided here serve as focused examples of how to perform various tasks in a PRM module. The samples can also be used to verify the basic infrastructure needed in your firmware implementation is working as expected by checking that the sample modules are found properly and the handlers perform their tasks as noted.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#important-note","title":"IMPORTANT NOTE","text":"<p>The sample modules have currently only been tested on the Visual Studio compiler tool chain. Sample module build may fail on other tool chains. A future work item is to enable broader build support.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#how-to-build-prm-sample-modules","title":"How to Build PRM Sample Modules","text":"<p>The sample modules are built as part of the normal <code>PrmPkg</code> build so you can follow the package build instructions and then find the PRM sample binaries in your workspace build output directory. For example, if your build workspace is called \"edk2\" and you build 64-bit binaries on the Visual Studio 2017 tool chain, your sample module binaries will be in the following location: \\ <code>edk2/Build/Prm/DEBUG_VS2017/X64/PrmPkg/Samples</code></p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#build-an-individual-prm-sample-module","title":"Build an Individual PRM Sample Module","text":"<p>Note that the build command does provide the option to build a specific module in a package which can result in faster build time. If you would like to just build a single PRM module that can be done by specifying the path to the module INF file with the \"-m\" argument to <code>build</code>. For example, this command builds 32-bit and 64-bit binaries with Visual Studio 2019: \\</p> <pre><code>build -p PrmPkg/PrmPkg.dsc -m PrmPkg/Samples/PrmSampleContextBufferModule/PrmSampleContextBufferModule.inf -a IA32 -a X64 -t VS2019\n</code></pre>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#prm-sample-module-users-guide","title":"PRM Sample Module User's Guide","text":"<p>The following table provides an overview of each sample module provided. By nature, different PRM handlers have different requirements. The information here is summarized for a user to understand how to use a given sample PRM handler along with GUID/name information to identify the sample PRM modules and their PRM handlers.</p> <p>It is recommended that all PRM authors write a similar set of documentation for their users to better understand and interact with their PRM modules.</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-acpi-parameter-buffer","title":"Module: PRM Sample ACPI Parameter Buffer","text":"<ul> <li>Name: <code>PrmSampleAcpiParameterBufferModule</code></li> <li>GUID: <code>dc2a58a6-5927-4776-b995-d118a27335a2</code></li> <li>Purpose:</li> <li>Provides an example of how to configure an ACPI parameter buffer</li> </ul> <p>Handlers:</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-check-parameter-buffer-prm-handler","title":"Handler: Check Parameter Buffer PRM Handler","text":"<ul> <li>Name: <code>CheckParamBufferPrmHandler</code></li> <li>GUID: <code>2e4f2d13-6240-4ed0-a401-c723fbdc34e8</code></li> <li>Actions:</li> <li> <p>Checks for the data signature \u2018T\u2019, \u2018E\u2019, \u2018S\u2019, \u2018T\u2019 (DWORD) at the beginning of the parameter buffer.</p> </li> <li> <p>Parameter Buffer Required: Yes</p> </li> <li>Parameter Buffer Contents:</li> <li> <p>A data signature of ['T', 'E', 'S', 'T'] (DWORD) at the beginning of the buffer.</p> </li> <li> <p>Context Buffer Required: No</p> </li> <li> <p>Runtime MMIO Range(s) Required: No</p> </li> </ul>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-context-buffer","title":"Module: PRM Sample Context Buffer","text":"<ul> <li>Name: <code>PrmSampleContextBufferModule</code></li> <li>GUID: <code>5a6cf42b-8bb4-472c-a233-5c4dc4033dc7</code></li> <li>Purpose:</li> <li>Provides an example of how to configure a static data buffer (which is pointed to in a context buffer) in       firmware and consume the buffer contents at runtime</li> </ul> <p>Handlers:</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-check-static-data-buffer-prm-handler","title":"Handler: Check Static Data Buffer PRM Handler","text":"<ul> <li>Name: <code>CheckStaticDataBufferPrmHandler</code></li> <li>GUID: <code>e1466081-7562-430f-896b-b0e523dc335a</code></li> <li>Actions:</li> <li> <p>Checks that the context buffer signature and static data buffer signature match in the context buffer provided.</p> </li> <li> <p>Parameter Buffer Required: No</p> </li> <li> <p>Context Buffer Required: Yes</p> </li> <li>Static Data Buffer Contents:</li> </ul> <pre><code>#define   SOME_VALUE_ARRAY_MAX_VALUES   16\n\ntypedef struct {\nBOOLEAN       Policy1Enabled;\nBOOLEAN       Policy2Enabled;\nUINT8         SomeValueArray[SOME_VALUE_ARRAY_MAX_VALUES];\n} STATIC_DATA_SAMPLE_CONTEXT_BUFFER_MODULE;\n</code></pre> <ul> <li>Runtime MMIO Range(s) Required: No</li> </ul>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#module-prm-sample-hardware-access-buffer","title":"Module: PRM Sample Hardware Access Buffer","text":"<ul> <li>Name: <code>PrmSampleHardwareAccessModule</code></li> <li>GUID: <code>0ef93ed7-14ae-425b-928f-b85a6213b57e</code></li> <li>Purpose:</li> <li>Demonstrate access of several types of hardware resources from a PRM module</li> </ul> <p>Handlers:</p>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-msr-access-microcode-signature-prm-handler","title":"Handler: MSR Access Microcode Signature PRM Handler","text":"<ul> <li>Name: <code>MsrAccessMicrocodeSignaturePrmHandler</code></li> <li>GUID: <code>2120cd3c-848b-4d8f-abbb-4b74ce64ac89</code></li> <li>Actions:</li> <li> <p>Access the loaded microcode signature at MSR 0x8B.</p> </li> <li> <p>Parameter Buffer Required: No</p> </li> <li> <p>Context Buffer Required: No</p> </li> <li> <p>Runtime MMIO Range(s) Required: No</p> </li> </ul>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-msr-access-mtrr-dump-prm-handler","title":"Handler: MSR Access MTRR Dump PRM Handler","text":"<ul> <li>Name: <code>MsrAccessMtrrDumpPrmHandler</code></li> <li>GUID: <code>ea0935a7-506b-4159-bbbb-48deeecb6f58</code></li> <li>Actions:</li> <li> <p>Access the fixed and variable MTRR values using MSRs.</p> </li> <li> <p>Parameter Buffer Required: No</p> </li> <li> <p>Context Buffer Required: No</p> </li> <li> <p>Runtime MMIO Range(s) Required: No</p> </li> </ul>"},{"location":"dyn/mu_tiano_plus/PrmPkg/Samples/Readme/#handler-hpet-mmio-access-prm-handler","title":"Handler: HPET MMIO Access PRM Handler","text":"<ul> <li>Name: <code>MmioAccessHpetPrmHandler</code></li> <li>GUID: <code>1bd1bda9-909a-4614-9699-25ec0c2783f7</code></li> <li>Actions:</li> <li> <p>Access some HPET registers using MMIO at 0xFED00000.</p> </li> <li> <p>Parameter Buffer Required: No</p> </li> <li> <p>Context Buffer Required: No</p> </li> <li> <p>Runtime MMIO Range(s) Required: Yes</p> </li> <li>Physical Base Address: 0xFED00000</li> <li>Length: 0x1000</li> </ul>"},{"location":"dyn/mu_tiano_plus/github/pull_request_template/","title":"Preface","text":"<p>Please ensure you have read the contribution docs prior to submitting the pull request. In particular, pull request guidelines.</p>"},{"location":"dyn/mu_tiano_plus/github/pull_request_template/#description","title":"Description","text":"<p>&lt;Please include a description of the change and why this change was made.&gt;</p> <p>For each item, place an \"x\" in between <code>[</code> and <code>]</code> if true. Example: <code>[x]</code>. (you can also check items in the GitHub UI)</p> <ul> <li> Impacts functionality?</li> <li> Impacts security?</li> <li> Breaking change?</li> <li> Includes tests?</li> <li> Includes documentation?</li> </ul>"},{"location":"dyn/mu_tiano_plus/github/pull_request_template/#how-this-was-tested","title":"How This Was Tested","text":"<p>&lt;Please describe the test(s) that were run to verify the changes.&gt;</p>"},{"location":"dyn/mu_tiano_plus/github/pull_request_template/#integration-instructions","title":"Integration Instructions","text":"<p>&lt;Describe how these changes should be integrated. Use N/A if nothing is required.&gt;</p>"}]}